{
  "gpt_model": {
    "Mbpp/2": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))",
      "basic_structure": "(assert (IsList test_tup1))\n(assert (IsList test_tup2))",
      "inputs": "(declare-const test_tup1 Value)\n(declare-const test_tup2 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList test_tup1))",
        "assert_1": "(define-fun C1 () Bool (IsList test_tup2))"
      },
      "constraints": {
        "assert_0": "assert isinstance(test_tup1, tuple), \"invalid inputs",
        "assert_1": "assert isinstance(test_tup2, tuple), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/3": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
        "assert_1": "(define-fun C1 () Bool (let ((num (ite (is-IntVal n) (ival n) 0))) (> num 0)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(n, int), \"invalid inputs",
        "assert_1": "assert n > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/4": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeI ((v Value)) Int\n  (ite (is-IntVal v) (ival v) 0))\n\n(define-fun-rec length ((l Value)) Int\n  (ite (is-Nil l)\n       0\n       (ite (is-Cons l)\n            (+ 1 (length (tail l)))\n            0)))\n\n(define-fun-rec IsList ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (IsList (tail l))\n            false)))\n\n(define-fun-rec list_all_int ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (and (is-IntVal (head l))\n                 (list_all_int (tail l)))\n            false)))",
      "basic_structure": "",
      "inputs": "(declare-const nums Value)\n(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList nums))",
        "assert_1": "(define-fun C1 () Bool (is-IntVal n))",
        "assert_2": "(define-fun C2 () Bool (> (SafeI n) 0))",
        "assert_3": "(define-fun C3 () Bool (list_all_int nums))",
        "assert_4": "(define-fun C4 () Bool (> (length nums) (SafeI n)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(nums, list), \"invalid inputs",
        "assert_1": "assert isinstance(n, int), \"invalid inputs",
        "assert_2": "assert n > 0, \"invalid inputs",
        "assert_3": "assert all(isinstance(i, int) for i in nums), \"invalid inputs",
        "assert_4": "assert len(nums) > n, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/6": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun safe-ival ((v Value)) Int\n  (ite (is-IntVal v) (ival v) 0))",
      "basic_structure": "",
      "inputs": "(declare-const a Value)\n(declare-const b Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal a))",
        "assert_1": "(define-fun C1 () Bool (is-IntVal b))"
      },
      "constraints": {
        "assert_0": "assert isinstance(a, int), \"invalid inputs",
        "assert_1": "assert isinstance(b, int), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/7": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const text Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal text))"
      },
      "constraints": {
        "assert_0": "assert isinstance(text, str), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/8": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (let ((t (tail v)))\n              (IsList t))\n            false)))\n\n(define-fun IsNumeric ((v Value)) Bool\n  (or (is-IntVal v) (is-FloatVal v)))\n\n(define-fun-rec list_all_numeric ((lst Value)) Bool\n  (ite (is-Nil lst)\n       true\n       (ite (is-Cons lst)\n            (let ((h (head lst)) (t (tail lst)))\n              (and (IsNumeric h)\n                   (list_all_numeric t)))\n            false)))",
      "basic_structure": "(assert (IsList nums))",
      "inputs": "(declare-const nums Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList nums))",
        "assert_1": "(define-fun C1 () Bool (list_all_numeric nums))"
      },
      "constraints": {
        "assert_0": "assert isinstance(nums, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(i, (int, float)) for i in nums), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/9": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun str_len ((v Value)) Int\n  (ite (is-StrVal v) (str.len (sval v)) 0))",
      "basic_structure": "",
      "inputs": "(declare-const s Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (is-StrVal s))",
        "assert_1": "(define-fun C1 () Bool\n  (and (is-StrVal s) (> (str_len s) 0)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(s, str), \"invalid inputs",
        "assert_1": "assert len(s) > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/11": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const s Value)\n(declare-const ch Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal s))",
        "assert_1": "(define-fun C1 () Bool (is-StrVal ch))",
        "assert_2": "(define-fun C2 () Bool (and (is-StrVal s) (> (str.len (sval s)) 0)))",
        "assert_3": "(define-fun C3 () Bool (and (is-StrVal ch) (= (str.len (sval ch)) 1)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(s, str), \"invalid inputs",
        "assert_1": "assert isinstance(ch, str), \"invalid inputs",
        "assert_2": "assert len(s) > 0, \"invalid inputs",
        "assert_3": "assert len(ch) == 1, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/12": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Cons v)\n       (IsList (tail v))\n       (is-Nil v)))\n\n(define-fun-rec length ((v Value)) Int\n  (ite (is-Cons v)\n       (+ 1 (length (tail v)))\n       0))\n\n(define-fun-rec list_all_numeric ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (or (is-IntVal (head v)) (is-FloatVal (head v)))\n                 (list_all_numeric (tail v)))\n            false)))\n\n(define-fun-rec matrix_is_list ((M Value)) Bool\n  (ite (is-Nil M)\n       true\n       (ite (is-Cons M)\n            (and (IsList (head M))\n                 (matrix_is_list (tail M)))\n            false)))\n\n(define-fun-rec matrix_all_numeric ((M Value)) Bool\n  (ite (is-Nil M)\n       true\n       (ite (is-Cons M)\n            (and (list_all_numeric (head M))\n                 (matrix_all_numeric (tail M)))\n            false)))\n\n(define-fun-rec matrix_row_length_eq ((M Value) (n Int)) Bool\n  (ite (is-Nil M)\n       true\n       (ite (is-Cons M)\n            (and (= (length (head M)) n)\n                 (matrix_row_length_eq (tail M) n))\n            false)))",
      "basic_structure": "(assert (IsList M))",
      "inputs": "(declare-const M Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList M))",
        "assert_1": "(define-fun C1 () Bool (> (length M) 0))",
        "assert_2": "(define-fun C2 () Bool (matrix_is_list M))",
        "assert_3": "(define-fun C3 () Bool (ite (is-Cons M) (> (length (head M)) 0) false))",
        "assert_4": "(define-fun C4 () Bool (ite (is-Cons M) (matrix_row_length_eq (tail M) (length (head M))) false))",
        "assert_5": "(define-fun C5 () Bool (matrix_all_numeric M))"
      },
      "constraints": {
        "assert_0": "assert isinstance(M, list), \"invalid inputs",
        "assert_1": "assert len(M) > 0, \"invalid inputs",
        "assert_2": "assert all(isinstance(row, list) for row in M), \"invalid inputs",
        "assert_3": "assert len(M[0]) > 0, \"invalid inputs",
        "assert_4": "assert all(len(row) == len(M[0]) for row in M), \"invalid inputs",
        "assert_5": "assert all(isinstance(item, (int, float)) for row in M for item in row), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/14": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun IsNumeric ((v Value)) Bool (or (is-IntVal v) (is-FloatVal v)))\n(define-fun V2Real ((v Value)) Real (ite (is-IntVal v) (to_real (ival v)) (ite (is-FloatVal v) (fval v) 0.0)))",
      "basic_structure": "(assert true)",
      "inputs": "(declare-const l Value)\n(declare-const b Value)\n(declare-const h Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsNumeric l))",
        "assert_1": "(define-fun C1 () Bool (IsNumeric b))",
        "assert_2": "(define-fun C2 () Bool (IsNumeric h))",
        "assert_3": "(define-fun C3 () Bool (> (V2Real l) 0.0))",
        "assert_4": "(define-fun C4 () Bool (> (V2Real b) 0.0))",
        "assert_5": "(define-fun C5 () Bool (> (V2Real h) 0.0))"
      },
      "constraints": {
        "assert_0": "assert isinstance(l, (int, float)), \"invalid inputs",
        "assert_1": "assert isinstance(b, (int, float)), \"invalid inputs",
        "assert_2": "assert isinstance(h, (int, float)), \"invalid inputs",
        "assert_3": "assert l > 0, \"invalid inputs",
        "assert_4": "assert b > 0, \"invalid inputs",
        "assert_5": "assert h > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/16": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeStr ((v Value)) String (ite (is-StrVal v) (sval v) \"\"))",
      "basic_structure": "",
      "inputs": "(declare-const text Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal text))",
        "assert_1": "(define-fun C1 () Bool (> (str.len (SafeStr text)) 0))"
      },
      "constraints": {
        "assert_0": "assert isinstance(text, str), \"invalid inputs",
        "assert_1": "assert len(text) > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/17": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun IsNumeric ((v Value)) Bool (or (is-IntVal v) (is-FloatVal v)))",
      "basic_structure": "",
      "inputs": "(declare-const a Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsNumeric a))",
        "assert_1": "(define-fun C1 () Bool (ite (is-IntVal a) (> (ival a) 0) (ite (is-FloatVal a) (> (fval a) 0) false)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(a, (int, float)), \"invalid inputs",
        "assert_1": "assert a > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/18": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeS ((v Value)) String\n  (ite (is-StrVal v) (sval v) \"\"))",
      "basic_structure": "",
      "inputs": "(declare-const string Value)\n(declare-const second_string Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal string))",
        "assert_1": "(define-fun C1 () Bool (is-StrVal second_string))",
        "assert_2": "(define-fun C2 () Bool (> (str.len (SafeS string)) 0))",
        "assert_3": "(define-fun C3 () Bool (> (str.len (SafeS second_string)) 0))"
      },
      "constraints": {
        "assert_0": "assert isinstance(string, str), \"invalid inputs",
        "assert_1": "assert isinstance(second_string, str), \"invalid inputs",
        "assert_2": "assert len(string) > 0, \"invalid inputs",
        "assert_3": "assert len(second_string) > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/19": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (or (is-Nil v)\n      (and (is-Cons v)\n           (IsList (tail v)))))\n\n(define-fun-rec list_all_ints ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (and (is-Cons v)\n            (let ((hd (head v)) (rest (tail v)))\n              (and (is-IntVal hd)\n                   (list_all_ints rest))))))",
      "basic_structure": "(assert (IsList arraynums))",
      "inputs": "(declare-const arraynums Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList arraynums))",
        "assert_1": "(define-fun C1 () Bool (list_all_ints arraynums))"
      },
      "constraints": {
        "assert_0": "assert isinstance(arraynums, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(item, int) for item in arraynums), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/20": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))\n(define-fun SafeF ((v Value)) Real (ite (is-FloatVal v) (fval v) 0.0))",
      "basic_structure": "",
      "inputs": "(declare-const x Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (or (is-IntVal x) (is-FloatVal x)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(x, (int, float)), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/56": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
      "basic_structure": "(assert (is-IntVal n))",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
        "assert_1": "(define-fun C1 () Bool (and C0 (>= (SafeI n) 0)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(n, int), \"invalid inputs",
        "assert_1": "assert n >= 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/57": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((x Value)) Bool\n  (ite (is-Nil x)\n       true\n       (ite (is-Cons x)\n            (IsList (tail x))\n            false)))\n\n(define-fun-rec ListAllNumeric ((x Value)) Bool\n  (ite (is-Nil x)\n       true\n       (ite (is-Cons x)\n            (let ((h (head x)) (rest (tail x)))\n              (and (is-IntVal h)\n                   (let ((n (ival h))) (and (<= 0 n) (<= n 9)))\n                   (ListAllNumeric rest)))\n            false)))",
      "basic_structure": "(assert (IsList arr))",
      "inputs": "(declare-const arr Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList arr))",
        "assert_1": "(define-fun C1 () Bool (ListAllNumeric arr))"
      },
      "constraints": {
        "assert_0": "assert isinstance(arr, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(item, int) and 0 <= item <= 9 for item in arr), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/58": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun safe_ival ((v Value)) Int\n  (ite (is-IntVal v) (ival v) 0))",
      "basic_structure": "",
      "inputs": "(declare-const x Value)\n(declare-const y Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal x))",
        "assert_1": "(define-fun C1 () Bool (is-IntVal y))"
      },
      "constraints": {
        "assert_0": "assert isinstance(x, int), \"invalid inputs",
        "assert_1": "assert isinstance(y, int), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/59": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
      "basic_structure": "",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
        "assert_1": "(define-fun C1 () Bool (> (SafeI n) 0))"
      },
      "constraints": {
        "assert_0": "assert isinstance(n, int), \"invalid inputs",
        "assert_1": "assert n > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/61": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeS ((v Value)) String\n  (ite (is-StrVal v) (sval v) \"\"))\n(define-fun is_digit_str ((v Value)) Bool\n  (and (is-StrVal v)\n       (str.in.re (sval v)\n         (re.* (re.union (str.to.re \"0\") (str.to.re \"1\") (str.to.re \"2\") (str.to.re \"3\") (str.to.re \"4\") (str.to.re \"5\") (str.to.re \"6\") (str.to.re \"7\") (str.to.re \"8\") (str.to.re \"9\"))))))",
      "basic_structure": "",
      "inputs": "(declare-const s Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal s))",
        "assert_1": "(define-fun C1 () Bool (is_digit_str s))"
      },
      "constraints": {
        "assert_0": "assert isinstance(s, str), \"invalid inputs",
        "assert_1": "assert s.isdigit(), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/62": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec list_all_numeric ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (and (or (is-IntVal (head l)) (is-FloatVal (head l)))\n                 (list_all_numeric (tail l)))\n            false)))",
      "basic_structure": "",
      "inputs": "(declare-const xs Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList xs))",
        "assert_1": "(define-fun C1 () Bool (and (IsList xs) (list_all_numeric xs)))",
        "assert_2": "(define-fun C2 () Bool (and (IsList xs) (not (is-Nil xs))))"
      },
      "constraints": {
        "assert_0": "assert isinstance(xs, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(item, (int, float)) for item in xs), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/63": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (or (is-Nil l)\n      (and (is-Cons l) (IsList (tail l)))))\n\n(define-fun IsPair ((v Value)) Bool\n  (and (is-Cons v)\n       (is-Cons (tail v))\n       (is-Nil (tail (tail v)))))\n\n(define-fun first  ((p Value)) Value (head p))\n(define-fun second ((p Value)) Value (head (tail p)))\n\n(define-fun IsNumeric ((v Value)) Bool\n  (or (is-IntVal v) (is-FloatVal v)))\n\n(define-fun-rec AllPair2 ((l Value)) Bool\n  (ite (is-Nil l) true\n       (and (is-Cons l)\n            (IsPair (head l))\n            (AllPair2 (tail l)))))\n\n(define-fun-rec AllNumericPairs ((l Value)) Bool\n  (ite (is-Nil l) true\n       (and (is-Cons l)\n            (let ((p (head l)))\n              (and (IsPair p)\n                   (IsNumeric (first p))\n                   (IsNumeric (second p))))\n            (AllNumericPairs (tail l)))))",
      "basic_structure": "",
      "inputs": "(declare-const test_list Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList test_list))",
        "assert_1": "(define-fun C1 () Bool (AllPair2 test_list))",
        "assert_2": "(define-fun C2 () Bool (AllNumericPairs test_list))"
      },
      "constraints": {
        "assert_0": "assert isinstance(test_list, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(item, tuple) and len(item) == 2 for item in test_list), \"invalid inputs",
        "assert_2": "assert all(isinstance(a, (int, float)) and isinstance(b, (int, float)) for a, b in test_list), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/64": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v) true\n    (ite (is-Cons v) (IsList (tail v)) false)))\n(define-fun IsNumericValue ((v Value)) Bool\n  (or (is-IntVal v) (is-FloatVal v)))\n(define-fun-rec AllTuplesMin2 ((l Value)) Bool\n  (ite (is-Nil l) true\n    (ite (is-Cons l)\n      (let ((item (head l)) (rest (tail l)))\n        (and (is-Cons item)\n             (let ((itemTail (tail item))) (is-Cons itemTail))\n             (AllTuplesMin2 rest)))\n      false)))\n(define-fun-rec AllNumericSecond ((l Value)) Bool\n  (ite (is-Nil l) true\n    (ite (is-Cons l)\n      (let ((item (head l)) (rest (tail l)))\n        (let ((second (ite (is-Cons item) (head (tail item)) Nil)))\n          (and (IsNumericValue second)\n               (AllNumericSecond rest))))\n      false)))",
      "basic_structure": "(assert (IsList subjectmarks))",
      "inputs": "(declare-const subjectmarks Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList subjectmarks))",
        "assert_1": "(define-fun C1 () Bool (AllTuplesMin2 subjectmarks))",
        "assert_2": "(define-fun C2 () Bool (AllNumericSecond subjectmarks))"
      },
      "constraints": {
        "assert_0": "assert isinstance(subjectmarks, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(item, tuple) and len(item) >= 2 for item in subjectmarks), \"invalid inputs",
        "assert_2": "assert all(isinstance(item[1], (int, float)) for item in subjectmarks), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/65": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (or\n    (is-Nil l)\n    (and (is-Cons l) (IsList (tail l)))))\n\n(define-fun-rec list_check ((l Value)) Bool\n  (ite (is-Cons l)\n       (and (list_check (head l)) (list_check (tail l)))\n       (ite (is-Nil l)\n            true\n            (or (is-IntVal l) (is-FloatVal l)))))",
      "basic_structure": "",
      "inputs": "(declare-const data_list Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList data_list))",
        "assert_1": "(define-fun C1 () Bool (list_check data_list))"
      },
      "constraints": {
        "assert_0": "assert isinstance(data_list, list), \"invalid inputs",
        "assert_1": "assert list_check(data_list), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/66": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((x Value)) Bool\n  (or\n    (is-Nil x)\n    (and (is-Cons x)\n         (let ((tailVal (tail x)))\n           (IsList tailVal)))))\n\n(define-fun-rec list_all_numeric ((x Value)) Bool\n  (ite (is-Nil x)\n       true\n       (ite (is-Cons x)\n            (let ((headVal (head x))\n                  (tailVal (tail x)))\n              (ite (or (is-IntVal headVal) (is-FloatVal headVal))\n                   (list_all_numeric tailVal)\n                   false))\n            false)))",
      "basic_structure": "(assert (IsList l))",
      "inputs": "(declare-const l Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList l))",
        "assert_1": "(define-fun C1 () Bool (list_all_numeric l))"
      },
      "constraints": {
        "assert_0": "assert isinstance(l, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(item, (int, float)) for item in l), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/67": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun safe-ival ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
      "basic_structure": "(assert (is-IntVal n))",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
        "assert_1": "(define-fun C1 () Bool (>= (safe-ival n) 0))",
        "assert_2": "(define-fun C2 () Bool (<= (safe-ival n) 100))"
      },
      "constraints": {
        "assert_0": "assert isinstance(n, int), \"invalid inputs",
        "assert_1": "assert n >= 0, \"invalid inputs",
        "assert_2": "assert n <= 100, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/68": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (or (is-Nil v)\n      (and (is-Cons v)\n           (IsList (tail v)))))\n(define-fun-rec ListAllNumeric ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (or (is-IntVal (head v)) (is-FloatVal (head v)))\n                 (ListAllNumeric (tail v)))\n            false)))",
      "basic_structure": "(assert (IsList A))",
      "inputs": "(declare-const A Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList A))",
        "assert_1": "(define-fun C1 () Bool (ListAllNumeric A))"
      },
      "constraints": {
        "assert_0": "assert isinstance(A, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(item, (int, float)) for item in A), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/69": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (IsList (head v)) (IsList (tail v)))\n            false)))",
      "basic_structure": "(assert (IsList l))\n(assert (IsList s))",
      "inputs": "(declare-const l Value)\n(declare-const s Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList l))",
        "assert_1": "(define-fun C1 () Bool (IsList s))"
      },
      "constraints": {
        "assert_0": "assert isinstance(l, list), \"invalid inputs",
        "assert_1": "assert isinstance(s, list), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/70": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (or (is-Nil v)\n      (and (is-Cons v) (IsList (tail v)))))\n\n(define-fun IsPair ((v Value)) Bool\n  (and (is-Cons v)\n       (is-Cons (tail v))\n       (is-Nil (tail (tail v)))))\n\n(define-fun-rec AllPair ((v Value)) Bool\n  (or (is-Nil v)\n      (and (is-Cons v)\n           (IsPair (head v))\n           (AllPair (tail v)))))",
      "basic_structure": "",
      "inputs": "(declare-const Input Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList Input))",
        "assert_1": "(define-fun C1 () Bool (AllPair Input))"
      },
      "constraints": {
        "assert_0": "assert isinstance(Input, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(item, tuple) for item in Input), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/71": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (IsList (tail l))\n            false)))\n\n(define-fun-rec list_all_numeric ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (let ((h (head l)) (t (tail l)))\n              (ite (or (is-IntVal h) (is-FloatVal h))\n                   (list_all_numeric t)\n                   false))\n            false)))",
      "basic_structure": "(assert (IsList nums))",
      "inputs": "(declare-const nums Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList nums))",
        "assert_1": "(define-fun C1 () Bool (list_all_numeric nums))"
      },
      "constraints": {
        "assert_0": "assert isinstance(nums, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(item, (int, float)) for item in nums), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/72": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
        "assert_1": "(define-fun C1 () Bool (ite (is-IntVal n) (> (ival n) 0) false))"
      },
      "constraints": {
        "assert_0": "assert isinstance(n, int), \"invalid inputs",
        "assert_1": "assert n > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/74": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec isList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (isList (tail v))\n            false)))",
      "basic_structure": "(assert (isList colors))\n(assert (isList patterns))",
      "inputs": "(declare-const colors Value)\n(declare-const patterns Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (isList colors))",
        "assert_1": "(define-fun C1 () Bool (isList patterns))"
      },
      "constraints": {
        "assert_0": "assert isinstance(colors, list), \"invalid inputs",
        "assert_1": "assert isinstance(patterns, list), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/75": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (IsList (tail l))\n            false)))\n\n(define-fun SafeI ((v Value)) Int\n  (ite (is-IntVal v) (ival v) 0))\n\n(define-fun-rec list_elems_are_cons ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (let ((hd (head l)) (tl (tail l)))\n              (and (is-Cons hd)\n                   (list_elems_are_cons tl)))\n            false)))\n\n(define-fun-rec list_all_ints ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (let ((hd (head l)) (tl (tail l)))\n              (and (is-IntVal hd)\n                   (list_all_ints tl)))\n            false)))\n\n(define-fun-rec list_all_inner_ints ((outer Value)) Bool\n  (ite (is-Nil outer)\n       true\n       (ite (is-Cons outer)\n            (let ((inner (head outer)) (rest (tail outer)))\n              (and (list_all_ints inner)\n                   (list_all_inner_ints rest)))\n            false)))",
      "basic_structure": "",
      "inputs": "(declare-const test_list Value)\n(declare-const K Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList test_list))",
        "assert_1": "(define-fun C1 () Bool (list_elems_are_cons test_list))",
        "assert_2": "(define-fun C2 () Bool (list_all_inner_ints test_list))",
        "assert_3": "(define-fun C3 () Bool (is-IntVal K))",
        "assert_4": "(define-fun C4 () Bool (> (SafeI K) 0))"
      },
      "constraints": {
        "assert_0": "assert isinstance(test_list, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(item, tuple) for item in test_list), \"invalid inputs",
        "assert_2": "assert all(isinstance(item, int) for tuple in test_list for item in tuple), \"invalid inputs",
        "assert_3": "assert isinstance(K, int), \"invalid inputs",
        "assert_4": "assert K > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/77": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))"
      },
      "constraints": {
        "assert_0": "assert isinstance(n, int), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/79": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun alphaCharRe () (RegEx String)\n  (re.union\n    (str.to.re \"A\") (str.to.re \"B\") (str.to.re \"C\") (str.to.re \"D\") (str.to.re \"E\") (str.to.re \"F\") (str.to.re \"G\") (str.to.re \"H\") (str.to.re \"I\") (str.to.re \"J\") (str.to.re \"K\") (str.to.re \"L\") (str.to.re \"M\") (str.to.re \"N\") (str.to.re \"O\") (str.to.re \"P\") (str.to.re \"Q\") (str.to.re \"R\") (str.to.re \"S\") (str.to.re \"T\") (str.to.re \"U\") (str.to.re \"V\") (str.to.re \"W\") (str.to.re \"X\") (str.to.re \"Y\") (str.to.re \"Z\")\n    (str.to.re \"a\") (str.to.re \"b\") (str.to.re \"c\") (str.to.re \"d\") (str.to.re \"e\") (str.to.re \"f\") (str.to.re \"g\") (str.to.re \"h\") (str.to.re \"i\") (str.to.re \"j\") (str.to.re \"k\") (str.to.re \"l\") (str.to.re \"m\") (str.to.re \"n\") (str.to.re \"o\") (str.to.re \"p\") (str.to.re \"q\") (str.to.re \"r\") (str.to.re \"s\") (str.to.re \"t\") (str.to.re \"u\") (str.to.re \"v\") (str.to.re \"w\") (str.to.re \"x\") (str.to.re \"y\") (str.to.re \"z\")\n  )\n)\n(define-fun alphaRe () (RegEx String)\n  (re.* alphaCharRe)\n)",
      "basic_structure": "",
      "inputs": "(declare-const s Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal s))",
        "assert_1": "(define-fun C1 () Bool\n  (and\n    (is-StrVal s)\n    (> (str.len (sval s)) 0)\n    (str.in.re (sval s) alphaRe)\n  )\n)"
      },
      "constraints": {
        "assert_0": "assert isinstance(s, str), \"invalid inputs",
        "assert_1": "assert s.isalpha(), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/80": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "(assert (is-IntVal n))",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
        "assert_1": "(define-fun C1 () Bool (ite (is-IntVal n) (>= (ival n) 0) false))"
      },
      "constraints": {
        "assert_0": "assert isinstance(n, int), \"invalid inputs",
        "assert_1": "assert n >= 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/82": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "(assert (or (is-IntVal r) (is-FloatVal r)))",
      "inputs": "(declare-const r Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (or (is-IntVal r) (is-FloatVal r)))",
        "assert_1": "(define-fun C1 () Bool (ite (is-IntVal r) (> (ival r) 0) (ite (is-FloatVal r) (> (fval r) 0.0) false)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(r, (int, float)), \"invalid inputs",
        "assert_1": "assert r > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/84": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeInt ((v Value)) Int\n  (ite (is-IntVal v) (ival v) 0))",
      "basic_structure": "",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (is-IntVal n))",
        "assert_1": "(define-fun C1 () Bool\n  (> (SafeInt n) 0))"
      },
      "constraints": {
        "assert_0": "assert isinstance(n, int), \"invalid inputs",
        "assert_1": "assert n > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/85": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun is-numeric ((v Value)) Bool (or (is-IntVal v) (is-FloatVal v)))\n(define-fun safe_to_real ((v Value)) Real\n  (ite (is-IntVal v)\n       (to_real (ival v))\n       (ite (is-FloatVal v)\n            (fval v)\n            0.0)))",
      "basic_structure": "",
      "inputs": "(declare-const r Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (is-numeric r))",
        "assert_1": "(define-fun C1 () Bool\n  (> (safe_to_real r) 0.0))"
      },
      "constraints": {
        "assert_0": "assert isinstance(r, (int, float)), \"invalid inputs",
        "assert_1": "assert r > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/86": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
        "assert_1": "(define-fun C1 () Bool (and (is-IntVal n) (> (ite (is-IntVal n) (ival n) 0) 0)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(n, int), \"invalid inputs",
        "assert_1": "assert n > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/87": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (or (is-Nil v) (and (is-Cons v) (IsList (tail v)))))\n\n(define-fun IsPair ((v Value)) Bool\n  (and (is-Cons v) (is-Cons (tail v)) (is-Nil (tail (tail v)))))\n\n(define-fun first ((p Value)) Value (head p))\n(define-fun second ((p Value)) Value (head (tail p)))\n\n(define-fun IsKVPair ((v Value)) Bool\n  (and (IsPair v) (is-StrVal (first v))))\n\n(define-fun-rec IsDict ((v Value)) Bool\n  (or (is-Nil v) (and (is-Cons v) (IsKVPair (head v)) (IsDict (tail v)))))",
      "basic_structure": "",
      "inputs": "(declare-const dict1 Value)\n(declare-const dict2 Value)\n(declare-const dict3 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsDict dict1))",
        "assert_1": "(define-fun C1 () Bool (IsDict dict2))",
        "assert_2": "(define-fun C2 () Bool (IsDict dict3))"
      },
      "constraints": {
        "assert_0": "assert isinstance(dict1, dict), \"invalid inputs",
        "assert_1": "assert isinstance(dict2, dict), \"invalid inputs",
        "assert_2": "assert isinstance(dict3, dict), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/88": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))",
      "basic_structure": "(assert true)",
      "inputs": "(declare-const list1 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList list1))"
      },
      "constraints": {
        "assert_0": "assert isinstance(list1, list), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/89": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const N Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal N))"
      },
      "constraints": {
        "assert_0": "assert isinstance(N, int), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/90": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun isList ((v Value)) Bool\n  (or (is-Nil v) (is-Cons v)))\n\n(define-fun-rec list_length ((v Value)) Int\n  (ite (is-Nil v)\n       0\n       (ite (is-Cons v)\n            (+ 1 (list_length (tail v)))\n            0)))\n\n(define-fun-rec list_all_string ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (is-StrVal (head v))\n                 (list_all_string (tail v)))\n            false)))",
      "basic_structure": "(assert (isList list1))",
      "inputs": "(declare-const list1 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (isList list1))",
        "assert_1": "(define-fun C1 () Bool\n  (> (list_length list1) 0))",
        "assert_2": "(define-fun C2 () Bool\n  (list_all_string list1))"
      },
      "constraints": {
        "assert_0": "assert isinstance(list1, list), \"invalid inputs",
        "assert_1": "assert len(list1) > 0, \"invalid inputs",
        "assert_2": "assert all(isinstance(item, str) for item in list1), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/91": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun isList ((v Value)) Bool (or (is-Nil v) (is-Cons v)))\n(define-fun-rec list_all_string ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (and (is-Cons l)\n            (let ((h (head l)) (t (tail l)))\n              (and (is-StrVal h)\n                   (list_all_string t))))))",
      "basic_structure": "",
      "inputs": "(declare-const str1 Value)\n(declare-const sub_str Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (isList str1))",
        "assert_1": "(define-fun C1 () Bool (list_all_string str1))",
        "assert_2": "(define-fun C2 () Bool (is-StrVal sub_str))"
      },
      "constraints": {
        "assert_0": "assert isinstance(str1, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(item, str) for item in str1), \"invalid inputs",
        "assert_2": "assert isinstance(sub_str, str), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/92": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "(assert (is-IntVal n))",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
        "assert_1": "(define-fun C1 () Bool (ite (is-IntVal n) (>= (ival n) 0) false))"
      },
      "constraints": {
        "assert_0": "assert isinstance(n, int), \"invalid inputs",
        "assert_1": "assert n >= 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/93": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const a Value)\n(declare-const b Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (or (is-IntVal a) (is-FloatVal a)))",
        "assert_1": "(define-fun C1 () Bool (is-IntVal b))"
      },
      "constraints": {
        "assert_0": "assert isinstance(a, (int, float)), \"invalid inputs",
        "assert_1": "assert isinstance(b, int), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/94": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (ite (is-Nil l) true\n       (ite (is-Cons l) (IsList (tail l)) false)))\n\n(define-fun-rec list_length ((l Value)) Int\n  (ite (is-Nil l) 0\n       (ite (is-Cons l) (+ 1 (list_length (tail l))) 0)))\n\n(define-fun-rec list_all_tuple2 ((l Value)) Bool\n  (ite (is-Nil l) true\n       (ite (is-Cons l)\n            (and (let ((item (head l)))\n                   (and (IsList item) (>= (list_length item) 2)))\n                 (list_all_tuple2 (tail l)))\n            false)))\n\n(define-fun-rec list_all_second_numeric ((l Value)) Bool\n  (ite (is-Nil l) true\n       (ite (is-Cons l)\n            (let ((item (head l)))\n              (and (is-Cons item)\n                   (let ((snd (head (tail item))))\n                     (or (is-IntVal snd) (is-FloatVal snd)))\n                   (list_all_second_numeric (tail l))))\n            false)))",
      "basic_structure": "(assert (IsList test_list))",
      "inputs": "(declare-const test_list Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (and (IsList test_list) (> (list_length test_list) 0)))",
        "assert_1": "(define-fun C1 () Bool (list_all_tuple2 test_list))",
        "assert_2": "(define-fun C2 () Bool (list_all_second_numeric test_list))"
      },
      "constraints": {
        "assert_0": "assert isinstance(test_list, list) and len(test_list) > 0, \"invalid inputs",
        "assert_1": "assert all(isinstance(item, tuple) and len(item) >= 2 for item in test_list), \"invalid inputs",
        "assert_2": "assert all(isinstance(item[1], (int, float)) for item in test_list), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/95": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n(define-fun-rec length ((v Value)) Int\n  (ite (is-Nil v)\n       0\n       (ite (is-Cons v)\n            (+ 1 (length (tail v)))\n            0)))\n(define-fun-rec AllItemsList ((lst Value)) Bool\n  (ite (is-Nil lst)\n       true\n       (ite (is-Cons lst)\n            (and (IsList (head lst))\n                 (AllItemsList (tail lst)))\n            false)))",
      "basic_structure": "(assert (IsList lst))",
      "inputs": "(declare-const lst Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList lst))",
        "assert_1": "(define-fun C1 () Bool (> (length lst) 0))",
        "assert_2": "(define-fun C2 () Bool (AllItemsList lst))"
      },
      "constraints": {
        "assert_0": "assert isinstance(lst, list), \"invalid inputs",
        "assert_1": "assert len(lst) > 0, \"invalid inputs",
        "assert_2": "assert all(isinstance(item, list) for item in lst), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/96": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
      "basic_structure": "",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
        "assert_1": "(define-fun C1 () Bool (> (SafeI n) 0))"
      },
      "constraints": {
        "assert_0": "assert isinstance(n, int), \"invalid inputs",
        "assert_1": "assert n > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/97": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec list_len ((v Value)) Int\n  (ite (is-Nil v)\n       0\n       (ite (is-Cons v)\n            (+ 1 (list_len (tail v)))\n            0)))\n\n(define-fun-rec AllList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (IsList (head v))\n                 (AllList (tail v)))\n            false)))\n\n(define-fun-rec ElemHashable ((v Value)) Bool\n  (or (is-IntVal v)\n      (is-FloatVal v)\n      (is-StrVal v)\n      (is-BoolVal v)))\n\n(define-fun-rec AllElemHashable ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (ElemHashable (head v))\n                 (AllElemHashable (tail v)))\n            false)))\n\n(define-fun-rec AllHashable ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (AllElemHashable (head v))\n                 (AllHashable (tail v)))\n            false)))",
      "basic_structure": "(assert (IsList list1))",
      "inputs": "(declare-const list1 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList list1))",
        "assert_1": "(define-fun C1 () Bool (> (list_len list1) 0))",
        "assert_2": "(define-fun C2 () Bool (AllList list1))",
        "assert_3": "(define-fun C3 () Bool (AllHashable list1))"
      },
      "constraints": {
        "assert_0": "assert isinstance(list1, list), \"invalid inputs",
        "assert_1": "assert len(list1) > 0, \"invalid inputs",
        "assert_2": "assert all(isinstance(item, list) for item in list1), \"invalid inputs",
        "assert_3": "assert all(is_hashable(item) for sublist in list1 for item in sublist), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/98": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun isList ((v Value)) Bool\n  (or (is-Nil v) (is-Cons v)))\n\n(define-fun-rec length ((v Value)) Int\n  (ite (is-Nil v) 0\n    (ite (is-Cons v)\n      (+ 1 (length (tail v)))\n      0)))\n\n(define-fun-rec list_all_numeric ((v Value)) Bool\n  (ite (is-Nil v) true\n    (ite (is-Cons v)\n      (and (or (is-IntVal (head v)) (is-FloatVal (head v)))\n           (list_all_numeric (tail v)))\n      false)))",
      "basic_structure": "(assert (isList numbers))",
      "inputs": "(declare-const numbers Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (isList numbers))",
        "assert_1": "(define-fun C1 () Bool (> (length numbers) 0))",
        "assert_2": "(define-fun C2 () Bool (list_all_numeric numbers))"
      },
      "constraints": {
        "assert_0": "assert isinstance(numbers, (tuple, list)), \"invalid inputs",
        "assert_1": "assert len(numbers) > 0, \"invalid inputs",
        "assert_2": "assert all(isinstance(item, (int, float)) for item in numbers), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/99": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))"
      },
      "constraints": {
        "assert_0": "assert isinstance(n, int), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/100": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
      "basic_structure": "",
      "inputs": "(declare-const num Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal num))",
        "assert_1": "(define-fun C1 () Bool (and C0 (>= (SafeI num) 0)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(num, int), \"invalid inputs",
        "assert_1": "assert num >= 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/101": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeIVal ((v Value)) Int\n  (ite (is-IntVal v) (ival v) 0))\n\n(define-fun-rec length ((lst Value)) Int\n  (ite (is-Nil lst) 0\n    (ite (is-Cons lst)\n      (+ 1 (length (tail lst)))\n      0)))\n\n(define-fun-rec IsList ((lst Value)) Bool\n  (ite (is-Nil lst) true\n    (ite (is-Cons lst)\n      (IsList (tail lst))\n      false)))",
      "basic_structure": "",
      "inputs": "(declare-const arr Value)\n(declare-const k Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (IsList arr))",
        "assert_1": "(define-fun C1 () Bool\n  (is-IntVal k))",
        "assert_2": "(define-fun C2 () Bool\n  (and\n    (>= (length arr) (SafeIVal k))\n    (>= (SafeIVal k) 1)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(arr, list), \"invalid inputs",
        "assert_1": "assert isinstance(k, int), \"invalid inputs",
        "assert_2": "assert len(arr) >= k >= 1, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/102": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeStrLen ((v Value)) Int\n  (ite (is-StrVal v)\n       (str.len (sval v))\n       0))",
      "basic_structure": "(assert (is-StrVal word))",
      "inputs": "(declare-const word Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (is-StrVal word))",
        "assert_1": "(define-fun C1 () Bool\n  (> (SafeStrLen word) 0))"
      },
      "constraints": {
        "assert_0": "assert isinstance(word, str), \"invalid inputs",
        "assert_1": "assert len(word) > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/103": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeI ((v Value)) Int\n  (ite (is-IntVal v) (ival v) 0))",
      "basic_structure": "(assert (is-IntVal n))\n(assert (is-IntVal m))",
      "inputs": "(declare-const n Value)\n(declare-const m Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (is-IntVal n))",
        "assert_1": "(define-fun C1 () Bool\n  (is-IntVal m))",
        "assert_2": "(define-fun C2 () Bool\n  (>= (SafeI n) 0))",
        "assert_3": "(define-fun C3 () Bool\n  (>= (SafeI m) 0))"
      },
      "constraints": {
        "assert_0": "assert isinstance(n, int), \"invalid inputs",
        "assert_1": "assert isinstance(m, int), \"invalid inputs",
        "assert_2": "assert n >= 0, \"invalid inputs",
        "assert_3": "assert m >= 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/104": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec list_all_list ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (IsList (head v))\n                 (list_all_list (tail v)))\n            false)))\n\n(define-fun-rec list_all_str ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (is-StrVal (head v))\n                 (list_all_str (tail v)))\n            false)))\n\n(define-fun-rec list_all_str_list ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (list_all_str (head v))\n                 (list_all_str_list (tail v)))\n            false)))",
      "basic_structure": "(assert (IsList input_list))",
      "inputs": "(declare-const input_list Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (IsList input_list))",
        "assert_1": "(define-fun C1 () Bool\n  (list_all_list input_list))",
        "assert_2": "(define-fun C2 () Bool\n  (list_all_str_list input_list))"
      },
      "constraints": {
        "assert_0": "assert isinstance(input_list, (list, tuple)), \"invalid inputs",
        "assert_1": "assert all(isinstance(x, list) for x in input_list), \"invalid inputs",
        "assert_2": "assert all(all(isinstance(y, str) for y in x) for x in input_list), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/105": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec list_all_bool ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (is-BoolVal (head v))\n                 (list_all_bool (tail v)))\n            false)))",
      "basic_structure": "(assert (IsList lst))",
      "inputs": "(declare-const lst Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList lst))",
        "assert_1": "(define-fun C1 () Bool (list_all_bool lst))"
      },
      "constraints": {
        "assert_0": "assert isinstance(lst, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(x, bool) for x in lst), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/106": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (or\n    (is-Nil l)\n    (and (is-Cons l) (let ((tl (tail l))) (IsList tl)))\n  )\n)",
      "basic_structure": "",
      "inputs": "(declare-const test_list Value)\n(declare-const test_tup Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList test_list))",
        "assert_1": "(define-fun C1 () Bool (IsList test_tup))"
      },
      "constraints": {
        "assert_0": "assert isinstance(test_list, list), \"invalid inputs",
        "assert_1": "assert isinstance(test_tup, tuple), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/108": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec is_List ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (is_List (tail l))\n            false)))\n(define-fun-rec list_all_numeric ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (let ((h (head l)) (t (tail l)))\n              (and (or (is-IntVal h) (is-FloatVal h))\n                   (list_all_numeric t)))\n            false)))",
      "basic_structure": "(assert (is_List num1))\n(assert (is_List num2))\n(assert (is_List num3))",
      "inputs": "(declare-const num1 Value)\n(declare-const num2 Value)\n(declare-const num3 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is_List num1))",
        "assert_1": "(define-fun C1 () Bool (is_List num2))",
        "assert_2": "(define-fun C2 () Bool (is_List num3))",
        "assert_3": "(define-fun C3 () Bool (list_all_numeric num1))",
        "assert_4": "(define-fun C4 () Bool (list_all_numeric num2))",
        "assert_5": "(define-fun C5 () Bool (list_all_numeric num3))"
      },
      "constraints": {
        "assert_0": "assert isinstance(num1, list), \"invalid inputs",
        "assert_1": "assert isinstance(num2, list), \"invalid inputs",
        "assert_2": "assert isinstance(num3, list), \"invalid inputs",
        "assert_3": "assert all(isinstance(x, (int, float)) for x in num1), \"invalid inputs",
        "assert_4": "assert all(isinstance(x, (int, float)) for x in num2), \"invalid inputs",
        "assert_5": "assert all(isinstance(x, (int, float)) for x in num3), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/109": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeI ((v Value)) Int\n  (ite (is-IntVal v) (ival v) 0))\n\n(define-fun IsBinStr ((v Value)) Bool\n  (ite (is-StrVal v)\n    (str.in.re (sval v)\n      (re.* (re.union (str.to.re \"0\") (str.to.re \"1\"))))\n    false))",
      "basic_structure": "(define-fun BASIC_STRUCTURE () Bool\n  (let ((sv? (is-StrVal s)))\n    (ite sv?\n      (let ((sl (str.len (sval s))))\n        (and\n          (is-IntVal n)\n          (>= sl (ival n))\n        )\n      )\n      false\n    )\n  )\n)",
      "inputs": "(declare-const s Value)\n(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal s))",
        "assert_1": "(define-fun C1 () Bool (is-IntVal n))",
        "assert_2": "(define-fun C2 () Bool (IsBinStr s))",
        "assert_3": "(define-fun C3 () Bool (>= (SafeI n) 0))"
      },
      "constraints": {
        "assert_0": "assert isinstance(s, str), \"invalid inputs",
        "assert_1": "assert isinstance(n, int), \"invalid inputs",
        "assert_2": "assert all([c in '01' for c in s]), \"invalid inputs",
        "assert_3": "assert n >= 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/111": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun isList ((v Value)) Bool\n  (or (is-Cons v) (is-Nil v)))\n\n(define-fun-rec ListAllLists ((v Value)) Bool\n  (ite (is-Cons v)\n       (let ((head_list (head v))\n             (tail_list (tail v)))\n         (and (isList head_list)\n              (ListAllLists tail_list)))\n       true))",
      "basic_structure": "",
      "inputs": "(declare-const nestedlist Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (isList nestedlist))",
        "assert_1": "(define-fun C1 () Bool\n  (ListAllLists nestedlist))"
      },
      "constraints": {
        "assert_0": "assert isinstance(nestedlist, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(item, list) for item in nestedlist), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/113": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "(assert (is-StrVal text))",
      "inputs": "(declare-const text Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal text))"
      },
      "constraints": {
        "assert_0": "assert isinstance(text, str), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/116": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec list_length ((v Value)) Int\n  (ite (is-Nil v)\n       0\n       (ite (is-Cons v)\n            (+ 1 (list_length (tail v)))\n            0)))\n\n(define-fun-rec list_all_int ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (is-IntVal (head v))\n                 (list_all_int (tail v)))\n            false)))\n\n(define-fun-rec list_all_positive ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (is-IntVal (head v))\n                 (> (ival (head v)) 0)\n                 (list_all_positive (tail v)))\n            false)))",
      "basic_structure": "(assert (IsList nums))",
      "inputs": "(declare-const nums Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList nums))",
        "assert_1": "(define-fun C1 () Bool (> (list_length nums) 0))",
        "assert_2": "(define-fun C2 () Bool (list_all_int nums))",
        "assert_3": "(define-fun C3 () Bool (list_all_positive nums))"
      },
      "constraints": {
        "assert_0": "assert isinstance(nums, tuple), \"invalid inputs",
        "assert_1": "assert len(nums) > 0, \"invalid inputs",
        "assert_2": "assert all(isinstance(x, int) for x in nums), \"invalid inputs",
        "assert_3": "assert all(x > 0 for x in nums), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/118": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "(assert (is-StrVal string))",
      "inputs": "(declare-const string Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal string))"
      },
      "constraints": {
        "assert_0": "assert isinstance(string, str), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/119": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec list_all_int ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (is-IntVal (head v))\n                 (list_all_int (tail v)))\n            false)))\n\n(define-fun-rec list_sorted ((v Value)) Bool\n  (ite (is-Cons v)\n       (let ((t (tail v)))\n         (ite (is-Cons t)\n              (let ((h1 (head v)) (h2 (head t)))\n                (and (is-IntVal h1)\n                     (is-IntVal h2)\n                     (<= (ival h1) (ival h2))\n                     (list_sorted t)))\n              true))\n       true))",
      "basic_structure": "(assert (IsList arr))",
      "inputs": "(declare-const arr Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList arr))",
        "assert_1": "(define-fun C1 () Bool (list_all_int arr))",
        "assert_2": "(define-fun C2 () Bool (list_sorted arr))"
      },
      "constraints": {
        "assert_0": "assert isinstance(arr, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(x, int) for x in arr), \"invalid inputs",
        "assert_2": "assert all(a <= b for a, b in zip(arr, arr[1:])), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/120": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (or (is-Nil l) (and (is-Cons l) (IsList (tail l)))))\n\n(define-fun IsPair ((v Value)) Bool\n  (and (is-Cons v)\n       (is-Cons (tail v))\n       (is-Nil (tail (tail v)))))\n\n(define-fun first ((p Value)) Value (head p))\n(define-fun second ((p Value)) Value (head (tail p)))\n\n(define-fun IsNumeric ((v Value)) Bool\n  (or (is-IntVal v) (is-FloatVal v)))\n\n(define-fun-rec list_all_Pair ((l Value)) Bool\n  (or (is-Nil l)\n      (and (is-Cons l)\n           (IsPair (head l))\n           (list_all_Pair (tail l)))))\n\n(define-fun-rec list_all_first_num ((l Value)) Bool\n  (or (is-Nil l)\n      (and (is-Cons l)\n           (IsPair (head l))\n           (IsNumeric (first (head l)))\n           (list_all_first_num (tail l)))))\n\n(define-fun-rec list_all_second_num ((l Value)) Bool\n  (or (is-Nil l)\n      (and (is-Cons l)\n           (IsPair (head l))\n           (IsNumeric (second (head l)))\n           (list_all_second_num (tail l)))))",
      "basic_structure": "(assert (IsList list1))",
      "inputs": "(declare-const list1 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList list1))",
        "assert_1": "(define-fun C1 () Bool (list_all_Pair list1))",
        "assert_2": "(define-fun C2 () Bool (list_all_Pair list1))",
        "assert_3": "(define-fun C3 () Bool (list_all_first_num list1))",
        "assert_4": "(define-fun C4 () Bool (list_all_second_num list1))"
      },
      "constraints": {
        "assert_0": "assert isinstance(list1, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(x, tuple) for x in list1), \"invalid inputs",
        "assert_2": "assert all(len(x) == 2 for x in list1), \"invalid inputs",
        "assert_3": "assert all(isinstance(x[0], (int, float)) for x in list1), \"invalid inputs",
        "assert_4": "assert all(isinstance(x[1], (int, float)) for x in list1), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/123": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
      "basic_structure": "",
      "inputs": "(declare-const limit Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal limit))",
        "assert_1": "(define-fun C1 () Bool (>= (SafeI limit) 1))"
      },
      "constraints": {
        "assert_0": "assert isinstance(limit, int), \"invalid inputs",
        "assert_1": "assert limit >= 1, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/124": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (or (is-Nil l) (and (is-Cons l) (IsList (tail l)))))\n\n(define-fun IsPair ((v Value)) Bool\n  (and (is-Cons v) (is-Cons (tail v)) (is-Nil (tail (tail v)))))\n\n(define-fun first ((p Value)) Value (head p))\n(define-fun second ((p Value)) Value (head (tail p)))\n\n(define-fun IsNumeric ((v Value)) Bool\n  (or (is-IntVal v) (is-FloatVal v)))\n\n(define-fun ToReal ((v Value)) Real\n  (ite (is-FloatVal v) (fval v)\n       (ite (is-IntVal v) (to_real (ival v)) 0.0)))\n\n(define-fun IsComplexPair ((v Value)) Bool\n  (and (IsPair v) (IsNumeric (first v)) (IsNumeric (second v))))\n\n(define-fun creal ((v Value)) Real (ToReal (first v)))\n(define-fun cimag ((v Value)) Real (ToReal (second v)))\n\n(define-fun SafeReal ((v Value)) Real\n  (ite (is-FloatVal v) (fval v)\n       (ite (is-IntVal v) (to_real (ival v))\n            (ite (IsComplexPair v) (creal v) 0.0))))\n\n(define-fun SafeImag ((v Value)) Real\n  (ite (IsComplexPair v) (cimag v) 0.0))",
      "basic_structure": "",
      "inputs": "(declare-const a Value)\n(declare-const b Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (or (is-IntVal a) (is-FloatVal a)))",
        "assert_1": "(define-fun C1 () Bool (or (IsComplexPair b) (is-FloatVal b)))",
        "assert_2": "(define-fun C2 () Bool (ite (IsComplexPair b) (= (creal b) 0.0) (ite (is-FloatVal b) (= (fval b) 0.0) false)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(a, (int, float)) or isinstance(a, float), \"invalid inputs",
        "assert_1": "assert isinstance(b, complex) or isinstance(b, float), \"invalid inputs",
        "assert_2": "assert b.real == 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/125": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeS ((v Value)) String (ite (is-StrVal v) (sval v) \"\"))\n(define-fun-rec all_01_char_at ((s String) (i Int) (len Int)) Bool\n  (ite (>= i len)\n       true\n       (let ((ch (str.at s i)))\n         (and (or (= ch \"0\") (= ch \"1\"))\n              (all_01_char_at s (+ i 1) len)))))",
      "basic_structure": "",
      "inputs": "(declare-const string Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal string))",
        "assert_1": "(define-fun C1 () Bool (let ((s (SafeS string))) (let ((len (str.len s))) (all_01_char_at s 0 len))))"
      },
      "constraints": {
        "assert_0": "assert isinstance(string, str), \"invalid inputs",
        "assert_1": "assert all([c in '01' for c in string]), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/126": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
      "basic_structure": "",
      "inputs": "(declare-const a Value)\n(declare-const b Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal a))",
        "assert_1": "(define-fun C1 () Bool (is-IntVal b))",
        "assert_2": "(define-fun C2 () Bool (> (SafeI a) 0))",
        "assert_3": "(define-fun C3 () Bool (> (SafeI b) 0))"
      },
      "constraints": {
        "assert_0": "assert isinstance(a, int), \"invalid inputs",
        "assert_1": "assert isinstance(b, int), \"invalid inputs",
        "assert_2": "assert a > 0, \"invalid inputs",
        "assert_3": "assert b > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/127": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const x Value)\n(declare-const y Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal x))",
        "assert_1": "(define-fun C1 () Bool (is-IntVal y))"
      },
      "constraints": {
        "assert_0": "assert isinstance(x, int), \"invalid inputs",
        "assert_1": "assert isinstance(y, int), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/128": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))\n(define-fun SafeS ((v Value)) String (ite (is-StrVal v) (sval v) \"\"))",
      "basic_structure": "(assert (is-IntVal n))\n(assert (is-StrVal s))",
      "inputs": "(declare-const n Value)\n(declare-const s Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
        "assert_1": "(define-fun C1 () Bool (is-StrVal s))",
        "assert_2": "(define-fun C2 () Bool (>= (SafeI n) 0))"
      },
      "constraints": {
        "assert_0": "assert isinstance(n, int), \"invalid inputs",
        "assert_1": "assert isinstance(s, str), \"invalid inputs",
        "assert_2": "assert n >= 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/129": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun IsList ((v Value)) Bool\n  (or (is-Nil v) (is-Cons v)))\n\n(define-fun-rec length ((l Value)) Int\n  (ite (is-Nil l) 0\n    (ite (is-Cons l)\n      (+ 1 (length (tail l)))\n      0)))\n\n(define-fun-rec all_is_list ((l Value)) Bool\n  (ite (is-Nil l) true\n    (ite (is-Cons l)\n      (and (IsList (head l)) (all_is_list (tail l)))\n      false)))\n\n(define-fun-rec all_same_length ((l Value) (len0 Int)) Bool\n  (ite (is-Nil l) true\n    (ite (is-Cons l)\n      (and (= (length (head l)) len0)\n           (all_same_length (tail l) len0))\n      false)))\n\n(define-fun-rec all_numeric_values ((l Value)) Bool\n  (ite (is-Nil l) true\n    (ite (is-Cons l)\n      (and (or (is-IntVal (head l)) (is-FloatVal (head l)))\n           (all_numeric_values (tail l)))\n      false)))\n\n(define-fun-rec all_numeric_matrix ((m Value)) Bool\n  (ite (is-Nil m) true\n    (ite (is-Cons m)\n      (and (let ((row (head m)))\n             (and (IsList row) (all_numeric_values row)))\n           (all_numeric_matrix (tail m)))\n      false)))",
      "basic_structure": "(assert (IsList my_matrix))",
      "inputs": "(declare-const my_matrix Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (IsList my_matrix))",
        "assert_1": "(define-fun C1 () Bool\n  (and (IsList my_matrix)\n       (> (length my_matrix) 0)))",
        "assert_2": "(define-fun C2 () Bool\n  (all_is_list my_matrix))",
        "assert_3": "(define-fun C3 () Bool\n  (and (is-Cons my_matrix)\n       (let ((first_row (head my_matrix)))\n         (and (IsList first_row)\n              (> (length first_row) 0)))))",
        "assert_4": "(define-fun C4 () Bool\n  (and (is-Cons my_matrix)\n       (let ((row0 (head my_matrix))\n             (len0 (length (head my_matrix))))\n         (and (IsList row0)\n              (all_same_length my_matrix len0)))))",
        "assert_5": "(define-fun C5 () Bool\n  (all_numeric_matrix my_matrix))"
      },
      "constraints": {
        "assert_0": "assert isinstance(my_matrix, list), \"invalid inputs",
        "assert_1": "assert len(my_matrix) > 0, \"invalid inputs",
        "assert_2": "assert all(isinstance(row, list) for row in my_matrix), \"invalid inputs",
        "assert_3": "assert len(my_matrix[0]) > 0, \"invalid inputs",
        "assert_4": "assert all(len(row) == len(my_matrix[0]) for row in my_matrix), \"invalid inputs",
        "assert_5": "assert all(isinstance(item, (int, float)) for row in my_matrix for item in row), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/130": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec AllValid ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (let ((hd (head v)) (tl (tail v)))\n              (and\n                (or (is-IntVal hd) (is-FloatVal hd) (is-StrVal hd))\n                (AllValid tl)))\n            false)))",
      "basic_structure": "",
      "inputs": "(declare-const nums Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList nums))",
        "assert_1": "(define-fun C1 () Bool (AllValid nums))"
      },
      "constraints": {
        "assert_0": "assert isinstance(nums, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(n, (int, float, str)) for n in nums), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/131": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "(assert (is-StrVal str1))",
      "inputs": "(declare-const str1 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal str1))"
      },
      "constraints": {
        "assert_0": "assert isinstance(str1, str), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/132": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n(define-fun-rec list_all_str ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (let ((h (head v)) (t (tail v)))\n              (and (is-StrVal h) (list_all_str t)))\n            false)))",
      "basic_structure": "",
      "inputs": "(declare-const tup1 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (IsList tup1))",
        "assert_1": "(define-fun C1 () Bool\n  (=> C0 (list_all_str tup1)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(tup1, tuple), \"invalid inputs",
        "assert_1": "assert all(isinstance(item, str) for item in tup1), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/133": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (ite (is-Nil l) true\n    (ite (is-Cons l) (IsList (tail l)) false)))\n\n(define-fun-rec list_all_numeric ((l Value)) Bool\n  (ite (is-Nil l) true\n    (ite (is-Cons l)\n      (and (or (is-IntVal (head l)) (is-FloatVal (head l)))\n           (list_all_numeric (tail l)))\n    false)))",
      "basic_structure": "(assert (IsList nums))",
      "inputs": "(declare-const nums Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList nums))",
        "assert_1": "(define-fun C1 () Bool (list_all_numeric nums))"
      },
      "constraints": {
        "assert_0": "assert isinstance(nums, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(x, (int, float)) for x in nums), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/135": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun UnwrapInt ((v Value)) Int\n  (ite (is-IntVal v) (ival v) 0))",
      "basic_structure": "",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (is-IntVal n))",
        "assert_1": "(define-fun C1 () Bool\n  (>= (UnwrapInt n) 0))"
      },
      "constraints": {
        "assert_0": "assert isinstance(n, int), \"invalid inputs",
        "assert_1": "assert n >= 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/137": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec list_all_int ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (is-IntVal (head v))\n                 (list_all_int (tail v)))\n            false)))",
      "basic_structure": "(assert (IsList nums))",
      "inputs": "(declare-const nums Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList nums))",
        "assert_1": "(define-fun C1 () Bool (list_all_int nums))",
        "assert_2": "(define-fun C2 () Bool (is-Cons nums))"
      },
      "constraints": {
        "assert_0": "assert isinstance(nums, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(x, int) for x in nums), \"invalid inputs",
        "assert_2": "assert len(nums) > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/138": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "(assert (is-IntVal n))",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))"
      },
      "constraints": {
        "assert_0": "assert isinstance(n, int), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/139": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const r Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal r))",
        "assert_1": "(define-fun C1 () Bool (and (is-IntVal r) (> (ival r) 0)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(r, int), \"invalid inputs",
        "assert_1": "assert r > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/140": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((x Value)) Bool\n  (ite (is-Nil x)\n       true\n       (ite (is-Cons x)\n            (IsList (tail x))\n            false)))\n\n(define-fun-rec ListAllList ((lst Value)) Bool\n  (ite (is-Nil lst)\n       true\n       (ite (is-Cons lst)\n            (and (IsList (head lst))\n                 (ListAllList (tail lst)))\n            false)))\n\n(define-fun-rec ListAllNumeric ((lst Value)) Bool\n  (ite (is-Nil lst)\n       true\n       (ite (is-Cons lst)\n            (and (or (is-IntVal (head lst))\n                     (is-FloatVal (head lst)))\n                 (ListAllNumeric (tail lst)))\n            false)))\n\n(define-fun-rec ListAllElementsNumeric ((matrix Value)) Bool\n  (ite (is-Nil matrix)\n       true\n       (ite (is-Cons matrix)\n            (and (ListAllNumeric (head matrix))\n                 (ListAllElementsNumeric (tail matrix)))\n            false)))",
      "basic_structure": "",
      "inputs": "(declare-const test_list Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList test_list))",
        "assert_1": "(define-fun C1 () Bool (ListAllList test_list))",
        "assert_2": "(define-fun C2 () Bool (ListAllElementsNumeric test_list))"
      },
      "constraints": {
        "assert_0": "assert isinstance(test_list, (list, tuple)), \"invalid inputs",
        "assert_1": "assert all(isinstance(x, (list, tuple)) for x in test_list), \"invalid inputs",
        "assert_2": "assert all(all(isinstance(y, (int, float)) for y in x) for x in test_list), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/141": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec list_all_numeric ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (or (is-IntVal (head v)) (is-FloatVal (head v)))\n                 (list_all_numeric (tail v)))\n            false)))",
      "basic_structure": "(assert (IsList nums))",
      "inputs": "(declare-const nums Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList nums))",
        "assert_1": "(define-fun C1 () Bool (list_all_numeric nums))"
      },
      "constraints": {
        "assert_0": "assert isinstance(nums, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(x, (int, float)) for x in nums), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/142": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))",
      "basic_structure": "",
      "inputs": "(declare-const list1 Value)\n(declare-const list2 Value)\n(declare-const list3 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList list1))",
        "assert_1": "(define-fun C1 () Bool (IsList list2))",
        "assert_2": "(define-fun C2 () Bool (IsList list3))"
      },
      "constraints": {
        "assert_0": "assert isinstance(list1, list), \"invalid inputs",
        "assert_1": "assert isinstance(list2, list), \"invalid inputs",
        "assert_2": "assert isinstance(list3, list), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/145": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (or (is-Nil v)\n      (and (is-Cons v)\n           (let ((tailVal (tail v)))\n             (IsList tailVal)))))\n\n(define-fun-rec length ((v Value)) Int\n  (ite (is-Nil v)\n       0\n       (ite (is-Cons v)\n            (let ((tailVal (tail v)))\n              (+ 1 (length tailVal)))\n            0)))\n\n(define-fun-rec all_numeric ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (or (is-IntVal (head v)) (is-FloatVal (head v)))\n                 (all_numeric (tail v)))\n            false)))",
      "basic_structure": "(assert (IsList arr))",
      "inputs": "(declare-const arr Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList arr))",
        "assert_1": "(define-fun C1 () Bool (> (length arr) 0))",
        "assert_2": "(define-fun C2 () Bool (all_numeric arr))"
      },
      "constraints": {
        "assert_0": "assert isinstance(arr, (tuple, list)), \"invalid inputs",
        "assert_1": "assert len(arr) > 0, \"invalid inputs",
        "assert_2": "assert all(isinstance(x, (int, float)) for x in arr), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/160": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const a Value)\n(declare-const b Value)\n(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal a))",
        "assert_1": "(define-fun C1 () Bool (is-IntVal b))",
        "assert_2": "(define-fun C2 () Bool (is-IntVal n))"
      },
      "constraints": {
        "assert_0": "assert isinstance(a, int), \"invalid inputs",
        "assert_1": "assert isinstance(b, int), \"invalid inputs",
        "assert_2": "assert isinstance(n, int), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/161": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))",
      "basic_structure": "(assert (IsList list1))\n(assert (IsList list2))",
      "inputs": "(declare-const list1 Value)\n(declare-const list2 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (or (is-Nil list1) (is-Cons list1)))",
        "assert_1": "(define-fun C1 () Bool (or (is-Nil list2) (is-Cons list2)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(list1, list), \"invalid inputs",
        "assert_1": "assert isinstance(list2, list), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/162": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
      "basic_structure": "(assert (is-IntVal n))",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))"
      },
      "constraints": {
        "assert_0": "assert isinstance(n, int), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/165": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun str_all_alpha ((v Value)) Bool (and (is-StrVal v) (str.in.re (sval v) (re.* (re.union (re.range \"A\" \"Z\") (re.range \"a\" \"z\"))))))",
      "basic_structure": "(assert (is-StrVal str1))",
      "inputs": "(declare-const str1 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal str1))",
        "assert_1": "(define-fun C1 () Bool (str_all_alpha str1))"
      },
      "constraints": {
        "assert_0": "assert isinstance(str1, str), \"invalid inputs",
        "assert_1": "assert all(x.isalpha() for x in str1), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/166": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n    true\n    (ite (is-Cons v)\n      (IsList (tail v))\n      false)))\n(define-fun-rec ListAllInt ((v Value)) Bool\n  (ite (is-Nil v)\n    true\n    (ite (is-Cons v)\n      (and (is-IntVal (head v)) (ListAllInt (tail v)))\n      false)))",
      "basic_structure": "(assert (IsList A))",
      "inputs": "(declare-const A Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList A))",
        "assert_1": "(define-fun C1 () Bool (ListAllInt A))"
      },
      "constraints": {
        "assert_0": "assert isinstance(A, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(x, int) for x in A), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/167": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
      "basic_structure": "(define-fun BasicStructure () Bool true)",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
        "assert_1": "(define-fun C1 () Bool (and C0 (>= (SafeI n) 0)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(n, int), \"invalid inputs",
        "assert_1": "assert n >= 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/168": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v) true\n    (ite (is-Cons v)\n      (IsList (tail v))\n      false)))",
      "basic_structure": "(assert (IsList a))",
      "inputs": "(declare-const a Value)\n(declare-const x Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList a))",
        "assert_1": "(define-fun C1 () Bool (or (is-IntVal x) (is-FloatVal x)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(a, list), \"invalid inputs",
        "assert_1": "assert isinstance(x, (int, float)), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/170": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec length ((v Value)) Int\n  (ite (is-Cons v)\n       (+ 1 (length (tail v)))\n       0))\n\n(define-fun-rec list_all_numeric ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (let ((h (head v)) (t (tail v)))\n              (ite (or (is-IntVal h) (is-FloatVal h))\n                   (list_all_numeric t)\n                   false))\n            false)))",
      "basic_structure": "(assert (IsList list1))",
      "inputs": "(declare-const list1 Value)\n(declare-const m Value)\n(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (IsList list1))",
        "assert_1": "(define-fun C1 () Bool\n  (list_all_numeric list1))",
        "assert_2": "(define-fun C2 () Bool\n  (is-IntVal m))",
        "assert_3": "(define-fun C3 () Bool\n  (is-IntVal n))",
        "assert_4": "(define-fun C4 () Bool\n  (and C2\n       (let ((m_int (ival m)) (len_v (length list1)))\n         (and (<= 0 m_int) (< m_int len_v)))))",
        "assert_5": "(define-fun C5 () Bool\n  (and C3\n       (let ((n_int (ival n)) (len_v (length list1)))\n         (and (<= 0 n_int) (< n_int len_v)))))"
      },
      "constraints": {
        "assert_0": "assert isinstance(list1, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(item, (int, float)) for item in list1), \"invalid inputs",
        "assert_2": "assert isinstance(m, int), \"invalid inputs",
        "assert_3": "assert isinstance(n, int), \"invalid inputs",
        "assert_4": "assert 0 <= m < len(list1), \"invalid inputs",
        "assert_5": "assert 0 <= n < len(list1), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/171": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun isNumber ((v Value)) Bool (or (is-IntVal v) (is-FloatVal v)))",
      "basic_structure": "(assert true)",
      "inputs": "(declare-const a Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (isNumber a))"
      },
      "constraints": {
        "assert_0": "assert isinstance(a, (int, float)), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/172": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const s Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal s))"
      },
      "constraints": {
        "assert_0": "assert isinstance(s, str), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/222": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun IsList ((v Value)) Bool\n  (or (is-Nil v) (is-Cons v)))\n\n(define-fun-rec length ((l Value)) Int\n  (ite (is-Nil l)\n       0\n       (+ 1 (length (tail l)))))",
      "basic_structure": "",
      "inputs": "(declare-const test_tuple Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (IsList test_tuple))",
        "assert_1": "(define-fun C1 () Bool\n  (> (length test_tuple) 0))"
      },
      "constraints": {
        "assert_0": "assert isinstance(test_tuple, tuple), \"invalid inputs",
        "assert_1": "assert len(test_tuple) > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/223": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(declare-fun IsList (Value) Bool)\n(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v) true\n    (ite (is-Cons v)\n      (IsList (tail v))\n      false)))\n(define-fun-rec length ((v Value)) Int\n  (ite (is-Nil v) 0\n    (ite (is-Cons v)\n      (+ 1 (length (tail v)))\n      0)))\n(define-fun-rec list_all_numeric ((v Value)) Bool\n  (ite (is-Nil v) true\n    (ite (is-Cons v)\n      (and (or (is-IntVal (head v)) (is-FloatVal (head v)))\n           (list_all_numeric (tail v)))\n      false)))\n(define-fun num_le ((a Value) (b Value)) Bool\n  (ite (and (is-IntVal a) (is-IntVal b))\n    (<= (to_real (ival a)) (to_real (ival b)))\n    (ite (and (is-FloatVal a) (is-FloatVal b))\n      (<= (fval a) (fval b))\n      (ite (and (is-IntVal a) (is-FloatVal b))\n        (<= (to_real (ival a)) (fval b))\n        (ite (and (is-FloatVal a) (is-IntVal b))\n          (<= (fval a) (to_real (ival b)))\n          false)))))\n(define-fun-rec is_sorted ((v Value)) Bool\n  (ite (is-Cons v)\n    (let ((hd (head v)) (tl (tail v)))\n      (ite (is-Cons tl)\n        (let ((hd2 (head tl)) (tl2 (tail tl)))\n          (and (num_le hd hd2) (is_sorted tl)))\n        true))\n    true))",
      "basic_structure": "(assert (IsList arr))\n(assert (list_all_numeric arr))\n(assert (is-IntVal n))\n(assert (or (is-IntVal x) (is-FloatVal x)))\n(assert (<= (length arr) (ival n)))",
      "inputs": "(declare-const arr Value)\n(declare-const n Value)\n(declare-const x Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList arr))",
        "assert_1": "(define-fun C1 () Bool (list_all_numeric arr))",
        "assert_2": "(define-fun C2 () Bool (is_sorted arr))",
        "assert_3": "(define-fun C3 () Bool (is-IntVal n))",
        "assert_4": "(define-fun C4 () Bool (or (is-IntVal x) (is-FloatVal x)))",
        "assert_5": "(define-fun C5 () Bool (<= (length arr) (ival n)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(arr, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(item, (int, float)) for item in arr), \"invalid inputs",
        "assert_2": "assert all(a <= b for a, b in zip(arr[:n], arr[1:n])), \"invalid inputs",
        "assert_3": "assert isinstance(n, int), \"invalid inputs",
        "assert_4": "assert isinstance(x, (int, float)), \"invalid inputs",
        "assert_5": "assert len(arr) <= n, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/224": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeIval ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
      "basic_structure": "",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
        "assert_1": "(define-fun C1 () Bool (>= (SafeIval n) 0))"
      },
      "constraints": {
        "assert_0": "assert isinstance(n, int), \"invalid inputs",
        "assert_1": "assert n >= 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/226": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeStr ((v Value)) String (ite (is-StrVal v) (sval v) \"\"))",
      "basic_structure": "",
      "inputs": "(declare-const str1 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal str1))"
      },
      "constraints": {
        "assert_0": "assert isinstance(str1, str), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/227": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const a Value)\n(declare-const b Value)\n(declare-const c Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (or (is-IntVal a) (is-FloatVal a)))",
        "assert_1": "(define-fun C1 () Bool (or (is-IntVal b) (is-FloatVal b)))",
        "assert_2": "(define-fun C2 () Bool (or (is-IntVal c) (is-FloatVal c)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(a, (int, float)), \"invalid inputs",
        "assert_1": "assert isinstance(b, (int, float)), \"invalid inputs",
        "assert_2": "assert isinstance(c, (int, float)), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/230": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeStr ((v Value)) String (ite (is-StrVal v) (sval v) \"\"))",
      "basic_structure": "(define-fun BasicStructure () Bool (and (is-StrVal str1) (is-StrVal char)))",
      "inputs": "(declare-const str1 Value)\n(declare-const char Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal str1))",
        "assert_1": "(define-fun C1 () Bool (is-StrVal char))",
        "assert_2": "(define-fun C2 () Bool (and (is-StrVal char) (= (str.len (SafeStr char)) 1)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(str1, str), \"invalid inputs",
        "assert_1": "assert isinstance(char, str), \"invalid inputs",
        "assert_2": "assert len(char) == 1, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/232": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))\n(define-fun-rec IsList ((l Value)) Bool (or (is-Nil l) (and (is-Cons l) (IsList (tail l)))))\n(define-fun-rec list_all_numeric ((l Value)) Bool (or (is-Nil l) (and (is-Cons l) (or (is-IntVal (head l)) (is-FloatVal (head l))) (list_all_numeric (tail l)))))\n(define-fun-rec list_length ((l Value)) Int (ite (is-Nil l) 0 (ite (is-Cons l) (+ 1 (list_length (tail l))) 0)))",
      "basic_structure": "",
      "inputs": "(declare-const list1 Value)\n(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList list1))",
        "assert_1": "(define-fun C1 () Bool (and (IsList list1) (list_all_numeric list1)))",
        "assert_2": "(define-fun C2 () Bool (is-IntVal n))",
        "assert_3": "(define-fun C3 () Bool (and (is-IntVal n) (<= 0 (SafeI n)) (<= (SafeI n) (list_length list1))))"
      },
      "constraints": {
        "assert_0": "assert isinstance(list1, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(x, (int, float)) for x in list1), \"invalid inputs",
        "assert_2": "assert isinstance(n, int), \"invalid inputs",
        "assert_3": "assert 0 <= n <= len(list1), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/233": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun is-Numeric ((v Value)) Bool\n  (or (is-IntVal v) (is-FloatVal v)))\n(define-fun toReal ((v Value)) Real\n  (ite (is-IntVal v) (to_real (ival v))\n    (ite (is-FloatVal v) (fval v) 0.0)))",
      "basic_structure": "",
      "inputs": "(declare-const r Value)\n(declare-const h Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-Numeric r))",
        "assert_1": "(define-fun C1 () Bool (is-Numeric h))",
        "assert_2": "(define-fun C2 () Bool (> (toReal r) 0.0))",
        "assert_3": "(define-fun C3 () Bool (> (toReal h) 0.0))"
      },
      "constraints": {
        "assert_0": "assert isinstance(r, (int, float)), \"invalid inputs",
        "assert_1": "assert isinstance(h, (int, float)), \"invalid inputs",
        "assert_2": "assert r > 0, \"invalid inputs",
        "assert_3": "assert h > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/234": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeNum ((v Value)) Real\n  (ite (is-IntVal v) (to_real (ival v))\n    (ite (is-FloatVal v) (fval v) 0.0)))",
      "basic_structure": "",
      "inputs": "(declare-const l Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (or (is-IntVal l) (is-FloatVal l)))",
        "assert_1": "(define-fun C1 () Bool (and C0 (> (SafeNum l) 0.0)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(l, (int, float)), \"invalid inputs",
        "assert_1": "assert l > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/235": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeInt ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
      "basic_structure": "(assert (is-IntVal n))",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
        "assert_1": "(define-fun C1 () Bool (>= (SafeInt n) 0))"
      },
      "constraints": {
        "assert_0": "assert isinstance(n, int), \"invalid inputs",
        "assert_1": "assert n >= 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/237": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec length ((v Value)) Int\n  (ite (is-Nil v)\n       0\n       (ite (is-Cons v)\n            (+ 1 (length (tail v)))\n            0)))\n\n(define-fun IsTuple ((v Value)) Bool\n  (and (IsList v)\n       (= (length v) 2)))\n\n(define-fun-rec list_all_tuple ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (and (IsTuple (head v))\n            (list_all_tuple (tail v)))))",
      "basic_structure": "(assert (IsList test_list))",
      "inputs": "(declare-const test_list Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (IsList test_list))",
        "assert_1": "(define-fun C1 () Bool\n  (list_all_tuple test_list))"
      },
      "constraints": {
        "assert_0": "assert isinstance(test_list, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(x, tuple) for x in test_list), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/238": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const str1 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal str1))"
      },
      "constraints": {
        "assert_0": "assert isinstance(str1, str), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/239": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
      "basic_structure": "",
      "inputs": "(declare-const m Value)\n(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (let ((mInt (SafeI m))) (and (is-IntVal m) (> mInt 0))))",
        "assert_1": "(define-fun C1 () Bool (let ((nInt (SafeI n))) (and (is-IntVal n) (> nInt 0))))"
      },
      "constraints": {
        "assert_0": "assert isinstance(m, int) and m > 0, \"invalid inputs",
        "assert_1": "assert isinstance(n, int) and n > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/240": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec Len ((v Value)) Int\n  (ite (is-Nil v)\n       0\n       (ite (is-Cons v)\n            (+ 1 (Len (tail v)))\n            0)))",
      "basic_structure": "(assert (IsList list1))\n(assert (IsList list2))",
      "inputs": "(declare-const list1 Value)\n(declare-const list2 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList list1))",
        "assert_1": "(define-fun C1 () Bool (> (Len list1) 0))",
        "assert_2": "(define-fun C2 () Bool (IsList list2))"
      },
      "constraints": {
        "assert_0": "assert isinstance(list1, list), \"invalid inputs",
        "assert_1": "assert len(list1) > 0, \"invalid inputs",
        "assert_2": "assert isinstance(list2, list), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/242": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const str1 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal str1))"
      },
      "constraints": {
        "assert_0": "assert isinstance(str1, str), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/244": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeToReal ((v Value)) Real\n  (ite (is-IntVal v)\n       (to_real (ival v))\n       (ite (is-FloatVal v)\n            (fval v)\n            0.0)))",
      "basic_structure": "(assert (or (is-IntVal N) (is-FloatVal N)))",
      "inputs": "(declare-const N Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (or (is-IntVal N) (is-FloatVal N)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(N, (int, float)), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/245": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (or (is-Nil l)\n      (and (is-Cons l)\n           (let ((t (tail l)))\n             (IsList t)))))\n(define-fun-rec length ((l Value)) Int\n  (ite (is-Nil l) 0\n       (ite (is-Cons l)\n            (let ((t (tail l)))\n              (+ 1 (length t)))\n            0)))\n(define-fun-rec list_all_numeric ((l Value)) Bool\n  (ite (is-Nil l) true\n       (ite (is-Cons l)\n            (let ((h (head l)) (t (tail l)))\n              (and (or (is-IntVal h) (is-FloatVal h))\n                   (list_all_numeric t)))\n            false)))",
      "basic_structure": "(assert (IsList arr))",
      "inputs": "(declare-const arr Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList arr))",
        "assert_1": "(define-fun C1 () Bool (> (length arr) 0))",
        "assert_2": "(define-fun C2 () Bool (list_all_numeric arr))"
      },
      "constraints": {
        "assert_0": "assert isinstance(arr, list), \"invalid inputs",
        "assert_1": "assert len(arr) > 0, \"invalid inputs",
        "assert_2": "assert all(isinstance(x, (int, float)) for x in arr), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/247": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "(assert (is-StrVal str1))",
      "inputs": "(declare-const str1 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal str1))"
      },
      "constraints": {
        "assert_0": "assert isinstance(str1, str), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/250": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))",
      "basic_structure": "",
      "inputs": "(declare-const tup Value)\n(declare-const x Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList tup))"
      },
      "constraints": {
        "assert_0": "assert isinstance(tup, tuple), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/251": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool (ite (is-Nil v) true (ite (is-Cons v) (IsList (tail v)) false)))",
      "basic_structure": "(assert (IsList list1))",
      "inputs": "(declare-const list1 Value)\n(declare-const element Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList list1))"
      },
      "constraints": {
        "assert_0": "assert isinstance(list1, list), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/252": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun IsPair ((v Value)) Bool\n  (and (is-Cons v) (is-Cons (tail v)) (is-Nil (tail (tail v)))))\n\n(define-fun first ((p Value)) Value (head p))\n(define-fun second ((p Value)) Value (head (tail p)))\n\n(define-fun IsNumeric ((v Value)) Bool (or (is-IntVal v) (is-FloatVal v)))\n\n(define-fun IsComplexPair ((v Value)) Bool\n  (and (IsPair v) (IsNumeric (first v)) (IsNumeric (second v))))\n\n(define-fun IsNumber ((v Value)) Bool (or (is-IntVal v) (is-FloatVal v) (IsComplexPair v)))",
      "basic_structure": "",
      "inputs": "(declare-const numbers Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsNumber numbers))"
      },
      "constraints": {
        "assert_0": "assert isinstance(numbers, (int, float, complex)), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/253": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))",
      "basic_structure": "(assert (IsList list1))",
      "inputs": "(declare-const list1 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList list1))"
      },
      "constraints": {
        "assert_0": "assert isinstance(list1, list), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/255": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n(define-fun SafeI ((v Value)) Int\n  (ite (is-IntVal v)\n       (ival v)\n       0))",
      "basic_structure": "(assert (IsList l))\n(assert (is-IntVal n))",
      "inputs": "(declare-const l Value)\n(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (IsList l))",
        "assert_1": "(define-fun C1 () Bool\n  (is-IntVal n))",
        "assert_2": "(define-fun C2 () Bool\n  (and (is-IntVal n)\n       (>= (SafeI n) 0)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(l, list), \"invalid inputs",
        "assert_1": "assert isinstance(n, int), \"invalid inputs",
        "assert_2": "assert n >= 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/256": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (and (is-IntVal n) (>= (ival n) 0)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(n, int) and n >= 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/257": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun is-IntOrFloat ((v Value)) Bool\n  (or (is-IntVal v) (is-FloatVal v)))",
      "basic_structure": "(assert true)",
      "inputs": "(declare-const a Value)\n(declare-const b Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntOrFloat a))",
        "assert_1": "(define-fun C1 () Bool (is-IntOrFloat b))"
      },
      "constraints": {
        "assert_0": "assert isinstance(a, (int, float)), \"invalid inputs",
        "assert_1": "assert isinstance(b, (int, float)), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/259": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (or (is-Nil v) (and (is-Cons v) (IsList (tail v)))))\n\n(define-fun-rec length ((v Value)) Int\n  (ite (is-Nil v) 0 (ite (is-Cons v) (+ 1 (length (tail v))) 0)))\n\n(define-fun-rec list_all_list ((v Value)) Bool\n  (or (is-Nil v)\n      (and (is-Cons v) (IsList (head v)) (list_all_list (tail v)))))\n\n(define-fun-rec list_all_len2 ((v Value)) Bool\n  (or (is-Nil v)\n      (and (is-Cons v) (IsList (head v)) (= (length (head v)) 2) (list_all_len2 (tail v)))))\n\n; pair (a,b) \u2261 Cons a (Cons b Nil)\n(define-fun IsPair ((v Value)) Bool\n  (and (is-Cons v) (is-Cons (tail v)) (is-Nil (tail (tail v)))))\n(define-fun first ((p Value)) Value (head p))\n(define-fun second ((p Value)) Value (head (tail p)))\n(define-fun IsNumeric ((v Value)) Bool (or (is-IntVal v) (is-FloatVal v)))\n\n; \ubaa8\ub4e0 \uc6d0\uc18c\uac00 (numeric, numeric) pair\uc778\uac00?\n(define-fun-rec list_all_numeric ((v Value)) Bool\n  (or (is-Nil v)\n      (and (is-Cons v)\n           (let ((p (head v)))\n             (and (IsPair p) (IsNumeric (first p)) (IsNumeric (second p))))\n           (list_all_numeric (tail v)))))",
      "basic_structure": "(assert (IsList test_tup1))\n(assert (IsList test_tup2))",
      "inputs": "(declare-const test_tup1 Value)\n(declare-const test_tup2 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList test_tup1))",
        "assert_1": "(define-fun C1 () Bool (IsList test_tup2))",
        "assert_2": "(define-fun C2 () Bool (= (length test_tup1) (length test_tup2)))",
        "assert_3": "(define-fun C3 () Bool (> (length test_tup1) 0))",
        "assert_4": "(define-fun C4 () Bool (> (length test_tup2) 0))",
        "assert_5": "(define-fun C5 () Bool (list_all_list test_tup1))",
        "assert_6": "(define-fun C6 () Bool (list_all_list test_tup2))",
        "assert_7": "(define-fun C7 () Bool (list_all_len2 test_tup1))",
        "assert_8": "(define-fun C8 () Bool (list_all_len2 test_tup2))",
        "assert_9": "(define-fun C9 () Bool (list_all_numeric test_tup1))",
        "assert_10": "(define-fun C10 () Bool (list_all_numeric test_tup2))"
      },
      "constraints": {
        "assert_0": "assert isinstance(test_tup1, tuple), \"invalid inputs",
        "assert_1": "assert isinstance(test_tup2, tuple), \"invalid inputs",
        "assert_2": "assert len(test_tup1) == len(test_tup2), \"invalid inputs",
        "assert_3": "assert len(test_tup1) > 0, \"invalid inputs",
        "assert_4": "assert len(test_tup2) > 0, \"invalid inputs",
        "assert_5": "assert all(isinstance(x, tuple) for x in test_tup1), \"invalid inputs",
        "assert_6": "assert all(isinstance(x, tuple) for x in test_tup2), \"invalid inputs",
        "assert_7": "assert all(len(x) == 2 for x in test_tup1), \"invalid inputs",
        "assert_8": "assert all(len(x) == 2 for x in test_tup2), \"invalid inputs",
        "assert_9": "assert all(isinstance(a, (int, float)) and isinstance(b, (int, float)) for a, b in test_tup1), \"invalid inputs",
        "assert_10": "assert all(isinstance(a, (int, float)) and isinstance(b, (int, float)) for a, b in test_tup2), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/260": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
      "basic_structure": "",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
        "assert_1": "(define-fun C1 () Bool (>= (SafeI n) 0))"
      },
      "constraints": {
        "assert_0": "assert isinstance(n, int), \"invalid inputs",
        "assert_1": "assert n >= 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/261": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v) true\n    (ite (is-Cons v)\n      (IsList (tail v))\n      false)))\n\n(define-fun-rec length ((lst Value)) Int\n  (ite (is-Nil lst) 0\n    (ite (is-Cons lst)\n      (+ 1 (length (tail lst)))\n      0)))\n\n(define-fun-rec list_all_numeric ((lst Value)) Bool\n  (ite (is-Nil lst) true\n    (ite (is-Cons lst)\n      (let ((h (head lst)) (t (tail lst)))\n        (and (or (is-IntVal h) (is-FloatVal h))\n             (list_all_numeric t)))\n      false)))\n\n(define-fun-rec list_nonzero_numeric ((lst Value)) Bool\n  (ite (is-Nil lst) true\n    (ite (is-Cons lst)\n      (let ((h (head lst)) (t (tail lst)))\n        (and (or (is-IntVal h) (is-FloatVal h))\n             (ite (is-IntVal h)\n                  (not (= (ival h) 0))\n                  (not (= (fval h) 0)))\n             (list_nonzero_numeric t)))\n      false)))",
      "basic_structure": "(assert (IsList test_tup1))\n(assert (IsList test_tup2))",
      "inputs": "(declare-const test_tup1 Value)\n(declare-const test_tup2 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList test_tup1))",
        "assert_1": "(define-fun C1 () Bool (IsList test_tup2))",
        "assert_2": "(define-fun C2 () Bool (= (length test_tup1) (length test_tup2)))",
        "assert_3": "(define-fun C3 () Bool (list_all_numeric test_tup1))",
        "assert_4": "(define-fun C4 () Bool (list_nonzero_numeric test_tup2))"
      },
      "constraints": {
        "assert_0": "assert isinstance(test_tup1, tuple), \"invalid inputs",
        "assert_1": "assert isinstance(test_tup2, tuple), \"invalid inputs",
        "assert_2": "assert len(test_tup1) == len(test_tup2), \"invalid inputs",
        "assert_3": "assert all(isinstance(ele, (int, float)) for ele in test_tup1), \"invalid inputs",
        "assert_4": "assert all(isinstance(ele, (int, float)) and ele != 0 for ele in test_tup2), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/262": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec length ((v Value)) Int\n  (ite (is-Nil v)\n       0\n       (ite (is-Cons v)\n            (+ 1 (length (tail v)))\n            0)))",
      "basic_structure": "",
      "inputs": "(declare-const list1 Value)\n(declare-const L Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList list1))",
        "assert_1": "(define-fun C1 () Bool (is-IntVal L))",
        "assert_2": "(define-fun C2 () Bool (and (is-IntVal L)\n                                      (<= 0 (ival L))\n                                      (<= (ival L) (length list1))))"
      },
      "constraints": {
        "assert_0": "assert isinstance(list1, list), \"invalid inputs",
        "assert_1": "assert isinstance(L, int), \"invalid inputs",
        "assert_2": "assert 0 <= L <= len(list1), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/264": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const h_age Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal h_age))",
        "assert_1": "(define-fun C1 () Bool (and (is-IntVal h_age) (>= (ival h_age) 0)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(h_age, int), \"invalid inputs",
        "assert_1": "assert h_age >= 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/265": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))",
      "basic_structure": "",
      "inputs": "(declare-const S Value)\n(declare-const step Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList S))",
        "assert_1": "(define-fun C1 () Bool (is-IntVal step))",
        "assert_2": "(define-fun C2 () Bool (ite C1 (> (ival step) 0) false))"
      },
      "constraints": {
        "assert_0": "assert isinstance(S, list), \"invalid inputs",
        "assert_1": "assert isinstance(step, int), \"invalid inputs",
        "assert_2": "assert step > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/266": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const l Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (or (is-IntVal l) (is-FloatVal l)))",
        "assert_1": "(define-fun C1 () Bool (or (and (is-IntVal l) (> (to_real (ival l)) 0)) (and (is-FloatVal l) (> (fval l) 0))))"
      },
      "constraints": {
        "assert_0": "assert isinstance(l, (int, float)), \"invalid inputs",
        "assert_1": "assert l > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/267": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
      "basic_structure": "",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
        "assert_1": "(define-fun C1 () Bool (and C0 (> (SafeI n) 0)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(n, int), \"invalid inputs",
        "assert_1": "assert n > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/268": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeI ((v Value)) Int\n  (ite (is-IntVal v) (ival v) 0)\n)",
      "basic_structure": "",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
        "assert_1": "(define-fun C1 () Bool (ite (is-IntVal n) (> (ival n) 0) false))"
      },
      "constraints": {
        "assert_0": "assert isinstance(n, int), \"invalid inputs",
        "assert_1": "assert n > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/269": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeS ((v Value)) String (ite (is-StrVal v) (sval v) \"\"))",
      "basic_structure": "(assert (is-StrVal k))",
      "inputs": "(declare-const k Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal k))",
        "assert_1": "(define-fun C1 () Bool (= (str.len (SafeS k)) 1))"
      },
      "constraints": {
        "assert_0": "assert isinstance(k, str), \"invalid inputs",
        "assert_1": "assert len(k)==1, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/270": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec list_all_int ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (is-IntVal (head v))\n                 (list_all_int (tail v)))\n            false)))",
      "basic_structure": "(assert (IsList arr))",
      "inputs": "(declare-const arr Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList arr))",
        "assert_1": "(define-fun C1 () Bool (list_all_int arr))"
      },
      "constraints": {
        "assert_0": "assert isinstance(arr, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(x, int) for x in arr), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/271": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
        "assert_1": "(define-fun C1 () Bool (ite (is-IntVal n) (> (ival n) 0) false))"
      },
      "constraints": {
        "assert_0": "assert isinstance(n, int), \"invalid inputs",
        "assert_1": "assert n > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/272": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec ListAllNonEmptyTuples ((lst Value)) Bool\n  (ite (is-Nil lst)\n       true\n       (ite (is-Cons lst)\n            (and (is-Cons (head lst))\n                 (ListAllNonEmptyTuples (tail lst)))\n            false)))",
      "basic_structure": "(assert (IsList test_list))",
      "inputs": "(declare-const test_list Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList test_list))",
        "assert_1": "(define-fun C1 () Bool (ListAllNonEmptyTuples test_list))"
      },
      "constraints": {
        "assert_0": "assert isinstance(test_list, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(x, tuple) and len(x) > 0 for x in test_list), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/273": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v) true\n    (ite (is-Cons v) (IsList (tail v)) false)))\n\n(define-fun-rec length ((v Value)) Int\n  (ite (is-Nil v) 0\n    (ite (is-Cons v) (+ 1 (length (tail v))) 0)))\n\n(define-fun-rec list_all_numeric ((v Value)) Bool\n  (ite (is-Nil v) true\n    (ite (is-Cons v)\n      (let ((h (head v)))\n        (and (or (is-IntVal h) (is-FloatVal h))\n             (list_all_numeric (tail v))))\n      false)))",
      "basic_structure": "",
      "inputs": "(declare-const test_tup1 Value)\n(declare-const test_tup2 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList test_tup1))",
        "assert_1": "(define-fun C1 () Bool (IsList test_tup2))",
        "assert_2": "(define-fun C2 () Bool (= (length test_tup1) (length test_tup2)))",
        "assert_3": "(define-fun C3 () Bool (list_all_numeric test_tup1))",
        "assert_4": "(define-fun C4 () Bool (list_all_numeric test_tup2))"
      },
      "constraints": {
        "assert_0": "assert isinstance(test_tup1, tuple), \"invalid inputs",
        "assert_1": "assert isinstance(test_tup2, tuple), \"invalid inputs",
        "assert_2": "assert len(test_tup1) == len(test_tup2), \"invalid inputs",
        "assert_3": "assert all(isinstance(x, (int, float)) for x in test_tup1), \"invalid inputs",
        "assert_4": "assert all(isinstance(x, (int, float)) for x in test_tup2), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/274": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeI ((v Value)) Int\n  (ite (is-IntVal v) (ival v) 0))",
      "basic_structure": "",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
        "assert_1": "(define-fun C1 () Bool (and (is-IntVal n) (> (ival n) 0)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(n, int), \"invalid inputs",
        "assert_1": "assert n > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/276": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun getNum ((v Value)) Real\n  (ite (is-IntVal v) (to_real (ival v))\n       (fval v)))",
      "basic_structure": "",
      "inputs": "(declare-const r Value)\n(declare-const h Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (or (is-IntVal r) (is-FloatVal r)))",
        "assert_1": "(define-fun C1 () Bool (or (is-IntVal h) (is-FloatVal h)))",
        "assert_2": "(define-fun C2 () Bool (and C0 (> (getNum r) 0)))",
        "assert_3": "(define-fun C3 () Bool (and C1 (> (getNum h) 0)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(r, (int, float)), \"invalid inputs",
        "assert_1": "assert isinstance(h, (int, float)), \"invalid inputs",
        "assert_2": "assert r > 0, \"invalid inputs",
        "assert_3": "assert h > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/277": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec list_all_pairs_shape ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (let ((hd (head v))\n                  (tl (tail v)))\n              (and\n                (is-Cons hd)\n                (let ((second_elem (tail hd)))\n                  (and\n                    (is-Cons second_elem)\n                    (is-Nil (tail second_elem))))\n                (list_all_pairs_shape tl)))\n            false)))\n\n(define-fun-rec list_all_vals_int ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (let ((hd (head v))\n                  (tl (tail v)))\n              (and\n                (is-Cons hd)\n                (let ((second_elem (tail hd)))\n                  (and\n                    (is-Cons second_elem)\n                    (let ((val_elem (head second_elem)))\n                      (is-IntVal val_elem))\n                    (is-Nil (tail second_elem))))\n                (list_all_vals_int tl)))\n            false)))",
      "basic_structure": "(assert (IsList dict1))\n(assert (list_all_pairs_shape dict1))\n(assert (is-IntVal n))",
      "inputs": "(declare-const dict1 Value)\n(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList dict1))",
        "assert_1": "(define-fun C1 () Bool (list_all_vals_int dict1))",
        "assert_2": "(define-fun C2 () Bool (is-IntVal n))"
      },
      "constraints": {
        "assert_0": "assert isinstance(dict1, dict), \"invalid inputs",
        "assert_1": "assert all(isinstance(x, int) for x in dict1.values()), \"invalid inputs",
        "assert_2": "assert isinstance(n, int), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/278": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool (ite (is-Cons v) (IsList (tail v)) (is-Nil v)))",
      "basic_structure": "(assert (IsList test_tup))",
      "inputs": "(declare-const test_tup Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList test_tup))"
      },
      "constraints": {
        "assert_0": "assert isinstance(test_tup, tuple), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/279": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeI ((v Value)) Int\n  (ite (is-IntVal v) (ival v) 0))",
      "basic_structure": "",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
        "assert_1": "(define-fun C1 () Bool (and C0 (> (SafeI n) 0)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(n, int), \"invalid inputs",
        "assert_1": "assert n > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/280": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun is-list ((v Value)) Bool (or (is-Nil v) (is-Cons v)))",
      "basic_structure": "(assert (is-list dlist))",
      "inputs": "(declare-const dlist Value)\n(declare-const item Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-list dlist))"
      },
      "constraints": {
        "assert_0": "assert isinstance(dlist, list), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/281": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))",
      "basic_structure": "(assert (IsList test_list))",
      "inputs": "(declare-const test_list Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (or (is-Nil test_list) (is-Cons test_list)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(test_list, list), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/282": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun IsList ((l Value)) Bool\n  (or (is-Nil l) (is-Cons l)))\n\n(define-fun-rec length ((l Value)) Int\n  (ite (is-Cons l)\n       (+ 1 (length (tail l)))\n       0))\n\n(define-fun-rec list_all_numeric ((l Value)) Bool\n  (ite (is-Cons l)\n       (and (or (is-IntVal (head l)) (is-FloatVal (head l)))\n            (list_all_numeric (tail l)))\n       true))",
      "basic_structure": "(assert (IsList nums1))\n(assert (IsList nums2))",
      "inputs": "(declare-const nums1 Value)\n(declare-const nums2 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList nums1))",
        "assert_1": "(define-fun C1 () Bool (IsList nums2))",
        "assert_2": "(define-fun C2 () Bool (> (length nums1) 0))",
        "assert_3": "(define-fun C3 () Bool (> (length nums2) 0))",
        "assert_4": "(define-fun C4 () Bool (= (length nums1) (length nums2)))",
        "assert_5": "(define-fun C5 () Bool (list_all_numeric nums1))",
        "assert_6": "(define-fun C6 () Bool (list_all_numeric nums2))"
      },
      "constraints": {
        "assert_0": "assert isinstance(nums1, list), \"invalid inputs",
        "assert_1": "assert isinstance(nums2, list), \"invalid inputs",
        "assert_2": "assert len(nums1) > 0, \"invalid inputs",
        "assert_3": "assert len(nums2) > 0, \"invalid inputs",
        "assert_4": "assert len(nums1) == len(nums2), \"invalid inputs",
        "assert_5": "assert all(isinstance(num, (int, float)) for num in nums1), \"invalid inputs",
        "assert_6": "assert all(isinstance(num, (int, float)) for num in nums2), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/283": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
      "basic_structure": "(assert (is-IntVal n))",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
        "assert_1": "(define-fun C1 () Bool (and (is-IntVal n) (>= (ival n) 0)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(n, int), \"invalid inputs",
        "assert_1": "assert n >= 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/284": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v) true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec list_all_same_type ((lst Value) (v Value)) Bool\n  (ite (is-Nil lst) true\n       (ite (is-Cons lst)\n            (and\n              (or (and (is-IntVal (head lst)) (is-IntVal v))\n                  (and (is-FloatVal (head lst)) (is-FloatVal v))\n                  (and (is-StrVal (head lst)) (is-StrVal v))\n                  (and (is-BoolVal (head lst)) (is-BoolVal v)))\n              (list_all_same_type (tail lst) v))\n            false)))",
      "basic_structure": "(assert (IsList list1))",
      "inputs": "(declare-const list1 Value)\n(declare-const element Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList list1))",
        "assert_1": "(define-fun C1 () Bool (and (IsList list1) (list_all_same_type list1 element)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(list1, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(x, type(element)) for x in list1), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/285": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeS ((v Value)) String (ite (is-StrVal v) (sval v) \"\"))",
      "basic_structure": "",
      "inputs": "(declare-const text Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal text))"
      },
      "constraints": {
        "assert_0": "assert isinstance(text, str), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/286": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun is_numeric ((v Value)) Bool (or (is-IntVal v) (is-FloatVal v)))\n(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n(define-fun-rec list_all_numeric ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (is_numeric (head v))\n                 (list_all_numeric (tail v)))\n            false)))\n(define-fun-rec length ((v Value)) Int\n  (ite (is-Nil v)\n       0\n       (ite (is-Cons v)\n            (+ 1 (length (tail v)))\n            0)))",
      "basic_structure": "",
      "inputs": "(declare-const a Value)\n(declare-const n Value)\n(declare-const k Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList a))",
        "assert_1": "(define-fun C1 () Bool (> (length a) 0))",
        "assert_2": "(define-fun C2 () Bool (list_all_numeric a))",
        "assert_3": "(define-fun C3 () Bool (and (is-IntVal n) (= (ival n) (length a))))",
        "assert_4": "(define-fun C4 () Bool (and (is-IntVal k) (>= (ival k) 0)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(a, list), \"invalid inputs",
        "assert_1": "assert len(a) > 0, \"invalid inputs",
        "assert_2": "assert all(isinstance(item, (int, float)) for item in a), \"invalid inputs",
        "assert_3": "assert isinstance(n, int) and n == len(a), \"invalid inputs",
        "assert_4": "assert isinstance(k, int) and k >= 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/287": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
        "assert_1": "(define-fun C1 () Bool (and C0 (>= (ival n) 0)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(n, int), \"invalid inputs",
        "assert_1": "assert n >= 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/290": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun is_list ((v Value)) Bool\n  (or (is-Nil v) (is-Cons v)))\n\n(define-fun-rec list_all_list ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (and (is_list (head l)) (list_all_list (tail l)))\n            false)))",
      "basic_structure": "(assert true)",
      "inputs": "(declare-const list1 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is_list list1))",
        "assert_1": "(define-fun C1 () Bool (list_all_list list1))"
      },
      "constraints": {
        "assert_0": "assert isinstance(list1, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(x, list) for x in list1), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/292": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const n Value)\n(declare-const m Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
        "assert_1": "(define-fun C1 () Bool (is-IntVal m))",
        "assert_2": "(define-fun C2 () Bool (ite (is-IntVal m) (not (= (ival m) 0)) false))"
      },
      "constraints": {
        "assert_0": "assert isinstance(n, int), \"invalid inputs",
        "assert_1": "assert isinstance(m, int), \"invalid inputs",
        "assert_2": "assert m != 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/293": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun is-numeric ((v Value)) Bool (or (is-IntVal v) (is-FloatVal v)))\n(define-fun num-to-real ((v Value)) Real (ite (is-IntVal v) (to_real (ival v)) (fval v)))",
      "basic_structure": "",
      "inputs": "(declare-const w Value)\n(declare-const h Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (and (is-numeric w) (> (num-to-real w) 0)))",
        "assert_1": "(define-fun C1 () Bool (and (is-numeric h) (> (num-to-real h) 0)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(w, (int, float)) and w > 0, \"invalid inputs",
        "assert_1": "assert isinstance(h, (int, float)) and h > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/294": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (or (is-Nil v)\n      (and (is-Cons v) (IsList (tail v)))))\n\n(define-fun-rec length ((lst Value)) Int\n  (ite (is-Nil lst) 0\n       (ite (is-Cons lst)\n            (+ 1 (length (tail lst)))\n            0)))\n\n(define-fun-rec any_int ((lst Value)) Bool\n  (ite (is-Cons lst)\n       (or (is-IntVal (head lst)) (any_int (tail lst)))\n       false))",
      "basic_structure": "",
      "inputs": "(declare-const listval Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList listval))",
        "assert_1": "(define-fun C1 () Bool (> (length listval) 0))",
        "assert_2": "(define-fun C2 () Bool (any_int listval))"
      },
      "constraints": {
        "assert_0": "assert isinstance(listval, list), \"invalid inputs",
        "assert_1": "assert len(listval) > 0, \"invalid inputs",
        "assert_2": "assert any(isinstance(i, int) for i in listval), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/296": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec isList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (isList (tail v))\n            false)))\n\n(define-fun-rec length ((lst Value)) Int\n  (ite (is-Nil lst)\n       0\n       (ite (is-Cons lst)\n            (+ 1 (length (tail lst)))\n            0)))\n\n(define-fun-rec list_all_numeric ((lst Value)) Bool\n  (ite (is-Nil lst)\n       true\n       (ite (is-Cons lst)\n            (and (or (is-IntVal (head lst)) (is-FloatVal (head lst)))\n                 (list_all_numeric (tail lst)))\n            false)))",
      "basic_structure": "(assert (isList arr))",
      "inputs": "(declare-const arr Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (isList arr))",
        "assert_1": "(define-fun C1 () Bool (> (length arr) 0))",
        "assert_2": "(define-fun C2 () Bool (list_all_numeric arr))"
      },
      "constraints": {
        "assert_0": "assert isinstance(arr, list), \"invalid inputs",
        "assert_1": "assert len(arr) > 0, \"invalid inputs",
        "assert_2": "assert all(isinstance(x, (int, float)) for x in arr), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/297": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Cons v)\n       (IsList (tail v))\n       (is-Nil v)))\n\n(define-fun-rec list_check ((v Value)) Bool\n  (ite (is-Cons v)\n       (let ((hd (head v)) (tl (tail v)))\n         (and (list_check hd) (list_check tl)))\n       (ite (is-Nil v)\n            true\n            (or (is-IntVal v) (is-FloatVal v)))))",
      "basic_structure": "",
      "inputs": "(declare-const list1 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList list1))",
        "assert_1": "(define-fun C1 () Bool (list_check list1))"
      },
      "constraints": {
        "assert_0": "assert isinstance(list1, list), \"invalid inputs",
        "assert_1": "assert list_check(list1), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/299": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (ite (is-Cons l)\n       (IsList (tail l))\n       (is-Nil l)))\n\n(define-fun is_list_length_2 ((l Value)) Bool\n  (and (is-Cons l)\n       (let ((rest1 (tail l)))\n         (and (is-Cons rest1)\n              (is-Nil (tail rest1))))))\n\n(define-fun-rec list_all_is_cons ((l Value)) Bool\n  (ite (is-Cons l)\n       (and (is-Cons (head l))\n            (list_all_is_cons (tail l)))\n       (is-Nil l)))\n\n(define-fun-rec list_all_len2 ((l Value)) Bool\n  (ite (is-Cons l)\n       (and (is_list_length_2 (head l))\n            (list_all_len2 (tail l)))\n       (is-Nil l)))\n\n(define-fun is_tuple_numeric ((t Value)) Bool\n  (and (is-Cons t)\n       (let ((rest1 (tail t)))\n         (and (is-Cons rest1)\n              (or (is-IntVal (head rest1))\n                  (is-FloatVal (head rest1)))))))\n\n(define-fun-rec list_all_second_numeric ((l Value)) Bool\n  (ite (is-Cons l)\n       (and (is_tuple_numeric (head l))\n            (list_all_second_numeric (tail l)))\n       (is-Nil l)))",
      "basic_structure": "",
      "inputs": "(declare-const stdata Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList stdata))",
        "assert_1": "(define-fun C1 () Bool (list_all_is_cons stdata))",
        "assert_2": "(define-fun C2 () Bool (list_all_len2 stdata))",
        "assert_3": "(define-fun C3 () Bool (list_all_second_numeric stdata))"
      },
      "constraints": {
        "assert_0": "assert isinstance(stdata, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(x, tuple) for x in stdata), \"invalid inputs",
        "assert_2": "assert all(len(x) == 2 for x in stdata), \"invalid inputs",
        "assert_3": "assert all(isinstance(x[1], (int, float)) for x in stdata), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/300": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "(assert (is-IntVal n))",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (> (ival n) 0))"
      },
      "constraints": {
        "assert_0": "assert isinstance(n, int) and n > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/301": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (or (is-Nil v) (and (is-Cons v) (IsList (tail v)))))\n\n; pair (a,b) \u2261 Cons a (Cons b Nil)\n(define-fun IsPair ((v Value)) Bool\n  (and (is-Cons v) (is-Cons (tail v)) (is-Nil (tail (tail v)))))\n(define-fun first  ((p Value)) Value (head p))\n(define-fun second ((p Value)) Value (head (tail p)))\n\n; (StrVal key, Value val)\uc778 (key,value) \uc30d\uc778\uc9c0\n(define-fun IsKVPair ((v Value)) Bool\n  (and (IsPair v) (is-StrVal (first v))))\n\n; dict \u2261 KVPair\ub4e4\uc758 \ub9ac\uc2a4\ud2b8\uc778\uc9c0\n(define-fun-rec IsDict ((v Value)) Bool\n  (or (is-Nil v) (and (is-Cons v) (IsKVPair (head v)) (IsDict (tail v)))))",
      "basic_structure": "",
      "inputs": "(declare-const d Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsDict d))"
      },
      "constraints": {
        "assert_0": "assert isinstance(d, dict), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/305": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((ls Value)) Bool\n  (ite (is-Nil ls) true\n    (ite (is-Cons ls)\n      (IsList (tail ls))\n      false)))\n\n(define-fun-rec list_all_str ((ls Value)) Bool\n  (ite (is-Nil ls) true\n    (ite (is-Cons ls)\n      (and (is-StrVal (head ls)) (list_all_str (tail ls)))\n      false)))",
      "basic_structure": "(assert (IsList words))",
      "inputs": "(declare-const words Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList words))",
        "assert_1": "(define-fun C1 () Bool (and (IsList words) (list_all_str words)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(words, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(x, str) for x in words), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/306": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeI ((v Value)) Int\n  (ite (is-IntVal v) (ival v) 0))\n\n(define-fun-rec length ((v Value)) Int\n  (ite (is-Nil v)\n    0\n    (ite (is-Cons v)\n      (+ 1 (length (tail v)))\n      0)))\n\n(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n    true\n    (ite (is-Cons v)\n      (IsList (tail v))\n      false)))\n\n(define-fun-rec list_all_numeric ((v Value)) Bool\n  (ite (is-Nil v)\n    true\n    (ite (is-Cons v)\n      (and\n        (or (is-IntVal (head v)) (is-FloatVal (head v)))\n        (list_all_numeric (tail v)))\n      false)))",
      "basic_structure": "(assert (IsList a))\n(assert (list_all_numeric a))\n(assert (is-IntVal n))\n(assert (<= (SafeI n) (length a)))",
      "inputs": "(declare-const a Value)\n(declare-const n Value)\n(declare-const index Value)\n(declare-const k Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList a))",
        "assert_1": "(define-fun C1 () Bool (list_all_numeric a))",
        "assert_2": "(define-fun C2 () Bool (is-IntVal n))",
        "assert_3": "(define-fun C3 () Bool (= (SafeI n) (length a)))",
        "assert_4": "(define-fun C4 () Bool (is-IntVal index))",
        "assert_4_detail": "(define-fun C5 () Bool (and (<= 0 (SafeI index)) (< (SafeI index) (SafeI n))))",
        "assert_6": "(define-fun C6 () Bool (is-IntVal k))",
        "assert_7": "(define-fun C7 () Bool (and (< (SafeI index) (SafeI k)) (< (SafeI k) (SafeI n))))"
      },
      "constraints": {
        "assert_0": "assert isinstance(a, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(x, (int, float)) for x in a), \"invalid inputs",
        "assert_2": "assert isinstance(n, int), \"invalid inputs",
        "assert_3": "assert n == len(a), \"invalid inputs",
        "assert_4": "assert isinstance(index, int), \"invalid inputs",
        "assert_5": "assert 0 <= index < n, \"invalid inputs",
        "assert_6": "assert isinstance(k, int), \"invalid inputs",
        "assert_7": "assert index < k < n, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/308": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun is_numeric ((v Value)) Bool (or (is-IntVal v) (is-FloatVal v)))\n(define-fun-rec length ((v Value)) Int\n  (ite (is-Cons v)\n       (+ 1 (length (tail v)))\n       0))\n(define-fun-rec list_all_numeric ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (is_numeric (head v)) (list_all_numeric (tail v)))\n            false)))\n(define-fun-rec IsList ((v Value)) Bool\n  (or (is-Nil v)\n      (and (is-Cons v) (IsList (tail v)))))\n(define-fun SafeI ((v Value)) Int\n  (ite (is-IntVal v) (ival v) 0))",
      "basic_structure": "(assert (IsList nums1))\n(assert (IsList nums2))",
      "inputs": "(declare-const nums1 Value)\n(declare-const nums2 Value)\n(declare-const N Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList nums1))",
        "assert_1": "(define-fun C1 () Bool (list_all_numeric nums1))",
        "assert_2": "(define-fun C2 () Bool (IsList nums2))",
        "assert_3": "(define-fun C3 () Bool (list_all_numeric nums2))",
        "assert_4": "(define-fun C4 () Bool (is-IntVal N))",
        "assert_5": "(define-fun C5 () Bool (and (<= 0 (SafeI N)) (<= (SafeI N) (* (length nums1) (length nums2)))))"
      },
      "constraints": {
        "assert_0": "assert isinstance(nums1, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(x, (int, float)) for x in nums1), \"invalid inputs",
        "assert_2": "assert isinstance(nums2, list), \"invalid inputs",
        "assert_3": "assert all(isinstance(x, (int, float)) for x in nums2), \"invalid inputs",
        "assert_4": "assert isinstance(N, int), \"invalid inputs",
        "assert_5": "assert 0 <= N <= len(nums1) * len(nums2), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/309": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun IsNumeric ((v Value)) Bool\n  (or (is-IntVal v) (is-FloatVal v)))",
      "basic_structure": "",
      "inputs": "(declare-const a Value)\n(declare-const b Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (IsNumeric a))",
        "assert_1": "(define-fun C1 () Bool\n  (IsNumeric b))"
      },
      "constraints": {
        "assert_0": "assert isinstance(a, (int, float)), \"invalid inputs",
        "assert_1": "assert isinstance(b, (int, float)), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/310": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeS ((v Value)) String (ite (is-StrVal v) (sval v) \"\"))",
      "basic_structure": "(assert true)",
      "inputs": "(declare-const str1 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal str1))"
      },
      "constraints": {
        "assert_0": "assert isinstance(str1, str), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/311": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun safe_ival ((v Value)) Int\n  (ite (is-IntVal v) (ival v) 0))",
      "basic_structure": "(assert (is-IntVal n))",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (and (is-IntVal n)\n       (>= (safe_ival n) 0)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(n, int) and n >= 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/312": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun IsNum ((v Value)) Bool\n  (or (is-IntVal v) (is-FloatVal v)))\n\n(define-fun SafeRealVal ((v Value)) Real\n  (ite (is-IntVal v)\n       (to_real (ival v))\n       (ite (is-FloatVal v)\n            (fval v)\n            0)))",
      "basic_structure": "(assert (IsNum r))\n(assert (IsNum h))",
      "inputs": "(declare-const r Value)\n(declare-const h Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (and\n    (or (is-IntVal r) (is-FloatVal r))\n    (> (SafeRealVal r) 0)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(r, (int, float)) and r > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/388": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeInt ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
      "basic_structure": "",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
        "assert_1": "(define-fun C1 () Bool (> (SafeInt n) 0))"
      },
      "constraints": {
        "assert_0": "assert isinstance(n, int), \"invalid inputs",
        "assert_1": "assert n > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/389": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "(assert (is-IntVal n))",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (and (is-IntVal n) (>= (ite (is-IntVal n) (ival n) 0) 0)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(n, int) and n >= 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/390": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n    true\n    (ite (is-Cons v)\n      (let ((rest (tail v))) (IsList rest))\n      false)))",
      "basic_structure": "",
      "inputs": "(declare-const list_ Value)\n(declare-const string Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList list_))",
        "assert_1": "(define-fun C1 () Bool (is-StrVal string))"
      },
      "constraints": {
        "assert_0": "assert isinstance(list_, list), \"invalid inputs",
        "assert_1": "assert isinstance(string, str), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/391": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))",
      "basic_structure": "(assert (IsList l1))\n(assert (IsList l2))\n(assert (IsList l3))",
      "inputs": "(declare-const l1 Value)\n(declare-const l2 Value)\n(declare-const l3 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList l1))",
        "assert_1": "(define-fun C1 () Bool (IsList l2))",
        "assert_2": "(define-fun C2 () Bool (IsList l3))"
      },
      "constraints": {
        "assert_0": "assert isinstance(l1, list), \"invalid inputs",
        "assert_1": "assert isinstance(l2, list), \"invalid inputs",
        "assert_2": "assert isinstance(l3, list), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/392": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "(assert (is-IntVal n))",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
        "assert_1": "(define-fun C1 () Bool (and (is-IntVal n) (>= (ival n) 0)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(n, int), \"invalid inputs",
        "assert_1": "assert n >= 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/394": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))",
      "basic_structure": "(assert (IsList test_tup))",
      "inputs": "(declare-const test_tup Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList test_tup))"
      },
      "constraints": {
        "assert_0": "assert isinstance(test_tup, tuple), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/395": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeS ((v Value)) String\n  (ite (is-StrVal v) (sval v) \"\"))\n\n(define-fun length ((v Value)) Int\n  (str.len (SafeS v)))",
      "basic_structure": "(assert (is-StrVal str1))",
      "inputs": "(declare-const str1 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal str1))",
        "assert_1": "(define-fun C1 () Bool (> (length str1) 0))"
      },
      "constraints": {
        "assert_0": "assert isinstance(str1, str), \"invalid inputs",
        "assert_1": "assert len(str1) > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/397": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun is-NumVal ((v Value)) Bool (or (is-IntVal v) (is-FloatVal v)))",
      "basic_structure": "",
      "inputs": "(declare-const a Value)\n(declare-const b Value)\n(declare-const c Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-NumVal a))",
        "assert_1": "(define-fun C1 () Bool (is-NumVal b))",
        "assert_2": "(define-fun C2 () Bool (is-NumVal c))"
      },
      "constraints": {
        "assert_0": "assert isinstance(a, (int, float)), \"invalid inputs",
        "assert_1": "assert isinstance(b, (int, float)), \"invalid inputs",
        "assert_2": "assert isinstance(c, (int, float)), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/398": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n    true\n    (ite (is-Cons v)\n      (IsList (tail v))\n      false)))",
      "basic_structure": "(assert (IsList nums))",
      "inputs": "(declare-const nums Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (IsList nums))"
      },
      "constraints": {
        "assert_0": "assert isinstance(nums, list), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/404": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const a Value)\n(declare-const b Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (or (is-IntVal a) (is-FloatVal a)))",
        "assert_1": "(define-fun C1 () Bool (or (is-IntVal b) (is-FloatVal b)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(a, (int, float)), \"invalid inputs",
        "assert_1": "assert isinstance(b, (int, float)), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/405": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))",
      "basic_structure": "(assert (IsList tuplex))",
      "inputs": "(declare-const tuplex Value)\n(declare-const element Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList tuplex))"
      },
      "constraints": {
        "assert_0": "assert isinstance(tuplex, tuple), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/406": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const x Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal x))"
      },
      "constraints": {
        "assert_0": "assert isinstance(x, int), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/409": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec Length ((v Value)) Int\n  (ite (is-Nil v)\n       0\n       (ite (is-Cons v)\n            (+ 1 (Length (tail v)))\n            0)))\n\n(define-fun Is2List ((v Value)) Bool\n  (and (is-Cons v)\n       (let ((t1 (tail v)))\n         (and (is-Cons t1)\n              (is-Nil (tail t1))))))\n\n(define-fun-rec ListAllTuple ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (and (is-Cons v) (Is2List (head v)))\n            (ListAllTuple (tail v))\n            false)))\n\n(define-fun-rec ListAllNumericSub ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (let ((h (head l)))\n              (and (or (is-IntVal h) (is-FloatVal h))\n                   (ListAllNumericSub (tail l))))\n            false)))\n\n(define-fun-rec ListAllNumeric ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (ListAllNumericSub (head v))\n                 (ListAllNumeric (tail v)))\n            false)))",
      "basic_structure": "(assert (IsList list1))",
      "inputs": "(declare-const list1 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList list1))",
        "assert_1": "(define-fun C1 () Bool (> (Length list1) 0))",
        "assert_2": "(define-fun C2 () Bool (ListAllTuple list1))",
        "assert_3": "(define-fun C3 () Bool (ListAllNumeric list1))"
      },
      "constraints": {
        "assert_0": "assert isinstance(list1, list), \"invalid inputs",
        "assert_1": "assert len(list1) > 0, \"invalid inputs",
        "assert_2": "assert all(isinstance(ele, tuple) for ele in list1), \"invalid inputs",
        "assert_3": "assert all(isinstance(ele, (int, float)) for sub in list1 for ele in sub), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/410": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (or (is-Nil v)\n      (and (is-Cons v)\n           (IsList (tail v)))))\n\n(define-fun-rec length ((v Value)) Int\n  (ite (is-Cons v)\n       (+ 1 (length (tail v)))\n       0))\n\n(define-fun-rec list_any_int ((v Value)) Bool\n  (ite (is-Cons v)\n       (let ((headv (head v))\n             (tailv (tail v)))\n         (or (is-IntVal headv)\n             (list_any_int tailv)))\n       false))",
      "basic_structure": "",
      "inputs": "(declare-const listval Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList listval))",
        "assert_1": "(define-fun C1 () Bool (> (length listval) 0))",
        "assert_2": "(define-fun C2 () Bool (list_any_int listval))"
      },
      "constraints": {
        "assert_0": "assert isinstance(listval, list), \"invalid inputs",
        "assert_1": "assert len(listval) > 0, \"invalid inputs",
        "assert_2": "assert any(isinstance(i, int) for i in listval), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/412": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (ite (is-Nil l) true\n    (ite (is-Cons l)\n      (IsList (tail l))\n      false)))\n\n(define-fun-rec list_all_int ((l Value)) Bool\n  (ite (is-Nil l) true\n    (ite (is-Cons l)\n      (let ((headVal (head l)) (tailVal (tail l)))\n        (ite (is-IntVal headVal)\n             (list_all_int tailVal)\n             false))\n      false)))",
      "basic_structure": "",
      "inputs": "(declare-const l Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList l))",
        "assert_1": "(define-fun C1 () Bool (list_all_int l))"
      },
      "constraints": {
        "assert_0": "assert isinstance(l, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(i, int) for i in l), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/413": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (or (is-Nil l) (and (is-Cons l) (IsList (tail l)))))\n\n(define-fun-rec lengthList ((l Value)) Int\n  (ite (is-Cons l) (+ 1 (lengthList (tail l))) 0))\n\n(define-fun SafeIval ((v Value)) Int\n  (ite (is-IntVal v) (ival v) 0))\n\n; all elements are sequences (tuple\u2248list)\n(define-fun-rec AllSeq ((l Value)) Bool\n  (or (is-Nil l) (and (is-Cons l) (IsList (head l)) (AllSeq (tail l)))))\n\n; for each element tup: idx < len(tup)\n(define-fun-rec AllIndexValid ((l Value) (idx Value)) Bool\n  (or (is-Nil l)\n      (and (is-Cons l) (IsList (head l))\n           (< (SafeIval idx) (lengthList (head l)))\n           (AllIndexValid (tail l) idx))))",
      "basic_structure": "",
      "inputs": "(declare-const list1 Value)\n(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList list1))",
        "assert_1": "(define-fun C1 () Bool (AllSeq list1))",
        "assert_2": "(define-fun C2 () Bool (is-IntVal n))",
        "assert_3": "(define-fun C3 () Bool (AllIndexValid list1 n))"
      },
      "constraints": {
        "assert_0": "assert isinstance(list1, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(tup, tuple) for tup in list1), \"invalid inputs",
        "assert_2": "assert isinstance(n, int), \"invalid inputs",
        "assert_3": "assert all(n < len(tup) for tup in list1), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/414": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (IsList (tail l))\n            false)))\n\n(define-fun-rec list_all_numeric ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (and (or (is-IntVal (head l)) (is-FloatVal (head l)))\n                 (list_all_numeric (tail l)))\n            false)))",
      "basic_structure": "(assert (IsList list1))\n(assert (IsList list2))",
      "inputs": "(declare-const list1 Value)\n(declare-const list2 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList list1))",
        "assert_1": "(define-fun C1 () Bool (IsList list2))",
        "assert_2": "(define-fun C2 () Bool (list_all_numeric list1))",
        "assert_3": "(define-fun C3 () Bool (list_all_numeric list2))"
      },
      "constraints": {
        "assert_0": "assert isinstance(list1, list), \"invalid inputs",
        "assert_1": "assert isinstance(list2, list), \"invalid inputs",
        "assert_2": "assert all(isinstance(i, (int, float)) for i in list1), \"invalid inputs",
        "assert_3": "assert all(isinstance(i, (int, float)) for i in list2), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/415": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (or (is-Nil v) (and (is-Cons v) (IsList (tail v)))))\n(define-fun-rec length ((v Value)) Int\n  (ite (is-Nil v) 0\n       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))\n(define-fun-rec list_all_int ((v Value)) Bool\n  (ite (is-Nil v) true\n       (ite (is-Cons v) (and (is-IntVal (head v)) (list_all_int (tail v))) false)))",
      "basic_structure": "",
      "inputs": "(declare-const arr Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList arr))",
        "assert_1": "(define-fun C1 () Bool (>= (length arr) 2))",
        "assert_2": "(define-fun C2 () Bool (list_all_int arr))"
      },
      "constraints": {
        "assert_0": "assert isinstance(arr, list), \"invalid inputs",
        "assert_1": "assert len(arr) >= 2, \"invalid inputs",
        "assert_2": "assert all(isinstance(i, int) for i in arr), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/418": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (or (is-Nil v)\n      (and (is-Cons v)\n           (let ((tl (tail v)))\n             (IsList tl)))))\n(define-fun-rec AllListLists ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (let ((hd (head l))\n             (tl (tail l)))\n         (and (IsList hd)\n              (AllListLists tl)))))",
      "basic_structure": "(assert (IsList lst))",
      "inputs": "(declare-const lst Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList lst))",
        "assert_1": "(define-fun C1 () Bool (AllListLists lst))"
      },
      "constraints": {
        "assert_0": "assert isinstance(lst, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(i, list) for i in lst), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/419": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec isList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (let ((t (tail v)))\n              (isList t))\n            false)))\n\n(define-fun-rec list_all_numeric ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (let ((h (head v))\n                  (t (tail v)))\n              (and (or (is-IntVal h) (is-FloatVal h))\n                   (list_all_numeric t)))\n            false)))",
      "basic_structure": "(assert (isList list1))",
      "inputs": "(declare-const list1 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (isList list1))",
        "assert_1": "(define-fun C1 () Bool (list_all_numeric list1))"
      },
      "constraints": {
        "assert_0": "assert isinstance(list1, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(i, (int, float)) for i in list1), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/420": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
      "basic_structure": "(assert (is-IntVal n))",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
        "assert_1": "(define-fun C1 () Bool (>= (SafeI n) 0))"
      },
      "constraints": {
        "assert_0": "assert isinstance(n, int), \"invalid inputs",
        "assert_1": "assert n >= 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/421": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool (or (is-Nil v) (and (is-Cons v) (IsList (tail v)))))",
      "basic_structure": "(IsList test_tup)",
      "inputs": "(declare-const test_tup Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList test_tup))"
      },
      "constraints": {
        "assert_0": "assert isinstance(test_tup, tuple), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/422": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "(assert (is-IntVal n))\n(assert (not (= (ival n) 0)))",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
        "assert_1": "(define-fun C1 () Bool (and (is-IntVal n) (>= (ival n) 0)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(n, int), \"invalid inputs",
        "assert_1": "assert n >= 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/424": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (or (is-Nil l)\n      (and (is-Cons l)\n           (IsList (tail l)))))\n\n(define-fun-rec list_all_str ((l Value)) Bool\n  (or (is-Nil l)\n      (and (is-Cons l)\n           (is-StrVal (head l))\n           (list_all_str (tail l)))))\n\n(define-fun-rec list_len_pos ((l Value)) Bool\n  (or (is-Nil l)\n      (and (is-Cons l)\n           (let ((elem (head l)))\n             (and (is-StrVal elem)\n                  (> (str.len (sval elem)) 0)))\n           (list_len_pos (tail l)))))",
      "basic_structure": "(assert (IsList test_tuple))",
      "inputs": "(declare-const test_tuple Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList test_tuple))",
        "assert_1": "(define-fun C1 () Bool (list_all_str test_tuple))",
        "assert_2": "(define-fun C2 () Bool (list_len_pos test_tuple))"
      },
      "constraints": {
        "assert_0": "assert isinstance(test_tuple, tuple), \"invalid inputs",
        "assert_1": "assert all(isinstance(ele, str) for ele in test_tuple), \"invalid inputs",
        "assert_2": "assert all(len(ele) > 0 for ele in test_tuple), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/425": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (IsList (tail l))\n            false)))\n\n(define-fun-rec ListElemsAreLists ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (and (IsList (head l))\n                 (ListElemsAreLists (tail l)))\n            false)))",
      "basic_structure": "(assert true)",
      "inputs": "(declare-const list1 Value)\n(declare-const x Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (IsList list1))",
        "assert_1": "(define-fun C1 () Bool\n  (ListElemsAreLists list1))"
      },
      "constraints": {
        "assert_0": "assert isinstance(list1, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(i, list) for i in list1), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/426": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (let ((hd (head v)) (tl (tail v)))\n              (IsList tl))\n            false)))\n\n(define-fun-rec list_all_int ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (let ((hd (head v)) (tl (tail v)))\n              (and (is-IntVal hd) (list_all_int tl)))\n            false)))",
      "basic_structure": "(assert (IsList nums))",
      "inputs": "(declare-const nums Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList nums))",
        "assert_1": "(define-fun C1 () Bool (and (IsList nums) (list_all_int nums)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(nums, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(n, int) for n in nums), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/427": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeS ((v Value)) String (ite (is-StrVal v) (sval v) \"\"))\n(define-fun digit_re () (RegEx String)\n  (re.union (str.to.re \"0\")\n    (re.union (str.to.re \"1\")\n      (re.union (str.to.re \"2\")\n        (re.union (str.to.re \"3\")\n          (re.union (str.to.re \"4\")\n            (re.union (str.to.re \"5\")\n              (re.union (str.to.re \"6\")\n                (re.union (str.to.re \"7\")\n                  (re.union (str.to.re \"8\")\n                           (str.to.re \"9\")))))))))))\n(define-fun four_digits_re () (RegEx String)\n  (re.++ digit_re digit_re digit_re digit_re))\n(define-fun one_two_digits_re () (RegEx String)\n  (re.++ digit_re (re.union digit_re (str.to.re \"\"))))\n(define-fun date_re () (RegEx String)\n  (re.++ four_digits_re (str.to.re \"-\") one_two_digits_re (str.to.re \"-\") one_two_digits_re))",
      "basic_structure": "",
      "inputs": "(declare-const dt Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal dt))",
        "assert_1": "(define-fun C1 () Bool (and C0 (str.in.re (SafeS dt) date_re)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(dt, str), \"invalid inputs",
        "assert_1": "assert re.match(r'\\d{4}-\\d{1,2}-\\d{1,2}', dt), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/428": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n(define-fun-rec list_all_numeric ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (or (is-IntVal (head v)) (is-FloatVal (head v)))\n                 (list_all_numeric (tail v)))\n            false)))",
      "basic_structure": "(assert (IsList my_list))",
      "inputs": "(declare-const my_list Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList my_list))",
        "assert_1": "(define-fun C1 () Bool (list_all_numeric my_list))"
      },
      "constraints": {
        "assert_0": "assert isinstance(my_list, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(ele, (int, float)) for ele in my_list), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/429": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec isList ((v Value)) Bool\n  (ite (is-Nil v) true\n    (ite (is-Cons v) (isList (tail v)) false)))\n\n(define-fun-rec length ((v Value)) Int\n  (ite (is-Nil v) 0\n    (ite (is-Cons v) (+ 1 (length (tail v))) 0)))",
      "basic_structure": "(assert (isList test_tup1))\n(assert (isList test_tup2))",
      "inputs": "(declare-const test_tup1 Value)\n(declare-const test_tup2 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (isList test_tup1))",
        "assert_1": "(define-fun C1 () Bool (isList test_tup2))",
        "assert_2": "(define-fun C2 () Bool (= (length test_tup1) (length test_tup2)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(test_tup1, tuple), \"invalid inputs",
        "assert_1": "assert isinstance(test_tup2, tuple), \"invalid inputs",
        "assert_2": "assert len(test_tup1) == len(test_tup2), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/430": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun is-Numeric ((v Value)) Bool (or (is-IntVal v) (is-FloatVal v)))\n(define-fun toReal ((v Value)) Real (ite (is-IntVal v) (to_real (ival v)) (fval v)))",
      "basic_structure": "",
      "inputs": "(declare-const a Value)\n(declare-const b Value)\n(declare-const c Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-Numeric a))",
        "assert_1": "(define-fun C1 () Bool (is-Numeric b))",
        "assert_2": "(define-fun C2 () Bool (is-Numeric c))"
      },
      "constraints": {
        "assert_0": "assert isinstance(a, (int, float)), \"invalid inputs",
        "assert_1": "assert isinstance(b, (int, float)), \"invalid inputs",
        "assert_2": "assert isinstance(c, (int, float)), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/432": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun isNumeric ((v Value)) Bool (or (is-IntVal v) (is-FloatVal v)))\n(define-fun SafeReal ((v Value)) Real (ite (is-IntVal v) (to_real (ival v)) (ite (is-FloatVal v) (fval v) 0)))",
      "basic_structure": "",
      "inputs": "(declare-const base1 Value)\n(declare-const base2 Value)\n(declare-const height Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (isNumeric base1))",
        "assert_1": "(define-fun C1 () Bool (isNumeric base2))"
      },
      "constraints": {
        "assert_0": "assert isinstance(base1, (int, float)), \"invalid inputs",
        "assert_1": "assert isinstance(base2, (int, float)), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/433": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun IsNumeric ((v Value)) Bool\n  (or (is-IntVal v) (is-FloatVal v)))\n\n(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec list_all_numeric ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (let ((hd (head v))\n                  (tl (tail v)))\n              (and (IsNumeric hd)\n                   (list_all_numeric tl)))\n            false)))",
      "basic_structure": "",
      "inputs": "(declare-const arr Value)\n(declare-const number Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (IsList arr))",
        "assert_1": "(define-fun C1 () Bool\n  (list_all_numeric arr))",
        "assert_2": "(define-fun C2 () Bool\n  (IsNumeric number))"
      },
      "constraints": {
        "assert_0": "assert isinstance(arr, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(el, (int, float)) for el in arr), \"invalid inputs",
        "assert_2": "assert isinstance(number, (int, float)), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/435": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeInt ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
      "basic_structure": "",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))"
      },
      "constraints": {
        "assert_0": "assert isinstance(n, int), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/436": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec is_list ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (is_list (tail v))\n            false)))\n\n(define-fun-rec list_all_numeric ((lst Value)) Bool\n  (ite (is-Nil lst)\n       true\n       (ite (is-Cons lst)\n            (let ((hd (head lst)) (tl (tail lst)))\n              (and (or (is-IntVal hd) (is-FloatVal hd))\n                   (list_all_numeric tl)))\n            false)))",
      "basic_structure": "(assert (is_list list1))",
      "inputs": "(declare-const list1 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is_list list1))",
        "assert_1": "(define-fun C1 () Bool (list_all_numeric list1))"
      },
      "constraints": {
        "assert_0": "assert isinstance(list1, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(i, (int, float)) for i in list1), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/437": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeStr ((v Value)) String (ite (is-StrVal v) (sval v) \"\"))",
      "basic_structure": "",
      "inputs": "(declare-const str1 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal str1))"
      },
      "constraints": {
        "assert_0": "assert isinstance(str1, str), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/439": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec is-List ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (is-List (tail v))\n            false)))\n\n(define-fun-rec list_all_int ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (and (is-Cons v) (is-IntVal (head v)))\n            (list_all_int (tail v))\n            false)))\n\n(define-fun-rec list_all_pos ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (and (is-Cons v)\n                 (is-IntVal (head v))\n                 (> (ival (head v)) 0))\n            (list_all_pos (tail v))\n            false)))",
      "basic_structure": "(assert (is-List L))",
      "inputs": "(declare-const L Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (is-List L))",
        "assert_1": "(define-fun C1 () Bool\n  (is-Cons L))",
        "assert_2": "(define-fun C2 () Bool\n  (list_all_int L))",
        "assert_3": "(define-fun C3 () Bool\n  (and (is-Cons L)\n       (list_all_pos (tail L))))"
      },
      "constraints": {
        "assert_0": "assert isinstance(L, list), \"invalid inputs",
        "assert_1": "assert len(L) > 0, \"invalid inputs",
        "assert_2": "assert all(isinstance(item, int) for item in L), \"invalid inputs",
        "assert_3": "assert all(item > 0 for item in L[1:]), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/440": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeS ((v Value)) String (ite (is-StrVal v) (sval v) \"\"))",
      "basic_structure": "(assert (is-StrVal text))",
      "inputs": "(declare-const text Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal text))"
      },
      "constraints": {
        "assert_0": "assert isinstance(text, str), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/441": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun is-Numeric ((v Value)) Bool (or (is-IntVal v) (is-FloatVal v)))\n(define-fun valToReal ((v Value)) Real (ite (is-IntVal v) (to_real (ival v)) (fval v)))",
      "basic_structure": "(assert (is-Numeric l))",
      "inputs": "(declare-const l Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (or (is-IntVal l) (is-FloatVal l)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(l, (int, float)), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/445": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (or (is-Nil v)\n      (and (is-Cons v)\n           (let ((t (tail v)))\n             (IsList t)))))\n\n(define-fun-rec length ((v Value)) Int\n  (ite (is-Nil v)\n       0\n       (let ((t (tail v)))\n         (+ 1 (length t)))))\n\n(define-fun NumericVal ((v Value)) Bool\n  (or (is-IntVal v)\n      (is-FloatVal v)))\n\n(define-fun-rec list_numeric ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (and (NumericVal (head l))\n            (list_numeric (tail l)))))\n\n(define-fun-rec list_all_list ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (and (or (is-Nil (head l))\n                (is-Cons (head l)))\n            (list_all_list (tail l)))))\n\n(define-fun-rec list_all_len_two ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (and (= (length (head l)) 2)\n            (list_all_len_two (tail l)))))\n\n(define-fun-rec list_all_numeric ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (and (list_numeric (head l))\n            (list_all_numeric (tail l)))))",
      "basic_structure": "(assert (IsList test_tup1))\n(assert (IsList test_tup2))",
      "inputs": "(declare-const test_tup1 Value)\n(declare-const test_tup2 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList test_tup1))",
        "assert_1": "(define-fun C1 () Bool (IsList test_tup2))",
        "assert_2": "(define-fun C2 () Bool (list_all_list test_tup1))",
        "assert_3": "(define-fun C3 () Bool (list_all_list test_tup2))",
        "assert_4": "(define-fun C4 () Bool (list_all_len_two test_tup1))",
        "assert_5": "(define-fun C5 () Bool (list_all_len_two test_tup2))",
        "assert_6": "(define-fun C6 () Bool (list_all_numeric test_tup1))",
        "assert_7": "(define-fun C7 () Bool (list_all_numeric test_tup2))"
      },
      "constraints": {
        "assert_0": "assert isinstance(test_tup1, tuple), \"invalid inputs",
        "assert_1": "assert isinstance(test_tup2, tuple), \"invalid inputs",
        "assert_2": "assert all(isinstance(ele, tuple) for ele in test_tup1), \"invalid inputs",
        "assert_3": "assert all(isinstance(ele, tuple) for ele in test_tup2), \"invalid inputs",
        "assert_4": "assert all(len(ele) == 2 for ele in test_tup1), \"invalid inputs",
        "assert_5": "assert all(len(ele) == 2 for ele in test_tup2), \"invalid inputs",
        "assert_6": "assert all(isinstance(ele, (int, float)) for tup in test_tup1 for ele in tup), \"invalid inputs",
        "assert_7": "assert all(isinstance(ele, (int, float)) for tup in test_tup2 for ele in tup), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/446": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun IsList ((v Value)) Bool\n  (or (is-Nil v) (is-Cons v)))",
      "basic_structure": "(assert (and (IsList tup) (IsList lst)))",
      "inputs": "(declare-const tup Value)\n(declare-const lst Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList tup))",
        "assert_1": "(define-fun C1 () Bool (IsList lst))"
      },
      "constraints": {
        "assert_0": "assert isinstance(tup, tuple), \"invalid inputs",
        "assert_1": "assert isinstance(lst, list), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/447": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v) true\n    (ite (is-Cons v)\n      (let ((t (tail v)))\n        (IsList t))\n      false)))\n\n(define-fun-rec ListAllNumeric ((v Value)) Bool\n  (ite (is-Nil v) true\n    (ite (is-Cons v)\n      (let ((h (head v)) (t (tail v)))\n        (and (or (is-IntVal h) (is-FloatVal h))\n             (ListAllNumeric t)))\n      false)))",
      "basic_structure": "(assert (IsList nums))",
      "inputs": "(declare-const nums Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList nums))",
        "assert_1": "(define-fun C1 () Bool (ListAllNumeric nums))"
      },
      "constraints": {
        "assert_0": "assert isinstance(nums, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(n, (int, float)) for n in nums), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/448": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "(assert true)",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))"
      },
      "constraints": {
        "assert_0": "assert isinstance(n, int), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/450": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun SafeStrLen ((v Value)) Int\n  (ite (is-StrVal v)\n       (str.len (sval v))\n       0))\n\n(define-fun-rec list_all_str ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (is-StrVal (head v))\n                 (list_all_str (tail v)))\n            false)))",
      "basic_structure": "(assert (IsList str1))\n(assert (is-IntVal l))",
      "inputs": "(declare-const str1 Value)\n(declare-const l Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList str1))",
        "assert_1": "(define-fun C1 () Bool (list_all_str str1))",
        "assert_2": "(define-fun C2 () Bool (is-IntVal l))"
      },
      "constraints": {
        "assert_0": "assert isinstance(str1, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(ele, str) for ele in str1), \"invalid inputs",
        "assert_2": "assert isinstance(l, int), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/451": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const text1 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal text1))"
      },
      "constraints": {
        "assert_0": "assert isinstance(text1, str), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/453": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
        "assert_1": "(define-fun C1 () Bool (and C0 (>= (ival n) 0)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(n, int), \"invalid inputs",
        "assert_1": "assert n >= 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/454": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeS ((v Value)) String (ite (is-StrVal v) (sval v) \"\"))",
      "basic_structure": "(assert true)",
      "inputs": "(declare-const text Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal text))"
      },
      "constraints": {
        "assert_0": "assert isinstance(text, str), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/455": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
      "basic_structure": "",
      "inputs": "(declare-const monthnum2 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal monthnum2))",
        "assert_1": "(define-fun C1 () Bool (and (is-IntVal monthnum2) (<= 1 (SafeI monthnum2) 12)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(monthnum2, int), \"invalid inputs",
        "assert_1": "assert 1 <= monthnum2 <= 12, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/456": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec ListAllStr ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (is-StrVal (head v))\n                 (ListAllStr (tail v)))\n            false)))",
      "basic_structure": "(assert (IsList stringlist))",
      "inputs": "(declare-const stringlist Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList stringlist))",
        "assert_1": "(define-fun C1 () Bool (ListAllStr stringlist))"
      },
      "constraints": {
        "assert_0": "assert isinstance(stringlist, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(x, str) for x in stringlist), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/457": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec list_all_lists ((lst Value)) Bool\n  (ite (is-Nil lst)\n       true\n       (ite (is-Cons lst)\n            (and (IsList (head lst))\n                 (list_all_lists (tail lst)))\n            false)))",
      "basic_structure": "(assert (IsList lst))",
      "inputs": "(declare-const lst Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList lst))",
        "assert_1": "(define-fun C1 () Bool (list_all_lists lst))"
      },
      "constraints": {
        "assert_0": "assert isinstance(lst, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(x, list) for x in lst), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/458": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const l Value)\n(declare-const b Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (or (is-IntVal l) (is-FloatVal l)))",
        "assert_1": "(define-fun C1 () Bool (or (is-IntVal b) (is-FloatVal b)))",
        "assert_2": "(define-fun C2 () Bool (ite (is-IntVal l) (> (to_real (ival l)) 0) (ite (is-FloatVal l) (> (fval l) 0) false)))",
        "assert_3": "(define-fun C3 () Bool (ite (is-IntVal b) (> (to_real (ival b)) 0) (ite (is-FloatVal b) (> (fval b) 0) false)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(l, (int, float)), \"invalid inputs",
        "assert_1": "assert isinstance(b, (int, float)), \"invalid inputs",
        "assert_2": "assert l > 0, \"invalid inputs",
        "assert_3": "assert b > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/459": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const str1 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal str1))"
      },
      "constraints": {
        "assert_0": "assert isinstance(str1, str), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/460": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (or (is-Nil v) (is-Cons v))\n)\n\n(define-fun-rec length ((lst Value)) Int\n  (ite (is-Cons lst)\n    (+ 1 (length (tail lst)))\n    0\n  )\n)\n\n(define-fun-rec list_all_list ((lst Value)) Bool\n  (ite (is-Cons lst)\n    (and (IsList (head lst))\n         (list_all_list (tail lst)))\n    (is-Nil lst)\n  )\n)\n\n(define-fun-rec list_all_non_empty ((lst Value)) Bool\n  (ite (is-Cons lst)\n    (let ((hd (head lst)) (tl (tail lst)))\n      (and (is-Cons hd)\n           (list_all_non_empty tl)))\n    (is-Nil lst)\n  )\n)",
      "basic_structure": "",
      "inputs": "(declare-const lst Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList lst))",
        "assert_1": "(define-fun C1 () Bool (list_all_list lst))",
        "assert_2": "(define-fun C2 () Bool (list_all_non_empty lst))"
      },
      "constraints": {
        "assert_0": "assert isinstance(lst, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(l, list) for l in lst), \"invalid inputs",
        "assert_2": "assert all(len(l) > 0 for l in lst), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/462": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec list_length ((v Value)) Int\n  (ite (is-Nil v)\n       0\n       (ite (is-Cons v)\n            (+ 1 (list_length (tail v)))\n            0)))\n\n(define-fun SafeHead ((v Value)) Value\n  (ite (is-Cons v)\n       (head v)\n       Nil))\n\n(define-fun SafeTail ((v Value)) Value\n  (ite (is-Cons v)\n       (tail v)\n       Nil))",
      "basic_structure": "",
      "inputs": "(declare-const list1 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (IsList list1))"
      },
      "constraints": {
        "assert_0": "assert isinstance(list1, list), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/463": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec isList ((v Value)) Bool\n  (or (is-Nil v) (is-Cons v)))\n\n(define-fun-rec list_length ((v Value)) Int\n  (ite (is-Nil v)\n       0\n       (ite (is-Cons v)\n            (+ 1 (list_length (tail v)))\n            0)))\n\n(define-fun-rec list_all_numeric ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (let ((h (head v)))\n              (let ((t (tail v)))\n                (and (or (is-IntVal h) (is-FloatVal h))\n                     (list_all_numeric t))))\n            false)))",
      "basic_structure": "(assert (isList arr))",
      "inputs": "(declare-const arr Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (isList arr))",
        "assert_1": "(define-fun C1 () Bool (> (list_length arr) 0))",
        "assert_2": "(define-fun C2 () Bool (list_all_numeric arr))"
      },
      "constraints": {
        "assert_0": "assert isinstance(arr, list), \"invalid inputs",
        "assert_1": "assert len(arr) > 0, \"invalid inputs",
        "assert_2": "assert all(isinstance(x, (int, float)) for x in arr), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/465": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (or (is-Nil v) (and (is-Cons v) (IsList (tail v)))))\n\n(define-fun IsPair ((v Value)) Bool\n  (and (is-Cons v) (is-Cons (tail v)) (is-Nil (tail (tail v)))))\n\n(define-fun first ((p Value)) Value (head p))\n(define-fun second ((p Value)) Value (head (tail p)))\n\n(define-fun IsKVPair ((v Value)) Bool\n  (and (IsPair v) (is-StrVal (first v))))\n\n(define-fun-rec IsDict ((v Value)) Bool\n  (or (is-Nil v) (and (is-Cons v) (IsKVPair (head v)) (IsDict (tail v)))))",
      "basic_structure": "(assert (IsDict dict1))",
      "inputs": "(declare-const dict1 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsDict dict1))"
      },
      "constraints": {
        "assert_0": "assert isinstance(dict1, dict), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/468": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun IsList ((v Value)) Bool (or (is-Nil v) (is-Cons v)))\n(define-fun-rec list_all_numeric ((lst Value)) Bool\n  (ite (is-Nil lst)\n       true\n       (ite (is-Cons lst)\n            (let ((hd (head lst)))\n              (and (or (is-IntVal hd) (is-FloatVal hd))\n                   (list_all_numeric (tail lst))))\n            false)))",
      "basic_structure": "(IsList arr)\n(list_all_numeric arr)",
      "inputs": "(declare-const arr Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList arr))",
        "assert_1": "(define-fun C1 () Bool (list_all_numeric arr))",
        "assert_2": "(define-fun C2 () Bool (not (is-Nil arr)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(arr, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(x, (int, float)) for x in arr), \"invalid inputs",
        "assert_2": "assert len(arr) > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/470": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec list_all_numeric ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (let ((h (head v)) (t (tail v)))\n              (and (or (is-IntVal h) (is-FloatVal h))\n                   (list_all_numeric t)))\n            false)))",
      "basic_structure": "(assert (IsList test_tup))",
      "inputs": "(declare-const test_tup Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList test_tup))",
        "assert_1": "(define-fun C1 () Bool (list_all_numeric test_tup))"
      },
      "constraints": {
        "assert_0": "assert isinstance(test_tup, tuple), \"invalid inputs",
        "assert_1": "assert all(isinstance(x, (int, float)) for x in test_tup), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/471": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool (ite (is-Nil v) true (ite (is-Cons v) (IsList (tail v)) false)))\n(define-fun-rec Length ((v Value)) Int (ite (is-Nil v) 0 (ite (is-Cons v) (+ 1 (Length (tail v))) 0)))\n(define-fun-rec list_all_numeric ((v Value)) Bool (ite (is-Nil v) true (ite (is-Cons v) (and (or (is-IntVal (head v)) (is-FloatVal (head v))) (list_all_numeric (tail v))) false)))",
      "basic_structure": "(assert (IsList arr))",
      "inputs": "(declare-const arr Value)\n(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList arr))",
        "assert_1": "(define-fun C1 () Bool (> (Length arr) 0))",
        "assert_2": "(define-fun C2 () Bool (list_all_numeric arr))",
        "assert_3": "(define-fun C3 () Bool (or (is-IntVal n) (is-FloatVal n)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(arr, list), \"invalid inputs",
        "assert_1": "assert len(arr) > 0, \"invalid inputs",
        "assert_2": "assert all(isinstance(x, (int, float)) for x in arr), \"invalid inputs",
        "assert_3": "assert isinstance(n, (int, float)), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/472": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((x Value)) Bool\n  (ite (is-Nil x) true\n       (ite (is-Cons x)\n            (IsList (tail x))\n            false)))\n\n(define-fun-rec length ((x Value)) Int\n  (ite (is-Nil x)\n       0\n       (ite (is-Cons x)\n            (+ 1 (length (tail x)))\n            0)))\n\n(define-fun-rec list_all_int ((x Value)) Bool\n  (ite (is-Nil x)\n       true\n       (ite (is-Cons x)\n            (let ((hd (head x)) (tl (tail x)))\n              (and (is-IntVal hd) (list_all_int tl)))\n            false)))",
      "basic_structure": "",
      "inputs": "(declare-const l Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList l))",
        "assert_1": "(define-fun C1 () Bool (> (length l) 0))",
        "assert_2": "(define-fun C2 () Bool (list_all_int l))"
      },
      "constraints": {
        "assert_0": "assert isinstance(l, list), \"invalid inputs",
        "assert_1": "assert len(l) > 0, \"invalid inputs",
        "assert_2": "assert all(isinstance(x, int) for x in l), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/473": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((x Value)) Bool\n  (ite (is-Nil x)\n       true\n       (ite (is-Cons x)\n            (IsList (tail x))\n            false)))\n\n(define-fun IsTuple ((x Value)) Bool\n  (and (is-Cons x)\n       (let ((t1 (tail x)))\n         (and (is-Cons t1)\n              (is-Nil (tail t1))))))\n\n(define-fun-rec ListAllTuple ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (and (IsTuple (head l))\n                 (ListAllTuple (tail l)))\n            false)))",
      "basic_structure": "(assert (IsList test_list1))\n(assert (IsList test_list2))",
      "inputs": "(declare-const test_list1 Value)\n(declare-const test_list2 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList test_list1))",
        "assert_1": "(define-fun C1 () Bool (IsList test_list2))",
        "assert_2": "(define-fun C2 () Bool (ListAllTuple test_list1))",
        "assert_3": "(define-fun C3 () Bool (ListAllTuple test_list2))"
      },
      "constraints": {
        "assert_0": "assert isinstance(test_list1, list), \"invalid inputs",
        "assert_1": "assert isinstance(test_list2, list), \"invalid inputs",
        "assert_2": "assert all(isinstance(ele, tuple) for ele in test_list1), \"invalid inputs",
        "assert_3": "assert all(isinstance(ele, tuple) for ele in test_list2), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/474": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeStr ((v Value)) String (ite (is-StrVal v) (sval v) \"\"))",
      "basic_structure": "",
      "inputs": "(declare-const str1 Value)\n(declare-const ch Value)\n(declare-const newch Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal str1))",
        "assert_1": "(define-fun C1 () Bool (is-StrVal ch))",
        "assert_2": "(define-fun C2 () Bool (and (is-StrVal ch) (= (str.len (SafeStr ch)) 1)))",
        "assert_3": "(define-fun C3 () Bool (is-StrVal newch))",
        "assert_4": "(define-fun C4 () Bool (and (is-StrVal newch) (= (str.len (SafeStr newch)) 1)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(str1, str), \"invalid inputs",
        "assert_1": "assert isinstance(ch, str), \"invalid inputs",
        "assert_2": "assert len(ch) == 1, \"invalid inputs",
        "assert_3": "assert isinstance(newch, str), \"invalid inputs",
        "assert_4": "assert len(newch) == 1, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/475": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec isList ((l Value)) Bool\n  (or (is-Nil l)\n      (and (is-Cons l)\n           (isList (tail l)))))\n\n(define-fun isIntOrFloat ((v Value)) Bool\n  (or (is-IntVal v)\n      (is-FloatVal v)))\n\n(define-fun isPair ((p Value)) Bool\n  (and (is-Cons p)\n       (let ((p1 (tail p)))\n         (and (is-Cons p1)\n              (is-Nil (tail p1))))))\n\n(define-fun-rec isDict ((d Value)) Bool\n  (or (is-Nil d)\n      (and (is-Cons d)\n           (let ((hd (head d)) (tl (tail d)))\n             (and (isPair hd)\n                  (let ((v (head (tail hd))))\n                    (and (is-StrVal (head hd)) (isIntOrFloat v)))\n                  (isDict tl))))))\n\n(define-fun-rec all_values_numeric ((d Value)) Bool\n  (or (is-Nil d)\n      (and (is-Cons d)\n           (let ((hd (head d)) (tl (tail d)))\n             (let ((v (head (tail hd))))\n               (and (isIntOrFloat v)\n                    (all_values_numeric tl)))))))",
      "basic_structure": "",
      "inputs": "(declare-const dict1 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (isDict dict1))",
        "assert_1": "(define-fun C1 () Bool\n  (or (not C0)\n      (all_values_numeric dict1)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(dict1, dict), \"invalid inputs",
        "assert_1": "assert all(isinstance(x, (int, float)) for x in dict1.values()), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/476": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (IsList (tail l))\n            false)))\n\n(define-fun-rec length ((l Value)) Int\n  (ite (is-Nil l)\n       0\n       (ite (is-Cons l)\n            (+ 1 (length (tail l)))\n            0)))\n\n(define-fun-rec list_all_numeric ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (let ((h (head l)) (t (tail l)))\n              (and (or (is-IntVal h) (is-FloatVal h))\n                   (list_all_numeric t)))\n            false)))",
      "basic_structure": "(assert (IsList nums))",
      "inputs": "(declare-const nums Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList nums))",
        "assert_1": "(define-fun C1 () Bool (> (length nums) 0))",
        "assert_2": "(define-fun C2 () Bool (list_all_numeric nums))"
      },
      "constraints": {
        "assert_0": "assert isinstance(nums, list), \"invalid inputs",
        "assert_1": "assert len(nums) > 0, \"invalid inputs",
        "assert_2": "assert all(isinstance(n, (int, float)) for n in nums), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/477": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const string Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal string))"
      },
      "constraints": {
        "assert_0": "assert isinstance(string, str), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/478": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const str1 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal str1))"
      },
      "constraints": {
        "assert_0": "assert isinstance(str1, str), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/479": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
      "basic_structure": "",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
        "assert_1": "(define-fun C1 () Bool (>= (SafeI n) 0))"
      },
      "constraints": {
        "assert_0": "assert isinstance(n, int), \"invalid inputs",
        "assert_1": "assert n >= 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/554": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (and (is-Cons l)\n            (IsList (tail l)))))\n(define-fun-rec length ((l Value)) Int\n  (ite (is-Nil l)\n       0\n       (ite (is-Cons l)\n            (+ 1 (length (tail l)))\n            0)))\n(define-fun-rec list_all_int ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (and (is-IntVal (head l))\n                 (list_all_int (tail l)))\n            false)))",
      "basic_structure": "(assert (IsList l))",
      "inputs": "(declare-const l Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList l))",
        "assert_1": "(define-fun C1 () Bool (> (length l) 0))",
        "assert_2": "(define-fun C2 () Bool (list_all_int l))"
      },
      "constraints": {
        "assert_0": "assert isinstance(l, list), \"invalid inputs",
        "assert_1": "assert len(l) > 0, \"invalid inputs",
        "assert_2": "assert all(isinstance(x, int) for x in l), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/555": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
        "assert_1": "(define-fun C1 () Bool (ite (is-IntVal n) (>= (ival n) 0) false))"
      },
      "constraints": {
        "assert_0": "assert isinstance(n, int), \"invalid inputs",
        "assert_1": "assert n >= 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/556": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun IsList ((l Value)) Bool (or (is-Nil l) (is-Cons l)))\n(define-fun-rec AllInt ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (and (is-IntVal (head l))\n            (AllInt (tail l)))))",
      "basic_structure": "(assert (IsList A))\n(assert (is-IntVal N))",
      "inputs": "(declare-const A Value)\n(declare-const N Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList A))",
        "assert_1": "(define-fun C1 () Bool (AllInt A))",
        "assert_2": "(define-fun C2 () Bool (is-IntVal N))"
      },
      "constraints": {
        "assert_0": "assert isinstance(A, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(x, int) for x in A), \"invalid inputs",
        "assert_2": "assert isinstance(N, int), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/557": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const string Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal string))"
      },
      "constraints": {
        "assert_0": "assert isinstance(string, str), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/558": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeInt ((v Value)) Int\n  (ite (is-IntVal v) (ival v) 0))",
      "basic_structure": "(assert (is-IntVal n1))\n(assert (is-IntVal n2))",
      "inputs": "(declare-const n1 Value)\n(declare-const n2 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n1))",
        "assert_1": "(define-fun C1 () Bool (is-IntVal n2))",
        "assert_2": "(define-fun C2 () Bool (>= (SafeInt n1) 0))",
        "assert_3": "(define-fun C3 () Bool (>= (SafeInt n2) 0))"
      },
      "constraints": {
        "assert_0": "assert isinstance(n1, int), \"invalid inputs",
        "assert_1": "assert isinstance(n2, int), \"invalid inputs",
        "assert_2": "assert n1 >= 0, \"invalid inputs",
        "assert_3": "assert n2 >= 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/559": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec ListAllInt ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (is-IntVal (head v))\n                 (ListAllInt (tail v)))\n            false)))\n\n(define-fun SafeIval ((v Value)) Int\n  (ite (is-IntVal v)\n       (ival v)\n       0))\n\n(define-fun-rec length ((v Value)) Int\n  (ite (is-Cons v)\n       (+ 1 (length (tail v)))\n       0))",
      "basic_structure": "(assert (ListAllInt a))",
      "inputs": "(declare-const a Value)\n(declare-const size Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList a))",
        "assert_1": "(define-fun C1 () Bool (is-IntVal size))",
        "assert_2": "(define-fun C2 () Bool\n  (and (is-IntVal size)\n       (IsList a)\n       (<= (SafeIval size) (length a))))"
      },
      "constraints": {
        "assert_0": "assert isinstance(a, list), \"invalid inputs",
        "assert_1": "assert isinstance(size, int), \"invalid inputs",
        "assert_2": "assert size <= len(a), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/560": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec list_all_numeric ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (or (is-IntVal (head v)) (is-FloatVal (head v)))\n                 (list_all_numeric (tail v)))\n            false)))",
      "basic_structure": "(assert (IsList test_tup1))\n(assert (IsList test_tup2))",
      "inputs": "(declare-const test_tup1 Value)\n(declare-const test_tup2 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList test_tup1))",
        "assert_1": "(define-fun C1 () Bool (IsList test_tup2))",
        "assert_2": "(define-fun C2 () Bool (list_all_numeric test_tup1))",
        "assert_3": "(define-fun C3 () Bool (list_all_numeric test_tup2))"
      },
      "constraints": {
        "assert_0": "assert isinstance(test_tup1, tuple), \"invalid inputs",
        "assert_1": "assert isinstance(test_tup2, tuple), \"invalid inputs",
        "assert_2": "assert all(isinstance(x, (int, float)) for x in test_tup1), \"invalid inputs",
        "assert_3": "assert all(isinstance(x, (int, float)) for x in test_tup2), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/562": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec length ((v Value)) Int\n  (ite (is-Nil v)\n       0\n       (ite (is-Cons v)\n            (+ 1 (length (tail v)))\n            0)))\n\n(define-fun-rec list_all_list ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (IsList (head v))\n                 (list_all_list (tail v)))\n            false)))",
      "basic_structure": "(assert (IsList lst))",
      "inputs": "(declare-const lst Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList lst))",
        "assert_1": "(define-fun C1 () Bool (> (length lst) 0))",
        "assert_2": "(define-fun C2 () Bool (list_all_list lst))"
      },
      "constraints": {
        "assert_0": "assert isinstance(lst, list), \"invalid inputs",
        "assert_1": "assert len(lst) > 0, \"invalid inputs",
        "assert_2": "assert all(isinstance(x, list) for x in lst), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/563": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "(assert (is-StrVal text))",
      "inputs": "(declare-const text Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal text))"
      },
      "constraints": {
        "assert_0": "assert isinstance(text, str), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/564": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v) true\n    (ite (is-Cons v) (IsList (tail v)) false)))\n\n(define-fun-rec AllInts ((v Value)) Bool\n  (ite (is-Nil v) true\n    (ite (is-Cons v)\n         (and (is-IntVal (head v)) (AllInts (tail v)))\n         false)))\n\n(define-fun SafeIval ((v Value)) Int\n  (ite (is-IntVal v) (ival v) 0))\n\n(define-fun-rec length ((v Value)) Int\n  (ite (is-Nil v) 0\n    (ite (is-Cons v) (+ 1 (length (tail v))) 0)))",
      "basic_structure": "(assert (IsList arr))\n(assert (is-IntVal n))",
      "inputs": "(declare-const arr Value)\n(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList arr))",
        "assert_1": "(define-fun C1 () Bool (AllInts arr))",
        "assert_2": "(define-fun C2 () Bool (is-IntVal n))",
        "assert_3": "(define-fun C3 () Bool (<= (SafeIval n) (length arr)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(arr, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(x, int) for x in arr), \"invalid inputs",
        "assert_2": "assert isinstance(n, int), \"invalid inputs",
        "assert_3": "assert n <= len(arr), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/565": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const word Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal word))"
      },
      "constraints": {
        "assert_0": "assert isinstance(word, str), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/566": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeIval ((v Value)) Int\n  (ite (is-IntVal v) (ival v) 0))",
      "basic_structure": "",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
        "assert_1": "(define-fun C1 () Bool (>= (SafeIval n) 0))"
      },
      "constraints": {
        "assert_0": "assert isinstance(n, int), \"invalid inputs",
        "assert_1": "assert n >= 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/567": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (let ((tailVal (tail l)))\n              (IsList tailVal))\n            false)))\n\n(define-fun-rec list_all_numeric ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (let ((headVal (head l))\n                  (tailVal (tail l)))\n              (and (or (is-IntVal headVal)\n                       (is-FloatVal headVal))\n                   (list_all_numeric tailVal)))\n            false)))",
      "basic_structure": "(assert (IsList list1))\n(assert (list_all_numeric list1))",
      "inputs": "(declare-const list1 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList list1))"
      },
      "constraints": {
        "assert_0": "assert isinstance(list1, list), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/568": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
      "basic_structure": "(assert (is-IntVal length))",
      "inputs": "(declare-const length Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal length))",
        "assert_1": "(define-fun C1 () Bool (and (is-IntVal length) (>= (ival length) 0)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(length, int), \"invalid inputs",
        "assert_1": "assert length >= 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/569": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (or (is-Nil v)\n      (and (is-Cons v)\n           (IsList (tail v)))))\n\n(define-fun-rec length ((l Value)) Int\n  (ite (is-Nil l) 0\n       (ite (is-Cons l)\n            (+ 1 (length (tail l)))\n            0)))\n\n(define-fun-rec all_list ((l Value)) Bool\n  (ite (is-Nil l) true\n       (ite (is-Cons l)\n            (let ((hd (head l)) (tl (tail l)))\n              (and (IsList hd)\n                   (all_list tl)))\n            false)))\n\n(define-fun-rec all_str ((l Value)) Bool\n  (ite (is-Nil l) true\n       (ite (is-Cons l)\n            (let ((hd (head l)) (tl (tail l)))\n              (and (is-StrVal hd)\n                   (all_str tl)))\n            false)))\n\n(define-fun-rec all_str_sublists ((l Value)) Bool\n  (ite (is-Nil l) true\n       (ite (is-Cons l)\n            (let ((hd (head l)) (tl (tail l)))\n              (and (all_str hd)\n                   (all_str_sublists tl)))\n            false)))",
      "basic_structure": "(assert (IsList list1))",
      "inputs": "(declare-const list1 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList list1))",
        "assert_1": "(define-fun C1 () Bool (ite (IsList list1) (> (length list1) 0) false))",
        "assert_2": "(define-fun C2 () Bool (ite (IsList list1) (all_list list1) false))",
        "assert_3": "(define-fun C3 () Bool (ite (IsList list1) (all_str_sublists list1) false))"
      },
      "constraints": {
        "assert_0": "assert isinstance(list1, list), \"invalid inputs",
        "assert_1": "assert len(list1) > 0, \"invalid inputs",
        "assert_2": "assert all(isinstance(x, list) for x in list1), \"invalid inputs",
        "assert_3": "assert all(isinstance(x, str) for sublist in list1 for x in sublist), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/572": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (IsList (tail l))\n            false)))\n\n(define-fun-rec list_all_numeric ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (and (or (is-IntVal (head l)) (is-FloatVal (head l)))\n                 (list_all_numeric (tail l)))\n            false)))",
      "basic_structure": "(assert (IsList nums))",
      "inputs": "(declare-const nums Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList nums))",
        "assert_1": "(define-fun C1 () Bool (list_all_numeric nums))"
      },
      "constraints": {
        "assert_0": "assert isinstance(nums, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(x, (int, float)) for x in nums), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/573": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (or\n    (is-Nil v)\n    (and\n      (is-Cons v)\n      (let ((hd (head v))\n            (tl (tail v)))\n        (IsList tl)\n      )\n    )\n  )\n)\n\n(define-fun-rec list_all_numeric ((v Value)) Bool\n  (or\n    (is-Nil v)\n    (and\n      (is-Cons v)\n      (let ((hd (head v))\n            (tl (tail v)))\n        (or (is-IntVal hd) (is-FloatVal hd))\n        (list_all_numeric tl)\n      )\n    )\n  )\n)",
      "basic_structure": "(assert (IsList list_data))",
      "inputs": "(declare-const list_data Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList list_data))",
        "assert_1": "(define-fun C1 () Bool (list_all_numeric list_data))"
      },
      "constraints": {
        "assert_0": "assert isinstance(list_data, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(x, (int, float)) for x in list_data), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/576": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (or (is-Nil v)\n      (and (is-Cons v)\n           (let ((tlVal (tail v)))\n             (IsList tlVal)))))",
      "basic_structure": "",
      "inputs": "(declare-const A Value)\n(declare-const B Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList A))",
        "assert_1": "(define-fun C1 () Bool (IsList B))"
      },
      "constraints": {
        "assert_0": "assert isinstance(A, list), \"invalid inputs",
        "assert_1": "assert isinstance(B, list), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/577": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (or (is-IntVal n) (is-FloatVal n)))",
        "assert_1": "(define-fun C1 () Bool (or (and (is-IntVal n) (>= (ival n) 0)) (and (is-FloatVal n) (>= (fval n) 0.0))))"
      },
      "constraints": {
        "assert_0": "assert isinstance(n, (int, float)), \"invalid inputs",
        "assert_1": "assert n >= 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/578": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n(define-fun-rec length ((v Value)) Int\n  (ite (is-Nil v)\n       0\n       (ite (is-Cons v)\n            (+ 1 (length (tail v)))\n            0)))",
      "basic_structure": "(assert (IsList list1))\n(assert (IsList list2))\n(assert (IsList list3))",
      "inputs": "(declare-const list1 Value)\n(declare-const list2 Value)\n(declare-const list3 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (IsList list1))",
        "assert_1": "(define-fun C1 () Bool\n  (IsList list2))",
        "assert_2": "(define-fun C2 () Bool\n  (IsList list3))",
        "assert_3": "(define-fun C3 () Bool\n  (and (= (length list1) (length list2))\n       (= (length list2) (length list3))))"
      },
      "constraints": {
        "assert_0": "assert isinstance(list1, list), \"invalid inputs",
        "assert_1": "assert isinstance(list2, list), \"invalid inputs",
        "assert_2": "assert isinstance(list3, list), \"invalid inputs",
        "assert_3": "assert len(list1) == len(list2) == len(list3), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/579": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))",
      "basic_structure": "(assert (IsList test_tup1))\n(assert (IsList test_tup2))",
      "inputs": "(declare-const test_tup1 Value)\n(declare-const test_tup2 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList test_tup1))",
        "assert_1": "(define-fun C1 () Bool (IsList test_tup2))"
      },
      "constraints": {
        "assert_0": "assert isinstance(test_tup1, tuple), \"invalid inputs",
        "assert_1": "assert isinstance(test_tup2, tuple), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/580": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun IsTuple ((v Value)) Bool\n  (or (is-Cons v) (is-Nil v)))\n\n(define-fun-rec tuple_check ((v Value)) Bool\n  (ite (is-Cons v)\n       (and (tuple_check (head v)) (tuple_check (tail v)))\n       (ite (is-Nil v)\n            true\n            (or (is-IntVal v) (is-FloatVal v)))))",
      "basic_structure": "(assert (IsTuple test_tuple))",
      "inputs": "(declare-const test_tuple Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsTuple test_tuple))",
        "assert_1": "(define-fun C1 () Bool (tuple_check test_tuple))"
      },
      "constraints": {
        "assert_0": "assert isinstance(test_tuple, tuple)",
        "assert_1": "assert tuple_check(test_tuple)"
      },
      "single_toggles": null
    },
    "Mbpp/581": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun isNumeric ((v Value)) Bool (or (is-IntVal v) (is-FloatVal v)))\n(define-fun toReal ((v Value)) Real\n  (ite (is-IntVal v)\n       (to_real (ival v))\n       (fval v)))",
      "basic_structure": "",
      "inputs": "(declare-const b Value)\n(declare-const s Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (isNumeric b))",
        "assert_1": "(define-fun C1 () Bool (isNumeric s))",
        "assert_2": "(define-fun C2 () Bool (and (isNumeric b) (> (toReal b) 0)))",
        "assert_3": "(define-fun C3 () Bool (and (isNumeric s) (> (toReal s) 0)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(b, (int, float)), \"invalid inputs",
        "assert_1": "assert isinstance(s, (int, float)), \"invalid inputs",
        "assert_2": "assert b > 0, \"invalid inputs",
        "assert_3": "assert s > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/583": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const num Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal num))",
        "assert_1": "(define-fun C1 () Bool (and (is-IntVal num) (>= (ival num) 0)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(num, int), \"invalid inputs",
        "assert_1": "assert num >= 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/585": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((l Value)) Bool (or (is-Nil l) (and (is-Cons l) (IsList (tail l)))))\n(define-fun IsPair ((v Value)) Bool (and (is-Cons v) (is-Cons (tail v)) (is-Nil (tail (tail v)))))\n(define-fun first ((p Value)) Value (head p))\n(define-fun second ((p Value)) Value (head (tail p)))\n(define-fun IsKVPair ((v Value)) Bool (and (IsPair v) (is-StrVal (first v))))\n(define-fun-rec IsDict ((v Value)) Bool (or (is-Nil v) (and (is-Cons v) (IsKVPair (head v)) (IsDict (tail v)))))\n(define-fun-rec dict_has_key ((d Value) (k Value)) Bool (ite (is-Cons d) (and (IsKVPair (head d)) (or (= (first (head d)) k) (dict_has_key (tail d) k))) false))\n(define-fun-rec dict_get ((d Value) (k Value)) Value (ite (is-Cons d) (let ((p (head d))) (ite (and (IsKVPair p) (= (first p) k)) (second p) (dict_get (tail d) k))) (StrVal \"\")))\n(define-fun IsNumeric ((v Value)) Bool (or (is-IntVal v) (is-FloatVal v)))\n(define-fun-rec list_all_dict ((l Value)) Bool (or (is-Nil l) (and (is-Cons l) (IsDict (head l)) (list_all_dict (tail l)))))\n(define-fun-rec list_all_has_name ((l Value)) Bool (or (is-Nil l) (and (is-Cons l) (IsDict (head l)) (dict_has_key (head l) (StrVal \"name\")) (list_all_has_name (tail l)))))\n(define-fun-rec list_all_has_price ((l Value)) Bool (or (is-Nil l) (and (is-Cons l) (IsDict (head l)) (dict_has_key (head l) (StrVal \"price\")) (list_all_has_price (tail l)))))\n(define-fun-rec list_all_price_numeric ((l Value)) Bool (or (is-Nil l) (and (is-Cons l) (IsDict (head l)) (IsNumeric (dict_get (head l) (StrVal \"price\"))) (list_all_price_numeric (tail l)))))",
      "basic_structure": "",
      "inputs": "(declare-const items Value)\n(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList items))",
        "assert_1": "(define-fun C1 () Bool (is-IntVal n))",
        "assert_2": "(define-fun C2 () Bool (and (is-IntVal n) (> (ival n) 0)))",
        "assert_3": "(define-fun C3 () Bool (list_all_dict items))",
        "assert_4": "(define-fun C4 () Bool (list_all_has_name items))",
        "assert_5": "(define-fun C5 () Bool (list_all_has_price items))",
        "assert_6": "(define-fun C6 () Bool (list_all_price_numeric items))"
      },
      "constraints": {
        "assert_0": "assert isinstance(items, list), \"invalid inputs",
        "assert_1": "assert isinstance(n, int), \"invalid inputs",
        "assert_2": "assert n > 0, \"invalid inputs",
        "assert_3": "assert all(isinstance(x, dict) for x in items), \"invalid inputs",
        "assert_4": "assert all('name' in x.keys() for x in items), \"invalid inputs",
        "assert_5": "assert all('price' in x.keys() for x in items), \"invalid inputs",
        "assert_6": "assert all(isinstance(x['price'], (int, float)) for x in items), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/586": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun IsList ((v Value)) Bool (or (is-Nil v) (is-Cons v)))\n(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))\n(define-fun-rec length ((l Value)) Int\n  (ite (is-Nil l)\n       0\n       (ite (is-Cons l)\n            (+ 1 (length (tail l)))\n            0)))",
      "basic_structure": "",
      "inputs": "(declare-const l Value)\n(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList l))",
        "assert_1": "(define-fun C1 () Bool (is-IntVal n))",
        "assert_2": "(define-fun C2 () Bool\n  (and (<= 0 (SafeI n))\n       (<= (SafeI n) (length l))))"
      },
      "constraints": {
        "assert_0": "assert isinstance(l, list), \"invalid inputs",
        "assert_1": "assert isinstance(n, int), \"invalid inputs",
        "assert_2": "assert 0 <= n <= len(l), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/587": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))",
      "basic_structure": "",
      "inputs": "(declare-const listx Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList listx))"
      },
      "constraints": {
        "assert_0": "assert isinstance(listx, list), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/588": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (or (is-Nil v)\n      (and (is-Cons v)\n           (let ((hd (head v))\n                 (tl (tail v)))\n             (IsList tl)))))\n\n(define-fun-rec length ((v Value)) Int\n  (ite (is-Nil v)\n       0\n       (ite (is-Cons v)\n            (+ 1 (length (tail v)))\n            0)))\n\n(define-fun-rec list_all_numeric ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (and (is-Cons v)\n            (let ((x (head v))\n                  (xs (tail v)))\n              (and (or (is-IntVal x) (is-FloatVal x))\n                   (list_all_numeric xs))))))",
      "basic_structure": "(assert (IsList nums))",
      "inputs": "(declare-const nums Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList nums))",
        "assert_1": "(define-fun C1 () Bool (> (length nums) 0))",
        "assert_2": "(define-fun C2 () Bool (list_all_numeric nums))"
      },
      "constraints": {
        "assert_0": "assert isinstance(nums, list), \"invalid inputs",
        "assert_1": "assert len(nums) > 0, \"invalid inputs",
        "assert_2": "assert all(isinstance(x, (int, float)) for x in nums), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/589": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun isIntVal ((v Value)) Bool (is-IntVal v))",
      "basic_structure": "",
      "inputs": "(declare-const a Value)\n(declare-const b Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (isIntVal a))",
        "assert_1": "(define-fun C1 () Bool (isIntVal b))"
      },
      "constraints": {
        "assert_0": "assert isinstance(a, int), \"invalid inputs",
        "assert_1": "assert isinstance(b, int), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/590": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun isNumeric ((v Value)) Bool (or (is-IntVal v) (is-FloatVal v)))",
      "basic_structure": "(assert true)",
      "inputs": "(declare-const x Value)\n(declare-const y Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (isNumeric x))",
        "assert_1": "(define-fun C1 () Bool (isNumeric y))"
      },
      "constraints": {
        "assert_0": "assert isinstance(x, (int, float)), \"invalid inputs",
        "assert_1": "assert isinstance(y, (int, float)), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/591": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (IsList (tail l))\n            false)))\n\n(define-fun-rec length ((l Value)) Int\n  (ite (is-Cons l)\n       (+ 1 (length (tail l)))\n       0))",
      "basic_structure": "(assert (IsList newList))",
      "inputs": "(declare-const newList Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (IsList newList))",
        "assert_1": "(define-fun C1 () Bool\n  (> (length newList) 0))"
      },
      "constraints": {
        "assert_0": "assert isinstance(newList, list), \"invalid inputs",
        "assert_1": "assert len(newList) > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/592": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
      "basic_structure": "(assert (is-IntVal n))",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
        "assert_1": "(define-fun C1 () Bool (and C0 (>= (SafeI n) 0)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(n, int), \"invalid inputs",
        "assert_1": "assert n >= 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/593": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeS ((v Value)) String\n  (ite (is-StrVal v) (sval v) \"\"))",
      "basic_structure": "(assert (is-StrVal ip))",
      "inputs": "(declare-const ip Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal ip))",
        "assert_1": "(define-fun C1 () Bool (> (str.len (SafeS ip)) 0))"
      },
      "constraints": {
        "assert_0": "assert isinstance(ip, str), \"invalid inputs",
        "assert_1": "assert len(ip) > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/594": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n    true\n    (ite (is-Cons v)\n      (IsList (tail v))\n      false)))\n\n(define-fun-rec all_ints ((v Value)) Bool\n  (ite (is-Nil v)\n    true\n    (ite (is-Cons v)\n      (let ((hd (head v)))\n        (and (is-IntVal hd)\n             (all_ints (tail v))))\n      false)))\n\n(define-fun-rec exists_even ((v Value)) Bool\n  (ite (is-Nil v)\n    false\n    (ite (is-Cons v)\n      (let ((hd (head v)))\n        (ite (and (is-IntVal hd)\n                  (= (mod (ival hd) 2) 0))\n             true\n             (exists_even (tail v))))\n      false)))\n\n(define-fun-rec exists_odd ((v Value)) Bool\n  (ite (is-Nil v)\n    false\n    (ite (is-Cons v)\n      (let ((hd (head v)))\n        (ite (and (is-IntVal hd)\n                  (not (= (mod (ival hd) 2) 0)))\n             true\n             (exists_odd (tail v))))\n      false)))",
      "basic_structure": "(assert (IsList list1))",
      "inputs": "(declare-const list1 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList list1))",
        "assert_1": "(define-fun C1 () Bool (all_ints list1))",
        "assert_2": "(define-fun C2 () Bool (exists_even list1))",
        "assert_3": "(define-fun C3 () Bool (exists_odd list1))"
      },
      "constraints": {
        "assert_0": "assert isinstance(list1, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(i, int) for i in list1), \"invalid inputs",
        "assert_2": "assert any(el%2==0 for el in list1), \"invalid inputs",
        "assert_3": "assert any(el%2!=0 for el in list1), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/596": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n    true\n    (ite (is-Cons v)\n      (IsList (tail v))\n      false)))",
      "basic_structure": "(assert true)",
      "inputs": "(declare-const tuple_list Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList tuple_list))"
      },
      "constraints": {
        "assert_0": "assert isinstance(tuple_list, tuple), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/597": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v) true\n    (ite (is-Cons v) (IsList (tail v)) false)))\n(define-fun-rec list_len ((v Value)) Int\n  (ite (is-Nil v) 0\n    (ite (is-Cons v) (+ 1 (list_len (tail v))) 0)))",
      "basic_structure": "(assert (IsList arr1))\n(assert (IsList arr2))\n(assert (is-IntVal k))",
      "inputs": "(declare-const arr1 Value)\n(declare-const arr2 Value)\n(declare-const k Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList arr1))",
        "assert_1": "(define-fun C1 () Bool (IsList arr2))",
        "assert_2": "(define-fun C2 () Bool (is-IntVal k))",
        "assert_3": "(define-fun C3 () Bool (let ((ki (ite (is-IntVal k) (ival k) 0)) (l1 (list_len arr1)) (l2 (list_len arr2))) (and (< 0 ki) (<= ki (+ l1 l2)))))"
      },
      "constraints": {
        "assert_0": "assert isinstance(arr1, list), \"invalid inputs",
        "assert_1": "assert isinstance(arr2, list), \"invalid inputs",
        "assert_2": "assert isinstance(k, int), \"invalid inputs",
        "assert_3": "assert 0 < k <= len(arr1) + len(arr2), \"invalid inputs\" j"
      },
      "single_toggles": null
    },
    "Mbpp/598": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const number Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal number))",
        "assert_1": "(define-fun C1 () Bool (and (is-IntVal number) (> (ival number) 0)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(number, int), \"invalid inputs",
        "assert_1": "assert number > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/599": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const number Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal number))",
        "assert_1": "(define-fun C1 () Bool (and C0 (> (ival number) 0)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(number, int), \"invalid inputs",
        "assert_1": "assert number > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/600": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))"
      },
      "constraints": {
        "assert_0": "assert isinstance(n, int), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/602": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const str1 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal str1))"
      },
      "constraints": {
        "assert_0": "assert isinstance(str1, str), \"invalid inputs\" I"
      },
      "single_toggles": null
    },
    "Mbpp/603": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeI ((v Value)) Int\n  (ite (is-IntVal v) (ival v) 0))",
      "basic_structure": "",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
        "assert_1": "(define-fun C1 () Bool (> (SafeI n) 0))"
      },
      "constraints": {
        "assert_0": "assert isinstance(n, int), \"invalid inputs",
        "assert_1": "assert n > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/604": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const s Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal s))"
      },
      "constraints": {
        "assert_0": "assert isinstance(s, str), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/605": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))\n(define-fun-rec prime_helper ((n Int) (i Int)) Bool\n  (ite (> (* i i) n)\n       true\n       (ite (= (mod n i) 0)\n            false\n            (prime_helper n (+ i 1)))))\n(define-fun is_prime ((v Value)) Bool\n  (ite (is-IntVal v)\n       (let ((n (ival v)))\n         (ite (<= n 1)\n              false\n              (prime_helper n 2)))\n       false))",
      "basic_structure": "",
      "inputs": "(declare-const num Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal num))"
      },
      "constraints": {
        "assert_0": "assert isinstance(num, int), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/606": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const degree Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal degree))"
      },
      "constraints": {
        "assert_0": "assert isinstance(degree, int), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/607": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const text Value)\n(declare-const pattern Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal text))",
        "assert_1": "(define-fun C1 () Bool (is-StrVal pattern))"
      },
      "constraints": {
        "assert_0": "assert isinstance(text, str), \"invalid inputs",
        "assert_1": "assert isinstance(pattern, str), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/608": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeInt ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
      "basic_structure": "",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
        "assert_1": "(define-fun C1 () Bool (and (is-IntVal n) (>= (SafeInt n) 0)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(n, int), \"invalid inputs",
        "assert_1": "assert n >= 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/610": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (IsList (tail l))\n            false)))\n\n(define-fun-rec list_length ((l Value)) Int\n  (ite (is-Nil l)\n       0\n       (ite (is-Cons l)\n            (+ 1 (list_length (tail l)))\n            0)))\n\n(define-fun get_int ((v Value)) Int\n  (ite (is-IntVal v) (ival v) 0))",
      "basic_structure": "(assert (IsList list1))",
      "inputs": "(declare-const list1 Value)\n(declare-const k Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList list1))",
        "assert_1": "(define-fun C1 () Bool (is-IntVal k))",
        "assert_2": "(define-fun C2 () Bool (and (> (get_int k) 0) (<= (get_int k) (list_length list1))))"
      },
      "constraints": {
        "assert_0": "assert isinstance(list1, list), \"invalid inputs",
        "assert_1": "assert isinstance(k, int), \"invalid inputs",
        "assert_2": "assert 0 < k <= len(list1), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/611": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v) true\n    (ite (is-Cons v)\n         (IsList (tail v))\n         false)))\n\n(define-fun safe_head ((v Value)) Value\n  (ite (is-Cons v)\n       (head v)\n       Nil))\n\n(define-fun safe_tail ((v Value)) Value\n  (ite (is-Cons v)\n       (tail v)\n       Nil))\n\n(define-fun safe_ival ((v Value)) Int\n  (ite (is-IntVal v)\n       (ival v)\n       0))\n\n(define-fun-rec length ((v Value)) Int\n  (ite (is-Nil v) 0\n    (ite (is-Cons v)\n         (+ 1 (length (tail v)))\n         0)))\n\n(define-fun-rec list_all_numeric ((v Value)) Bool\n  (ite (is-Cons v)\n       (and (or (is-IntVal (head v)) (is-FloatVal (head v)))\n            (list_all_numeric (tail v)))\n       true))\n\n(define-fun-rec matrix_all_numeric ((m Value)) Bool\n  (ite (is-Cons m)\n       (and (list_all_numeric (safe_head m))\n            (matrix_all_numeric (safe_tail m)))\n       true))\n\n(define-fun-rec all_rows_are_list ((m Value)) Bool\n  (ite (is-Cons m)\n       (and (IsList (head m))\n            (all_rows_are_list (tail m)))\n       true))\n\n(define-fun-rec all_rows_len_equal ((m Value) (len0 Int)) Bool\n  (ite (is-Cons m)\n       (and (= (length (safe_head m)) len0)\n            (all_rows_len_equal (safe_tail m) len0))\n       true))",
      "basic_structure": "(assert (IsList test_list))",
      "inputs": "(declare-const test_list Value)\n(declare-const N Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList test_list))",
        "assert_1": "(define-fun C1 () Bool (> (length test_list) 0))",
        "assert_2": "(define-fun C2 () Bool (all_rows_are_list test_list))",
        "assert_3": "(define-fun C3 () Bool (> (length (safe_head test_list)) 0))",
        "assert_4": "(define-fun C4 () Bool (let ((len0 (length (safe_head test_list)))) (all_rows_len_equal test_list len0)))",
        "assert_5": "(define-fun C5 () Bool (matrix_all_numeric test_list))",
        "assert_6": "(define-fun C6 () Bool (< (safe_ival N) (length (safe_head test_list))))"
      },
      "constraints": {
        "assert_0": "assert isinstance(test_list, list), \"invalid inputs",
        "assert_1": "assert len(test_list) > 0, \"invalid inputs",
        "assert_2": "assert all(isinstance(row, list) for row in test_list), \"invalid inputs",
        "assert_3": "assert len(test_list[0]) > 0, \"invalid inputs",
        "assert_4": "assert all(len(row) == len(test_list[0]) for row in test_list), \"invalid inputs",
        "assert_5": "assert all(isinstance(item, (int, float)) for row in test_list for item in row), \"invalid inputs",
        "assert_6": "assert N < len(test_list[0]), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/612": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n    (or (is-Nil v)\n        (and (is-Cons v)\n             (IsList (tail v)))))\n\n(define-fun-rec length ((v Value)) Int\n    (ite (is-Nil v) 0\n         (ite (is-Cons v) (+ 1 (length (tail v)))\n              0)))\n\n(define-fun-rec list_all_size2 ((v Value)) Bool\n    (ite (is-Nil v) true\n         (ite (is-Cons v)\n              (let ((sub (head v)))\n                (and (IsList sub)\n                     (= (length sub) 2)\n                     (list_all_size2 (tail v))))\n              true)))",
      "basic_structure": "(assert (IsList lst))",
      "inputs": "(declare-const lst Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList lst))",
        "assert_1": "(define-fun C1 () Bool (and (IsList lst) (> (length lst) 0)))",
        "assert_2": "(define-fun C2 () Bool (and (IsList lst) (list_all_size2 lst)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(lst, list), \"invalid inputs",
        "assert_1": "assert len(lst) > 0, \"invalid inputs",
        "assert_2": "assert all(len(sublist) == 2 for sublist in lst), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/614": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (or (is-Nil v) (and (is-Cons v) (IsList (tail v)))))\n\n(define-fun-rec AllSeq ((l Value)) Bool\n  (or (is-Nil l) (and (is-Cons l) (IsList (head l)) (AllSeq (tail l)))))\n\n(define-fun-rec concatenate ((t1 Value) (t2 Value)) Value\n  (ite (is-Nil t1) t2 (Cons (head t1) (concatenate (tail t1) t2))))\n\n(define-fun-rec flatten ((lst Value)) Value\n  (ite (is-Nil lst) Nil (concatenate (head lst) (flatten (tail lst)))))\n\n(define-fun IsNumeric ((v Value)) Bool (or (is-IntVal v) (is-FloatVal v)))\n\n(define-fun-rec list_all_numeric ((lst Value)) Bool\n  (or (is-Nil lst) (and (is-Cons lst) (IsNumeric (head lst)) (list_all_numeric (tail lst)))))",
      "basic_structure": "(assert (IsList test_list))",
      "inputs": "(declare-const test_list Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList test_list))",
        "assert_1": "(define-fun C1 () Bool (AllSeq test_list))",
        "assert_2": "(define-fun C2 () Bool (ite C1 (list_all_numeric (flatten test_list)) false))"
      },
      "constraints": {
        "assert_0": "assert isinstance(test_list, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(el, tuple) for el in test_list), \"invalid inputs",
        "assert_2": "assert all(isinstance(el, (int, float)) for el in sum(test_list, ())), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/615": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun IsList ((v Value)) Bool\n  (or (is-Nil v) (is-Cons v)))\n\n(define-fun-rec list_all_list ((lst Value)) Bool\n  (ite (is-Nil lst)\n       true\n       (ite (is-Cons lst)\n            (let ((hd (head lst)) (tl (tail lst)))\n              (and (IsList hd) (list_all_list tl)))\n            false)))\n\n(define-fun-rec append ((a Value) (b Value)) Value\n  (ite (is-Nil a)\n       b\n       (let ((hdA (head a)) (tlA (tail a)))\n         (Cons hdA (append tlA b)))))\n\n(define-fun-rec flatten ((lst Value)) Value\n  (ite (is-Nil lst)\n       lst\n       (let ((hd (head lst)) (tl (tail lst)))\n         (append hd (flatten tl)))))\n\n(define-fun-rec list_all_numeric ((lst Value)) Bool\n  (ite (is-Nil lst)\n       true\n       (ite (is-Cons lst)\n            (let ((hd (head lst)) (tl (tail lst)))\n              (and (or (is-IntVal hd) (is-FloatVal hd))\n                   (list_all_numeric tl)))\n            false)))",
      "basic_structure": "(assert (IsList nums))",
      "inputs": "(declare-const nums Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList nums))",
        "assert_1": "(define-fun C1 () Bool (list_all_list nums))",
        "assert_2": "(define-fun C2 () Bool (list_all_numeric (flatten nums)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(nums, tuple), \"invalid inputs",
        "assert_1": "assert all(isinstance(x, tuple) for x in nums), \"invalid inputs",
        "assert_2": "assert all(isinstance(x, (int, float)) for x in sum(nums, ())), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/616": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((lst Value)) Bool\n  (ite (is-Nil lst) true\n    (ite (is-Cons lst) (IsList (tail lst)) false)))\n\n(define-fun-rec list_length ((lst Value)) Int\n  (ite (is-Nil lst) 0\n    (ite (is-Cons lst) (+ 1 (list_length (tail lst))) 0)))\n\n(define-fun-rec list_all_int ((lst Value)) Bool\n  (ite (is-Nil lst) true\n    (ite (is-Cons lst)\n      (and (is-IntVal (head lst)) (list_all_int (tail lst))) false)))\n\n(define-fun-rec list_all_positive ((lst Value)) Bool\n  (ite (is-Nil lst) true\n    (ite (is-Cons lst)\n      (and (is-IntVal (head lst)) (> (ival (head lst)) 0) (list_all_positive (tail lst))) false)))",
      "basic_structure": "(assert (IsList test_tup1))\n(assert (IsList test_tup2))",
      "inputs": "(declare-const test_tup1 Value)\n(declare-const test_tup2 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList test_tup1))",
        "assert_1": "(define-fun C1 () Bool (IsList test_tup2))",
        "assert_2": "(define-fun C2 () Bool (= (list_length test_tup1) (list_length test_tup2)))",
        "assert_3": "(define-fun C3 () Bool (and (list_all_int test_tup1) (list_all_int test_tup2)))",
        "assert_4": "(define-fun C4 () Bool (list_all_positive test_tup2))"
      },
      "constraints": {
        "assert_0": "assert isinstance(test_tup1, tuple), \"invalid inputs",
        "assert_1": "assert isinstance(test_tup2, tuple), \"invalid inputs",
        "assert_2": "assert len(test_tup1) == len(test_tup2), \"invalid inputs",
        "assert_3": "assert all(isinstance(x, int) for x in test_tup1 + test_tup2), \"invalid inputs",
        "assert_4": "assert all(x > 0 for x in test_tup2), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/618": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v) true\n    (ite (is-Cons v)\n      (let ((t (tail v)))\n        (IsList t))\n      false)))\n\n(define-fun-rec length ((l Value)) Int\n  (ite (is-Nil l) 0\n    (ite (is-Cons l)\n      (let ((t (tail l)))\n        (+ 1 (length t)))\n      0)))\n\n(define-fun-rec list_all_numeric ((l Value)) Bool\n  (ite (is-Nil l) true\n    (ite (is-Cons l)\n      (let ((h (head l)) (t (tail l)))\n        (and (or (is-IntVal h) (is-FloatVal h))\n             (list_all_numeric t)))\n      false)))\n\n(define-fun-rec list_all_non_zero ((l Value)) Bool\n  (ite (is-Nil l) true\n    (ite (is-Cons l)\n      (let ((h (head l)) (t (tail l)))\n        (and\n          (ite (is-IntVal h)\n               (distinct (ival h) 0)\n               (ite (is-FloatVal h)\n                    (distinct (fval h) 0.0)\n                    false))\n          (list_all_non_zero t)))\n      false)))",
      "basic_structure": "(assert (IsList nums1))\n(assert (IsList nums2))",
      "inputs": "(declare-const nums1 Value)\n(declare-const nums2 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList nums1))",
        "assert_1": "(define-fun C1 () Bool (IsList nums2))",
        "assert_2": "(define-fun C2 () Bool (> (length nums1) 0))",
        "assert_3": "(define-fun C3 () Bool (> (length nums2) 0))",
        "assert_4": "(define-fun C4 () Bool (= (length nums1) (length nums2)))",
        "assert_5": "(define-fun C5 () Bool (and (list_all_numeric nums1) (list_all_numeric nums2)))",
        "assert_6": "(define-fun C6 () Bool (list_all_non_zero nums2))"
      },
      "constraints": {
        "assert_0": "assert isinstance(nums1, list), \"invalid inputs",
        "assert_1": "assert isinstance(nums2, list), \"invalid inputs",
        "assert_2": "assert len(nums1) > 0, \"invalid inputs",
        "assert_3": "assert len(nums2) > 0, \"invalid inputs",
        "assert_4": "assert len(nums1) == len(nums2), \"invalid inputs",
        "assert_5": "assert all(isinstance(x, (int, float)) for x in nums1 + nums2), \"invalid inputs",
        "assert_6": "assert all(x != 0 for x in nums2), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/619": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const test_str Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal test_str))"
      },
      "constraints": {
        "assert_0": "assert isinstance(test_str, str), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/620": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (IsList (tail l))\n            false)))\n\n(define-fun-rec length ((lst Value)) Int\n  (ite (is-Nil lst)\n       0\n       (ite (is-Cons lst)\n            (+ 1 (length (tail lst)))\n            0)))\n\n(define-fun-rec list_all_numeric ((lst Value)) Bool\n  (ite (is-Nil lst)\n       true\n       (ite (is-Cons lst)\n            (and (or (is-IntVal (head lst))\n                     (is-FloatVal (head lst)))\n                 (list_all_numeric (tail lst)))\n            false)))",
      "basic_structure": "(assert (IsList a))",
      "inputs": "(declare-const a Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList a))",
        "assert_1": "(define-fun C1 () Bool (>= (length a) 2))",
        "assert_2": "(define-fun C2 () Bool (list_all_numeric a))"
      },
      "constraints": {
        "assert_0": "assert isinstance(a, list), \"invalid inputs",
        "assert_1": "assert len(a) >= 2, \"invalid inputs",
        "assert_2": "assert all(isinstance(el, (int, float)) for el in a), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/622": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v) true\n       (ite (is-Cons v) (IsList (tail v)) false)))\n\n(define-fun-rec length ((l Value)) Int\n  (ite (is-Nil l) 0\n       (ite (is-Cons l) (+ 1 (length (tail l))) 0)))\n\n(define-fun SafeI ((v Value)) Int\n  (ite (is-IntVal v) (ival v) 0))\n\n(define-fun toReal ((v Value)) Real\n  (ite (is-IntVal v) (to_real (ival v))\n       (ite (is-FloatVal v) (fval v) 0.0)))\n\n(define-fun-rec list_all_numeric ((l Value)) Bool\n  (ite (is-Nil l) true\n       (ite (is-Cons l)\n            (let ((hd (head l)) (tl (tail l)))\n              (and (or (is-IntVal hd) (is-FloatVal hd))\n                   (list_all_numeric tl)))\n            false)))\n\n(define-fun-rec sorted_prefix ((l Value) (k Int)) Bool\n  (ite (<= k 1) true\n       (and (is-Cons l)\n            (is-Cons (tail l))\n            (<= (toReal (head l)) (toReal (head (tail l))))\n            (sorted_prefix (tail l) (- k 1)))))",
      "basic_structure": "(assert (IsList arr1))\n(assert (IsList arr2))\n(assert (is-IntVal n))",
      "inputs": "(declare-const arr1 Value)\n(declare-const arr2 Value)\n(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList arr1))",
        "assert_1": "(define-fun C1 () Bool (IsList arr2))",
        "assert_2": "(define-fun C2 () Bool (and (is-IntVal n) (<= 0 (ival n)) (<= (ival n) (length arr1)) (<= (ival n) (length arr2))))",
        "assert_3": "(define-fun C3 () Bool (and (list_all_numeric arr1) (list_all_numeric arr2)))",
        "assert_4": "(define-fun C4 () Bool (sorted_prefix arr1 (SafeI n)))",
        "assert_5": "(define-fun C5 () Bool (sorted_prefix arr2 (SafeI n)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(arr1, list), \"invalid inputs",
        "assert_1": "assert isinstance(arr2, list), \"invalid inputs",
        "assert_2": "assert 0 <= n <= min(len(arr1), len(arr2)), \"invalid inputs",
        "assert_3": "assert all(isinstance(el, (int, float)) for el in arr1 + arr2), \"invalid inputs",
        "assert_4": "assert all(x <= y for x, y in zip(arr1[0:n], arr1[1:n])), \"invalid inputs",
        "assert_5": "assert all(x <= y for x, y in zip(arr2[0:n], arr2[1:n])), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/623": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec list_all_numeric ((lst Value)) Bool\n  (ite (is-Nil lst)\n       true\n       (ite (is-Cons lst)\n            (let ((h (head lst))\n                  (t (tail lst)))\n              (and (or (is-IntVal h)\n                       (is-FloatVal h))\n                   (list_all_numeric t)))\n            false)))",
      "basic_structure": "(assert (IsList nums))",
      "inputs": "(declare-const nums Value)\n(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList nums))",
        "assert_1": "(define-fun C1 () Bool (list_all_numeric nums))",
        "assert_2": "(define-fun C2 () Bool (or (is-IntVal n) (is-FloatVal n)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(nums, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(el, (int, float)) for el in nums), \"invalid inputs",
        "assert_2": "assert isinstance(n, (int, float)), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/624": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "(assert (is-StrVal string))",
      "inputs": "(declare-const string Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal string))"
      },
      "constraints": {
        "assert_0": "assert isinstance(string, str), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/626": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun is-NumericVal ((v Value)) Bool\n  (or (is-IntVal v) (is-FloatVal v)))\n\n(define-fun toReal ((v Value)) Real\n  (ite (is-IntVal v) (to_real (ival v)) (fval v)))",
      "basic_structure": "",
      "inputs": "(declare-const r Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (or (is-IntVal r) (is-FloatVal r)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(r, (int, float)), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/628": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const string Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal string))"
      },
      "constraints": {
        "assert_0": "assert isinstance(string, str), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/629": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec isList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (isList (tail v))\n            false)))\n\n(define-fun-rec list_all_int ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (is-IntVal (head v)) (list_all_int (tail v)))\n            false)))",
      "basic_structure": "(assert (isList l))",
      "inputs": "(declare-const l Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (isList l))",
        "assert_1": "(define-fun C1 () Bool (list_all_int l))"
      },
      "constraints": {
        "assert_0": "assert isinstance(l, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(x, int) for x in l), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/630": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec Length ((v Value)) Int\n  (ite (is-Nil v)\n       0\n       (+ 1 (Length (tail v)))))\n\n(define-fun-rec AllInt ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (is-IntVal (head v))\n                 (AllInt (tail v)))\n            false)))",
      "basic_structure": "(assert (IsList test_tup))\n(assert (> (Length test_tup) 0))",
      "inputs": "(declare-const test_tup Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (IsList test_tup))",
        "assert_1": "(define-fun C1 () Bool\n  (AllInt test_tup))"
      },
      "constraints": {
        "assert_0": "assert isinstance(test_tup, tuple), \"invalid inputs",
        "assert_1": "assert all(isinstance(x, int) for x in test_tup), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/631": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeS ((v Value)) String (ite (is-StrVal v) (sval v) \"\"))",
      "basic_structure": "(assert (is-StrVal text))",
      "inputs": "(declare-const text Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal text))"
      },
      "constraints": {
        "assert_0": "assert isinstance(text, str), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/632": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n    true\n    (ite (is-Cons v)\n      (IsList (tail v))\n      false)))\n(define-fun-rec list_all_numeric ((v Value)) Bool\n  (ite (is-Nil v)\n    true\n    (ite (is-Cons v)\n      (let ((headVal (head v)) (tailVal (tail v)))\n        (and\n          (or (is-IntVal headVal) (is-FloatVal headVal))\n          (list_all_numeric tailVal)))\n      false)))",
      "basic_structure": "(assert (IsList num_list))",
      "inputs": "(declare-const num_list Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList num_list))",
        "assert_1": "(define-fun C1 () Bool (list_all_numeric num_list))"
      },
      "constraints": {
        "assert_0": "assert isinstance(num_list, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(x, (int, float)) for x in num_list), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/633": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (let ((t (tail v)))\n              (IsList t))\n            false)))\n\n(define-fun-rec length ((v Value)) Int\n  (ite (is-Nil v)\n       0\n       (ite (is-Cons v)\n            (let ((t (tail v)))\n              (+ 1 (length t)))\n            0)))\n\n(define-fun SafeI ((v Value)) Int\n  (ite (is-IntVal v)\n       (ival v)\n       0))\n\n(define-fun-rec list_all_numeric ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (let ((h (head v)) (t (tail v)))\n              (and (or (is-IntVal h) (is-FloatVal h))\n                   (list_all_numeric t)))\n            false)))",
      "basic_structure": "(assert (IsList arr))\n(assert (is-IntVal n))",
      "inputs": "(declare-const arr Value)\n(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList arr))",
        "assert_1": "(define-fun C1 () Bool (list_all_numeric arr))",
        "assert_2": "(define-fun C2 () Bool (<= (SafeI n) (length arr)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(arr, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(x, (int, float)) for x in arr), \"invalid inputs",
        "assert_2": "assert n <= len(arr), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/635": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (or (is-Nil v)\n      (and (is-Cons v)\n           (let ((head_val (head v))\n                 (tail_val (tail v)))\n             (IsList tail_val)))))\n\n(define-fun-rec list_all_numeric ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (let ((head_val (head v))\n                  (tail_val (tail v)))\n              (and (or (is-IntVal head_val)\n                       (is-FloatVal head_val))\n                   (list_all_numeric tail_val)))\n            false)))",
      "basic_structure": "(assert (IsList iterable))",
      "inputs": "(declare-const iterable Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList iterable))",
        "assert_1": "(define-fun C1 () Bool (list_all_numeric iterable))"
      },
      "constraints": {
        "assert_0": "assert isinstance(iterable, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(x, (int, float)) for x in iterable), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/637": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun is-number ((v Value)) Bool (or (is-IntVal v) (is-FloatVal v)))",
      "basic_structure": "",
      "inputs": "(declare-const actual_cost Value)\n(declare-const sale_amount Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-number actual_cost))",
        "assert_1": "(define-fun C1 () Bool (is-number sale_amount))"
      },
      "constraints": {
        "assert_0": "assert isinstance(actual_cost, (int, float)), \"invalid inputs",
        "assert_1": "assert isinstance(sale_amount, (int, float)), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/638": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(declare-fun pow (Real Real) Real)\n(declare-fun roundI (Real) Int)\n(define-fun isNumeric ((x Value)) Bool\n  (or (is-IntVal x) (is-FloatVal x)))\n(define-fun safeReal ((x Value)) Real\n  (ite (is-IntVal x)\n       (to_real (ival x))\n       (ite (is-FloatVal x)\n            (fval x)\n            0.0)))",
      "basic_structure": "",
      "inputs": "(declare-const v Value)\n(declare-const t Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (isNumeric v))",
        "assert_1": "(define-fun C1 () Bool (isNumeric t))"
      },
      "constraints": {
        "assert_0": "assert isinstance(v, (int, float)), \"invalid inputs",
        "assert_1": "assert isinstance(t, (int, float)), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/639": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (or (is-Nil l)\n      (and (is-Cons l)\n           (IsList (tail l)))))\n\n(define-fun-rec ListAllStr ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (and (is-Cons l)\n            (let ((hd (head l)))\n              (and (is-StrVal hd)\n                   (ListAllStr (tail l)))))))",
      "basic_structure": "(assert (IsList sample_names))",
      "inputs": "(declare-const sample_names Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList sample_names))",
        "assert_1": "(define-fun C1 () Bool (ListAllStr sample_names))"
      },
      "constraints": {
        "assert_0": "assert isinstance(sample_names, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(x, str) for x in sample_names), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/641": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
      "basic_structure": "",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
        "assert_1": "(define-fun C1 () Bool (>= (SafeI n) 0))"
      },
      "constraints": {
        "assert_0": "assert isinstance(n, int), \"invalid inputs",
        "assert_1": "assert n >= 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/643": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const text Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal text))"
      },
      "constraints": {
        "assert_0": "assert isinstance(text, str), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/644": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool (ite (is-Nil v) true (ite (is-Cons v) (IsList (tail v)) false)))\n(define-fun-rec length ((v Value)) Int (ite (is-Nil v) 0 (ite (is-Cons v) (+ 1 (length (tail v))) 0)))",
      "basic_structure": "(assert (IsList input))",
      "inputs": "(declare-const input Value)\n(declare-const k Int)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList input))",
        "assert_1": "(define-fun C1 () Bool (ite (IsList input) (and (> k 0) (<= k (length input))) false))"
      },
      "constraints": {
        "assert_0": "assert isinstance(input, list), \"invalid inputs",
        "assert_1": "assert 0 < k <= len(input), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/720": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (or (is-Nil v) (and (is-Cons v) (IsList (tail v)))))\n\n(define-fun IsPair ((v Value)) Bool\n  (and (is-Cons v) (is-Cons (tail v)) (is-Nil (tail (tail v)))))\n(define-fun first ((p Value)) Value (head p))\n(define-fun second ((p Value)) Value (head (tail p)))\n\n(define-fun IsKVPair ((v Value)) Bool\n  (and (IsPair v) (is-StrVal (first v))))\n\n(define-fun-rec IsDict ((v Value)) Bool\n  (or (is-Nil v) (and (is-Cons v) (IsKVPair (head v)) (IsDict (tail v)))))",
      "basic_structure": "",
      "inputs": "(declare-const test_tup Value)\n(declare-const test_dict Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList test_tup))",
        "assert_1": "(define-fun C1 () Bool (IsDict test_dict))"
      },
      "constraints": {
        "assert_0": "assert isinstance(test_tup, tuple), \"invalid inputs",
        "assert_1": "assert isinstance(test_dict, dict), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/721": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun isList ((v Value)) Bool (or (is-Nil v) (is-Cons v)))\n(define-fun-rec length ((lst Value)) Int\n  (ite (is-Nil lst)\n       0\n       (ite (is-Cons lst)\n            (+ 1 (length (tail lst)))\n            0)))\n(define-fun-rec list_all_lists ((lst Value)) Bool\n  (ite (is-Nil lst)\n       true\n       (ite (is-Cons lst)\n            (and (isList (head lst)) (list_all_lists (tail lst)))\n            false)))\n(define-fun-rec list_all_numeric ((lst Value)) Bool\n  (ite (is-Nil lst)\n       true\n       (ite (is-Cons lst)\n            (and (or (is-IntVal (head lst)) (is-FloatVal (head lst)))\n                 (list_all_numeric (tail lst)))\n            false)))\n(define-fun-rec list_all_numeric_matrix ((m Value)) Bool\n  (ite (is-Nil m)\n       true\n       (ite (is-Cons m)\n            (and (list_all_numeric (head m))\n                 (list_all_numeric_matrix (tail m)))\n            false)))\n(define-fun-rec all_row_lengths_equal ((lst Value) (n Int)) Bool\n  (ite (is-Nil lst)\n       true\n       (ite (is-Cons lst)\n            (and (= (length (head lst)) n)\n                 (all_row_lengths_equal (tail lst) n))\n            false)))",
      "basic_structure": "(assert (isList cost))\n(assert (> (length cost) 0))",
      "inputs": "(declare-const cost Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (isList cost))",
        "assert_1": "(define-fun C1 () Bool (> (length cost) 0))",
        "assert_2": "(define-fun C2 () Bool (list_all_lists cost))",
        "assert_3": "(define-fun C3 () Bool\n  (ite (is-Cons cost)\n       (let ((n (length cost)))\n         (and (= (length (head cost)) n)\n              (all_row_lengths_equal (tail cost) n)))\n       false))",
        "assert_4": "(define-fun C4 () Bool (list_all_numeric_matrix cost))"
      },
      "constraints": {
        "assert_0": "assert isinstance(cost, list), \"invalid inputs",
        "assert_1": "assert len(cost) > 0, \"invalid inputs",
        "assert_2": "assert all(isinstance(x, list) for x in cost), \"invalid inputs",
        "assert_3": "assert all(len(x) == len(cost) == len(cost[0]) for x in cost), \"invalid inputs",
        "assert_4": "assert all(isinstance(x, (int, float)) for x in sum(cost, [])), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/722": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (or (is-Nil l) (and (is-Cons l) (IsList (tail l)))))\n\n; pair (a,b) \u2261 Cons a (Cons b Nil)\n(define-fun IsPair ((v Value)) Bool\n  (and (is-Cons v) (is-Cons (tail v)) (is-Nil (tail (tail v)))))\n(define-fun first  ((p Value)) Value (head p))\n(define-fun second ((p Value)) Value (head (tail p)))\n\n; dict := list of (StrVal key, Value val) pairs\n(define-fun IsKVPair ((v Value)) Bool\n  (and (IsPair v) (is-StrVal (first v))))\n(define-fun-rec IsDict ((v Value)) Bool\n  (or (is-Nil v) (and (is-Cons v) (IsKVPair (head v)) (IsDict (tail v)))))\n\n; all keys are strings (redundant if IsDict holds, but kept for contract mapping)\n(define-fun-rec AllKeysStr ((d Value)) Bool\n  (or (is-Nil d) (and (is-Cons d) (IsKVPair (head d)) (AllKeysStr (tail d)))))\n\n; all values are pairs (tuple-like)\n(define-fun-rec AllValsPair ((d Value)) Bool\n  (or (is-Nil d) (and (is-Cons d) (IsKVPair (head d)) (IsPair (second (head d))) (AllValsPair (tail d)))))\n\n; all values have length 2 (same as pair, kept to mirror contract)\n(define-fun-rec AllValLen2 ((d Value)) Bool\n  (or (is-Nil d) (and (is-Cons d) (IsKVPair (head d)) (IsPair (second (head d))) (AllValLen2 (tail d)))))\n\n; numeric helpers\n(define-fun is-Number ((v Value)) Bool (or (is-IntVal v) (is-FloatVal v)))\n(define-fun SafeReal ((v Value)) Real\n  (ite (is-FloatVal v) (fval v) (ite (is-IntVal v) (to_real (ival v)) 0.0)))\n\n; all (height, weight) are numeric\n(define-fun-rec AllValsNumericPair ((d Value)) Bool\n  (or (is-Nil d)\n      (and (is-Cons d) (IsKVPair (head d))\n           (let ((v (second (head d))))\n             (and (IsPair v) (is-Number (first v)) (is-Number (second v))))\n           (AllValsNumericPair (tail d)))))",
      "basic_structure": "",
      "inputs": "(declare-const students Value)\n(declare-const h Value)\n(declare-const w Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsDict students))",
        "assert_1": "(define-fun C1 () Bool (AllKeysStr students))",
        "assert_2": "(define-fun C2 () Bool (AllValsPair students))",
        "assert_3": "(define-fun C3 () Bool (AllValLen2 students))",
        "assert_4": "(define-fun C4 () Bool (AllValsNumericPair students))",
        "assert_5": "(define-fun C5 () Bool (is-Number h))",
        "assert_6": "(define-fun C6 () Bool (is-Number w))",
        "assert_7": "(define-fun C7 () Bool (and (is-Number h) (>= (SafeReal h) 0.0)))",
        "assert_8": "(define-fun C8 () Bool (and (is-Number w) (>= (SafeReal w) 0.0)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(students, dict), \"invalid inputs",
        "assert_1": "assert all(isinstance(x, str) for x in students.keys()), \"invalid inputs",
        "assert_2": "assert all(isinstance(x, tuple) for x in students.values()), \"invalid inputs",
        "assert_3": "assert all(len(x) == 2 for x in students.values()), \"invalid inputs",
        "assert_4": "assert all(isinstance(height, (int, float)) and isinstance(weight, (int, float)) for height, weight in students.values())",
        "assert_5": "assert isinstance(h, (int, float)), \"invalid inputs",
        "assert_6": "assert isinstance(w, (int, float)), \"invalid inputs",
        "assert_7": "assert h >= 0, \"invalid inputs",
        "assert_8": "assert w >= 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/723": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec ListLen ((v Value)) Int\n  (ite (is-Nil v)\n       0\n       (ite (is-Cons v)\n            (+ 1 (ListLen (tail v)))\n            0)))\n\n(define-fun SameType ((v1 Value) (v2 Value)) Bool\n  (or (and (is-IntVal v1)   (is-IntVal v2))\n      (and (is-FloatVal v1) (is-FloatVal v2))\n      (and (is-StrVal v1)   (is-StrVal v2))\n      (and (is-BoolVal v1)  (is-BoolVal v2))\n      (and (is-Nil v1)      (is-Nil v2))\n      (and (is-Cons v1)     (is-Cons v2))))\n\n(define-fun-rec AllSameTypeIndices ((l1 Value) (l2 Value)) Bool\n  (ite (and (is-Nil l1) (is-Nil l2))\n       true\n       (ite (and (is-Cons l1) (is-Cons l2))\n            (and (SameType (head l1) (head l2))\n                 (AllSameTypeIndices (tail l1) (tail l2)))\n            false)))",
      "basic_structure": "",
      "inputs": "(declare-const nums1 Value)\n(declare-const nums2 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList nums1))",
        "assert_1": "(define-fun C1 () Bool (IsList nums2))",
        "assert_2": "(define-fun C2 () Bool (= (ListLen nums1) (ListLen nums2)))",
        "assert_3": "(define-fun C3 () Bool (AllSameTypeIndices nums1 nums2))"
      },
      "constraints": {
        "assert_0": "assert isinstance(nums1, list), \"invalid inputs",
        "assert_1": "assert isinstance(nums2, list), \"invalid inputs",
        "assert_2": "assert len(nums1) == len(nums2), \"invalid inputs",
        "assert_3": "assert all(hasattr(a, '__eq__') and isinstance(a, type(b)) for a, b in zip(nums1, nums2)), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/724": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeIval ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
      "basic_structure": "",
      "inputs": "(declare-const base Value)\n(declare-const power Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal base))",
        "assert_1": "(define-fun C1 () Bool (>= (SafeIval base) 0))",
        "assert_2": "(define-fun C2 () Bool (is-IntVal power))"
      },
      "constraints": {
        "assert_0": "assert isinstance(base, int), \"invalid inputs",
        "assert_1": "assert base >= 0, \"invalid inputs",
        "assert_2": "assert isinstance(power, int), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/725": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeS ((v Value)) String (ite (is-StrVal v) (sval v) \"\"))",
      "basic_structure": "",
      "inputs": "(declare-const text1 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal text1))"
      },
      "constraints": {
        "assert_0": "assert isinstance(text1, str), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/726": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec list_all_numeric ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (or (is-IntVal (head v)) (is-FloatVal (head v)))\n                 (list_all_numeric (tail v)))\n            false)))",
      "basic_structure": "(assert (IsList test_tup))",
      "inputs": "(declare-const test_tup Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList test_tup))",
        "assert_1": "(define-fun C1 () Bool (list_all_numeric test_tup))"
      },
      "constraints": {
        "assert_0": "assert isinstance(test_tup, tuple), \"invalid inputs",
        "assert_1": "assert all(isinstance(x, (int, float)) for x in test_tup), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/728": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((lst Value)) Bool\n  (or (is-Nil lst)\n      (and (is-Cons lst)\n           (IsList (tail lst)))))\n\n(define-fun-rec length ((lst Value)) Int\n  (ite (is-Nil lst) 0\n       (ite (is-Cons lst)\n            (+ 1 (length (tail lst)))\n            0)))",
      "basic_structure": "(assert (IsList lst1))\n(assert (IsList lst2))",
      "inputs": "(declare-const lst1 Value)\n(declare-const lst2 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList lst1))",
        "assert_1": "(define-fun C1 () Bool (IsList lst2))",
        "assert_2": "(define-fun C2 () Bool (= (length lst1) (length lst2)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(lst1, list), \"invalid inputs",
        "assert_1": "assert isinstance(lst2, list), \"invalid inputs",
        "assert_2": "assert len(lst1) == len(lst2), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/730": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (IsList (tail l))\n            false)))",
      "basic_structure": "(assert (IsList nums))",
      "inputs": "(declare-const nums Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList nums))"
      },
      "constraints": {
        "assert_0": "assert isinstance(nums, list), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/731": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun is-numeric ((v Value)) Bool\n  (or (is-IntVal v) (is-FloatVal v)))\n\n(define-fun value-to-real ((v Value)) Real\n  (ite (is-IntVal v)\n       (to_real (ival v))\n       (ite (is-FloatVal v)\n            (fval v)\n            0)))",
      "basic_structure": "",
      "inputs": "(declare-const r Value)\n(declare-const h Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-numeric r))",
        "assert_1": "(define-fun C1 () Bool (is-numeric h))",
        "assert_2": "(define-fun C2 () Bool (> (value-to-real r) 0))",
        "assert_3": "(define-fun C3 () Bool (> (value-to-real h) 0))"
      },
      "constraints": {
        "assert_0": "assert isinstance(r, (int, float)), \"invalid inputs",
        "assert_1": "assert isinstance(h, (int, float)), \"invalid inputs",
        "assert_2": "assert r > 0, \"invalid inputs",
        "assert_3": "assert h > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/732": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const text Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal text))"
      },
      "constraints": {
        "assert_0": "assert isinstance(text, str), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/733": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec isList ((l Value)) Bool\n  (ite (is-Nil l) true\n    (ite (is-Cons l) (isList (tail l)) false)))\n\n(define-fun-rec list_all_numeric ((l Value)) Bool\n  (ite (is-Nil l) true\n    (ite (is-Cons l)\n      (let ((h (head l)) (t (tail l)))\n        (and (or (is-IntVal h) (is-FloatVal h))\n             (list_all_numeric t)))\n      false)))\n\n(define-fun-rec list_sorted ((l Value)) Bool\n  (ite (is-Nil l) true\n    (ite (is-Cons l)\n      (let ((h1 (head l)) (rest1 (tail l)))\n        (ite (is-Cons rest1)\n          (let ((h2 (head rest1)))\n            (and (let ((v1 (ite (is-IntVal h1) (to_real (ival h1)) (fval h1)))\n                       (v2 (ite (is-IntVal h2) (to_real (ival h2)) (fval h2))))\n                   (<= v1 v2))\n                 (list_sorted rest1)))\n          true))\n      false)))\n\n(define-fun-rec list_contains ((l Value) (x Value)) Bool\n  (ite (is-Nil l) false\n    (ite (is-Cons l)\n      (let ((h (head l)) (t (tail l)))\n        (ite (is-IntVal h)\n          (ite (= (ival h) (ival x)) true (list_contains t x))\n          (ite (is-FloatVal h)\n            (ite (= (fval h) (to_real (ival x))) true (list_contains t x))\n            (list_contains t x))))\n      false)))",
      "basic_structure": "(assert (isList A))\n(assert (is-IntVal x))",
      "inputs": "(declare-const A Value)\n(declare-const x Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (isList A))",
        "assert_1": "(define-fun C1 () Bool (list_all_numeric A))",
        "assert_2": "(define-fun C2 () Bool (list_sorted A))",
        "assert_3": "(define-fun C3 () Bool (list_contains A x))",
        "assert_4": "(define-fun C4 () Bool (is-IntVal x))"
      },
      "constraints": {
        "assert_0": "assert isinstance(A, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(a, (int, float)) for a in A), \"invalid inputs",
        "assert_2": "assert all(a <= b for a, b in zip(A, A[1:])), \"invalid inputs",
        "assert_3": "assert x in A, \"invalid inputs",
        "assert_4": "assert isinstance(x, int), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/734": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec length ((l Value)) Int\n  (ite (is-Nil l)\n       0\n       (+ 1 (length (tail l)))))\n\n(define-fun-rec list_all_numeric ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (let ((h (head l)))\n              (ite (or (is-IntVal h) (is-FloatVal h))\n                   (list_all_numeric (tail l))\n                   false))\n            false)))",
      "basic_structure": "(assert (IsList arr))\n(assert (list_all_numeric arr))",
      "inputs": "(declare-const arr Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList arr))",
        "assert_1": "(define-fun C1 () Bool (> (length arr) 0))",
        "assert_2": "(define-fun C2 () Bool (list_all_numeric arr))"
      },
      "constraints": {
        "assert_0": "assert isinstance(arr, list), \"invalid inputs",
        "assert_1": "assert len(arr) > 0, \"invalid inputs",
        "assert_2": "assert all(isinstance(x, (int, float)) for x in arr), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/735": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
        "assert_1": "(define-fun C1 () Bool (and (is-IntVal n) (>= (ival n) 0)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(n, int), \"invalid inputs",
        "assert_1": "assert n >= 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/736": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (or (is-Nil v) (and (is-Cons v) (IsList (tail v)))))\n\n(define-fun value_to_real ((v Value)) Real\n  (ite (is-IntVal v) (to_real (ival v)) (ite (is-FloatVal v) (fval v) 0.0)))\n\n(define-fun-rec list_all_numeric ((lst Value)) Bool\n  (or (is-Nil lst) (and (or (is-IntVal (head lst)) (is-FloatVal (head lst))) (list_all_numeric (tail lst)))))\n\n(define-fun-rec list_sorted ((lst Value)) Bool\n  (or (is-Nil lst)\n      (and (is-Cons lst)\n           (or (is-Nil (tail lst))\n               (and (<= (value_to_real (head lst)) (value_to_real (head (tail lst))))\n                    (list_sorted (tail lst)))))))",
      "basic_structure": "(assert (IsList a))",
      "inputs": "(declare-const a Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList a))",
        "assert_1": "(define-fun C1 () Bool (list_sorted a))",
        "assert_2": "(define-fun C2 () Bool (list_all_numeric a))"
      },
      "constraints": {
        "assert_0": "assert isinstance(a, list), \"invalid inputs",
        "assert_1": "assert all(x <= y for x, y in zip(a, a[1:])), \"invalid inputs",
        "assert_2": "assert all(isinstance(x, (int, float)) for x in a), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/737": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const string Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal string))"
      },
      "constraints": {
        "assert_0": "assert isinstance(string, str), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/739": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
        "assert_1": "(define-fun C1 () Bool (ite (is-IntVal n) (>= (ival n) 1) false))"
      },
      "constraints": {
        "assert_0": "assert isinstance(n, int), \"invalid inputs",
        "assert_1": "assert n >= 1, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/740": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (or (is-Nil v)\n      (and (is-Cons v) (IsList (tail v)))))\n\n(define-fun-rec length ((v Value)) Int\n  (ite (is-Nil v)\n       0\n       (ite (is-Cons v)\n            (+ 1 (length (tail v)))\n            0)))",
      "basic_structure": "(assert (IsList test_tup))",
      "inputs": "(declare-const test_tup Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList test_tup))",
        "assert_1": "(define-fun C1 () Bool (= (mod (length test_tup) 2) 0))"
      },
      "constraints": {
        "assert_0": "assert isinstance(test_tup, tuple), \"invalid inputs",
        "assert_1": "assert len(test_tup) % 2 == 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/741": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeCharAt ((v Value) (i Int)) String\n  (ite (and (is-StrVal v) (<= 0 i) (< i (str.len (sval v))))\n       (str.at (sval v) i)\n       \"\"))\n(define-fun SafeStrSub ((v Value) (start Int)) String\n  (ite (and (is-StrVal v)\n            (<= 0 start)\n            (<= start (str.len (sval v))))\n       (str.substr (sval v) start (- (str.len (sval v)) start))\n       \"\"))",
      "basic_structure": "(let ((s0 (SafeCharAt s 0))\n      (restStr (SafeStrSub s 1)))\n  true)",
      "inputs": "(declare-const s Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal s))"
      },
      "constraints": {
        "assert_0": "assert isinstance(s, str), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/742": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun isNumeric ((v Value)) Bool\n  (or (is-IntVal v) (is-FloatVal v)))\n\n(define-fun safe_to_real ((v Value)) Real\n  (ite (is-IntVal v) (to_real (ival v))\n    (ite (is-FloatVal v) (fval v) 0.0)))",
      "basic_structure": "(assert true)",
      "inputs": "(declare-const side Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (or (is-IntVal side) (is-FloatVal side)))",
        "assert_1": "(define-fun C1 () Bool\n  (> (safe_to_real side) 0))"
      },
      "constraints": {
        "assert_0": "assert isinstance(side, (int, float)), \"invalid inputs",
        "assert_1": "assert side > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/743": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((l Value)) Bool (ite (is-Nil l) true (ite (is-Cons l) (IsList (tail l)) false)))\n(define-fun-rec length ((l Value)) Int (ite (is-Nil l) 0 (ite (is-Cons l) (+ 1 (length (tail l))) 0)))",
      "basic_structure": "",
      "inputs": "(declare-const l Value)\n(declare-const m Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList l))",
        "assert_1": "(define-fun C1 () Bool (is-IntVal m))",
        "assert_2": "(define-fun C2 () Bool (let ((m_int (ite (is-IntVal m) (ival m) 0)) (len_l (length l))) (and (is-IntVal m) (<= 0 m_int) (<= m_int len_l))))"
      },
      "constraints": {
        "assert_0": "assert isinstance(l, list), \"invalid inputs",
        "assert_1": "assert isinstance(m, int), \"invalid inputs",
        "assert_2": "assert 0 <= m <= len(l), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/744": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))",
      "basic_structure": "",
      "inputs": "(declare-const test_tup Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList test_tup))"
      },
      "constraints": {
        "assert_0": "assert isinstance(test_tup, tuple), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/745": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
      "basic_structure": "",
      "inputs": "(declare-const startnum Value)\n(declare-const endnum Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal startnum))",
        "assert_1": "(define-fun C1 () Bool (is-IntVal endnum))",
        "assert_2": "(define-fun C2 () Bool (<= (SafeI startnum) (SafeI endnum)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(startnum, int), \"invalid inputs",
        "assert_1": "assert isinstance(endnum, int), \"invalid inputs",
        "assert_2": "assert startnum <= endnum, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/748": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeS ((v Value)) String\n  (ite (is-StrVal v) (sval v) \"\"))",
      "basic_structure": "(assert (is-StrVal str1))",
      "inputs": "(declare-const str1 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (is-StrVal str1))"
      },
      "constraints": {
        "assert_0": "assert isinstance(str1, str), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/749": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun isList ((v Value)) Bool (or (is-Nil v) (is-Cons v)))\n(define-fun check_numeric ((s Value)) Bool (and (is-StrVal s)\n                                        (str.in.re (sval s)\n                                                   (re.++ (re.* (str.to.re \"-\"))\n                                                         (re.+ (re.range \"0\" \"9\"))\n                                                         (re.* (str.to.re \" \"))))))\n(define-fun-rec list_all_str ((lst Value)) Bool\n  (ite (is-Nil lst)\n       true\n       (ite (is-Cons lst)\n            (and (is-StrVal (head lst)) (list_all_str (tail lst)))\n            false)))\n(define-fun-rec list_all_num_str ((lst Value)) Bool\n  (ite (is-Nil lst)\n       true\n       (ite (is-Cons lst)\n            (and (check_numeric (head lst)) (list_all_num_str (tail lst)))\n            false)))",
      "basic_structure": "(assert (isList nums_str))",
      "inputs": "(declare-const nums_str Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (isList nums_str))",
        "assert_1": "(define-fun C1 () Bool (list_all_str nums_str))",
        "assert_2": "(define-fun C2 () Bool (list_all_num_str nums_str))"
      },
      "constraints": {
        "assert_0": "assert isinstance(nums_str, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(x, str) for x in nums_str), \"invalid inputs",
        "assert_2": "assert all(check_numeric(num) for num in nums_str), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/750": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))",
      "basic_structure": "(assert (IsList test_list))",
      "inputs": "(declare-const test_list Value)\n(declare-const test_tup Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList test_list))",
        "assert_1": "(define-fun C1 () Bool (IsList test_tup))"
      },
      "constraints": {
        "assert_0": "assert isinstance(test_list, list), \"invalid inputs",
        "assert_1": "assert isinstance(test_tup, tuple), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/751": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (let ((hd (head v))\n                  (tl (tail v)))\n              (IsList tl))\n            false)))\n\n(define-fun-rec list_all_int ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (let ((hd (head v))\n                  (tl (tail v)))\n              (and (is-IntVal hd)\n                   (list_all_int tl)))\n            false)))",
      "basic_structure": "",
      "inputs": "(declare-const arr Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (IsList arr))",
        "assert_1": "(define-fun C1 () Bool\n  (list_all_int arr))"
      },
      "constraints": {
        "assert_0": "assert isinstance(arr, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(x, int) for x in arr), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/752": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
        "assert_1": "(define-fun C1 () Bool (and (is-IntVal n) (>= (ival n) 0)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(n, int), \"invalid inputs",
        "assert_1": "assert n >= 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/753": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (or (is-Nil l) (and (is-Cons l) (IsList (tail l)))))\n\n(define-fun isNumericVal ((v Value)) Bool\n  (or (is-IntVal v) (is-FloatVal v)))\n\n; all elements are sequences (we'll cast to Python tuples on reconstruction)\n(define-fun-rec AllSeq ((l Value)) Bool\n  (or (is-Nil l) (and (is-Cons l) (IsList (head l)) (AllSeq (tail l)))))\n\n; check that each element has a numeric second item (index 1)\n(define-fun-rec AllSecondNumeric ((l Value)) Bool\n  (or (is-Nil l)\n      (and (is-Cons l)\n           (IsList (head l))\n           (is-Cons (tail (head l)))\n           (isNumericVal (head (tail (head l))))\n           (AllSecondNumeric (tail l)))))\n\n(define-fun-rec length ((l Value)) Int\n  (ite (is-Nil l) 0 (ite (is-Cons l) (+ 1 (length (tail l))) 0)))",
      "basic_structure": "",
      "inputs": "(declare-const test_list Value)\n(declare-const K Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList test_list))",
        "assert_1": "(define-fun C1 () Bool (AllSeq test_list))",
        "assert_2": "(define-fun C2 () Bool (AllSecondNumeric test_list))",
        "assert_3": "(define-fun C3 () Bool (and (is-IntVal K) (<= (ival K) (length test_list))))"
      },
      "constraints": {
        "assert_0": "assert isinstance(test_list, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(x, tuple) for x in test_list), \"invalid inputs",
        "assert_2": "assert all(isinstance(x[1], (int, float)) for x in test_list), \"invalid inputs",
        "assert_3": "assert K <= len(test_list), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/754": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (or (is-Nil v)\n      (and (is-Cons v)\n           (IsList (tail v)))))",
      "basic_structure": "",
      "inputs": "(declare-const l1 Value)\n(declare-const l2 Value)\n(declare-const l3 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList l1))",
        "assert_1": "(define-fun C1 () Bool (IsList l2))",
        "assert_2": "(define-fun C2 () Bool (IsList l3))"
      },
      "constraints": {
        "assert_0": "assert isinstance(l1, list), \"invalid inputs",
        "assert_1": "assert isinstance(l2, list), \"invalid inputs",
        "assert_2": "assert isinstance(l3, list), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/755": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec list_all_numeric ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (or (is-IntVal (head v)) (is-FloatVal (head v)))\n                 (list_all_numeric (tail v)))\n            false)))",
      "basic_structure": "(assert (IsList numbers))",
      "inputs": "(declare-const numbers Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList numbers))",
        "assert_1": "(define-fun C1 () Bool (list_all_numeric numbers))"
      },
      "constraints": {
        "assert_0": "assert isinstance(numbers, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(i, (int, float)) for i in numbers), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/757": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec list_all_str ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (is-StrVal (head v))\n                 (list_all_str (tail v)))\n            false)))",
      "basic_structure": "(assert (IsList test_list))",
      "inputs": "(declare-const test_list Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList test_list))",
        "assert_1": "(define-fun C1 () Bool (list_all_str test_list))"
      },
      "constraints": {
        "assert_0": "assert isinstance(test_list, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(x, str) for x in test_list), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/758": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (or (is-Nil v)\n      (and (is-Cons v)\n           (IsList (tail v)))))\n\n(define-fun-rec AllLists ((l Value)) Bool\n  (or (is-Nil l)\n      (and (is-Cons l)\n           (IsList (head l))\n           (AllLists (tail l)))))\n\n(define-fun-rec AllAtomic ((l Value)) Bool\n  (or (is-Nil l)\n      (and (is-Cons l)\n           (or (is-IntVal (head l))\n               (is-FloatVal (head l))\n               (is-StrVal (head l))\n               (is-BoolVal (head l)))\n           (AllAtomic (tail l)))))\n\n(define-fun-rec AllHashableLists ((l Value)) Bool\n  (or (is-Nil l)\n      (and (is-Cons l)\n           (AllAtomic (head l))\n           (AllHashableLists (tail l)))))",
      "basic_structure": "(assert (IsList list1))",
      "inputs": "(declare-const list1 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList list1))",
        "assert_1": "(define-fun C1 () Bool (AllLists list1))",
        "assert_2": "(define-fun C2 () Bool (AllHashableLists list1))"
      },
      "constraints": {
        "assert_0": "assert isinstance(list1, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(x, list) for x in list1), \"invalid inputs",
        "assert_2": "assert all(is_hashable(tuple(x)) for x in list1), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/759": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const num Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal num))"
      },
      "constraints": {
        "assert_0": "assert isinstance(num, str), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/760": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n(define-fun-rec length ((v Value)) Int\n  (ite (is-Nil v)\n       0\n       (ite (is-Cons v)\n            (+ 1 (length (tail v)))\n            0)))",
      "basic_structure": "(assert (IsList arr))",
      "inputs": "(declare-const arr Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList arr))",
        "assert_1": "(define-fun C1 () Bool (> (length arr) 0))"
      },
      "constraints": {
        "assert_0": "assert isinstance(arr, list), \"invalid inputs",
        "assert_1": "assert len(arr) > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/762": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun getInt ((v Value)) Int\n  (ite (is-IntVal v) (ival v) 0))",
      "basic_structure": "",
      "inputs": "(declare-const monthnum3 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (is-IntVal monthnum3))",
        "assert_1": "(define-fun C1 () Bool\n  (and (>= (getInt monthnum3) 1)\n       (<= (getInt monthnum3) 12)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(monthnum3, int), \"invalid inputs",
        "assert_1": "assert 1 <= monthnum3 <= 12, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/763": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v) true\n    (ite (is-Cons v)\n      (IsList (tail v))\n      false)))\n\n(define-fun-rec list_length ((v Value)) Int\n  (ite (is-Nil v) 0\n    (ite (is-Cons v)\n      (+ 1 (list_length (tail v)))\n      0)))\n\n(define-fun-rec list_all_numeric ((v Value)) Bool\n  (ite (is-Nil v) true\n    (ite (is-Cons v)\n      (and (or (is-IntVal (head v)) (is-FloatVal (head v)))\n           (list_all_numeric (tail v)))\n      false)))",
      "basic_structure": "(assert (IsList arr))\n(assert (is-IntVal n))",
      "inputs": "(declare-const arr Value)\n(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList arr))",
        "assert_1": "(define-fun C1 () Bool (list_all_numeric arr))",
        "assert_2": "(define-fun C2 () Bool (is-IntVal n))",
        "assert_3": "(define-fun C3 () Bool (and (is-IntVal n) (= (ival n) (list_length arr))))"
      },
      "constraints": {
        "assert_0": "assert isinstance(arr, tuple), \"invalid inputs",
        "assert_1": "assert all(isinstance(x, (int, float)) for x in arr), \"invalid inputs",
        "assert_2": "assert isinstance(n, int), \"invalid inputs",
        "assert_3": "assert n == len(arr), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/764": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const s Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal s))"
      },
      "constraints": {
        "assert_0": "assert isinstance(s, str), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/765": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeIval ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
      "basic_structure": "",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
        "assert_1": "(define-fun C1 () Bool (ite (is-IntVal n) (>= (ival n) 1) false))"
      },
      "constraints": {
        "assert_0": "assert isinstance(n, int), \"invalid inputs",
        "assert_1": "assert n >= 1, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/766": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((x Value)) Bool (ite (is-Nil x) true (ite (is-Cons x) (IsList (tail x)) false)))",
      "basic_structure": "(assert (IsList l1))",
      "inputs": "(declare-const l1 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList l1))"
      },
      "constraints": {
        "assert_0": "assert isinstance(l1, list), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/767": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec isList ((l Value)) Bool\n  (or\n    (is-Nil l)\n    (and\n      (is-Cons l)\n      (let ((t (tail l)))\n        (isList t)))))\n\n(define-fun-rec list_all_numeric ((l Value)) Bool\n  (ite\n    (is-Nil l)\n    true\n    (and\n      (is-Cons l)\n      (let ((h (head l)) (t (tail l)))\n        (and\n          (or (is-IntVal h) (is-FloatVal h))\n          (list_all_numeric t))))))",
      "basic_structure": "(assert (isList arr))",
      "inputs": "(declare-const arr Value)\n(declare-const sum_ Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (isList arr))",
        "assert_1": "(define-fun C1 () Bool (list_all_numeric arr))",
        "assert_2": "(define-fun C2 () Bool (or (is-IntVal sum_) (is-FloatVal sum_)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(arr, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(x, (int, float)) for x in arr), \"invalid inputs",
        "assert_2": "assert isinstance(sum_, (int, float)), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/769": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (or (is-Nil v)\n      (and (is-Cons v)\n           (let ((tl (tail v)))\n             (IsList tl)))))",
      "basic_structure": "",
      "inputs": "(declare-const li1 Value)\n(declare-const li2 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList li1))",
        "assert_1": "(define-fun C1 () Bool (IsList li2))"
      },
      "constraints": {
        "assert_0": "assert isinstance(li1, list), \"invalid inputs",
        "assert_1": "assert isinstance(li2, list), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/770": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
      "basic_structure": "",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
        "assert_1": "(define-fun C1 () Bool (>= (SafeI n) 1))"
      },
      "constraints": {
        "assert_0": "assert isinstance(n, int), \"invalid inputs",
        "assert_1": "assert n >= 1, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/771": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeS ((v Value)) String\n  (ite (is-StrVal v) (sval v) \"\"))",
      "basic_structure": "(assert true)",
      "inputs": "(declare-const exp Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (is-StrVal exp))"
      },
      "constraints": {
        "assert_0": "assert isinstance(exp, str), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/772": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "(assert (is-StrVal test_str))\n(assert (is-IntVal K))",
      "inputs": "(declare-const test_str Value)\n(declare-const K Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal test_str))",
        "assert_1": "(define-fun C1 () Bool (is-IntVal K))"
      },
      "constraints": {
        "assert_0": "assert isinstance(test_str, str), \"invalid inputs",
        "assert_1": "assert isinstance(K, int), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/773": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeS ((v Value)) String (ite (is-StrVal v) (sval v) \"\"))",
      "basic_structure": "(assert (is-StrVal text))\n(assert (is-StrVal pattern))",
      "inputs": "(declare-const text Value)\n(declare-const pattern Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal text))",
        "assert_1": "(define-fun C1 () Bool (is-StrVal pattern))"
      },
      "constraints": {
        "assert_0": "assert isinstance(text, str), \"invalid inputs",
        "assert_1": "assert isinstance(pattern, str), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/775": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (or (is-Nil v)\n      (and (is-Cons v) (IsList (tail v)))))\n\n(define-fun-rec list_all_int ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (and (is-Cons v)\n            (let ((h (head v)) (t (tail v)))\n              (and (is-IntVal h)\n                   (list_all_int t))))))",
      "basic_structure": "(assert (IsList nums))",
      "inputs": "(declare-const nums Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList nums))",
        "assert_1": "(define-fun C1 () Bool (list_all_int nums))"
      },
      "constraints": {
        "assert_0": "assert isinstance(nums, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(n, int) for n in nums), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/777": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v) true\n    (ite (is-Cons v) (IsList (tail v)) false)))\n\n(define-fun IsNumeric ((v Value)) Bool\n  (or (is-IntVal v) (is-FloatVal v)))\n\n(define-fun-rec list_all_numeric ((lst Value)) Bool\n  (ite (is-Nil lst) true\n    (ite (is-Cons lst)\n      (and (IsNumeric (head lst)) (list_all_numeric (tail lst)))\n      false)))",
      "basic_structure": "(assert (IsList arr))",
      "inputs": "(declare-const arr Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList arr))",
        "assert_1": "(define-fun C1 () Bool (list_all_numeric arr))"
      },
      "constraints": {
        "assert_0": "assert isinstance(arr, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(x, (int, float)) for x in arr), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/778": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (or (is-Nil v)\n      (and (is-Cons v)\n           (IsList (tail v)))))",
      "basic_structure": "(assert (IsList list1))",
      "inputs": "(declare-const list1 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList list1))"
      },
      "constraints": {
        "assert_0": "assert isinstance(list1, list), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/780": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool (ite (is-Nil v) true (ite (is-Cons v) (IsList (tail v)) false)))\n(define-fun-rec list_length ((v Value)) Int (ite (is-Nil v) 0 (ite (is-Cons v) (+ 1 (list_length (tail v))) 0)))\n(define-fun-rec AllSeq ((lst Value)) Bool (ite (is-Nil lst) true (ite (is-Cons lst) (and (IsList (head lst)) (AllSeq (tail lst))) false)))\n(define-fun-rec all_same_length ((lst Value) (base_len Int)) Bool (ite (is-Nil lst) true (ite (is-Cons lst) (and (IsList (head lst)) (= (list_length (head lst)) base_len) (all_same_length (tail lst) base_len)) false)))\n(define-fun-rec all_numeric ((lst Value)) Bool (ite (is-Nil lst) true (ite (is-Cons lst) (and (or (is-IntVal (head lst)) (is-FloatVal (head lst))) (all_numeric (tail lst))) false)))\n(define-fun-rec all_numeric_tuples ((lst Value)) Bool (ite (is-Nil lst) true (ite (is-Cons lst) (and (IsList (head lst)) (all_numeric (head lst)) (all_numeric_tuples (tail lst))) false)))",
      "basic_structure": "(assert (IsList test_list))",
      "inputs": "(declare-const test_list Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList test_list))",
        "assert_1": "(define-fun C1 () Bool (> (list_length test_list) 0))",
        "assert_2": "(define-fun C2 () Bool (AllSeq test_list))",
        "assert_3": "(define-fun C3 () Bool (all_same_length test_list (ite (is-Cons test_list) (list_length (head test_list)) 0)))",
        "assert_4": "(define-fun C4 () Bool (all_numeric_tuples test_list))"
      },
      "constraints": {
        "assert_0": "assert isinstance(test_list, list), \"invalid inputs",
        "assert_1": "assert len(test_list) > 0, \"invalid inputs",
        "assert_2": "assert all(isinstance(t, tuple) for t in test_list), \"invalid inputs",
        "assert_3": "assert all(len(t) == len(test_list[0]) for t in test_list), \"invalid inputs\" ))",
        "assert_4": "assert all(isinstance(x, (int, float)) for t in test_list for x in t), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/781": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun safe-ival ((v Value)) Int\n  (ite (is-IntVal v) (ival v) 0))",
      "basic_structure": "",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
        "assert_1": "(define-fun C1 () Bool (and (is-IntVal n) (> (ival n) 0)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(n, int), \"invalid inputs",
        "assert_1": "assert n > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/782": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (ite (is-Nil l)\n    true\n    (ite (is-Cons l)\n      (IsList (tail l))\n      false)))\n\n(define-fun IsNumeric ((v Value)) Bool\n  (or (is-IntVal v) (is-FloatVal v)))\n\n(define-fun-rec list_all_numeric ((l Value)) Bool\n  (ite (is-Nil l)\n    true\n    (ite (is-Cons l)\n      (and (IsNumeric (head l))\n           (list_all_numeric (tail l)))\n      false)))",
      "basic_structure": "",
      "inputs": "(declare-const arr Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList arr))",
        "assert_1": "(define-fun C1 () Bool (list_all_numeric arr))"
      },
      "constraints": {
        "assert_0": "assert isinstance(arr, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(x, (int, float)) for x in arr), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/784": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (IsList (tail l))\n            false)))\n\n(define-fun-rec list_all_numeric ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (and (or (is-IntVal (head l)) (is-FloatVal (head l)))\n                 (list_all_numeric (tail l)))\n            false)))\n\n(define-fun-rec list_any_even ((l Value)) Bool\n  (ite (is-Nil l)\n       false\n       (ite (is-Cons l)\n            (let ((h (head l)))\n              (ite (and (is-IntVal h)\n                       (= (mod (ival h) 2) 0))\n                   true\n                   (list_any_even (tail l))))\n            false)))\n\n(define-fun-rec list_any_odd ((l Value)) Bool\n  (ite (is-Nil l)\n       false\n       (ite (is-Cons l)\n            (let ((h (head l)))\n              (ite (and (is-IntVal h)\n                       (= (mod (ival h) 2) 1))\n                   true\n                   (list_any_odd (tail l))))\n            false)))",
      "basic_structure": "(assert (IsList list1))",
      "inputs": "(declare-const list1 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList list1))",
        "assert_1": "(define-fun C1 () Bool (list_any_even list1))",
        "assert_2": "(define-fun C2 () Bool (list_any_odd list1))",
        "assert_3": "(define-fun C3 () Bool (list_all_numeric list1))"
      },
      "constraints": {
        "assert_0": "assert isinstance(list1, list), \"invalid inputs",
        "assert_1": "assert any(x % 2 == 0 for x in list1), \"invalid inputs",
        "assert_2": "assert any(x % 2 != 0 for x in list1), \"invalid inputs",
        "assert_3": "assert all(isinstance(x, (int, float)) for x in list1), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/785": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeStr ((v Value)) String (ite (is-StrVal v) (sval v) \"\"))\n\n(define-fun-rec replace_all ((s String) (target String) (rep String)) String\n  (ite (str.contains s target)\n       (let ((idx (str.indexof s target 0)))\n         (let ((pre  (str.substr s 0 idx))\n               (post (str.substr s (+ idx (str.len target)) (- (str.len s) (+ idx (str.len target))))))\n           (str.++ pre rep (replace_all post target rep))))\n       s))\n\n(define-fun is_digit_string ((s String)) Bool (str.in.re s (re.+ (re.range \"0\" \"9\"))))",
      "basic_structure": "",
      "inputs": "(declare-const test_str Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal test_str))",
        "assert_1": "(define-fun C1 () Bool (and (is-StrVal test_str) (str.prefixof \"(\" (SafeStr test_str))))",
        "assert_2": "(define-fun C2 () Bool (and (is-StrVal test_str) (str.suffixof \")\" (SafeStr test_str))))",
        "assert_3": "(define-fun C3 () Bool\n  (let ((s0 (SafeStr test_str)))\n    (let ((inner (ite (and (str.prefixof \"(\" s0) (str.suffixof \")\" s0))\n                       (str.substr s0 1 (- (str.len s0) 2))\n                       \"\")))\n      (let ((s1 (replace_all inner \"...\" \"\")))\n        (let ((s2 (replace_all s1 \",\" \"\")))\n          (let ((s3 (replace_all s2 \" \" \"\")))\n            (is_digit_string s3)))))))"
      },
      "constraints": {
        "assert_0": "assert isinstance(test_str, str), \"invalid inputs",
        "assert_1": "assert test_str.startswith('('), \"invalid inputs",
        "assert_2": "assert test_str.endswith(')'), \"invalid inputs",
        "assert_3": "assert test_str.lstrip('(').rstrip(')').replace('...', '').replace(',', '').replace(' ', '').isdigit(), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/786": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec list_all_numeric ((lst Value)) Bool\n  (ite (is-Nil lst)\n       true\n       (ite (is-Cons lst)\n            (and (or (is-IntVal (head lst)) (is-FloatVal (head lst)))\n                 (list_all_numeric (tail lst)))\n            false)))",
      "basic_structure": "(assert (IsList a))",
      "inputs": "(declare-const a Value)\n(declare-const x Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList a))",
        "assert_1": "(define-fun C1 () Bool (list_all_numeric a))",
        "assert_2": "(define-fun C2 () Bool (or (is-IntVal x) (is-FloatVal x)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(a, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(item, (int, float)) for item in a), \"invalid inputs",
        "assert_2": "assert isinstance(x, (int, float)), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/787": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeS ((v Value)) String\n  (ite (is-StrVal v) (sval v) \"\"))",
      "basic_structure": "",
      "inputs": "(declare-const text Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (is-StrVal text))"
      },
      "constraints": {
        "assert_0": "assert isinstance(text, str), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/788": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((l Value)) Bool (ite (is-Nil l) true (ite (is-Cons l) (IsList (tail l)) false)))",
      "basic_structure": "",
      "inputs": "(declare-const test_list Value)\n(declare-const test_str Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList test_list))",
        "assert_1": "(define-fun C1 () Bool (is-StrVal test_str))"
      },
      "constraints": {
        "assert_0": "assert isinstance(test_list, list), \"invalid inputs",
        "assert_1": "assert isinstance(test_str, str), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/790": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun isNil ((v Value)) Bool (is-Nil v))\n(define-fun isCons ((v Value)) Bool (is-Cons v))\n(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n(define-fun-rec ListAllInt ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (is-IntVal (head v))\n                 (ListAllInt (tail v)))\n            false)))\n(define-fun-rec ListAllEven ((v Value) (idx Int)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (let ((h (head v)) (t (tail v)))\n              (ite (is-IntVal h)\n                   (and (= (mod (ival h) 2) (mod idx 2))\n                        (ListAllEven t (+ idx 1)))\n                   false))\n            false)))",
      "basic_structure": "(assert (IsList nums))",
      "inputs": "(declare-const nums Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList nums))",
        "assert_1": "(define-fun C1 () Bool (ListAllInt nums))"
      },
      "constraints": {
        "assert_0": "assert isinstance(nums, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(i, int) for i in nums), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/791": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))",
      "basic_structure": "(assert (IsList test_tup))",
      "inputs": "(declare-const test_tup Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList test_tup))"
      },
      "constraints": {
        "assert_0": "assert isinstance(test_tup, tuple), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/792": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (or (is-Nil v)\n      (and (is-Cons v)\n           (IsList (tail v)))))",
      "basic_structure": "",
      "inputs": "(declare-const input_list Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList input_list))"
      },
      "constraints": {
        "assert_0": "assert isinstance(input_list, list), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/793": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (or (is-Nil v)\n      (and (is-Cons v)\n           (IsList (tail v)))))\n\n(define-fun SafeReal ((v Value)) Real\n  (ite (is-IntVal v)\n       (to_real (ival v))\n       (ite (is-FloatVal v)\n            (fval v)\n            0)))\n\n(define-fun-rec list_all_numeric ((v Value)) Bool\n  (or (is-Nil v)\n      (and (is-Cons v)\n           (let ((h (head v)) (t (tail v)))\n             (and (or (is-IntVal h) (is-FloatVal h))\n                  (list_all_numeric t))))))\n\n(define-fun-rec list_sorted ((v Value)) Bool\n  (or (is-Nil v)\n      (and (is-Cons v)\n           (let ((t1 (tail v)))\n             (or (is-Nil t1)\n                 (and (is-Cons t1)\n                      (let ((h1 (head v)) (h2 (head t1)))\n                        (and (<= (SafeReal h1) (SafeReal h2))\n                             (list_sorted t1)))))))))\n\n(define-fun-rec Value_eq ((a Value) (b Value)) Bool\n  (or (and (is-IntVal a) (is-IntVal b) (= (ival a) (ival b)))\n      (and (is-FloatVal a) (is-FloatVal b) (= (fval a) (fval b)))))\n\n(define-fun-rec in_list ((v Value) (x Value)) Bool\n  (or (and (is-Cons v)\n           (let ((h (head v)) (t (tail v)))\n             (or (Value_eq h x)\n                 (in_list t x))))\n      false))",
      "basic_structure": "(assert (IsList arr))\n(assert (or (is-IntVal x) (is-FloatVal x)))",
      "inputs": "(declare-const arr Value)\n(declare-const x Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList arr))",
        "assert_1": "(define-fun C1 () Bool (list_all_numeric arr))",
        "assert_2": "(define-fun C2 () Bool (list_sorted arr))",
        "assert_3": "(define-fun C3 () Bool (or (is-IntVal x) (is-FloatVal x)))",
        "assert_4": "(define-fun C4 () Bool (in_list arr x))"
      },
      "constraints": {
        "assert_0": "assert isinstance(arr, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(i, (int, arr)) for i in arr), \"invalid inputs",
        "assert_2": "assert all(a <= b for a, b in zip(arr, arr[1:])), \"invalid inputs",
        "assert_3": "assert isinstance(x, (int, float)), \"invalid inputs",
        "assert_4": "assert x in arr, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/794": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeS ((v Value)) String (ite (is-StrVal v) (sval v) \"\"))",
      "basic_structure": "",
      "inputs": "(declare-const text Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal text))"
      },
      "constraints": {
        "assert_0": "assert isinstance(text, str), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/796": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun IsPair ((v Value)) Bool (and (is-Cons v) (is-Cons (tail v)) (is-Nil (tail (tail v)))))\n(define-fun first  ((p Value)) Value (head p))\n(define-fun second ((p Value)) Value (head (tail p)))\n\n(define-fun-rec IsDict ((v Value)) Bool\n  (or (is-Nil v) (and (is-Cons v) (IsPair (head v)) (IsDict (tail v)))))\n\n(define-fun isNumeric ((v Value)) Bool (or (is-IntVal v) (is-FloatVal v)))\n(define-fun-rec dict_all_numeric ((v Value)) Bool\n  (or (is-Nil v) (and (is-Cons v) (IsPair (head v)) (isNumeric (second (head v))) (dict_all_numeric (tail v)))))",
      "basic_structure": "(assert (IsDict d))",
      "inputs": "(declare-const d Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsDict d))",
        "assert_1": "(define-fun C1 () Bool (dict_all_numeric d))"
      },
      "constraints": {
        "assert_0": "assert isinstance(d, dict), \"invalid inputs",
        "assert_1": "assert all(isinstance(x, (int, float)) for x in d.values()), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/797": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "(assert true)",
      "inputs": "(declare-const l Value)\n(declare-const r Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal l))",
        "assert_1": "(define-fun C1 () Bool (is-IntVal r))",
        "assert_2": "(define-fun C2 () Bool (and (is-IntVal l) (is-IntVal r) (<= 0 (ival l)) (<= (ival l) (ival r))))"
      },
      "constraints": {
        "assert_0": "assert isinstance(l, int), \"invalid inputs",
        "assert_1": "assert isinstance(r, int), \"invalid inputs",
        "assert_2": "assert 0 <= l <= r, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/798": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun isList ((v Value)) Bool (or (is-Nil v) (is-Cons v)))\n(define-fun-rec list_all_numeric ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (let ((hd (head v)) (tl (tail v)))\n              (and (or (is-IntVal hd) (is-FloatVal hd))\n                   (list_all_numeric tl)))\n            false)))",
      "basic_structure": "(assert (isList arr))",
      "inputs": "(declare-const arr Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (isList arr))",
        "assert_1": "(define-fun C1 () Bool (list_all_numeric arr))"
      },
      "constraints": {
        "assert_0": "assert isinstance(arr, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(n, (int, float)) for n in arr), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/799": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeI ((v Value)) Int\n  (ite (is-IntVal v) (ival v) 0))",
      "basic_structure": "",
      "inputs": "(declare-const n Value)\n(declare-const d Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
        "assert_1": "(define-fun C1 () Bool (is-IntVal d))",
        "assert_2": "(define-fun C2 () Bool (and (>= (SafeI n) 0) (<= (SafeI n) 4294967295)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(n, int), \"invalid inputs",
        "assert_1": "assert isinstance(d, int), \"invalid inputs",
        "assert_2": "assert 0 <= n <= 0xffffffff, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/800": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const text Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal text))"
      },
      "constraints": {
        "assert_0": "assert isinstance(text, str), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/801": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const x Value)\n(declare-const y Value)\n(declare-const z Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal x))",
        "assert_1": "(define-fun C1 () Bool (is-IntVal y))",
        "assert_2": "(define-fun C2 () Bool (is-IntVal z))"
      },
      "constraints": {
        "assert_0": "assert isinstance(x, int), \"invalid inputs",
        "assert_1": "assert isinstance(y, int), \"invalid inputs",
        "assert_2": "assert isinstance(z, int), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/803": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))"
      },
      "constraints": {
        "assert_0": "assert isinstance(n, int), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/804": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v) true\n    (ite (is-Cons v) (IsList (tail v)) false)))\n\n(define-fun-rec length ((lst Value)) Int\n  (ite (is-Nil lst) 0\n    (ite (is-Cons lst) (+ 1 (length (tail lst))) 0)))\n\n(define-fun-rec ListAllInt ((lst Value)) Bool\n  (ite (is-Nil lst) true\n    (ite (is-Cons lst)\n         (and (is-IntVal (head lst)) (ListAllInt (tail lst)))\n         false)))",
      "basic_structure": "(assert (IsList arr))",
      "inputs": "(declare-const arr Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList arr))",
        "assert_1": "(define-fun C1 () Bool (> (length arr) 0))",
        "assert_2": "(define-fun C2 () Bool (ListAllInt arr))"
      },
      "constraints": {
        "assert_0": "assert isinstance(arr, list), \"invalid inputs",
        "assert_1": "assert len(arr) > 0, \"invalid inputs",
        "assert_2": "assert all(isinstance(x, int) for x in arr), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/805": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec ListP ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (ListP (tail l))\n            false)))\n\n(define-fun isNumericVal ((v Value)) Bool\n  (or (is-IntVal v) (is-FloatVal v)))\n\n(define-fun-rec ListAllNumeric ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (and (isNumericVal (head l)) (ListAllNumeric (tail l)))\n            false)))\n\n(define-fun-rec ListAllList ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (and (ListP (head l)) (ListAllList (tail l)))\n            false)))\n\n(define-fun-rec ListAllSublistNumeric ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (and (ListAllNumeric (head l)) (ListAllSublistNumeric (tail l)))\n            false)))",
      "basic_structure": "(assert (ListP lists))",
      "inputs": "(declare-const lists Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (ListP lists))",
        "assert_1": "(define-fun C1 () Bool (ListAllList lists))",
        "assert_2": "(define-fun C2 () Bool (ListAllSublistNumeric lists))"
      },
      "constraints": {
        "assert_0": "assert isinstance(lists, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(x, list) for x in lists), \"invalid inputs",
        "assert_2": "assert all(all(isinstance(y, (int, float)) for y in x) for x in lists), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/806": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeS ((v Value)) String (ite (is-StrVal v) (sval v) \"\"))",
      "basic_structure": "(assert (is-StrVal test_str))",
      "inputs": "(declare-const test_str Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal test_str))",
        "assert_1": "(define-fun C1 () Bool (> (str.len (SafeS test_str)) 0))"
      },
      "constraints": {
        "assert_0": "assert isinstance(test_str, str), \"invalid inputs",
        "assert_1": "assert len(test_str) > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/807": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (IsList (tail l))\n            false)))\n\n(define-fun-rec list_all_ints ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (and (is-IntVal (head l))\n                 (list_all_ints (tail l)))\n            false)))\n\n(define-fun-rec any_odd ((l Value)) Bool\n  (ite (is-Nil l)\n       false\n       (ite (is-Cons l)\n            (let ((h (head l)) (t (tail l)))\n              (ite (is-IntVal h)\n                   (or (not (= (mod (ival h) 2) 0))\n                       (any_odd t))\n                   (any_odd t)))\n            false)))",
      "basic_structure": "(assert (IsList nums))",
      "inputs": "(declare-const nums Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList nums))",
        "assert_1": "(define-fun C1 () Bool (list_all_ints nums))",
        "assert_2": "(define-fun C2 () Bool (any_odd nums))"
      },
      "constraints": {
        "assert_0": "assert isinstance(nums, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(el, int) for el in nums), \"invalid inputs",
        "assert_2": "assert any(el % 2 != 0 for el in nums), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/808": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (IsList (tail l))\n            false)))",
      "basic_structure": "(assert (IsList test_tup))",
      "inputs": "(declare-const test_tup Value)\n(declare-const K Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList test_tup))"
      },
      "constraints": {
        "assert_0": "assert isinstance(test_tup, tuple), \"invalid inputs"
      },
      "single_toggles": null
    },
    "Mbpp/809": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v) true\n       (ite (is-Cons v) (IsList (tail v)) false)))\n(define-fun-rec list_length ((v Value)) Int\n  (ite (is-Nil v) 0\n       (ite (is-Cons v) (+ 1 (list_length (tail v))) 0)))\n(define-fun-rec list_all_int ((v Value)) Bool\n  (ite (is-Nil v) true\n       (ite (is-Cons v) (and (is-IntVal (head v)) (list_all_int (tail v))) false)))",
      "basic_structure": "(assert (IsList test_tup1))\n(assert (IsList test_tup2))",
      "inputs": "(declare-const test_tup1 Value)\n(declare-const test_tup2 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList test_tup1))",
        "assert_1": "(define-fun C1 () Bool (IsList test_tup2))",
        "assert_2": "(define-fun C2 () Bool (= (list_length test_tup1) (list_length test_tup2)))",
        "assert_3": "(define-fun C3 () Bool (list_all_int test_tup1))",
        "assert_4": "(define-fun C4 () Bool (list_all_int test_tup2))"
      },
      "constraints": {
        "assert_0": "assert isinstance(test_tup1, tuple), \"invalid inputs",
        "assert_1": "assert isinstance(test_tup2, tuple), \"invalid inputs",
        "assert_2": "assert len(test_tup1) == len(test_tup2), \"invalid inputs",
        "assert_3": "assert all(isinstance(x, int) for x in test_tup1), \"invalid inputs",
        "assert_4": "assert all(isinstance(x, int) for x in test_tup2), \"invalid inputs"
      },
      "single_toggles": null
    }
  }
}