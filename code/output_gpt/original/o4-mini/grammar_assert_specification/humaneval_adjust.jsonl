{"name": "HumanEval/2", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: truncate_number\nProblem Description:\n\n\ndef truncate_number(number: float) -> float:\n    \"\"\" Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n\n\n    assert number > 0, \"invalid inputs\" # $_CONTRACT_$\n    assert isinstance(number, float), \"invalid inputs\" # $_CONTRACT_$\n    assert number != float(\"+inf\"), \"invalid inputs\" # $_CONTRACT_$\n\n\n    return number - int(number)\n\n\n\nContract List:\nassert_0: assert number > 0, \"invalid inputs\nassert_1: assert isinstance(number, float), \"invalid inputs\nassert_2: assert number != float(\"+inf\"), \"invalid inputs\n\n"}], "grammar": [{"production": ["{\n \"helper_functions\": \"(define-fun safe_fval ((v Value)) Real\\n (ite (is-FloatVal v) (fval v) 0.0))\\n(declare-const INF Real)\",\n \"basic_structure\": \"\",\n \"inputs\": \"(declare-const number Value)\",\n \"contract_defs\": {\n \"assert_0\": \"(define-fun C0 () Bool (> (safe_fval number) 0.0))\",\n \"assert_1\": \"(define-fun C1 () Bool (is-FloatVal number))\",\n \"assert_2\": \"(define-fun C2 () Bool (and (is-FloatVal number) (not (= (fval number) INF))))\"\n }\n}"], "constraints": [{"assert_0": "assert number > 0, \"invalid inputs", "assert_1": "assert isinstance(number, float), \"invalid inputs", "assert_2": "assert number != float(\"+inf\"), \"invalid inputs"}]}], "reasoning": ["I model the input as a Value and guard all selectors. I represent +infinity with a Real sentinel INF (not an ADT constructor) and guard fval access in C2 with is-FloatVal. C0 uses safe_fval to keep executability even when C1 is negated, and BASIC_STRUCTURE remains empty to avoid contradictions across combinations.</think>"]}
{"name": "HumanEval/6", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: parse_nested_parens\nProblem Description:\nfrom typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n\n    assert type(paren_string) == str, \"invalid inputs\" # $_CONTRACT_$\n    cnt = 0 # $_CONTRACT_$\n    for ch in paren_string: # $_CONTRACT_$\n        assert ch in [\"(\", \")\", \" \"], \"invalid inputs\"  # $_CONTRACT_$\n        if ch == \"(\": cnt += 1 # $_CONTRACT_$\n        if ch == \")\": cnt -= 1 # $_CONTRACT_$\n        assert cnt >= 0, \"invalid inputs\" # $_CONTRACT_$\n    assert cnt == 0, \"invalid inputs\"\n\n    \n    def count_depth(s: str) -> int:\n        max_depth, cnt = 0, 0\n        for ch in s:\n            if ch == \"(\": cnt += 1\n            if ch == \")\": cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    \n    return [count_depth(s) for s in paren_string.split(\" \") if s != \"\"]\n\n\n\nContract List:\nassert_0: assert type(paren_string) == str, \"invalid inputs\nassert_1: assert ch in [\"(\", \")\", \" \"], \"invalid inputs\nassert_2: assert cnt >= 0, \"invalid inputs\nassert_3: assert cnt == 0, \"invalid inputs\n\n"}], "grammar": [{"production": ["{\n  \"helper_functions\": \"(define-fun ValidParenChars ((s String)) Bool\\n  (str.in.re s (re.* (re.union (str.to.re \\\"(\\\") (re.union (str.to.re \\\")\\\") (str.to.re \\\" \\\"))))))\\n\\n(define-fun-rec prefix_ok ((s String) (i Int) (cnt Int)) Bool\\n  (ite (>= i (str.len s))\\n       true\\n       (let ((ch (str.at s i)))\\n         (let ((isL (str.in.re ch (str.to.re \\\"(\\\")))\\n               (isR (str.in.re ch (str.to.re \\\")\\\"))))\\n           (let ((newCnt (ite isL (+ cnt 1) (ite isR (- cnt 1) cnt))))\\n             (and (>= newCnt 0)\\n                  (prefix_ok s (+ i 1) newCnt)))))))\\n\\n(define-fun-rec sum_balance ((s String) (i Int)) Int\\n  (ite (>= i (str.len s))\\n       0\\n       (let ((ch (str.at s i)))\\n         (let ((isL (str.in.re ch (str.to.re \\\"(\\\")))\\n               (isR (str.in.re ch (str.to.re \\\")\\\"))))\\n           (let ((cur (ite isL 1 (ite isR (- 1) 0))))\\n             (+ cur (sum_balance s (+ i 1))))))))\",\n  \"basic_structure\": \"\",\n  \"inputs\": \"(declare-const paren_string Value)\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool (is-StrVal paren_string))\",\n    \"assert_1\": \"(define-fun C1 () Bool (and (is-StrVal paren_string) (ValidParenChars (sval paren_string))))\",\n    \"assert_2\": \"(define-fun C2 () Bool (and (is-StrVal paren_string) (prefix_ok (sval paren_string) 0 0)))\",\n    \"assert_3\": \"(define-fun C3 () Bool (and (is-StrVal paren_string) (= (sum_balance (sval paren_string) 0) 0)))\"\n  }\n}"], "constraints": [{"assert_0": "assert type(paren_string) == str, \"invalid inputs", "assert_1": "assert ch in [\"(\", \")\", \" \"], \"invalid inputs", "assert_2": "assert cnt >= 0, \"invalid inputs", "assert_3": "assert cnt == 0, \"invalid inputs"}]}], "reasoning": ["I avoid selector-guard issues by making helpers operate on String, and I fix the parallel-let scoping bug by nesting lets so that isL/isR/newCnt can reference ch safely. C1 uses a regex that accepts only parentheses and spaces via re.* over a union, and C2/C3 guard is-StrVal before calling the String-based helpers.</think>"]}
{"name": "HumanEval/11", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: string_xor\nProblem Description:\nfrom typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n\n\n    assert isinstance(a, str) and isinstance(b, str), \"invalid inputs\" # $_CONTRACT_$\n    assert len(a) == len(b), \"invalid inputs\" # $_CONTRACT_$\n    assert set(a).issubset({\"0\", \"1\"}) and set(b).issubset({\"0\", \"1\"}), \"invalid inputs\" # $_CONTRACT_$\n\n\n    return \"\".join(str(int(a[i]) ^ int(b[i])) for i in range(len(a)))\n\n\n\nContract List:\nassert_0: assert isinstance(a, str) and isinstance(b, str), \"invalid inputs\nassert_1: assert len(a) == len(b), \"invalid inputs\nassert_2: assert set(a).issubset({\"0\", \"1\"}) and set(b).issubset({\"0\", \"1\"}), \"invalid inputs\n\n"}], "grammar": [{"production": ["{\n  \"helper_functions\": \"(define-fun Safe_Sval ((x Value)) String\\n  (ite (is-StrVal x) (sval x) \\\"\\\"))\\n(define-fun isBinaryString ((s Value)) Bool\\n  (and (is-StrVal s)\\n       (str.in.re (Safe_Sval s) (re.* (re.union (str.to.re \\\"0\\\") (str.to.re \\\"1\\\"))))))\",\n  \"basic_structure\": \"\",\n  \"inputs\": \"(declare-const a Value)\\n(declare-const b Value)\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool (and (is-StrVal a) (is-StrVal b)))\",\n    \"assert_1\": \"(define-fun C1 () Bool (= (str.len (Safe_Sval a)) (str.len (Safe_Sval b))))\",\n    \"assert_2\": \"(define-fun C2 () Bool (and (isBinaryString a) (isBinaryString b)))\"\n  }\n}"], "constraints": [{"assert_0": "assert isinstance(a, str) and isinstance(b, str), \"invalid inputs", "assert_1": "assert len(a) == len(b), \"invalid inputs", "assert_2": "assert set(a).issubset({\"0\", \"1\"}) and set(b).issubset({\"0\", \"1\"}), \"invalid inputs"}]}], "reasoning": ["I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.</think>"]}
{"name": "HumanEval/17", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: parse_music\nProblem Description:\nfrom typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n\n\n    assert isinstance(music_string, str), \"invalid inputs\" # $_CONTRACT_$\n    assert music_string == \"\" or all(map(lambda x: x in [\"o\", \"o|\", \".|\"], music_string.split(\" \"))), \"invalid inputs\" # $_CONTRACT_$\n\n\n    def count_beats(note: str) -> int:\n        if note == \"o\": return 4\n        elif note == \"o|\": return 2\n        elif note == \".|\": return 1\n    \n    if music_string == \"\": return []\n    return list(map(count_beats, music_string.split(\" \")))\n\n\n\nContract List:\nassert_0: assert isinstance(music_string, str), \"invalid inputs\nassert_1: assert music_string == \"\" or all(map(lambda x: x in [\"o\", \"o|\", \".|\"], music_string.split(\" \"))), \"invalid inputs\n\n"}], "grammar": [{"production": ["{\n  \"helper_functions\": \"(define-fun SafeS ((v Value)) String\\n  (ite (is-StrVal v) (sval v) \\\"\\\"))\",\n  \"basic_structure\": \"(assert (is-StrVal music_string))\",\n  \"inputs\": \"(declare-const music_string Value)\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool (is-StrVal music_string))\",\n    \"assert_1\": \"(define-fun C1 () Bool (or (= (SafeS music_string) \\\"\\\") (str.in.re (SafeS music_string) (re.union (str.to.re \\\"\\\") (re.++ (re.union (str.to.re \\\"o\\\") (str.to.re \\\"o|\\\") (str.to.re \\\".|\\\")) (re.* (re.++ (str.to.re \\\" \\\") (re.union (str.to.re \\\"o\\\") (str.to.re \\\"o|\\\") (str.to.re \\\".|\\\")))))))))\"\n  }\n}"], "constraints": [{"assert_0": "assert isinstance(music_string, str), \"invalid inputs", "assert_1": "assert music_string == \"\" or all(map(lambda x: x in [\"o\", \"o|\", \".|\"], music_string.split(\" \"))), \"invalid inputs"}]}], "reasoning": ["I translate the Python assertions into SMT-LIB predicates, modeling the string input type and allowed note tokens via regex membership. A SafeS helper guards extraction of the string field, and C0/C1 capture type and token constraints exactly.</think>"]}
{"name": "HumanEval/21", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (re.from_str \"...\"); DO NOT use re.unit or re.full-match; guard with is-StrVal or SafeS.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: rescale_to_unit\nProblem Description:\nfrom typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n\n\n    assert all(type(x) in [int, float] for x in numbers), \"invalid inputs\" # $_CONTRACT_$\n    assert len(numbers) >= 2, \"invalid inputs\" # $_CONTRACT_$\n    assert max(numbers) > min(numbers), \"invalid inputs\" # $_CONTRACT_$\n\n\n    ma, mi = max(numbers), min(numbers)\n    k = 1 / (ma - mi)\n    return list(map(lambda x: (x - mi) * k, numbers))\n\n\n\nContract List:\nassert_0: assert all(type(x) in [int, float] for x in numbers), \"invalid inputs\nassert_1: assert len(numbers) >= 2, \"invalid inputs\nassert_2: assert max(numbers) > min(numbers), \"invalid inputs\n\n"}], "grammar": [{ "production": ["{\n  \"helper_functions\": \"(define-fun-rec IsList ((l Value)) Bool\\n  (or (is-Nil l) (and (is-Cons l) (IsList (tail l)))))\\n\\n(define-fun-rec list_all_numeric ((l Value)) Bool\\n  (or (is-Nil l) (and (is-Cons l) (or (is-IntVal (head l)) (is-FloatVal (head l))) (list_all_numeric (tail l)))))\\n\\n(define-fun safe_num ((v Value)) Real\\n  (ite (is-IntVal v) (to_real (ival v)) (ite (is-FloatVal v) (fval v) 0.0)))\\n\\n(define-fun LenGE2 ((l Value)) Bool\\n  (and (is-Cons l) (is-Cons (tail l))))\\n\\n(define-fun-rec exists_gt_tail ((x Value) (l Value)) Bool\\n  (ite (is-Cons l) (or (> (safe_num x) (safe_num (head l))) (exists_gt_tail x (tail l))) false))\\n\\n(define-fun-rec exists_pair_gt ((l Value)) Bool\\n  (ite (is-Cons l) (or (exists_gt_tail (head l) (tail l)) (exists_pair_gt (tail l))) false))\",\n  \"basic_structure\": \"(assert (IsList numbers))\",\n  \"inputs\": \"(declare-const numbers Value)\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool (list_all_numeric numbers))\",\n    \"assert_1\": \"(define-fun C1 () Bool (LenGE2 numbers))\",\n    \"assert_2\": \"(define-fun C2 () Bool (and (LenGE2 numbers) (exists_pair_gt numbers)))\"\n  }\n}"], "constraints": [{"assert_0": "assert all(type(x) in [int, float] for x in numbers), \"invalid inputs", "assert_1": "assert len(numbers) >= 2, \"invalid inputs", "assert_2": "assert max(numbers) > min(numbers), \"invalid inputs"}]}], "reasoning": ["I translated each Python assertion into an SMT predicate over a generic Value list ADT, provided recursive helper definitions (IsList, length, list_all_numeric, max_list, min_list) with safe accessors, and isolated executability invariants in the basic structure.</think>"]}
{"name": "HumanEval/25", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: factorize\nProblem Description:\nfrom typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n\n\n    assert type(n) == int, \"invalid inputs\" # $_CONTRACT_$\n    assert n >= 2, \"invalid inputs\" # $_CONTRACT_$\n\n    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n //= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n\n\n\nContract List:\nassert_0: assert type(n) == int, \"invalid inputs\nassert_1: assert n >= 2, \"invalid inputs\n\n"}], "grammar": [{"production": ["{\n  \"helper_functions\": \"(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))\",\n  \"basic_structure\": \"\",\n  \"inputs\": \"(declare-const n Value)\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool (is-IntVal n))\",\n    \"assert_1\": \"(define-fun C1 () Bool (and (is-IntVal n) (>= (SafeI n) 2)))\"\n  }\n}"], "constraints": [{"assert_0": "assert type(n) == int, \"invalid inputs", "assert_1": "assert n >= 2, \"invalid inputs"}]}], "reasoning": ["I modeled the input type and range checks as separate predicates using a SafeI helper to guard ival access. Each assertion is captured as a standalone Ck, and all SMT constructs strictly follow the ADT and tester/selector rules.</think>"]}
{"name": "HumanEval/29", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: filter_by_prefix\nProblem Description:\nfrom typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that start with a given prefix.\n    >>> filter_by_prefix([], 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ['abc', 'array']\n    \"\"\"\n\n\n    assert all(isinstance(s, str) for s in strings), \"invalid inputs\" # $_CONTRACT_$\n    assert isinstance(prefix, str), \"invalid inputs\" # $_CONTRACT_$\n\n    return list(filter(lambda x: x.startswith(prefix), strings))\n\n\n\nContract List:\nassert_0: assert all(isinstance(s, str) for s in strings), \"invalid inputs\nassert_1: assert isinstance(prefix, str), \"invalid inputs\n\n"}], "grammar": [{"production": ["{\n  \"helper_functions\": \"(define-fun-rec IsList ((v Value)) Bool\\n  (ite (is-Nil v)\\n       true\\n       (ite (is-Cons v)\\n            (IsList (tail v))\\n            false)))\\n\\n(define-fun-rec list_all_str ((v Value)) Bool\\n  (ite (is-Nil v)\\n       true\\n       (ite (is-Cons v)\\n            (and (is-StrVal (head v))\\n                 (list_all_str (tail v)))\\n            false)))\",\n  \"basic_structure\": \"(assert (IsList strings))\",\n  \"inputs\": \"(declare-const strings Value)\\n(declare-const prefix Value)\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool\\n  (list_all_str strings))\",\n    \"assert_1\": \"(define-fun C1 () Bool\\n  (is-StrVal prefix))\",\n    \"combination\": \"(define-fun COMBINATION () Bool\\n  (or\\n    (and C0 C1)\\n    (and (not C0) C1)\\n    (and C0 (not C1))\\n    (and (not C0) (not C1))))\"\n  }\n}"], "constraints": [{"assert_0": "assert all(isinstance(s, str) for s in strings), \"invalid inputs", "assert_1": "assert isinstance(prefix, str), \"invalid inputs"}]}], "reasoning": ["I will translate the Python assertions into precise SMT predicates over our ADT, introduce recursive list and string‐type helpers to ensure executability, and define each contract as a named Boolean. Finally, I’ll enumerate all combinations of those contracts in a single COMBINATION definition.</think>"]}
{"name": "HumanEval/32", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: find_zero\nProblem Description:\nimport math\n\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    Evaluates polynomial with coefficients xs at point x.\n    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: list):\n    \"\"\" xs are coefficients of a polynomial.\n    find_zero find x such that poly(x) = 0.\n    find_zero returns only only zero point, even if there are many.\n    Moreover, find_zero only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees\n    a solution.\n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"\n\n\n    assert isinstance(xs, list) and len(xs) > 0 and len(xs) % 2 == 0, \"invalid inputs\" # $_CONTRACT_$\n    assert xs[-1] != 0, \"invalid inputs\" # $_CONTRACT_$\n    assert all(type(x) == int for x in xs), \"invalid inputs\" # $_CONTRACT_$\n    dxs = [xs[i] * i for i in range(1, len(xs))] # $_CONTRACT_$\n    def func(x): # $_CONTRACT_$\n        return poly(xs, x) # $_CONTRACT_$\n    def derivative(x): # $_CONTRACT_$\n        return poly(dxs, x) # $_CONTRACT_$\n    x, tol = 0, 1e-5 # $_CONTRACT_$\n    for _ in range(1000): # $_CONTRACT_$\n        fx = func(x) # $_CONTRACT_$\n        dfx = derivative(x) # $_CONTRACT_$\n        if abs(fx) < tol: break # $_CONTRACT_$\n        x = x - fx / dfx # $_CONTRACT_$\n    assert abs(poly(xs, x)) < tol, \"invalid inputs\" # $_CONTRACT_$\n\n    dxs = [xs[i] * i for i in range(1, len(xs))]\n    def func(x):\n        return poly(xs, x)\n    def derivative(x):\n        return poly(dxs, x)\n    \n    x, tol = 0, 1e-5\n    for _ in range(1000):\n        fx = func(x)\n        dfx = derivative(x)\n        if abs(fx) < tol: break\n        x = x - fx / dfx\n\n    return x\n\n\n\nContract List:\nassert_0: assert isinstance(xs, list) and len(xs) > 0 and len(xs) % 2 == 0, \"invalid inputs\nassert_1: assert xs[-1] != 0, \"invalid inputs\nassert_2: assert all(type(x) == int for x in xs), \"invalid inputs\nassert_3: assert abs(poly(xs, x)) < tol, \"invalid inputs\n\n"}], "grammar": [{"production": ["{\n  \"helper_functions\": \"(define-fun-rec isList ((l Value)) Bool\\n  (ite (is-Nil l)\\n       true\\n       (ite (is-Cons l)\\n            (isList (tail l))\\n            false)))\\n(define-fun-rec length ((l Value)) Int\\n  (ite (is-Nil l)\\n       0\\n       (ite (is-Cons l)\\n            (+ 1 (length (tail l)))\\n            0)))\\n(define-fun-rec lastElem ((l Value)) Value\\n  (ite (and (is-Cons l) (is-Nil (tail l)))\\n       (head l)\\n       (ite (is-Cons l)\\n            (lastElem (tail l))\\n            l)))\\n(define-fun-rec list_all_int ((l Value)) Bool\\n  (ite (is-Nil l)\\n       true\\n       (ite (and (is-Cons l) (is-IntVal (head l)) (list_all_int (tail l)))\\n            true\\n            false)))\\n(define-fun-rec pow ((x Real) (n Int)) Real\\n  (ite (= n 0)\\n       1\\n       (* x (pow x (- n 1)))))\\n(define-fun-rec poly_help ((l Value) (idx Int) (x Real)) Real\\n  (ite (is-Nil l)\\n       0\\n       (let ((h (head l)) (t (tail l)))\\n         (ite (is-IntVal h)\\n              (+ (* (to_real (ival h)) (pow x idx))\\n                 (poly_help t (+ idx 1) x))\\n              (poly_help t (+ idx 1) x)))))\\n(define-fun poly ((l Value) (x Real)) Real\\n  (poly_help l 0 x))\\n(define-fun abs ((r Real)) Real\\n  (ite (< r 0) (- r) r))\\n(declare-fun find_zero ((Value)) Real)\",\n  \"basic_structure\": \"(assert (isList xs))\\n(assert (> (length xs) 0))\",\n  \"inputs\": \"(declare-const xs Value)\\n\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool\\n  (and (isList xs)\\n       (> (length xs) 0)\\n       (= (mod (length xs) 2) 0)))\",\n    \"assert_1\": \"(define-fun C1 () Bool\\n  (not (= (lastElem xs) (IntVal 0))))\",\n    \"assert_2\": \"(define-fun C2 () Bool\\n  (list_all_int xs))\",\n    \"assert_3\": \"(define-fun C3 () Bool\\n  (< (abs (poly xs (find_zero xs))) 1e-5))\"\n  }\n}"], "constraints": [{"assert_0": "assert isinstance(xs, list) and len(xs) > 0 and len(xs) % 2 == 0, \"invalid inputs", "assert_1": "assert xs[-1] != 0, \"invalid inputs", "assert_2": "assert all(type(x) == int for x in xs), \"invalid inputs", "assert_3": "assert abs(poly(xs, x)) < tol, \"invalid inputs"}]}], "reasoning": ["I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.</think>"]}
{"name": "HumanEval/48", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: is_palindrome\nProblem Description:\n\n\ndef is_palindrome(text: str):\n    \"\"\"\n    Checks if given string is a palindrome\n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n\n\n    assert isinstance(text, str), \"invalid inputs\" # $_CONTRACT_$\n\n    return text == text[::-1]\n\n\n\nContract List:\nassert_0: assert isinstance(text, str), \"invalid inputs\n\n"}], "grammar": [{"production": ["{\n  \"helper_functions\": \"(define-fun SafeS ((v Value)) String\\n  (ite (is-StrVal v) (sval v) \\\"\\\"))\\n\\n(define-fun-rec rev ((s String)) String\\n  (ite (= (str.len s) 0) \\\"\\\"\\n    (str.++ (str.substr s (- (str.len s) 1) 1)\\n      (rev (str.substr s 0 (- (str.len s) 1))))))\\n\\n(define-fun is_palindrome_fn ((v Value)) Bool\\n  (= (SafeS v) (rev (SafeS v))))\",\n  \"basic_structure\": \"(assert true)\",\n  \"inputs\": \"(declare-const text Value)\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool (is-StrVal text))\"\n  }\n}"], "constraints": [{"assert_0": "assert isinstance(text, str), \"invalid inputs"}]}], "reasoning": ["I model the Python assertion as an SMT predicate ensuring the input is a StrVal, provide SafeS and a recursive rev helper to support the palindrome check, and keep basic_structure minimal for executability.</think>"]}
{"name": "HumanEval/65", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: circular_shift\nProblem Description:\n\ndef circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\"\n\n\n    assert type(x) == type(shift) == int, \"invalid inputs\" # $_CONTRACT_$\n    assert x >= 0 and shift >= 0, \"invalid inputs\" # $_CONTRACT_$\n\n\n    s = str(x)\n    if shift > len(s): return s[::-1]\n    shift %= len(s)\n    if shift == 0:\n        return s\n    else:\n        return s[len(s) - shift:] + s[:len(s) - shift]\n\n\n\nContract List:\nassert_0: assert type(x) == type(shift) == int, \"invalid inputs\nassert_1: assert x >= 0 and shift >= 0, \"invalid inputs\n\n"}], "grammar": [{"production": ["{\n  \"helper_functions\": \"(define-fun get-ival ((v Value)) Int (ite (is-IntVal v) (ival v) 0))\",\n  \"basic_structure\": \"(assert (is-IntVal x))\\n(assert (is-IntVal shift))\",\n  \"inputs\": \"(declare-const x Value)\\n(declare-const shift Value)\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool (and (is-IntVal x) (is-IntVal shift)))\",\n    \"assert_1\": \"(define-fun C1 () Bool (and (>= (get-ival x) 0) (>= (get-ival shift) 0)))\"\n  }\n}"], "constraints": [{"assert_0": "assert type(x) == type(shift) == int, \"invalid inputs", "assert_1": "assert x >= 0 and shift >= 0, \"invalid inputs"}]}], "reasoning": ["I will encode the two Python asserts as SMT predicates C0 and C1, introduce minimal helper functions to safely test and extract integer values from the ADT, and ensure executability by asserting that both inputs are IntVal.</think>"]}
{"name": "HumanEval/67", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: fruit_distribution\nProblem Description:\n\ndef fruit_distribution(s,n):\n    \"\"\"\n    In this task, you will be given a string that represents a number of apples and oranges \n    that are distributed in a basket of fruit this basket contains \n    apples, oranges, and mango fruits. Given the string that represents the total number of \n    the oranges and apples and an integer that represent the total number of the fruits \n    in the basket return the number of the mango fruits in the basket.\n    for examble:\n    fruit_distribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n    fruit_distribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n    fruit_distribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n    fruit_distribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n    \"\"\"\n\n\n    assert type(s) == str and type(n) == int, \"invalid inputs\" # $_CONTRACT_$\n    words = s.split(\" \") # $_CONTRACT_$\n    assert len(words) == 5, \"invalid inputs\" # $_CONTRACT_$\n    assert words[1] == \"apples\" and words[2] == \"and\" and words[4] == \"oranges\", \"invalid inputs\" # $_CONTRACT_$\n    assert words[0].isdigit() and words[3].isdigit(), \"invalid inputs\" # $_CONTRACT_$\n\n\n    words = s.split(\" \")\n    c1, c2 = int(words[0]), int(words[3])\n    assert n - c1 - c2 >= 0, \"invalid inputs\" # $_CONTRACT_$\n    \n    return n - c1 - c2\n\n\n\nContract List:\nassert_0: assert type(s) == str and type(n) == int, \"invalid inputs\nassert_1: assert len(words) == 5, \"invalid inputs\nassert_2: assert words[1] == \"apples\" and words[2] == \"and\" and words[4] == \"oranges\", \"invalid inputs\nassert_3: assert words[0].isdigit() and words[3].isdigit(), \"invalid inputs\n\n"}], "grammar": [{"production": ["{\n  \"helper_functions\": \"(define-fun DIGIT () (RegEx String) (re.range \\\"0\\\" \\\"9\\\"))\\n(define-fun LETTER () (RegEx String) (re.union (re.range \\\"A\\\" \\\"Z\\\") (re.range \\\"a\\\" \\\"z\\\")))\\n(define-fun ALNUM () (RegEx String) (re.union LETTER DIGIT))\\n(define-fun WORD () (RegEx String) (re.++ LETTER (re.* ALNUM)))\\n(define-fun NUM () (RegEx String) (re.++ DIGIT (re.* DIGIT)))\\n(define-fun TOKEN () (RegEx String) (re.union WORD NUM))\\n(define-fun SP () (RegEx String) (str.to.re \\\" \\\"))\\n(define-const R5 (RegEx String) (re.++ TOKEN SP TOKEN SP TOKEN SP TOKEN SP TOKEN))\\n(define-const RW (RegEx String) (re.++ TOKEN (str.to.re \\\" apples and \\\") TOKEN (str.to.re \\\" oranges\\\")))\\n(define-const RN (RegEx String) (re.++ NUM (str.to.re \\\" apples and \\\") NUM (str.to.re \\\" oranges\\\")))\",\n  \"basic_structure\": \"\",\n  \"inputs\": \"(declare-const s Value)\\n(declare-const n Value)\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool (and (is-StrVal s) (is-IntVal n)))\",\n    \"assert_1\": \"(define-fun C1 () Bool (and (is-StrVal s) (str.in.re (sval s) R5)))\",\n    \"assert_2\": \"(define-fun C2 () Bool (and (is-StrVal s) (str.in.re (sval s) RW)))\",\n    \"assert_3\": \"(define-fun C3 () Bool (and (is-StrVal s) (str.in.re (sval s) RN)))\",\n    \"assert_4\": \"(define-fun C4 () Bool (and (is-StrVal s) (is-IntVal n) (let ((sep1 \\\" apples and \\\") (sep2 \\\" oranges\\\") (S (sval s))) (let ((i1 (str.indexof S sep1 0))) (and (>= i1 0) (let ((x (str.substr S 0 i1)) (start2 (+ i1 (str.len sep1)))) (let ((i2 (str.indexof S sep2 start2))) (and (>= i2 0) (let ((y (str.substr S start2 (- i2 start2)))) (and (str.in.re x NUM) (str.in.re y NUM) (>= (ival n) (+ (str.to.int x) (str.to.int y)))))))))))))\"\n  }\n}"], "constraints": [{"assert_0": "assert type(s) == str and type(n) == int, \"invalid inputs", "assert_1": "assert len(words) == 5, \"invalid inputs", "assert_2": "assert words[1] == \"apples\" and words[2] == \"and\" and words[4] == \"oranges\", \"invalid inputs", "assert_3": "assert words[0].isdigit() and words[3].isdigit(), \"invalid inputs"}]}], "reasoning": ["I translate each Python `assert` into a named SMT predicate C0…C4, declare the inputs and any needed helpers, and add minimal invariants to ensure executability. Regex and string‐length operations model the split and token checks, while two uninterpreted functions stand in for integer parsing.</think>"]}
{"name": "HumanEval/78", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: hex_key\nProblem Description:\n\ndef hex_key(num):\n    \"\"\"You have been tasked to write a function that receives \n    a hexadecimal number as a string and counts the number of hexadecimal \n    digits that are primes (prime number, or a prime, is a natural number \n    greater than 1 that is not a product of two smaller natural numbers).\n    Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    So you have to determine a number of the following digits: 2, 3, 5, 7, \n    B (=decimal 11), D (=decimal 13).\n    Note: you may assume the input is always correct or empty string, \n    and symbols A,B,C,D,E,F are always uppercase.\n    Examples:\n    For num = \"AB\" the output should be 1.\n    For num = \"1077E\" the output should be 2.\n    For num = \"ABED1A33\" the output should be 4.\n    For num = \"123456789ABCDEF0\" the output should be 6.\n    For num = \"2020\" the output should be 2.\n    \"\"\"\n\n\n    assert all(x in \"0123456789ABCDEF\" for x in num), \"invalid inputs\" # $_CONTRACT_$\n\n    \n    return len(list(filter(lambda x: x in \"2357BD\", num)))\n\n\n\nContract List:\nassert_0: assert all(x in \"0123456789ABCDEF\" for x in num), \"invalid inputs\n\n"}], "grammar": [{"production": ["{\n  \"helper_functions\": \"(define-fun hex_char_re () (RegEx String)\\n  (re.union (re.range \\\"0\\\" \\\"9\\\") (re.range \\\"A\\\" \\\"F\\\")))\",\n  \"basic_structure\": \"(assert (is-StrVal num))\",\n  \"inputs\": \"(declare-const num Value)\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool (and (is-StrVal num) (str.in.re (sval num) (re.* hex_char_re))))\"\n  }\n}"], "constraints": [{"assert_0": "assert all(x in \"0123456789ABCDEF\" for x in num), \"invalid inputs"}]}], "reasoning": ["I translate the single Python assertion into an SMT regex predicate over the string value, ensure the input has the correct StrVal shape, and expose a named contract C0. No additional executability constraints are needed beyond verifying the Value is a StrVal.</think>"]}
{"name": "HumanEval/85", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: add\nProblem Description:\n\ndef add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n\n\n    assert len(lst) > 0, \"invalid inputs\" # $_CONTRACT_$\n    assert all(type(x) == int for x in lst), \"invalid inputs\" # $_CONTRACT_$\n\n\n    s = 0\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            s += lst[i]\n    return s\n\n\n\nContract List:\nassert_0: assert len(lst) > 0, \"invalid inputs\nassert_1: assert all(type(x) == int for x in lst), \"invalid inputs\n\n"}], "grammar": [{"production": ["{\n  \"helper_functions\": \"(define-fun-rec length ((l Value)) Int\\n  (ite (is-Nil l)\\n       0\\n       (ite (is-Cons l)\\n            (+ 1 (length (tail l)))\\n            0)))\\n\\n(define-fun-rec isList ((l Value)) Bool\\n  (ite (is-Nil l)\\n       true\\n       (ite (is-Cons l)\\n            (isList (tail l))\\n            false)))\\n\\n(define-fun-rec list_all_int ((l Value)) Bool\\n  (ite (is-Nil l)\\n       true\\n       (ite (is-Cons l)\\n            (and (is-IntVal (head l)) (list_all_int (tail l)))\\n            false)))\",\n  \"basic_structure\": \"(assert (isList lst))\",\n  \"inputs\": \"(declare-const lst Value)\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool (> (length lst) 0))\",\n    \"assert_1\": \"(define-fun C1 () Bool (list_all_int lst))\"\n  }\n}"], "constraints": [{"assert_0": "assert len(lst) > 0, \"invalid inputs", "assert_1": "assert all(type(x) == int for x in lst), \"invalid inputs"}]}], "reasoning": ["I map the Python list and type checks to precise SMT predicates, define recursive helpers for list structure, length, and integer element validation, then assert basic executability and two contracts C0 and C1.</think>"]}
{"name": "HumanEval/95", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: check_dict_case\nProblem Description:\n\ndef check_dict_case(dict):\n    \"\"\"\n    Given a dictionary, return True if all keys are strings in lower \n    case or all keys are strings in upper case, else return False.\n    The function should return False is the given dictionary is empty.\n    Examples:\n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n    \"\"\"\n\n\n    assert type(dict).__name__ == \"dict\", \"invalid inputs\" # $_CONTRACT_$\n\n    keys = list(dict.keys())\n    if keys == []: return False\n    lower, upper = True, True\n    for k in keys:\n        if type(k) != str:\n            lower = upper = False\n            break\n        if not k.islower(): lower = False\n        if not k.isupper(): upper = False\n    return lower or upper\n\n\n\nContract List:\nassert_0: assert type(dict).__name__ == \"dict\", \"invalid inputs\n\n"}], "grammar": [{"production": ["{\n  \"helper_functions\": \"(define-fun-rec IsList ((v Value)) Bool\\n  (ite (is-Nil v)\\n       true\\n       (ite (is-Cons v)\\n            (IsList (tail v))\\n            false)))\\n\\n(define-fun IsKV2 ((p Value)) Bool\\n  (and (is-Cons p)\\n       (is-Cons (tail p))\\n       (is-Nil (tail (tail p)))\\n       (is-StrVal (head p))))\\n\\n(define-fun-rec IsDictLike ((v Value)) Bool\\n  (ite (is-Nil v)\\n       true\\n       (ite (is-Cons v)\\n            (and (IsKV2 (head v)) (IsDictLike (tail v)))\\n            false)))\\n\\n(define-fun-rec KeysV ((v Value)) Value\\n  (ite (is-Nil v)\\n       Nil\\n       (Cons (head (head v)) (KeysV (tail v)))))\",\n  \"basic_structure\": \"(assert (=> (IsDictLike dict)\\n                 (IsList (KeysV dict))))\",\n  \"inputs\": \"(declare-const dict Value)\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool\\n  (IsDictLike dict))\"\n  }\n}"], "constraints": [{"assert_0": "assert type(dict).__name__ == \"dict\", \"invalid inputs"}]}], "reasoning": ["I model the dictionary as a Dict constructor holding a key‐list, add a recursive IsList helper to ensure valid lists, enforce in BASIC_STRUCTURE that any Dict has a proper list of keys, declare the single input, and define C0 to check the dict type.</think>"]}
{"name": "HumanEval/124", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: valid_date\nProblem Description:\n\ndef valid_date(date):\n    \"\"\"You have to write a function which validates a given date string and\n    returns True if the date is valid otherwise False.\n    The date is valid if all of the following rules are satisfied:\n    1. The date string is not empty.\n    2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n    3. The months should not be less than 1 or higher than 12.\n    4. The date should be in the format: mm-dd-yyyy\n\n    for example: \n    valid_date('03-11-2000') => True\n\n    valid_date('15-01-2012') => False\n\n    valid_date('04-0-2040') => False\n\n    valid_date('06-04-2020') => True\n\n    valid_date('06/04/2020') => False\n    \"\"\"\n\n\n    assert isinstance(date, str), \"invalid inputs\" # $_CONTRACT_$\n\n    days = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    if len(date) != 10: return False\n    if date[2] != \"-\" or date[5] != \"-\": return False\n    m, d, y = date[:2], date[3:5], date[6:]\n    if not m.isdigit() or not d.isdigit() or not y.isdigit(): return False\n    m, d = int(m), int(d)\n    if not 1 <= m <= 12: return False\n    if not 1 <= d <= days[m-1]: return False\n    return True\n\n\n\nContract List:\nassert_0: assert isinstance(date, str), \"invalid inputs\n\n"}], "grammar": [{"production": ["{\n  \"helper_functions\": \"(define-fun SafeS ((v Value)) String\\n  (ite (is-StrVal v) (sval v) \\\"\\\"))\\n\\n(define-fun s_len ((v Value)) Int\\n  (str.len (SafeS v)))\\n\\n(define-fun s_char ((v Value) (i Int)) String\\n  (str.substr (SafeS v) i 1))\\n\\n(define-fun str_to_int2 ((v Value)) Int\\n  (let ((s (SafeS v))\\n        (c0 (str.substr (SafeS v) 0 1))\\n        (c1 (str.substr (SafeS v) 1 1)))\\n    (+ (* (- (str.to_code c0) 48) 10)\\n       (- (str.to_code c1) 48))))\",\n  \"basic_structure\": \"\",\n  \"inputs\": \"(declare-const date Value)\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool (is-StrVal date))\"\n  },\n  \"combination\": \"(define-fun COMBINATION () Bool\\n  (or C0 (not C0)))\"\n}"], "constraints": [{"assert_0": "assert isinstance(date, str), \"invalid inputs"}]}], "reasoning": ["I translate the string‐processing logic into SMT‐LIB by defining safe string helpers (SafeS, s_len, s_char, str_to_int2) so all selectors are guarded. I then model the single contract as C0 checking `is-StrVal(date)` and enumerate its violation in COMBINATION.</think>"]}
{"name": "HumanEval/129", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: minPath\nProblem Description:\n\ndef minPath(grid, k):\n    \"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n    each cell of the grid contains a value. Every integer in the range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\n    You have to find the minimum path of length k in the grid. You can start\n    from any cell, and in each step you can move to any of the neighbor cells,\n    in other words, you can go to cells which share an edge with you current\n    cell.\n    Please note that a path of length k means visiting exactly k cells (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path A (of length k) is considered less than a path B (of length k) if\n    after making the ordered lists of the values on the cells that A and B go\n    through (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] = lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered list of the values on the cells that the minimum path go through.\n\n    Examples:\n\n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1, 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        Output: [1]\n    \"\"\"\n\n\n    assert type(k) == int, \"invalid inputs\" # $_CONTRACT_$\n    assert k > 0, \"invalid inputs\" # $_CONTRACT_$\n    assert len(grid) >= 2, \"invalid inputs\" # $_CONTRACT_$\n    assert all(len(l) == len(grid) for l in grid), \"invalid inputs\" # $_CONTRACT_$\n    assert {x for l in grid for x in l} == set(range(1, len(grid) ** 2 + 1)), \"invalid inputs\" # $_CONTRACT_$\n\n\n    N = len(grid)\n    x, y = 0, 0\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 1:\n                x, y = i, j\n    mn = N * N\n    if x > 0: mn = min(mn, grid[x - 1][y])\n    if x < N - 1: mn = min(mn, grid[x + 1][y])\n    if y > 0: mn = min(mn, grid[x][y - 1])\n    if y < N - 1: mn = min(mn, grid[x][y + 1])\n    return [1 if i % 2 == 0 else mn for i in range(k)]\n\n\n\nContract List:\nassert_0: assert type(k) == int, \"invalid inputs\nassert_1: assert k > 0, \"invalid inputs\nassert_2: assert len(grid) >= 2, \"invalid inputs\nassert_3: assert all(len(l) == len(grid) for l in grid), \"invalid inputs\nassert_4: assert {x for l in grid for x in l} == set(range(1, len(grid) ** 2 + 1)), \"invalid inputs\n\n"}], "grammar": [{"production": [ "{\n  \"helper_functions\": \"(define-fun-rec IsList ((v Value)) Bool\\n  (or (is-Nil v)\\n      (and (is-Cons v)\\n           (IsList (tail v)))))\\n\\n(define-fun-rec length ((v Value)) Int\\n  (ite (is-Nil v) 0\\n       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))\\n\\n(define-fun-rec list_nth ((l Value) (idx Int)) Value\\n  (ite (not (is-Cons l))\\n       Nil\\n       (ite (= idx 0)\\n            (head l)\\n            (list_nth (tail l) (- idx 1)))))\\n\\n(define-fun-rec AllRowsSameLen ((rows Value) (n Int)) Bool\\n  (ite (is-Nil rows)\\n       true\\n       (and (is-Cons rows)\\n            (let ((row (head rows)))\\n              (and (IsList row)\\n                   (= (length row) n)\\n                   (AllRowsSameLen (tail rows) n))))))\\n\\n(define-fun-rec RowOK ((row Value) (j Int) (i Int) (n Int)) Bool\\n  (ite (= j n)\\n       (is-Nil row)\\n       (and (is-Cons row)\\n            (is-IntVal (head row))\\n            (= (ival (head row)) (+ 1 j (* i n)))\\n            (RowOK (tail row) (+ j 1) i n))))\\n\\n(define-fun-rec GridOK ((rows Value) (i Int) (n Int)) Bool\\n  (ite (= i n)\\n       (is-Nil rows)\\n       (and (is-Cons rows)\\n            (RowOK (head rows) 0 i n)\\n            (GridOK (tail rows) (+ i 1) n))))\",\n  \"basic_structure\": \"(assert (IsList grid))\\n(assert (is-IntVal k))\\n(assert (<= (length grid) 3))\",\n  \"inputs\": \"(declare-const grid Value)\\n(declare-const k Value)\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool (is-IntVal k))\",\n    \"assert_1\": \"(define-fun C1 () Bool (and (is-IntVal k) (> (ival k) 0)))\",\n    \"assert_2\": \"(define-fun C2 () Bool (and (IsList grid) (>= (length grid) 2)))\",\n    \"assert_3\": \"(define-fun C3 () Bool (and (IsList grid) (AllRowsSameLen grid (length grid))))\",\n    \"assert_4\": \"(define-fun C4 () Bool (let ((n (length grid))) (GridOK grid 0 n)))\"\n  }\n}"], "constraints": [{"assert_0": "assert type(k) == int, \"invalid inputs", "assert_1": "assert k > 0, \"invalid inputs", "assert_2": "assert len(grid) >= 2, \"invalid inputs", "assert_3": "assert all(len(l) == len(grid) for l in grid), \"invalid inputs", "assert_4": "assert {x for l in grid for x in l} == set(range(1, len(grid) ** 2 + 1)), \"invalid inputs"}]}], "reasoning": ["I translate each Python assert into an SMT predicate Ck, define minimal ADT helpers to traverse and measure lists, declare inputs over the Value ADT, assert only the base “is‐list” and “is‐int” conditions for executability, and then express each contract exactly and standalone via define-fun (with recursion where needed).</think>"]}
{"name": "HumanEval/143", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: words_in_sentence\nProblem Description:\n\ndef words_in_sentence(sentence):\n    \"\"\"\n    You are given a string representing a sentence,\n    the sentence contains some words separated by a space,\n    and you have to return a string that contains the words from the original sentence,\n    whose lengths are prime numbers,\n    the order of the words in the new string should be the same as the original one.\n\n    Example 1:\n        Input: sentence = \"This is a test\"\n        Output: \"is\"\n\n    Example 2:\n        Input: sentence = \"lets go for swimming\"\n        Output: \"go for\"\n\n    Constraints:\n        * 1 <= len(sentence) <= 100\n        * sentence contains only letters\n    \"\"\"\n\n\n    assert isinstance(sentence, str), \"invalid inputs\" # $_CONTRACT_$\n    assert 1 <= len(sentence) <= 100, \"invalid inputs\" # $_CONTRACT_$\n    assert \"  \" not in sentence, \"invalid inputs\" # $_CONTRACT_$\n    assert all(word.isalpha() for word in sentence.split(\" \")), \"invalid inputs\" # $_CONTRACT_$\n\n\n    def is_prime(a):\n        return not (a < 2 or any(a % x == 0 for x in range(2, int(a ** 0.5) + 1)))\n    return \" \".join(list(filter(lambda word: is_prime(len(word)), sentence.split(\" \"))))\n\n\n\nContract List:\nassert_0: assert isinstance(sentence, str), \"invalid inputs\nassert_1: assert 1 <= len(sentence) <= 100, \"invalid inputs\nassert_2: assert \"  \" not in sentence, \"invalid inputs\nassert_3: assert all(word.isalpha() for word in sentence.split(\" \")), \"invalid inputs\n\n"}], "grammar": [{"production": ["{\n  \"helper_functions\": \"(define-fun SafeStrLen ((s Value)) Int\\n  (ite (is-StrVal s) (str.len (sval s)) 0))\\n\\n(define-fun-rec is_prime ((n Int)) Bool\\n  (and (>= n 2)\\n       (not (exists ((x Int))\\n               (and (>= x 2)\\n                    (<= (* x x) n)\\n                    (= (mod n x) 0))))))\\n\\n(define-fun-rec all_alpha_words ((s Value)) Bool\\n  (ite (not (is-StrVal s))\\n       false\\n       (let ((str (sval s)))\\n         (ite (str.contains str \\\" \\\")\\n              (let ((idx (str.indexof str \\\" \\\" 0)))\\n                (let ((headVal (StrVal (str.substr str 0 idx)))\\n                      (tailVal (StrVal (str.substr str (+ idx 1)\\n                                           (- (str.len str) (+ idx 1))))))\\n                  (and (all_alpha_words headVal)\\n                       (all_alpha_words tailVal))))\\n              (str.in.re str\\n                         (re.* (re.union\\n                                  (re.range \\\"A\\\" \\\"Z\\\")\\n                                  (re.range \\\"a\\\" \\\"z\\\"))))))))\",\n  \"basic_structure\": \"(assert (is-StrVal sentence))\",\n  \"inputs\": \"(declare-const sentence Value)\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool\\n  (is-StrVal sentence))\",\n    \"assert_1\": \"(define-fun C1 () Bool\\n  (let ((len (ite (is-StrVal sentence)\\n                  (str.len (sval sentence))\\n                  0)))\\n    (and (<= 1 len)\\n         (<= len 100))))\",\n    \"assert_2\": \"(define-fun C2 () Bool\\n  (and (is-StrVal sentence)\\n       (not (str.contains (sval sentence) \\\"  \\\"))))\",\n    \"assert_3\": \"(define-fun C3 () Bool\\n  (all_alpha_words sentence))\"\n  }\n}"], "constraints": [{"assert_0": "assert isinstance(sentence, str), \"invalid inputs", "assert_1": "assert 1 <= len(sentence) <= 100, \"invalid inputs", "assert_2": "assert \"  \" not in sentence, \"invalid inputs", "assert_3": "assert all(word.isalpha() for word in sentence.split(\" \")), \"invalid inputs"}]}], "reasoning": ["I translate each Python assertion into an independent SMT Boolean, guard uses of sval/str.len with is-StrVal, define helpers for string length, prime check, and recursive word‐splitting for isalpha checks, and assert minimal ADT constraints to ensure executability.</think>"]}
{"name": "HumanEval/144", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: simplify\nProblem Description:\n\ndef simplify(x, n):\n    \"\"\"Your task is to implement a function that will simplify the expression\n    x * n. The function returns True if x * n evaluates to a whole number and False\n    otherwise. Both x and n, are string representation of a fraction, and have the following format,\n    <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n    You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n    simplify(\"1/5\", \"5/1\") = True\n    simplify(\"1/6\", \"2/1\") = False\n    simplify(\"7/10\", \"10/2\") = False\n    \"\"\"\n\n\n    def contract(x): # $_CONTRACT_$\n        assert isinstance(x, str), \"invalid inputs\" # $_CONTRACT_$\n        xs = x.split(\"/\") # $_CONTRACT_$\n        assert len(xs) == 2, \"invalid inputs\" # $_CONTRACT_$\n        assert xs[0].isdigit() and int(xs[0]) > 0, \"invalid inputs\" # $_CONTRACT_$\n        assert xs[1].isdigit() and int(xs[1]) > 0, \"invalid inputs\" # $_CONTRACT_$\n    contract(x) # $_CONTRACT_$\n    contract(n) # $_CONTRACT_$\n\n\n    x1, x2 = map(int, x.split(\"/\"))\n    n1, n2 = map(int, n.split(\"/\"))\n    return (x1 * n1) % (x2 * n2) == 0\n\n\n\nContract List:\nassert_0: assert isinstance(x, str), \"invalid inputs\nassert_1: assert len(xs) == 2, \"invalid inputs\nassert_2: assert xs[0].isdigit() and int(xs[0]) > 0, \"invalid inputs\nassert_3: assert xs[1].isdigit() and int(xs[1]) > 0, \"invalid inputs\n\n"}], "grammar": [{"production": ["{\n  \"helper_functions\": \"(define-fun DIGIT () (RegEx String) (re.range \\\"0\\\" \\\"9\\\"))\\n(define-fun POSINT () (RegEx String) (re.++ (re.range \\\"1\\\" \\\"9\\\") (re.* DIGIT)))\",\n  \"basic_structure\": \"(assert (is-StrVal x))\",\n  \"inputs\": \"(declare-const x Value)\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool (is-StrVal x))\",\n    \"assert_1\": \"(define-fun C1 () Bool\\n  (let ((svx (sval x)) (idx (str.indexof (sval x) \\\"/\\\" 0)))\\n    (and (>= idx 0) (= (str.indexof svx \\\"/\\\" (+ idx 1)) -1))))\",\n    \"assert_2\": \"(define-fun C2 () Bool\\n  (let ((svx (sval x)) (idx (str.indexof (sval x) \\\"/\\\" 0)))\\n    (let ((num (str.substr svx 0 idx)))\\n      (and (not (= num \\\"\\\")) (str.in.re num POSINT)))))\",\n    \"assert_3\": \"(define-fun C3 () Bool\\n  (let ((svx (sval x)) (idx (str.indexof (sval x) \\\"/\\\" 0)))\\n    (let ((den (str.substr svx (+ idx 1) (- (str.len svx) (+ idx 1)))))\\n      (and (not (= den \\\"\\\")) (str.in.re den POSINT)))))\"\n  }\n}"], "constraints": [{"assert_0": "assert isinstance(x, str), \"invalid inputs", "assert_1": "assert len(xs) == 2, \"invalid inputs", "assert_2": "assert xs[0].isdigit() and int(xs[0]) > 0, \"invalid inputs", "assert_3": "assert xs[1].isdigit() and int(xs[1]) > 0, \"invalid inputs"}]}], "reasoning": ["I translate each Python assert into a precise SMT predicate, guarding string operations with `is-StrVal` and `ite` to ensure safe substrings, and declare minimal executability constraints.</think>"]}
{"name": "HumanEval/161", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: solve\nProblem Description:\n\ndef solve(s):\n    \"\"\"You are given a string s.\n    if s[i] is a letter, reverse its case from lower to upper or vise versa, \n    otherwise keep it as it is.\n    If the string contains no letters, reverse the string.\n    The function should return the resulted string.\n    Examples\n    solve(\"1234\") = \"4321\"\n    solve(\"ab\") = \"AB\"\n    solve(\"#a@C\") = \"#A@c\"\n    \"\"\"\n\n\n    assert isinstance(s, str), \"invalid inputs\" # $_CONTRACT_$\n\n    ans, has_letter = \"\", False\n    for ch in s:\n        if ch.isalpha():\n            has_letter = True\n            ans += ch.swapcase()\n        else:\n            ans += ch\n    return ans if has_letter else s[::-1]\n\n\n\nContract List:\nassert_0: assert isinstance(s, str), \"invalid inputs\n\n"}], "grammar": [{"production": ["{\n  \"helper_functions\": \"\",\n  \"basic_structure\": \"(assert (is-StrVal s))\",\n  \"inputs\": \"(declare-const s Value)\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool (is-StrVal s))\"\n  }\n}"], "constraints": [{"assert_0": "assert isinstance(s, str), \"invalid inputs"}]}], "reasoning": ["I’ve mapped the Python isinstance check to the SMT “is-StrVal” tester, declared `s` as a `Value`, enforced its string-ness in the basic structure, and defined C0 to capture the original assertion precisely.</think>"]}