Mbpp/2

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: similar_elements
Problem Description:
"""
Write a function to find the shared elements from the given two lists.
assert set(similar_elements((3, 4, 5, 6),(5, 7, 4, 10))) == set((4, 5))
"""


def similar_elements(test_tup1, test_tup2):

  assert isinstance(test_tup1, tuple), "invalid inputs" # $_CONTRACT_$
  assert isinstance(test_tup2, tuple), "invalid inputs" # $_CONTRACT_$
  return tuple(set(test_tup1) & set(test_tup2))


Contract List:
assert_0: assert isinstance(test_tup1, tuple), "invalid inputs
assert_1: assert isinstance(test_tup2, tuple), "invalid inputs


I will translate the tuple‐type assertions into precise SMT-LIB predicates, introduce a safe IsList definition for executability, and keep contracts separate for systematic violation testing.

```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))",
  "basic_structure": "(assert (IsList test_tup1))\n(assert (IsList test_tup2))",
  "inputs": "(declare-const test_tup1 Value)\n(declare-const test_tup2 Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList test_tup1))",
    "assert_1": "(define-fun C1 () Bool (IsList test_tup2))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/3

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: is_not_prime
Problem Description:
"""
Write a python function to identify non-prime numbers.
assert is_not_prime(2) == False
"""


import math
def is_not_prime(n):

    assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
    assert n > 0, "invalid inputs" # $_CONTRACT_$
    if n == 1:
        return True
    for i in range(2, int(math.sqrt(n))+1):
        if n % i == 0:
            return True
    return False


Contract List:
assert_0: assert isinstance(n, int), "invalid inputs
assert_1: assert n > 0, "invalid inputs


<think>
I translate the Python input assertions into two precise SMT predicates over our ADT, guarding selector use with ite to ensure soundness even if the type test fails.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "",
  "inputs": "(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
    "assert_1": "(define-fun C1 () Bool (let ((num (ite (is-IntVal n) (ival n) 0))) (> num 0)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/4

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: heap_queue_largest
Problem Description:
"""
Write a function to find the n largest integers from a given list of numbers, returned in descending order.
assert heap_queue_largest( [25, 35, 22, 85, 14, 65, 75, 22, 58],3)==[85, 75, 65]
"""


import heapq as hq
def heap_queue_largest(nums: list,n: int) -> list:

  assert isinstance(nums, list), "invalid inputs" # $_CONTRACT_$
  assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
  assert n > 0, "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(i, int) for i in nums), "invalid inputs" # $_CONTRACT_$
  assert len(nums) > n, "invalid inputs" # $_CONTRACT_$
  largest_nums = hq.nlargest(n, nums)
  return largest_nums


Contract List:
assert_0: assert isinstance(nums, list), "invalid inputs
assert_1: assert isinstance(n, int), "invalid inputs
assert_2: assert n > 0, "invalid inputs
assert_3: assert all(isinstance(i, int) for i in nums), "invalid inputs
assert_4: assert len(nums) > n, "invalid inputs


<think>
I translate Python input assertions into SMT-LIB Bool predicates, define ADT helper functions for safe extraction, list structure and recursion, and declare inputs and basic structure for executability.
</think>
```json
{
  "helper_functions": "(define-fun SafeI ((v Value)) Int\n  (ite (is-IntVal v) (ival v) 0))\n\n(define-fun-rec length ((l Value)) Int\n  (ite (is-Nil l)\n       0\n       (ite (is-Cons l)\n            (+ 1 (length (tail l)))\n            0)))\n\n(define-fun-rec IsList ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (IsList (tail l))\n            false)))\n\n(define-fun-rec list_all_int ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (and (is-IntVal (head l))\n                 (list_all_int (tail l)))\n            false)))",
  "basic_structure": "",
  "inputs": "(declare-const nums Value)\n(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList nums))",
    "assert_1": "(define-fun C1 () Bool (is-IntVal n))",
    "assert_2": "(define-fun C2 () Bool (> (SafeI n) 0))",
    "assert_3": "(define-fun C3 () Bool (list_all_int nums))",
    "assert_4": "(define-fun C4 () Bool (> (length nums) (SafeI n)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/6

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: differ_At_One_Bit_Pos
Problem Description:
"""
Write a python function to check whether the two numbers differ at one bit position only or not.
assert differ_At_One_Bit_Pos(13,9) == True
"""


def is_Power_Of_Two(x: int): 
    return x > 0 and (x & (x - 1)) == 0
def differ_At_One_Bit_Pos(a: int,b: int):

    assert isinstance(a, int), "invalid inputs" # $_CONTRACT_$
    assert isinstance(b, int), "invalid inputs" # $_CONTRACT_$ 
    return is_Power_Of_Two(a ^ b)


Contract List:
assert_0: assert isinstance(a, int), "invalid inputs
assert_1: assert isinstance(b, int), "invalid inputs


<think>
I translate the Python type checks into corresponding SMT-LIB predicates C0 and C1, provide a safe integer extractor helper to preserve executability without imposing shape invariants in BASIC_STRUCTURE, and declare inputs as Values.
</think>
```json
{
  "helper_functions": "(define-fun safe-ival ((v Value)) Int\n  (ite (is-IntVal v) (ival v) 0))",
  "basic_structure": "",
  "inputs": "(declare-const a Value)\n(declare-const b Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal a))",
    "assert_1": "(define-fun C1 () Bool (is-IntVal b))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/7

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: find_char_long
Problem Description:
"""
Write a function to find all words which are at least 4 characters long in a string.
assert set(find_char_long('Please move back to stream')) == set(['Please', 'move', 'back', 'stream'])
"""


import re
def find_char_long(text):

  assert isinstance(text, str), "invalid inputs" # $_CONTRACT_$
  return (re.findall(r"\b\w{4,}\b", text))


Contract List:
assert_0: assert isinstance(text, str), "invalid inputs


<think>
I model the single Python assertion as an SMT predicate C0 ensuring the input is a StrVal. No extra helpers or invariants are needed beyond declaring the ADT and the input.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "",
  "inputs": "(declare-const text Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-StrVal text))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/8

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: square_nums
Problem Description:
"""
Write a function to find squares of individual elements in a list.
assert square_nums([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])==[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
"""


def square_nums(nums):

 assert isinstance(nums, list), "invalid inputs" # $_CONTRACT_$
 assert all(isinstance(i, (int, float)) for i in nums), "invalid inputs" # $_CONTRACT_$
 return [i**2 for i in nums]


Contract List:
assert_0: assert isinstance(nums, list), "invalid inputs
assert_1: assert all(isinstance(i, (int, float)) for i in nums), "invalid inputs


<think>
I translated the Python assertions into SMT‐LIB predicates by first defining recursive ADT‐safe helpers (IsList and list_all_numeric) guarded by datatype testers, then mapping each assert to a named Ck predicate while ensuring the input can always be deconstructed safely.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (let ((t (tail v)))\n              (IsList t))\n            false)))\n\n(define-fun IsNumeric ((v Value)) Bool\n  (or (is-IntVal v) (is-FloatVal v)))\n\n(define-fun-rec list_all_numeric ((lst Value)) Bool\n  (ite (is-Nil lst)\n       true\n       (ite (is-Cons lst)\n            (let ((h (head lst)) (t (tail lst)))\n              (and (IsNumeric h)\n                   (list_all_numeric t)))\n            false)))",
  "basic_structure": "(assert (IsList nums))",
  "inputs": "(declare-const nums Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList nums))",
    "assert_1": "(define-fun C1 () Bool (list_all_numeric nums))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/9

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: find_Rotations
Problem Description:
"""
Write a python function to find the minimum number of rotations (greater than 0) required to get the same string.
assert find_Rotations("aaaa") == 1
"""


def find_Rotations(s):

    assert isinstance(s, str), "invalid inputs" # $_CONTRACT_$
    assert len(s) > 0, "invalid inputs" # $_CONTRACT_$
 
    n = len(s)
    s += s
    for i in range(1, n + 1):
        if s[i: i + n] == s[0: n]:
            return i
    return n


Contract List:
assert_0: assert isinstance(s, str), "invalid inputs
assert_1: assert len(s) > 0, "invalid inputs


<think>
I translated the Python type and length assertions into precise SMT predicates with a safe string-length helper, kept basic structure minimal, and declared `s` as a `Value`. Each contract predicate C0/C1 matches the original assertion semantics.
</think>
```json
{
  "helper_functions": "(define-fun str_len ((v Value)) Int\n  (ite (is-StrVal v) (str.len (sval v)) 0))",
  "basic_structure": "",
  "inputs": "(declare-const s Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool\n  (is-StrVal s))",
    "assert_1": "(define-fun C1 () Bool\n  (and (is-StrVal s) (> (str_len s) 0)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/11

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: remove_Occ
Problem Description:
"""
Write a python function to remove first and last occurrence of a given character from the string.
assert remove_Occ("hello","l") == "heo"
"""


def remove_Occ(s,ch):

    assert isinstance(s, str), "invalid inputs" # $_CONTRACT_$
    assert isinstance(ch, str), "invalid inputs" # $_CONTRACT_$
    assert len(s) > 0, "invalid inputs" # $_CONTRACT_$
    assert len(ch) == 1, "invalid inputs" # $_CONTRACT_$
 
    s = s.replace(ch, '', 1)
    s = s[::-1].replace(ch, '', 1)[::-1]
    return s 


Contract List:
assert_0: assert isinstance(s, str), "invalid inputs
assert_1: assert isinstance(ch, str), "invalid inputs
assert_2: assert len(s) > 0, "invalid inputs
assert_3: assert len(ch) == 1, "invalid inputs


<think>
I translate each Python assertion into a standalone SMT-LIB predicate, using is-StrVal guards for safe string operations and ensuring each contract is independently satisfiable. No extra helper functions or core invariants are needed beyond the ADT for this simple string‐based validation.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "",
  "inputs": "(declare-const s Value)\n(declare-const ch Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-StrVal s))",
    "assert_1": "(define-fun C1 () Bool (is-StrVal ch))",
    "assert_2": "(define-fun C2 () Bool (and (is-StrVal s) (> (str.len (sval s)) 0)))",
    "assert_3": "(define-fun C3 () Bool (and (is-StrVal ch) (= (str.len (sval ch)) 1)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/12

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: sort_matrix
Problem Description:
"""
Write a function to sort a given matrix in ascending order according to the sum of its rows.
assert sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]])==[[1, 1, 1], [1, 2, 3], [2, 4, 5]]
"""


def sort_matrix(M):

    assert isinstance(M, list), "invalid inputs" # $_CONTRACT_$
    assert len(M) > 0, "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(row, list) for row in M), "invalid inputs" # $_CONTRACT_$
    assert len(M[0]) > 0, "invalid inputs" # $_CONTRACT_$
    assert all(len(row) == len(M[0]) for row in M), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(item, (int, float)) for row in M for item in row), "invalid inputs" # $_CONTRACT_$
    result = sorted(M, key=sum)
    return result


Contract List:
assert_0: assert isinstance(M, list), "invalid inputs
assert_1: assert len(M) > 0, "invalid inputs
assert_2: assert all(isinstance(row, list) for row in M), "invalid inputs
assert_3: assert len(M[0]) > 0, "invalid inputs
assert_4: assert all(len(row) == len(M[0]) for row in M), "invalid inputs
assert_5: assert all(isinstance(item, (int, float)) for row in M for item in row), "invalid inputs


<think>
I will analyze the input validation assertions for sort_matrix and translate them into named SMT-LIB predicates C0..C5. I define ADT‐based recursive helpers to ensure safe list operations and numeric checks, and isolate each contract for standalone satisfiability.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Cons v)\n       (IsList (tail v))\n       (is-Nil v)))\n\n(define-fun-rec length ((v Value)) Int\n  (ite (is-Cons v)\n       (+ 1 (length (tail v)))\n       0))\n\n(define-fun-rec list_all_numeric ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (or (is-IntVal (head v)) (is-FloatVal (head v)))\n                 (list_all_numeric (tail v)))\n            false)))\n\n(define-fun-rec matrix_is_list ((M Value)) Bool\n  (ite (is-Nil M)\n       true\n       (ite (is-Cons M)\n            (and (IsList (head M))\n                 (matrix_is_list (tail M)))\n            false)))\n\n(define-fun-rec matrix_all_numeric ((M Value)) Bool\n  (ite (is-Nil M)\n       true\n       (ite (is-Cons M)\n            (and (list_all_numeric (head M))\n                 (matrix_all_numeric (tail M)))\n            false)))\n\n(define-fun-rec matrix_row_length_eq ((M Value) (n Int)) Bool\n  (ite (is-Nil M)\n       true\n       (ite (is-Cons M)\n            (and (= (length (head M)) n)\n                 (matrix_row_length_eq (tail M) n))\n            false)))",
  "basic_structure": "(assert (IsList M))",
  "inputs": "(declare-const M Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList M))",
    "assert_1": "(define-fun C1 () Bool (> (length M) 0))",
    "assert_2": "(define-fun C2 () Bool (matrix_is_list M))",
    "assert_3": "(define-fun C3 () Bool (ite (is-Cons M) (> (length (head M)) 0) false))",
    "assert_4": "(define-fun C4 () Bool (ite (is-Cons M) (matrix_row_length_eq (tail M) (length (head M))) false))",
    "assert_5": "(define-fun C5 () Bool (matrix_all_numeric M))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/14

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: find_Volume
Problem Description:
"""
Write a python function to find the volume of a triangular prism.
assert find_Volume(10,8,6) == 240
"""


def find_Volume(l,b,h) :

    assert isinstance(l, (int, float)), "invalid inputs" # $_CONTRACT_$
    assert isinstance(b, (int, float)), "invalid inputs" # $_CONTRACT_$
    assert isinstance(h, (int, float)), "invalid inputs" # $_CONTRACT_$
    assert l > 0, "invalid inputs" # $_CONTRACT_$
    assert b > 0, "invalid inputs" # $_CONTRACT_$
    assert h > 0, "invalid inputs" # $_CONTRACT_$
 
    return ((l * b * h) / 2) 


Contract List:
assert_0: assert isinstance(l, (int, float)), "invalid inputs
assert_1: assert isinstance(b, (int, float)), "invalid inputs
assert_2: assert isinstance(h, (int, float)), "invalid inputs
assert_3: assert l > 0, "invalid inputs
assert_4: assert b > 0, "invalid inputs
assert_5: assert h > 0, "invalid inputs


<think>
I will translate each Python `assert` into a precise SMT-LIB predicate, define minimal helper functions to check numeric types and extract real values, and include a trivial basic structure to ensure the template remains satisfiable even when all contracts are negated.
</think>
```json
{
  "helper_functions": "(define-fun IsNumeric ((v Value)) Bool (or (is-IntVal v) (is-FloatVal v)))\n(define-fun V2Real ((v Value)) Real (ite (is-IntVal v) (to_real (ival v)) (ite (is-FloatVal v) (fval v) 0.0)))",
  "basic_structure": "(assert true)",
  "inputs": "(declare-const l Value)\n(declare-const b Value)\n(declare-const h Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsNumeric l))",
    "assert_1": "(define-fun C1 () Bool (IsNumeric b))",
    "assert_2": "(define-fun C2 () Bool (IsNumeric h))",
    "assert_3": "(define-fun C3 () Bool (> (V2Real l) 0.0))",
    "assert_4": "(define-fun C4 () Bool (> (V2Real b) 0.0))",
    "assert_5": "(define-fun C5 () Bool (> (V2Real h) 0.0))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/16

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: text_lowercase_underscore
Problem Description:
"""
Write a function to that returns true if the input string contains sequences of lowercase letters joined with an underscore and false otherwise.
assert text_lowercase_underscore("aab_cbbbc")==(True)
"""


import re
def text_lowercase_underscore(text):

        assert isinstance(text, str), "invalid inputs" # $_CONTRACT_$
        assert len(text) > 0, "invalid inputs" # $_CONTRACT_$
        return bool(re.match('^[a-z]+(_[a-z]+)*$', text))


Contract List:
assert_0: assert isinstance(text, str), "invalid inputs
assert_1: assert len(text) > 0, "invalid inputs


<think>
I model the Python string input as a Value ADT with a SafeStr extractor to guard against non-string values. I then define two contract predicates: C0 checking the StrVal type and C1 ensuring the string length is positive, using SafeStr for selector safety.
</think>
```json
{
  "helper_functions": "(define-fun SafeStr ((v Value)) String (ite (is-StrVal v) (sval v) \"\"))",
  "basic_structure": "",
  "inputs": "(declare-const text Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-StrVal text))",
    "assert_1": "(define-fun C1 () Bool (> (str.len (SafeStr text)) 0))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/17

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: square_perimeter
Problem Description:
"""
Write a function that returns the perimeter of a square given its side length as input.
assert square_perimeter(10)==40
"""


def square_perimeter(a):

  assert isinstance(a, (int, float)), "invalid inputs" # $_CONTRACT_$
  assert a > 0, "invalid inputs" # $_CONTRACT_$
  return 4*a


Contract List:
assert_0: assert isinstance(a, (int, float)), "invalid inputs
assert_1: assert a > 0, "invalid inputs


<think>
I represent the Value ADT and define an IsNumeric helper to guard type checks. Then I translate each assert into a Boolean predicate: C0 ensures the argument is Int or Float, and C1 enforces it is positive using guarded selectors.
</think>
```json
{
  "helper_functions": "(define-fun IsNumeric ((v Value)) Bool (or (is-IntVal v) (is-FloatVal v)))",
  "basic_structure": "",
  "inputs": "(declare-const a Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsNumeric a))",
    "assert_1": "(define-fun C1 () Bool (ite (is-IntVal a) (> (ival a) 0) (ite (is-FloatVal a) (> (fval a) 0) false)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/18

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: remove_dirty_chars
Problem Description:
"""
Write a function to remove characters from the first string which are present in the second string.
assert remove_dirty_chars("probasscurve", "pros") == 'bacuve'
"""


def remove_dirty_chars(string, second_string):

	assert isinstance(string, str), "invalid inputs" # $_CONTRACT_$
	assert isinstance(second_string, str), "invalid inputs" # $_CONTRACT_$
	assert len(string) > 0, "invalid inputs" # $_CONTRACT_$
	assert len(second_string) > 0, "invalid inputs" # $_CONTRACT_$
 
	for char in second_string:
		string = string.replace(char, '')
	return string


Contract List:
assert_0: assert isinstance(string, str), "invalid inputs
assert_1: assert isinstance(second_string, str), "invalid inputs
assert_2: assert len(string) > 0, "invalid inputs
assert_3: assert len(second_string) > 0, "invalid inputs


<think>
I translate each Python assert into an SMT-LIB Bool predicate Ck, using a SafeS helper to extract strings safely. I declare the inputs as generic Values, define the necessary helper, and then precisely capture each contract’s semantics without embedding extraneous invariants.
</think>
```json
{
  "helper_functions": "(define-fun SafeS ((v Value)) String\n  (ite (is-StrVal v) (sval v) \"\"))",
  "basic_structure": "",
  "inputs": "(declare-const string Value)\n(declare-const second_string Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-StrVal string))",
    "assert_1": "(define-fun C1 () Bool (is-StrVal second_string))",
    "assert_2": "(define-fun C2 () Bool (> (str.len (SafeS string)) 0))",
    "assert_3": "(define-fun C3 () Bool (> (str.len (SafeS second_string)) 0))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/19

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: test_duplicate
Problem Description:
"""
Write a function to find whether a given array of integers contains any duplicate element.
assert test_duplicate(([1,2,3,4,5]))==False
"""


def test_duplicate(arraynums):

    assert isinstance(arraynums, list), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(item, int) for item in arraynums), "invalid inputs" # $_CONTRACT_$
    return len(arraynums) != len(set(arraynums))


Contract List:
assert_0: assert isinstance(arraynums, list), "invalid inputs
assert_1: assert all(isinstance(item, int) for item in arraynums), "invalid inputs


<think>
I will define helper functions to model list structure and integer-only lists, declare the array input, assert basic list shape for executability, and translate each Python assertion into a separate SMT predicate C0 and C1.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (or (is-Nil v)\n      (and (is-Cons v)\n           (IsList (tail v)))))\n\n(define-fun-rec list_all_ints ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (and (is-Cons v)\n            (let ((hd (head v)) (rest (tail v)))\n              (and (is-IntVal hd)\n                   (list_all_ints rest))))))",
  "basic_structure": "(assert (IsList arraynums))",
  "inputs": "(declare-const arraynums Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList arraynums))",
    "assert_1": "(define-fun C1 () Bool (list_all_ints arraynums))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/20

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: is_woodall
Problem Description:
"""
Write a function to check if the given number is woodball or not.
assert is_woodall(383) == True
"""


def is_woodall(x):

	assert isinstance(x, (int, float)), "invalid inputs" # $_CONTRACT_$
 
	if not isinstance(x, int):
		return False
	if x <= 0 or x % 2 == 0:
		return False
	if (x == 1): 
		return True
	x += 1 
	i = 0
	while (x % 2 == 0): 
		x /= 2
		i += 1
		if (i == x): 
			return True
	return False


Contract List:
assert_0: assert isinstance(x, (int, float)), "invalid inputs


<think>
I capture the single type‐check assertion as a Boolean predicate over the ADT, define helpers for safely extracting Int/Float values, declare the input, and leave the minimal basic structure empty since no further invariants are needed.
</think>
```json
{
  "helper_functions": "(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))\n(define-fun SafeF ((v Value)) Real (ite (is-FloatVal v) (fval v) 0.0))",
  "basic_structure": "",
  "inputs": "(declare-const x Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (or (is-IntVal x) (is-FloatVal x)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/56

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: check
Problem Description:
"""
Write a python function to check if a given number is one less than twice its reverse.
assert check(70) == False
"""


def check(n):

    assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
    assert n >= 0, "invalid inputs" # $_CONTRACT_$
    
    return n == 2 * int(str(n)[::-1]) - 1


Contract List:
assert_0: assert isinstance(n, int), "invalid inputs
assert_1: assert n >= 0, "invalid inputs


<think>
I translate the Python type and range assertions into precise SMT predicates, defining a safe integer extractor to guard selectors. I assert basic executability invariants, declare inputs, and map each contract to a standalone Boolean definition.
</think>
```json
{
  "helper_functions": "(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
  "basic_structure": "(assert (is-IntVal n))",
  "inputs": "(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
    "assert_1": "(define-fun C1 () Bool (and C0 (>= (SafeI n) 0)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/57

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: find_Max_Num
Problem Description:
"""
Write a python function to find the largest number that can be formed with the given list of digits.
assert find_Max_Num([1,2,3]) == 321
"""


def find_Max_Num(arr) :

    assert isinstance(arr, list), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(item, int) and 0 <= item <= 9 for item in arr), "invalid inputs" # $_CONTRACT_$
 
    arr.sort(reverse = True)
    return int("".join(map(str,arr)))


Contract List:
assert_0: assert isinstance(arr, list), "invalid inputs
assert_1: assert all(isinstance(item, int) and 0 <= item <= 9 for item in arr), "invalid inputs


<think>
I will encode the Python list‐and‐integer assertions as precise SMT predicates over a canonical Value ADT, define recursive helpers for list shape and digit checks, assert the minimal executability constraint, and expose each Python assert as a named Bool (C0, C1).
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((x Value)) Bool\n  (ite (is-Nil x)\n       true\n       (ite (is-Cons x)\n            (IsList (tail x))\n            false)))\n\n(define-fun-rec ListAllNumeric ((x Value)) Bool\n  (ite (is-Nil x)\n       true\n       (ite (is-Cons x)\n            (let ((h (head x)) (rest (tail x)))\n              (and (is-IntVal h)\n                   (let ((n (ival h))) (and (<= 0 n) (<= n 9)))\n                   (ListAllNumeric rest)))\n            false)))",
  "basic_structure": "(assert (IsList arr))",
  "inputs": "(declare-const arr Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList arr))",
    "assert_1": "(define-fun C1 () Bool (ListAllNumeric arr))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/58

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: opposite_Signs
Problem Description:
"""
Write a python function to check whether the given two integers have opposite sign or not.
assert opposite_Signs(1,-2) == True
"""


def opposite_Signs(x,y):

    assert isinstance(x, int), "invalid inputs" # $_CONTRACT_$
    assert isinstance(y, int), "invalid inputs" # $_CONTRACT_$
 
    return ((x ^ y) < 0) 


Contract List:
assert_0: assert isinstance(x, int), "invalid inputs
assert_1: assert isinstance(y, int), "invalid inputs


<think>
I model each input as a Value and provide a safe_ival helper to extract Int under the IntVal tester, ensuring selector safety. I then declare x and y, leave the basic structure trivial (no extra invariants), and define C0 and C1 exactly matching isinstance(x, int) and isinstance(y, int).
</think>
```json
{
  "helper_functions": "(define-fun safe_ival ((v Value)) Int\n  (ite (is-IntVal v) (ival v) 0))",
  "basic_structure": "",
  "inputs": "(declare-const x Value)\n(declare-const y Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal x))",
    "assert_1": "(define-fun C1 () Bool (is-IntVal y))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/59

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: is_octagonal
Problem Description:
"""
Write a function to find the nth octagonal number.
assert is_octagonal(5) == 65
"""


def is_octagonal(n):

	assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
	assert n > 0, "invalid inputs" # $_CONTRACT_$
 
	return 3 * n * n - 2 * n 


Contract List:
assert_0: assert isinstance(n, int), "invalid inputs
assert_1: assert n > 0, "invalid inputs


<think>
I introduce a SafeI helper to safely extract integers from the Value ADT, then define each contract as a Boolean predicate C0/C1 matching the Python asserts. The base template ensures selector safety and maintains precise semantics.
</think>
```json
{
  "helper_functions": "(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
  "basic_structure": "",
  "inputs": "(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
    "assert_1": "(define-fun C1 () Bool (> (SafeI n) 0))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/61

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: count_Substrings
Problem Description:
"""
Write a python function to count the number of substrings with the sum of digits equal to their length.
assert count_Substrings('112112') == 6
"""


from collections import defaultdict
def count_Substrings(s):

    assert isinstance(s, str), "invalid inputs" # $_CONTRACT_$
    assert s.isdigit(), "invalid inputs" # $_CONTRACT_$
    n, count, sum = len(s), 0, 0
    mp = defaultdict(lambda : 0)
    mp[0] += 1
    for i in range(n):
        sum += ord(s[i]) - ord('0')
        count += mp[sum - i - 1]
        mp[sum - i - 1] += 1
    return count


Contract List:
assert_0: assert isinstance(s, str), "invalid inputs
assert_1: assert s.isdigit(), "invalid inputs


<think>
I translate the Python string and digit assertions into precise SMT-LIB predicates, defining helpers to safely extract string values and to check for all-digit content, while keeping the base executability unconstrained.
</think>
```json
{
  "helper_functions": "(define-fun SafeS ((v Value)) String\n  (ite (is-StrVal v) (sval v) \"\"))\n(define-fun is_digit_str ((v Value)) Bool\n  (and (is-StrVal v)\n       (str.in.re (sval v)\n         (re.* (re.union (str.to.re \"0\") (str.to.re \"1\") (str.to.re \"2\") (str.to.re \"3\") (str.to.re \"4\") (str.to.re \"5\") (str.to.re \"6\") (str.to.re \"7\") (str.to.re \"8\") (str.to.re \"9\"))))))",
  "basic_structure": "",
  "inputs": "(declare-const s Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-StrVal s))",
    "assert_1": "(define-fun C1 () Bool (is_digit_str s))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/62

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: smallest_num
Problem Description:
"""
Write a python function to find smallest number in a list.
assert smallest_num([10, 20, 1, 45, 99]) == 1
"""


def smallest_num(xs):

  assert isinstance(xs, list), "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(item, (int, float)) for item in xs), "invalid inputs" # $_CONTRACT_$
  assert len(xs) > 0, "invalid inputs"
  return min(xs)


Contract List:
assert_0: assert isinstance(xs, list), "invalid inputs
assert_1: assert all(isinstance(item, (int, float)) for item in xs), "invalid inputs


<think>
I translated each Python assertion into a precise SMT predicate, introduced safe recursive checks for list structure and numeric elements, and kept basic structure empty since all executability guards live inside contract predicates via testers.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec list_all_numeric ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (and (or (is-IntVal (head l)) (is-FloatVal (head l)))\n                 (list_all_numeric (tail l)))\n            false)))",
  "basic_structure": "",
  "inputs": "(declare-const xs Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList xs))",
    "assert_1": "(define-fun C1 () Bool (and (IsList xs) (list_all_numeric xs)))",
    "assert_2": "(define-fun C2 () Bool (and (IsList xs) (not (is-Nil xs))))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/63

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: max_difference
Problem Description:
"""
Write a function to find the maximum difference between available pairs in the given tuple list.
assert max_difference([(3, 5), (1, 7), (10, 3), (1, 2)]) == 7
"""


def max_difference(test_list):

  assert isinstance(test_list, list), "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(item, tuple) and len(item) == 2 for item in test_list), "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(a, (int, float)) and isinstance(b, (int, float)) for a, b in test_list), "invalid inputs" # $_CONTRACT_$
  return max(abs(a - b) for a, b in test_list)


Contract List:
assert_0: assert isinstance(test_list, list), "invalid inputs
assert_1: assert all(isinstance(item, tuple) and len(item) == 2 for item in test_list), "invalid inputs
assert_2: assert all(isinstance(a, (int, float)) and isinstance(b, (int, float)) for a, b in test_list), "invalid inputs


<think>
I will introduce a TupleVal constructor, define recursive helpers for list shape and element checks, then map each Python assertion to a Bool predicate using those helpers.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (ite (is-Nil l) true\n    (ite (is-Cons l)\n         (IsList (tail l))\n         false)))\n\n(define-fun-rec AllTuple2 ((l Value)) Bool\n  (ite (is-Nil l) true\n    (ite (is-Cons l)\n         (and (is-TupleVal (head l))\n              (AllTuple2 (tail l)))\n         false)))\n\n(define-fun-rec AllNumericPairs ((l Value)) Bool\n  (ite (is-Nil l) true\n    (ite (is-Cons l)\n         (let ((h (head l)))\n           (and (is-TupleVal h)\n                (let ((a (tfirst h)) (b (tsecond h)))\n                  (and (or (is-IntVal a) (is-FloatVal a))\n                       (or (is-IntVal b) (is-FloatVal b))\n                       (AllNumericPairs (tail l))))))\n         false)))",
  "basic_structure": "",
  "inputs": "(declare-const test_list Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList test_list))",
    "assert_1": "(define-fun C1 () Bool (AllTuple2 test_list))",
    "assert_2": "(define-fun C2 () Bool (AllNumericPairs test_list))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/64

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: subject_marks
Problem Description:
"""
Write a function to sort a list of tuples using the second value of each tuple.
assert subject_marks([('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)])==[('Social sciences', 82), ('English', 88), ('Science', 90), ('Maths', 97)]
"""


def subject_marks(subjectmarks):

 assert isinstance(subjectmarks, list), "invalid inputs" # $_CONTRACT_$
 assert all(isinstance(item, tuple) and len(item) >= 2 for item in subjectmarks), "invalid inputs" # $_CONTRACT_$
 assert all(isinstance(item[1], (int, float)) for item in subjectmarks), "invalid inputs" # $_CONTRACT_$
#subject_marks = [('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)])
 subjectmarks.sort(key = lambda x: x[1])
 return subjectmarks


Contract List:
assert_0: assert isinstance(subjectmarks, list), "invalid inputs
assert_1: assert all(isinstance(item, tuple) and len(item) >= 2 for item in subjectmarks), "invalid inputs
assert_2: assert all(isinstance(item[1], (int, float)) for item in subjectmarks), "invalid inputs


<think>
I translate each Python assertion into precise SMT-LIB predicates, defining recursive helpers for list shape, tuple-length, and numeric-second checks. I ensure all inputs satisfy the ADT structure (Value) and expose each contract as a named Boolean (C0, C1, C2).
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v) true\n    (ite (is-Cons v) (IsList (tail v)) false)))\n(define-fun IsNumericValue ((v Value)) Bool\n  (or (is-IntVal v) (is-FloatVal v)))\n(define-fun-rec AllTuplesMin2 ((l Value)) Bool\n  (ite (is-Nil l) true\n    (ite (is-Cons l)\n      (let ((item (head l)) (rest (tail l)))\n        (and (is-Cons item)\n             (let ((itemTail (tail item))) (is-Cons itemTail))\n             (AllTuplesMin2 rest)))\n      false)))\n(define-fun-rec AllNumericSecond ((l Value)) Bool\n  (ite (is-Nil l) true\n    (ite (is-Cons l)\n      (let ((item (head l)) (rest (tail l)))\n        (let ((second (ite (is-Cons item) (head (tail item)) Nil)))\n          (and (IsNumericValue second)\n               (AllNumericSecond rest))))\n      false)))",
  "basic_structure": "(assert (IsList subjectmarks))",
  "inputs": "(declare-const subjectmarks Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList subjectmarks))",
    "assert_1": "(define-fun C1 () Bool (AllTuplesMin2 subjectmarks))",
    "assert_2": "(define-fun C2 () Bool (AllNumericSecond subjectmarks))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/65

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: recursive_list_sum
Problem Description:
"""
Write a function to flatten a list and sum all of its elements.
assert recursive_list_sum(([1, 2, [3,4],[5,6]]))==21
"""


def recursive_list_sum(data_list):

	def list_check(l): # $_CONTRACT_$
		if not isinstance(l, list): # $_CONTRACT_$
			return isinstance(l, (int, float)) # $_CONTRACT_$
		else: # $_CONTRACT_$
			return all(list_check(item) for item in l) # $_CONTRACT_$
	assert isinstance(data_list, list), "invalid inputs" # $_CONTRACT_$
	assert list_check(data_list), "invalid inputs" # $_CONTRACT_$
	total = 0
	for element in data_list:
		if type(element) == type([]):
			total = total + recursive_list_sum(element)
		else:
			total = total + element
	return total


Contract List:
assert_0: assert isinstance(data_list, list), "invalid inputs
assert_1: assert list_check(data_list), "invalid inputs


I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.

```json
{
  "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (or\n    (is-Nil l)\n    (and (is-Cons l) (IsList (tail l)))))\n\n(define-fun-rec list_check ((l Value)) Bool\n  (ite (is-Cons l)\n       (and (list_check (head l)) (list_check (tail l)))\n       (ite (is-Nil l)\n            true\n            (or (is-IntVal l) (is-FloatVal l)))))",
  "basic_structure": "",
  "inputs": "(declare-const data_list Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList data_list))",
    "assert_1": "(define-fun C1 () Bool (list_check data_list))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/66

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: pos_count
Problem Description:
"""
Write a python function to count the number of positive numbers in a list.
assert pos_count([1,-2,3,-4]) == 2
"""


def pos_count(l):

  assert isinstance(l, list), "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(item, (int, float)) for item in l), "invalid inputs" # $_CONTRACT_$
  return len([x for x in l if x > 0])


Contract List:
assert_0: assert isinstance(l, list), "invalid inputs
assert_1: assert all(isinstance(item, (int, float)) for item in l), "invalid inputs


<think>
I translated the Python type and structural assertions into precise SMT-LIB predicates, defining recursive helpers for list shape and numeric checks, and separated basic execution constraints from test-specific contracts. I also enumerated all combinations of contract satisfactions to support systematic violation testing.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((x Value)) Bool\n  (or\n    (is-Nil x)\n    (and (is-Cons x)\n         (let ((tailVal (tail x)))\n           (IsList tailVal)))))\n\n(define-fun-rec list_all_numeric ((x Value)) Bool\n  (ite (is-Nil x)\n       true\n       (ite (is-Cons x)\n            (let ((headVal (head x))\n                  (tailVal (tail x)))\n              (ite (or (is-IntVal headVal) (is-FloatVal headVal))\n                   (list_all_numeric tailVal)\n                   false))\n            false)))",
  "basic_structure": "(assert (IsList l))",
  "inputs": "(declare-const l Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList l))",
    "assert_1": "(define-fun C1 () Bool (list_all_numeric l))"
  },
  "combination": "(define-fun comb_both_valid () Bool (and C0 C1))\n(define-fun comb_only_C0 () Bool (and C0 (not C1)))\n(define-fun comb_only_C1 () Bool (and (not C0) C1))\n(define-fun comb_neither_valid () Bool (and (not C0) (not C1)))"
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/67

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: bell_number
Problem Description:
"""
Write a function to find the number of ways to partition a set of Bell numbers.
assert bell_number(2)==2
"""


def bell_number(n):

    assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
    assert n >= 0, "invalid inputs" # $_CONTRACT_$
    assert n <= 100, "invalid inputs" # $_CONTRACT_$
   
    bell = [[0 for i in range(n+1)] for j in range(n+1)] 
    bell[0][0] = 1
    for i in range(1, n+1): 
        bell[i][0] = bell[i-1][i-1]  
        for j in range(1, i+1): 
            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]   
    return bell[n][0] 


Contract List:
assert_0: assert isinstance(n, int), "invalid inputs
assert_1: assert n >= 0, "invalid inputs
assert_2: assert n <= 100, "invalid inputs


<think>
I will model the integer input using the Value ADT, provide a safe selector to extract its IntVal, assert the basic type invariant, and then encode each Python assertion as a named Bool predicate C0–C2.
</think>
```json
{
  "helper_functions": "(define-fun safe-ival ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
  "basic_structure": "(assert (is-IntVal n))",
  "inputs": "(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
    "assert_1": "(define-fun C1 () Bool (>= (safe-ival n) 0))",
    "assert_2": "(define-fun C2 () Bool (<= (safe-ival n) 100))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/68

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: is_Monotonic
Problem Description:
"""
Write a python function to check whether the given array is monotonic or not.
assert is_Monotonic([6, 5, 4, 4]) == True
"""


def is_Monotonic(A):

    assert isinstance(A, list), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(item, (int, float)) for item in A), "invalid inputs" # $_CONTRACT_$
 
    return all(a <= b for a, b in zip(A, A[1:])) or all(a >= b for a, b in zip(A, A[1:]))


Contract List:
assert_0: assert isinstance(A, list), "invalid inputs
assert_1: assert all(isinstance(item, (int, float)) for item in A), "invalid inputs


<think>
I define recursive helper functions IsList and ListAllNumeric to capture the list shape and numeric-item constraints, declare the input A as a Value, assert the basic list‐shape invariant for executability, and then encode each Python assert as a separate Boolean predicate C0 and C1.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (or (is-Nil v)\n      (and (is-Cons v)\n           (IsList (tail v)))))\n(define-fun-rec ListAllNumeric ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (or (is-IntVal (head v)) (is-FloatVal (head v)))\n                 (ListAllNumeric (tail v)))\n            false)))",
  "basic_structure": "(assert (IsList A))",
  "inputs": "(declare-const A Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList A))",
    "assert_1": "(define-fun C1 () Bool (ListAllNumeric A))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/69

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: is_sublist
Problem Description:
"""
Write a function to check whether a list contains the given sublist or not.
assert is_sublist([2,4,3,5,7],[3,7])==False
"""


def is_sublist(l, s):

	assert isinstance(l, list), "invalid inputs" # $_CONTRACT_$
	assert isinstance(s, list), "invalid inputs" # $_CONTRACT_$
	if len(l) < len(s):
		return False
	return any(l[i:i+len(s)] == s for i in range(len(l)-len(s)+1))


Contract List:
assert_0: assert isinstance(l, list), "invalid inputs
assert_1: assert isinstance(s, list), "invalid inputs


<think>
I define a recursive SMT ADT for lists via a guarded IsList predicate, declare inputs l and s of sort Value, assert they satisfy the list shape in the basic structure, and translate each isinstance assertion into a named Boolean predicate C0 and C1.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (IsList (head v)) (IsList (tail v)))\n            false)))",
  "basic_structure": "(assert (IsList l))\n(assert (IsList s))",
  "inputs": "(declare-const l Value)\n(declare-const s Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList l))",
    "assert_1": "(define-fun C1 () Bool (IsList s))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/70

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: get_equal
Problem Description:
"""
Write a function to find whether all the given tuples have equal length or not.
assert get_equal([(11, 22, 33), (44, 55, 66)]) == True
"""


def get_equal(Input):

  assert isinstance(Input, list), "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(item, tuple) for item in Input), "invalid inputs" # $_CONTRACT_$
  return len(set(len(item) for item in Input)) == 1


Contract List:
assert_0: assert isinstance(Input, list), "invalid inputs
assert_1: assert all(isinstance(item, tuple) for item in Input), "invalid inputs


<think>
I model Python’s list and tuple structures via recursive ADTs and helper functions IsList and AllTuple, then declare Input and define C0 and C1 exactly matching the two asserts. This preserves executability without mixing in test properties and keeps each contract standalone.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (or (is-Nil v)\n      (and (is-Cons v)\n           (IsList (tail v)))))\n\n(define-fun-rec AllTuple ((v Value)) Bool\n  (or (is-Nil v)\n      (and (is-Cons v)\n           (let ((h (head v)) (t (tail v)))\n             (and (is-TupleVal h)\n                  (AllTuple t))))))",
  "basic_structure": "",
  "inputs": "(declare-const Input Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList Input))",
    "assert_1": "(define-fun C1 () Bool (AllTuple Input))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/71

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: comb_sort
Problem Description:
"""
Write a function to sort a list of elements.
assert comb_sort([5, 15, 37, 25, 79]) == [5, 15, 25, 37, 79]
"""


def comb_sort(nums):

    assert isinstance(nums, list), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(item, (int, float)) for item in nums), "invalid inputs" # $_CONTRACT_$
    n = len(nums)
    gap = n
    shrink = 1.3
    swapped = True
    while gap > 1 or swapped:
        gap = int(gap / shrink)
        if gap < 1:
            gap = 1
        swapped = False
        for i in range(n - gap):
            if nums[i] > nums[i + gap]:
                nums[i], nums[i + gap] = nums[i + gap], nums[i]
                swapped = True
    return nums


Contract List:
assert_0: assert isinstance(nums, list), "invalid inputs
assert_1: assert all(isinstance(item, (int, float)) for item in nums), "invalid inputs


<think>
I translate Python’s list and numeric-type checks into recursive SMT predicates over a custom Value ADT, ensuring executability by asserting list structure upfront. Each contract maps to a Boolean predicate (C0, C1) reflecting the original assertions semantically.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (IsList (tail l))\n            false)))\n\n(define-fun-rec list_all_numeric ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (let ((h (head l)) (t (tail l)))\n              (ite (or (is-IntVal h) (is-FloatVal h))\n                   (list_all_numeric t)\n                   false))\n            false)))",
  "basic_structure": "(assert (IsList nums))",
  "inputs": "(declare-const nums Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList nums))",
    "assert_1": "(define-fun C1 () Bool (list_all_numeric nums))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/72

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: dif_Square
Problem Description:
"""
Write a python function to check whether the given number can be represented as the difference of two squares or not.
assert dif_Square(5) == True
"""


def dif_Square(n):

    assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
    assert n > 0, "invalid inputs" # $_CONTRACT_$
 
    # see https://www.quora.com/Which-numbers-can-be-expressed-as-the-difference-of-two-squares
    return n % 4 != 2


Contract List:
assert_0: assert isinstance(n, int), "invalid inputs
assert_1: assert n > 0, "invalid inputs


<think>
I translated the Python assertions into two standalone SMT-LIB predicates, ensuring Boolean contracts mirror the Python type and range checks. No extra helpers or structural invariants are needed beyond the tests themselves.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "",
  "inputs": "(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
    "assert_1": "(define-fun C1 () Bool (ite (is-IntVal n) (> (ival n) 0) false))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/74

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: is_samepatterns
Problem Description:
"""
Write a function to check whether it follows the sequence given in the patterns array.
assert is_samepatterns(["red","green","green"], ["a", "b", "b"])==True
"""


def is_samepatterns(colors, patterns):

    assert isinstance(colors, list), "invalid inputs" # $_CONTRACT_$
    assert isinstance(patterns, list), "invalid inputs" # $_CONTRACT_$
    
    if len(colors) != len(patterns):
        return False    
    pattern_color_dict = {pattern: set() for pattern in patterns}
    for color, pattern in zip(colors, patterns):
        pattern_color_dict[pattern].add(color)
    return all(len(pattern_color_dict[pattern]) == 1 for pattern in patterns)


Contract List:
assert_0: assert isinstance(colors, list), "invalid inputs
assert_1: assert isinstance(patterns, list), "invalid inputs


<think>
I map each Python isinstance check into an SMT Bool predicate using a recursive isList discriminator over the Value ADT, declare inputs as Value, enforce basic list-structure for executability, and define C0/C1 exactly matching the asserts.
</think>
```json
{
  "helper_functions": "(define-fun-rec isList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (isList (tail v))\n            false)))",
  "basic_structure": "(assert (isList colors))\n(assert (isList patterns))",
  "inputs": "(declare-const colors Value)\n(declare-const patterns Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (isList colors))",
    "assert_1": "(define-fun C1 () Bool (isList patterns))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/75

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: find_tuples
Problem Description:
"""
Write a function to find tuples which have all elements divisible by k from the given list of tuples.
assert find_tuples([(6, 24, 12), (7, 9, 6), (12, 18, 21)], 6) == [(6, 24, 12)]
"""


def find_tuples(test_list, K):

  assert isinstance(test_list, list), "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(item, tuple) for item in test_list), "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(item, int) for tuple in test_list for item in tuple), "invalid inputs" # $_CONTRACT_$
  assert isinstance(K, int), "invalid inputs" # $_CONTRACT_$
  assert K > 0, "invalid inputs" # $_CONTRACT_$
  res = [sub for sub in test_list if all(ele % K == 0 for ele in sub)]
  return res


Contract List:
assert_0: assert isinstance(test_list, list), "invalid inputs
assert_1: assert all(isinstance(item, tuple) for item in test_list), "invalid inputs
assert_2: assert all(isinstance(item, int) for tuple in test_list for item in tuple), "invalid inputs
assert_3: assert isinstance(K, int), "invalid inputs
assert_4: assert K > 0, "invalid inputs


<think>
I model tuples as nested lists within the single Value ADT and define recursive predicates to check list shapes and integer contents, along with a safe integer extractor. Each Python assert becomes a separate SMT‐LIB Bool predicate Ck.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (IsList (tail l))\n            false)))\n\n(define-fun SafeI ((v Value)) Int\n  (ite (is-IntVal v) (ival v) 0))\n\n(define-fun-rec list_elems_are_cons ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (let ((hd (head l)) (tl (tail l)))\n              (and (is-Cons hd)\n                   (list_elems_are_cons tl)))\n            false)))\n\n(define-fun-rec list_all_ints ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (let ((hd (head l)) (tl (tail l)))\n              (and (is-IntVal hd)\n                   (list_all_ints tl)))\n            false)))\n\n(define-fun-rec list_all_inner_ints ((outer Value)) Bool\n  (ite (is-Nil outer)\n       true\n       (ite (is-Cons outer)\n            (let ((inner (head outer)) (rest (tail outer)))\n              (and (list_all_ints inner)\n                   (list_all_inner_ints rest)))\n            false)))",
  "basic_structure": "",
  "inputs": "(declare-const test_list Value)\n(declare-const K Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList test_list))",
    "assert_1": "(define-fun C1 () Bool (list_elems_are_cons test_list))",
    "assert_2": "(define-fun C2 () Bool (list_all_inner_ints test_list))",
    "assert_3": "(define-fun C3 () Bool (is-IntVal K))",
    "assert_4": "(define-fun C4 () Bool (> (SafeI K) 0))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/77

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: is_Diff
Problem Description:
"""
Write a python function to find whether a number is divisible by 11.
assert is_Diff (12345) == False
"""


def is_Diff(n):

    assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
 
    return n % 11 == 0 


Contract List:
assert_0: assert isinstance(n, int), "invalid inputs


<think>
I map the Python isinstance(n, int) assertion to an SMT is-IntVal predicate on the Value n, ensuring the input is an integer at the ADT level. No extra helper functions or universal invariants are required for this single-contract scenario.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "",
  "inputs": "(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal n))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/79

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: word_len
Problem Description:
"""
Write a python function to check whether the length of the word is odd or not.
assert word_len("Hadoop") == False
"""


def word_len(s):

    assert isinstance(s, str), "invalid inputs" # $_CONTRACT_$
    assert s.isalpha(), "invalid inputs" # $_CONTRACT_$
 
    return len(s) % 2 == 1


Contract List:
assert_0: assert isinstance(s, str), "invalid inputs
assert_1: assert s.isalpha(), "invalid inputs


<think>
I translate the Python type and alphabetic assertions into SMT-LIB predicates, defining a regex-based helper for alphabetic checking and guarding string selectors to ensure semantic equivalence.
</think>
```json
{
  "helper_functions": "(define-fun alphaCharRe () (RegEx String)\n  (re.union\n    (str.to.re \"A\") (str.to.re \"B\") (str.to.re \"C\") (str.to.re \"D\") (str.to.re \"E\") (str.to.re \"F\") (str.to.re \"G\") (str.to.re \"H\") (str.to.re \"I\") (str.to.re \"J\") (str.to.re \"K\") (str.to.re \"L\") (str.to.re \"M\") (str.to.re \"N\") (str.to.re \"O\") (str.to.re \"P\") (str.to.re \"Q\") (str.to.re \"R\") (str.to.re \"S\") (str.to.re \"T\") (str.to.re \"U\") (str.to.re \"V\") (str.to.re \"W\") (str.to.re \"X\") (str.to.re \"Y\") (str.to.re \"Z\")\n    (str.to.re \"a\") (str.to.re \"b\") (str.to.re \"c\") (str.to.re \"d\") (str.to.re \"e\") (str.to.re \"f\") (str.to.re \"g\") (str.to.re \"h\") (str.to.re \"i\") (str.to.re \"j\") (str.to.re \"k\") (str.to.re \"l\") (str.to.re \"m\") (str.to.re \"n\") (str.to.re \"o\") (str.to.re \"p\") (str.to.re \"q\") (str.to.re \"r\") (str.to.re \"s\") (str.to.re \"t\") (str.to.re \"u\") (str.to.re \"v\") (str.to.re \"w\") (str.to.re \"x\") (str.to.re \"y\") (str.to.re \"z\")\n  )\n)\n(define-fun alphaRe () (RegEx String)\n  (re.* alphaCharRe)\n)",
  "basic_structure": "",
  "inputs": "(declare-const s Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-StrVal s))",
    "assert_1": "(define-fun C1 () Bool\n  (and\n    (is-StrVal s)\n    (> (str.len (sval s)) 0)\n    (str.in.re (sval s) alphaRe)\n  )\n)"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/80

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: tetrahedral_number
Problem Description:
"""
Write a function to find the nth tetrahedral number.
assert tetrahedral_number(5) == 35
"""


def tetrahedral_number(n):

	assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
	assert n >= 0, "invalid inputs" # $_CONTRACT_$
 
	return (n * (n + 1) * (n + 2)) / 6


Contract List:
assert_0: assert isinstance(n, int), "invalid inputs
assert_1: assert n >= 0, "invalid inputs


<think>
I will translate the input type and range assertions into standalone SMT-LIB predicates (C0, C1), ensure n’s ADT shape for execution in the basic structure, and declare the Value ADT once for safe extraction.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "(assert (is-IntVal n))",
  "inputs": "(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
    "assert_1": "(define-fun C1 () Bool (ite (is-IntVal n) (>= (ival n) 0) false))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/82

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: volume_sphere
Problem Description:
"""
Write a function to find the volume of a sphere.
assert math.isclose(volume_sphere(10), 4188.790204786391, rel_tol=0.001)
"""


import math
def volume_sphere(r):

  assert isinstance(r, (int, float)), "invalid inputs" # $_CONTRACT_$
  assert r > 0, "invalid inputs" # $_CONTRACT_$
  return (4./3.) * math.pi * (r**3)


Contract List:
assert_0: assert isinstance(r, (int, float)), "invalid inputs
assert_1: assert r > 0, "invalid inputs


<think>
I will translate the Python input checks into precise SMT-LIB predicates over the canonical Value ADT, guarding numeric selectors properly, and define standalone contract Booleans C0 and C1 to reflect the isinstance and positive-value requirements.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "(assert (or (is-IntVal r) (is-FloatVal r)))",
  "inputs": "(declare-const r Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (or (is-IntVal r) (is-FloatVal r)))",
    "assert_1": "(define-fun C1 () Bool (ite (is-IntVal r) (> (ival r) 0) (ite (is-FloatVal r) (> (fval r) 0.0) false)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/84

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: sequence
Problem Description:
"""
Write a function to find the nth number in the newman conway sequence.
assert sequence(10) == 6
"""


def sequence(n):

	assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
	assert n > 0, "invalid inputs" # $_CONTRACT_$
 
	if n == 1 or n == 2: 
		return 1
	seq = [0] * (n + 1)
	seq[1] = seq[2] = 1
	for i in range(3, n + 1):
		seq[i] = seq[seq[i - 1]] + seq[i - seq[i - 1]]
	return seq[n]


Contract List:
assert_0: assert isinstance(n, int), "invalid inputs
assert_1: assert n > 0, "invalid inputs


<think>
I model the input `n` as a `Value` and provide a `SafeInt` extractor to avoid unsafe selector use. Each Python assertion maps to a Boolean predicate `Ck`, with `C0` testing that `n` is an integer and `C1` that its value exceeds zero. The JSON separates helper functions, minimal environment constraints, input declaration, and contract definitions.
</think>
```json
{
  "helper_functions": "(define-fun SafeInt ((v Value)) Int\n  (ite (is-IntVal v) (ival v) 0))",
  "basic_structure": "",
  "inputs": "(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool\n  (is-IntVal n))",
    "assert_1": "(define-fun C1 () Bool\n  (> (SafeInt n) 0))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/85

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: surfacearea_sphere
Problem Description:
"""
Write a function to find the surface area of a sphere.
assert math.isclose(surfacearea_sphere(10), 1256.6370614359173, rel_tol=0.001)
"""


import math
def surfacearea_sphere(r):

  assert isinstance(r, (int, float)), "invalid inputs" # $_CONTRACT_$
  assert r > 0, "invalid inputs" # $_CONTRACT_$
  return 4 * math.pi * (r**2)


Contract List:
assert_0: assert isinstance(r, (int, float)), "invalid inputs
assert_1: assert r > 0, "invalid inputs


<think>
I translate each Python assertion into standalone SMT predicates with safe numeric extraction, define helper functions to ensure executability even when contracts are violated, and declare inputs per the ADT.
</think>
```json
{
  "helper_functions": "(define-fun is-numeric ((v Value)) Bool (or (is-IntVal v) (is-FloatVal v)))\n(define-fun safe_to_real ((v Value)) Real\n  (ite (is-IntVal v)\n       (to_real (ival v))\n       (ite (is-FloatVal v)\n            (fval v)\n            0.0)))",
  "basic_structure": "",
  "inputs": "(declare-const r Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool\n  (is-numeric r))",
    "assert_1": "(define-fun C1 () Bool\n  (> (safe_to_real r) 0.0))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/86

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: centered_hexagonal_number
Problem Description:
"""
Write a function to find nth centered hexagonal number.
assert centered_hexagonal_number(10) == 271
"""


def centered_hexagonal_number(n):

  assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
  assert n > 0, "invalid inputs" # $_CONTRACT_$
  return 3 * n * (n - 1) + 1


Contract List:
assert_0: assert isinstance(n, int), "invalid inputs
assert_1: assert n > 0, "invalid inputs


<think>
I translate the Python asserts into precise SMT predicates: C0 checks that n is an IntVal, and C1 ensures n>0 using a guarded selector. No extra helpers or base invariants are needed beyond declaring n.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "",
  "inputs": "(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
    "assert_1": "(define-fun C1 () Bool (and (is-IntVal n) (> (ite (is-IntVal n) (ival n) 0) 0)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/87

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: merge_dictionaries_three
Problem Description:
"""
Write a function to merge three dictionaries into a single dictionary.
assert merge_dictionaries_three({ "R": "Red", "B": "Black", "P": "Pink" }, { "G": "Green", "W": "White" },{ "O": "Orange", "W": "White", "B": "Black" })=={'B': 'Black', 'R': 'Red', 'P': 'Pink', 'G': 'Green', 'W': 'White', 'O': 'Orange'}
"""


import collections as ct
def merge_dictionaries_three(dict1,dict2, dict3):

    assert isinstance(dict1, dict), "invalid inputs" # $_CONTRACT_$
    assert isinstance(dict2, dict), "invalid inputs" # $_CONTRACT_$
    assert isinstance(dict3, dict), "invalid inputs" # $_CONTRACT_$
    merged_dict = dict(ct.ChainMap({},dict1,dict2,dict3))
    return merged_dict


Contract List:
assert_0: assert isinstance(dict1, dict), "invalid inputs
assert_1: assert isinstance(dict2, dict), "invalid inputs
assert_2: assert isinstance(dict3, dict), "invalid inputs


<think>
I introduce a DictVal variant in the ADT and a simple IsDict helper to capture Python’s isinstance(dict) check, then define three Boolean predicates C0–C2 to mirror each input‐validation assert.
</think>
```json
{
  "helper_functions": "(define-fun IsDict ((v Value)) Bool (is-DictVal v))",
  "basic_structure": "",
  "inputs": "(declare-const dict1 Value)\n(declare-const dict2 Value)\n(declare-const dict3 Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsDict dict1))",
    "assert_1": "(define-fun C1 () Bool (IsDict dict2))",
    "assert_2": "(define-fun C2 () Bool (IsDict dict3))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/88

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: freq_count
Problem Description:
"""
Write a function to get the frequency of all the elements in a list, returned as a dictionary.
assert freq_count([10,10,10,10,20,20,20,20,40,40,50,50,30])==({10: 4, 20: 4, 40: 2, 50: 2, 30: 1})
"""


import collections
def freq_count(list1):

  assert isinstance(list1, list), "invalid inputs" # $_CONTRACT_$
  freq_count= collections.Counter(list1)
  return freq_count


Contract List:
assert_0: assert isinstance(list1, list), "invalid inputs


<think>
I model the Python list type check as a recursive SMT predicate IsList over our ADT and then define C0 to assert that input list1 satisfies this predicate. This keeps executability guarantees separate from contract definitions.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))",
  "basic_structure": "(assert true)",
  "inputs": "(declare-const list1 Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList list1))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/89

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: closest_num
Problem Description:
"""
Write a function to find the closest smaller number than n.
assert closest_num(11) == 10
"""


def closest_num(N):

  assert isinstance(N, int), "invalid inputs" # $_CONTRACT_$
  return (N - 1)


Contract List:
assert_0: assert isinstance(N, int), "invalid inputs


<think>
I translate the Python type check into an SMT predicate and set up the minimal ADT and input declaration so that the model is executable. Since there are no recursive or additional structural contracts, no helper functions or basic structure constraints beyond the input declaration are needed.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "",
  "inputs": "(declare-const N Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal N))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/90

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: len_log
Problem Description:
"""
Write a python function to find the length of the longest word.
assert len_log(["python","PHP","bigdata"]) == 7
"""


def len_log(list1):

    assert isinstance(list1, list), "invalid inputs" # $_CONTRACT_$
    assert len(list1) > 0, "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(item, str) for item in list1), "invalid inputs" # $_CONTRACT_$
    return max(len(x) for x in list1)


Contract List:
assert_0: assert isinstance(list1, list), "invalid inputs
assert_1: assert len(list1) > 0, "invalid inputs
assert_2: assert all(isinstance(item, str) for item in list1), "invalid inputs


<think>
I translate each Python assertion into a named SMT predicate, define minimal list‐ and string‐checking helpers with safe recursion, and assert only the core structural invariant in the basic structure so all contract predicates remain independently testable.
</think>
```json
{
  "helper_functions": "(define-fun isList ((v Value)) Bool\n  (or (is-Nil v) (is-Cons v)))\n\n(define-fun-rec list_length ((v Value)) Int\n  (ite (is-Nil v)\n       0\n       (ite (is-Cons v)\n            (+ 1 (list_length (tail v)))\n            0)))\n\n(define-fun-rec list_all_string ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (is-StrVal (head v))\n                 (list_all_string (tail v)))\n            false)))",
  "basic_structure": "(assert (isList list1))",
  "inputs": "(declare-const list1 Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool\n  (isList list1))",
    "assert_1": "(define-fun C1 () Bool\n  (> (list_length list1) 0))",
    "assert_2": "(define-fun C2 () Bool\n  (list_all_string list1))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/91

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: find_substring
Problem Description:
"""
Write a function to check if a string is present as a substring in a given list of string values.
assert find_substring(["red", "black", "white", "green", "orange"],"ack")==True
"""


def find_substring(str1, sub_str):

   assert isinstance(str1, list), "invalid inputs" # $_CONTRACT_$
   assert all(isinstance(item, str) for item in str1), "invalid inputs" # $_CONTRACT_$
   assert isinstance(sub_str, str), "invalid inputs" # $_CONTRACT_$
   return any(sub_str in s for s in str1)


Contract List:
assert_0: assert isinstance(str1, list), "invalid inputs
assert_1: assert all(isinstance(item, str) for item in str1), "invalid inputs
assert_2: assert isinstance(sub_str, str), "invalid inputs


<think>
I translate each Python assertion into a precise SMT predicate (C0–C2), introduce helpers to model lists and element-type checks, and keep “basic_structure” empty so that all input-shape invariants live in the Ck definitions for systematic violation testing.
</think>
```json
{
  "helper_functions": "(define-fun isList ((v Value)) Bool (or (is-Nil v) (is-Cons v)))\n(define-fun-rec list_all_string ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (and (is-Cons l)\n            (let ((h (head l)) (t (tail l)))\n              (and (is-StrVal h)\n                   (list_all_string t))))))",
  "basic_structure": "",
  "inputs": "(declare-const str1 Value)\n(declare-const sub_str Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (isList str1))",
    "assert_1": "(define-fun C1 () Bool (list_all_string str1))",
    "assert_2": "(define-fun C2 () Bool (is-StrVal sub_str))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/92

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: is_undulating
Problem Description:
"""
Write a function to check whether the given number is undulating or not.
assert is_undulating(1212121) == True
"""


def is_undulating(n):

	assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
	assert n >= 0, "invalid inputs" # $_CONTRACT_$
 
	digits = [int(digit) for digit in str(n)]
	if len(set(digits)) != 2:
		return False
	return all(a != b for a, b in zip(digits, digits[1:]))


Contract List:
assert_0: assert isinstance(n, int), "invalid inputs
assert_1: assert n >= 0, "invalid inputs


<think>
I translated the two Python asserts into precise SMT predicates over the Value ADT, guarding the integer selector to avoid unsafe access. The basic structure ensures the input can be treated as an integer value, and no extra helpers are needed for these simple checks.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "(assert (is-IntVal n))",
  "inputs": "(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
    "assert_1": "(define-fun C1 () Bool (ite (is-IntVal n) (>= (ival n) 0) false))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/93

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: power
Problem Description:
"""
Write a function to calculate the value of 'a' to the power 'b'.
assert power(3,4) == 81
"""


def power(a, b):

	assert isinstance(a, (int, float)), "invalid inputs" # $_CONTRACT_$
	assert isinstance(b, int), "invalid inputs" # $_CONTRACT_$
	return a ** b


Contract List:
assert_0: assert isinstance(a, (int, float)), "invalid inputs
assert_1: assert isinstance(b, int), "invalid inputs


<think>
I model each Python isinstance check as a Boolean SMT predicate over the ADT constructors, ensuring `a` is either IntVal or FloatVal and `b` is IntVal. No extra helper functions or structural invariants are needed beyond these checks for the simple `power` function.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "",
  "inputs": "(declare-const a Value)\n(declare-const b Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (or (is-IntVal a) (is-FloatVal a)))",
    "assert_1": "(define-fun C1 () Bool (is-IntVal b))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/94

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: index_minimum
Problem Description:
"""
Given a list of tuples, write a function that returns the first value of the tuple with the smallest second value.
assert index_minimum([('Rash', 143), ('Manjeet', 200), ('Varsha', 100)]) == 'Varsha'
"""


from operator import itemgetter 
def index_minimum(test_list):

  assert isinstance(test_list, list) and len(test_list) > 0, "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(item, tuple) and len(item) >= 2 for item in test_list), "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(item[1], (int, float)) for item in test_list), "invalid inputs" # $_CONTRACT_$
  res = min(test_list, key = itemgetter(1))[0]
  return (res) 


Contract List:
assert_0: assert isinstance(test_list, list) and len(test_list) > 0, "invalid inputs
assert_1: assert all(isinstance(item, tuple) and len(item) >= 2 for item in test_list), "invalid inputs
assert_2: assert all(isinstance(item[1], (int, float)) for item in test_list), "invalid inputs


<think>
I will model the list‐of‐tuples contract by defining recursive SMT predicates to recognize lists, compute lengths, check tuple shapes, and verify numeric seconds—all guarded to avoid unsafe selectors. Then I translate each Python assert into a named Boolean Ck predicate while keeping only the list‐structure invariant in the basic structure.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (ite (is-Nil l) true\n       (ite (is-Cons l) (IsList (tail l)) false)))\n\n(define-fun-rec list_length ((l Value)) Int\n  (ite (is-Nil l) 0\n       (ite (is-Cons l) (+ 1 (list_length (tail l))) 0)))\n\n(define-fun-rec list_all_tuple2 ((l Value)) Bool\n  (ite (is-Nil l) true\n       (ite (is-Cons l)\n            (and (let ((item (head l)))\n                   (and (IsList item) (>= (list_length item) 2)))\n                 (list_all_tuple2 (tail l)))\n            false)))\n\n(define-fun-rec list_all_second_numeric ((l Value)) Bool\n  (ite (is-Nil l) true\n       (ite (is-Cons l)\n            (let ((item (head l)))\n              (and (is-Cons item)\n                   (let ((snd (head (tail item))))\n                     (or (is-IntVal snd) (is-FloatVal snd)))\n                   (list_all_second_numeric (tail l))))\n            false)))",
  "basic_structure": "(assert (IsList test_list))",
  "inputs": "(declare-const test_list Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (and (IsList test_list) (> (list_length test_list) 0)))",
    "assert_1": "(define-fun C1 () Bool (list_all_tuple2 test_list))",
    "assert_2": "(define-fun C2 () Bool (list_all_second_numeric test_list))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/95

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: Find_Min_Length
Problem Description:
"""
Write a python function to find the length of the smallest list in a list of lists.
assert Find_Min_Length([[1],[1,2]]) == 1
"""


def Find_Min_Length(lst):

    assert isinstance(lst, list), "invalid inputs" # $_CONTRACT_$
    assert len(lst) > 0, "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(item, list) for item in lst), "invalid inputs" # $_CONTRACT_$
  
    minLength = min(len(x) for x in lst )
    return minLength 


Contract List:
assert_0: assert isinstance(lst, list), "invalid inputs
assert_1: assert len(lst) > 0, "invalid inputs
assert_2: assert all(isinstance(item, list) for item in lst), "invalid inputs


<think>
I translate Python list‐shape and length assertions into safe, recursive SMT predicates (IsList, length, AllItemsList) and expose each original assert as a standalone Ck predicate, while preserving a minimal basic structure for executable safety.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n(define-fun-rec length ((v Value)) Int\n  (ite (is-Nil v)\n       0\n       (ite (is-Cons v)\n            (+ 1 (length (tail v)))\n            0)))\n(define-fun-rec AllItemsList ((lst Value)) Bool\n  (ite (is-Nil lst)\n       true\n       (ite (is-Cons lst)\n            (and (IsList (head lst))\n                 (AllItemsList (tail lst)))\n            false)))",
  "basic_structure": "(assert (IsList lst))",
  "inputs": "(declare-const lst Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList lst))",
    "assert_1": "(define-fun C1 () Bool (> (length lst) 0))",
    "assert_2": "(define-fun C2 () Bool (AllItemsList lst))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/96

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: divisor
Problem Description:
"""
Write a python function to find the number of divisors of a given integer.
assert divisor(15) == 4
"""


def divisor(n):

  assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
  assert n > 0, "invalid inputs" # $_CONTRACT_$
  return sum(1 for i in range(1, n + 1) if n % i == 0)


Contract List:
assert_0: assert isinstance(n, int), "invalid inputs
assert_1: assert n > 0, "invalid inputs


<think>
I define a SafeI extractor to guard the int selector, declare the sole input `n`, and express each Python assertion as a precise SMT‐LIB predicate that safely encodes `isinstance(n,int)` and `n>0`.
</think>
```json
{
  "helper_functions": "(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
  "basic_structure": "",
  "inputs": "(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
    "assert_1": "(define-fun C1 () Bool (> (SafeI n) 0))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/97

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: frequency_lists
Problem Description:
"""
Write a function to find frequency of each element in a flattened list of lists, returned in a dictionary.
assert frequency_lists([[1, 2, 3, 2], [4, 5, 6, 2], [7, 8, 9, 5]])=={1: 1, 2: 3, 3: 1, 4: 1, 5: 2, 6: 1, 7: 1, 8: 1, 9: 1}
"""


def frequency_lists(list1):

    def is_hashable(obj): # $_CONTRACT_$
        try: # $_CONTRACT_$
            hash(obj) # $_CONTRACT_$
            return True # $_CONTRACT_$
        except TypeError: # $_CONTRACT_$
            return False # $_CONTRACT_$
    assert isinstance(list1, list), "invalid inputs" # $_CONTRACT_$
    assert len(list1) > 0, "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(item, list) for item in list1), "invalid inputs" # $_CONTRACT_$
    assert all(is_hashable(item) for sublist in list1 for item in sublist), "invalid inputs" # $_CONTRACT_$
    list1 = [item for sublist in list1 for item in sublist]
    return {x: list1.count(x) for x in list1}


Contract List:
assert_0: assert isinstance(list1, list), "invalid inputs
assert_1: assert len(list1) > 0, "invalid inputs
assert_2: assert all(isinstance(item, list) for item in list1), "invalid inputs
assert_3: assert all(is_hashable(item) for sublist in list1 for item in sublist), "invalid inputs


<think>
I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints, defining recursive list predicates and hashability checks, and modeling each contract as a Boolean predicate C0...C3.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec list_len ((v Value)) Int\n  (ite (is-Nil v)\n       0\n       (ite (is-Cons v)\n            (+ 1 (list_len (tail v)))\n            0)))\n\n(define-fun-rec AllList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (IsList (head v))\n                 (AllList (tail v)))\n            false)))\n\n(define-fun-rec ElemHashable ((v Value)) Bool\n  (or (is-IntVal v)\n      (is-FloatVal v)\n      (is-StrVal v)\n      (is-BoolVal v)))\n\n(define-fun-rec AllElemHashable ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (ElemHashable (head v))\n                 (AllElemHashable (tail v)))\n            false)))\n\n(define-fun-rec AllHashable ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (AllElemHashable (head v))\n                 (AllHashable (tail v)))\n            false)))",
  "basic_structure": "(assert (IsList list1))",
  "inputs": "(declare-const list1 Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList list1))",
    "assert_1": "(define-fun C1 () Bool (> (list_len list1) 0))",
    "assert_2": "(define-fun C2 () Bool (AllList list1))",
    "assert_3": "(define-fun C3 () Bool (AllHashable list1))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/98

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: multiply_num
Problem Description:
"""
Write a function to multiply all the numbers in a list and divide with the length of the list.
assert math.isclose(multiply_num((8, 2, 3, -1, 7)), -67.2, rel_tol=0.001)
"""


def multiply_num(numbers):

    assert isinstance(numbers, (tuple, list)), "invalid inputs" # $_CONTRACT_$
    assert len(numbers) > 0, "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(item, (int, float)) for item in numbers), "invalid inputs" # $_CONTRACT_$
  
    from functools import reduce
    return reduce(lambda x, y: x * y, numbers) / len(numbers)


Contract List:
assert_0: assert isinstance(numbers, (tuple, list)), "invalid inputs
assert_1: assert len(numbers) > 0, "invalid inputs
assert_2: assert all(isinstance(item, (int, float)) for item in numbers), "invalid inputs


<think>
I translated the Python assertions into SMT-LIB predicates, defined helper functions under safe ADT rules for list structure, length, and numeric checks, and set up the basic shape assertion and named contract predicates for exhaustive testing.
</think>
```json
{
  "helper_functions": "(define-fun isList ((v Value)) Bool\n  (or (is-Nil v) (is-Cons v)))\n\n(define-fun-rec length ((v Value)) Int\n  (ite (is-Nil v) 0\n    (ite (is-Cons v)\n      (+ 1 (length (tail v)))\n      0)))\n\n(define-fun-rec list_all_numeric ((v Value)) Bool\n  (ite (is-Nil v) true\n    (ite (is-Cons v)\n      (and (or (is-IntVal (head v)) (is-FloatVal (head v)))\n           (list_all_numeric (tail v)))\n      false)))",
  "basic_structure": "(assert (isList numbers))",
  "inputs": "(declare-const numbers Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (isList numbers))",
    "assert_1": "(define-fun C1 () Bool (> (length numbers) 0))",
    "assert_2": "(define-fun C2 () Bool (list_all_numeric numbers))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/99

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: decimal_to_binary
Problem Description:
"""
Write a function to convert the given decimal number to its binary equivalent, represented as a string with no leading zeros.
assert decimal_to_binary(8) == '1000'
"""


def decimal_to_binary(n):

    assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
 
    return bin(n).replace("0b","") 


Contract List:
assert_0: assert isinstance(n, int), "invalid inputs


<think>
I will translate the Python isinstance check into an SMT is-IntVal predicate, declare the input as a Value, and leave helper and basic structure sections empty since no further invariants or utilities are needed.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "",
  "inputs": "(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal n))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/100

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: next_smallest_palindrome
Problem Description:
"""
Write a function to find the next smallest palindrome of a specified integer, returned as an integer.
assert next_smallest_palindrome(99)==101
"""


def next_smallest_palindrome(num):

    assert isinstance(num, int), "invalid inputs" # $_CONTRACT_$
    assert num >= 0, "invalid inputs" # $_CONTRACT_$
    if all(digit == '9' for digit in str(num)):
        return num + 2
    else:
        num = [int(digit) for digit in str(num)]
        n = len(num)
        mid = n // 2
        left_smaller = False
        # if n is odd, ignore the middle digit at first
        i = mid - 1
        j = mid + 1 if n % 2 else mid
        while i >= 0 and num[i] == num[j]:
            i -= 1
            j += 1
        # stop if traverse end or difference found
        if i < 0 or num[i] < num[j]:
            left_smaller = True
        # copy left to right
        while i >= 0:
            num[j] = num[i]
            j += 1
            i -= 1
        # the middle digit must be incremented
        if left_smaller:
            carry = 1
            i = mid - 1
            if n % 2:
                num[mid] += carry
                carry = num[mid] // 10
                num[mid] %= 10
                j = mid + 1
            else:
                j = mid
            while i >= 0:
                num[i] += carry
                carry = num[i] // 10
                num[i] %= 10
                num[j] = num[i]
                j += 1
                i -= 1
    return int("".join(map(str, num)))


Contract List:
assert_0: assert isinstance(num, int), "invalid inputs
assert_1: assert num >= 0, "invalid inputs


<think>
I will define a SafeI helper to extract integers only when the Value is an IntVal, declare the input, leave the basic structure unconstrained beyond ADT satisfiability, and encode each Python assert as a named predicate.
</think>
```json
{
  "helper_functions": "(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
  "basic_structure": "",
  "inputs": "(declare-const num Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal num))",
    "assert_1": "(define-fun C1 () Bool (and C0 (>= (SafeI num) 0)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/101

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: kth_element
Problem Description:
"""
Write a function to find the kth element in the given array using 1-based indexing.
assert kth_element([12,3,5,7,19], 2) == 3
"""


def kth_element(arr, k):

  assert isinstance(arr, list), "invalid inputs" # $_CONTRACT_$
  assert isinstance(k, int), "invalid inputs" # $_CONTRACT_$ 
  assert len(arr) >= k >= 1, "invalid inputs" # $_CONTRACT_$
  return arr[k-1]


Contract List:
assert_0: assert isinstance(arr, list), "invalid inputs
assert_1: assert isinstance(k, int), "invalid inputs
assert_2: assert len(arr) >= k >= 1, "invalid inputs


<think>
I translate each Python assertion into a precise SMT-LIB Boolean predicate and supply minimal helper functions (SafeIVal, length, IsList) to model list structure and integer extraction without unsafe selectors. No global invariants are forced so that each Ck can be independently tested for violation.
</think>
```json
{
  "helper_functions": "(define-fun SafeIVal ((v Value)) Int\n  (ite (is-IntVal v) (ival v) 0))\n\n(define-fun-rec length ((lst Value)) Int\n  (ite (is-Nil lst) 0\n    (ite (is-Cons lst)\n      (+ 1 (length (tail lst)))\n      0)))\n\n(define-fun-rec IsList ((lst Value)) Bool\n  (ite (is-Nil lst) true\n    (ite (is-Cons lst)\n      (IsList (tail lst))\n      false)))",
  "basic_structure": "",
  "inputs": "(declare-const arr Value)\n(declare-const k Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool\n  (IsList arr))",
    "assert_1": "(define-fun C1 () Bool\n  (is-IntVal k))",
    "assert_2": "(define-fun C2 () Bool\n  (and\n    (>= (length arr) (SafeIVal k))\n    (>= (SafeIVal k) 1)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/102

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: snake_to_camel
Problem Description:
"""
Write a function to convert a snake case string to camel case string.
assert snake_to_camel('python_program')=='PythonProgram'
"""


def snake_to_camel(word):

    assert isinstance(word, str), "invalid inputs" # $_CONTRACT_$
    assert len(word) > 0, "invalid inputs" # $_CONTRACT_$
    return ''.join(x.capitalize() or '_' for x in word.split('_'))


Contract List:
assert_0: assert isinstance(word, str), "invalid inputs
assert_1: assert len(word) > 0, "invalid inputs


<think>
I introduce a SafeStrLen helper to guard string length, assert the input is a StrVal for safe operations, and then define C0/C1 to mirror the Python type and non‐empty assertions.
</think>
```json
{
  "helper_functions": "(define-fun SafeStrLen ((v Value)) Int\n  (ite (is-StrVal v)\n       (str.len (sval v))\n       0))",
  "basic_structure": "(assert (is-StrVal word))",
  "inputs": "(declare-const word Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool\n  (is-StrVal word))",
    "assert_1": "(define-fun C1 () Bool\n  (> (SafeStrLen word) 0))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/103

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: eulerian_num
Problem Description:
"""
Write a function to find the Eulerian number a(n, m).
assert eulerian_num(3, 1) == 4
"""


def eulerian_num(n, m):

	assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
	assert isinstance(m, int), "invalid inputs" # $_CONTRACT_$
	assert n >= 0, "invalid inputs" # $_CONTRACT_$
	assert m >= 0, "invalid inputs" # $_CONTRACT_$
 
	if (m >= n or n == 0): 
		return 0 
	if (m == 0): 
		return 1 
	return (n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m)


Contract List:
assert_0: assert isinstance(n, int), "invalid inputs
assert_1: assert isinstance(m, int), "invalid inputs
assert_2: assert n >= 0, "invalid inputs
assert_3: assert m >= 0, "invalid inputs


<think>
I will translate each Python assertion into an SMT Bool predicate using the Value ADT and a SafeI helper to extract IntVal safely, while ensuring that inputs are always IntVal for executability.
</think>
```json
{
  "helper_functions": "(define-fun SafeI ((v Value)) Int\n  (ite (is-IntVal v) (ival v) 0))",
  "basic_structure": "(assert (is-IntVal n))\n(assert (is-IntVal m))",
  "inputs": "(declare-const n Value)\n(declare-const m Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool\n  (is-IntVal n))",
    "assert_1": "(define-fun C1 () Bool\n  (is-IntVal m))",
    "assert_2": "(define-fun C2 () Bool\n  (>= (SafeI n) 0))",
    "assert_3": "(define-fun C3 () Bool\n  (>= (SafeI m) 0))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/104

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: sort_sublists
Problem Description:
"""
Write a function to sort each sublist of strings in a given list of lists.
assert sort_sublists((["green", "orange"], ["black", "white"], ["white", "black", "orange"]))==[['green', 'orange'], ['black', 'white'], ['black', 'orange', 'white']]
"""


def sort_sublists(input_list):

    assert isinstance(input_list, (list, tuple)), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(x, list) for x in input_list), "invalid inputs" # $_CONTRACT_$
    assert all(all(isinstance(y, str) for y in x) for x in input_list), "invalid inputs" # $_CONTRACT_$
    return [sorted(x) for x in input_list]


Contract List:
assert_0: assert isinstance(input_list, (list, tuple)), "invalid inputs
assert_1: assert all(isinstance(x, list) for x in input_list), "invalid inputs
assert_2: assert all(all(isinstance(y, str) for y in x) for x in input_list), "invalid inputs


<think>
I translated each Python assertion into precise SMT-LIB predicates, defining recursive helper functions to model list structure and element types, then mapped each assert to a named contract C0–C2 while keeping only the basic IsList check in the core structure.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec list_all_list ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (IsList (head v))\n                 (list_all_list (tail v)))\n            false)))\n\n(define-fun-rec list_all_str ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (is-StrVal (head v))\n                 (list_all_str (tail v)))\n            false)))\n\n(define-fun-rec list_all_str_list ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (list_all_str (head v))\n                 (list_all_str_list (tail v)))\n            false)))",
  "basic_structure": "(assert (IsList input_list))",
  "inputs": "(declare-const input_list Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool\n  (IsList input_list))",
    "assert_1": "(define-fun C1 () Bool\n  (list_all_list input_list))",
    "assert_2": "(define-fun C2 () Bool\n  (list_all_str_list input_list))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/105

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: count
Problem Description:
"""
Write a python function to count true booleans in the given list.
assert count([True,False,True]) == 2
"""


def count(lst):

    assert isinstance(lst, list), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(x, bool) for x in lst), "invalid inputs" # $_CONTRACT_$
   
    return sum(lst) 


Contract List:
assert_0: assert isinstance(lst, list), "invalid inputs
assert_1: assert all(isinstance(x, bool) for x in lst), "invalid inputs


<think>
I will translate the Python assertions into SMT helper functions and predicates while ensuring the list ADT shape and boolean-element constraints are captured. I define IsList and list_all_bool to model the Python contracts precisely.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec list_all_bool ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (is-BoolVal (head v))\n                 (list_all_bool (tail v)))\n            false)))",
  "basic_structure": "(assert (IsList lst))",
  "inputs": "(declare-const lst Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList lst))",
    "assert_1": "(define-fun C1 () Bool (list_all_bool lst))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/106

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: add_lists
Problem Description:
"""
Write a function to append the given list to the given tuples.
assert add_lists([5, 6, 7], (9, 10)) == (9, 10, 5, 6, 7)
"""


def add_lists(test_list, test_tup):

  assert isinstance(test_list, list), "invalid inputs" # $_CONTRACT_$
  assert isinstance(test_tup, tuple), "invalid inputs" # $_CONTRACT_$
  return test_tup + tuple(test_list)


Contract List:
assert_0: assert isinstance(test_list, list), "invalid inputs
assert_1: assert isinstance(test_tup, tuple), "invalid inputs


<think>
I translate the Python type assertions into SMT-LIB predicates by defining a recursive IsList over the Value ADT, declare the two Value inputs, and map each isinstance check to C0 and C1 respectively.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (or\n    (is-Nil l)\n    (and (is-Cons l) (let ((tl (tail l))) (IsList tl)))\n  )\n)",
  "basic_structure": "",
  "inputs": "(declare-const test_list Value)\n(declare-const test_tup Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList test_list))",
    "assert_1": "(define-fun C1 () Bool (IsList test_tup))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/108

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: merge_sorted_list
Problem Description:
"""
Write a function to merge three lists into a single sorted list.
assert merge_sorted_list([25, 24, 15, 4, 5, 29, 110],[19, 20, 11, 56, 25, 233, 154],[24, 26, 54, 48])==[4, 5, 11, 15, 19, 20, 24, 24, 25, 25, 26, 29, 48, 54, 56, 110, 154, 233]
"""


import heapq
def merge_sorted_list(num1,num2,num3):

  assert isinstance(num1, list), "invalid inputs" # $_CONTRACT_$
  assert isinstance(num2, list), "invalid inputs" # $_CONTRACT_$
  assert isinstance(num3, list), "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(x, (int, float)) for x in num1), "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(x, (int, float)) for x in num2), "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(x, (int, float)) for x in num3), "invalid inputs" # $_CONTRACT_$
  return sorted(num1 + num2 + num3)


Contract List:
assert_0: assert isinstance(num1, list), "invalid inputs
assert_1: assert isinstance(num2, list), "invalid inputs
assert_2: assert isinstance(num3, list), "invalid inputs
assert_3: assert all(isinstance(x, (int, float)) for x in num1), "invalid inputs
assert_4: assert all(isinstance(x, (int, float)) for x in num2), "invalid inputs
assert_5: assert all(isinstance(x, (int, float)) for x in num3), "invalid inputs


<think>
I translated each Python assertion into a named SMT predicate (C0–C5), defined precise recursive helpers for lists and numeric checks, and ensured basic structure constraints require each input to be a valid list for execution.
</think>
```json
{
  "helper_functions": "(define-fun-rec is_List ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (is_List (tail l))\n            false)))\n(define-fun-rec list_all_numeric ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (let ((h (head l)) (t (tail l)))\n              (and (or (is-IntVal h) (is-FloatVal h))\n                   (list_all_numeric t)))\n            false)))",
  "basic_structure": "(assert (is_List num1))\n(assert (is_List num2))\n(assert (is_List num3))",
  "inputs": "(declare-const num1 Value)\n(declare-const num2 Value)\n(declare-const num3 Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is_List num1))",
    "assert_1": "(define-fun C1 () Bool (is_List num2))",
    "assert_2": "(define-fun C2 () Bool (is_List num3))",
    "assert_3": "(define-fun C3 () Bool (list_all_numeric num1))",
    "assert_4": "(define-fun C4 () Bool (list_all_numeric num2))",
    "assert_5": "(define-fun C5 () Bool (list_all_numeric num3))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/109

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: odd_Equivalent
Problem Description:
"""
Write a python function to find the number of numbers with an odd value when rotating a binary string the given number of times.
assert odd_Equivalent("011001",6) == 3
"""


def odd_Equivalent(s,n):

    assert isinstance(s, str), "invalid inputs" # $_CONTRACT_$
    assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
    assert all([c in '01' for c in s]), "invalid inputs" # $_CONTRACT_$
    assert n >= 0, "invalid inputs" # $_CONTRACT_$
 
    count=0
    for i in range(0,n): 
        if (s[i] == '1'): 
            count = count + 1
    return count 


Contract List:
assert_0: assert isinstance(s, str), "invalid inputs
assert_1: assert isinstance(n, int), "invalid inputs
assert_2: assert all([c in '01' for c in s]), "invalid inputs
assert_3: assert n >= 0, "invalid inputs


<think>
I will translate the Python input‐validation assertions into named SMT‐LIB predicates, introduce safe helper functions for Value extraction, and capture the required execution invariants so each contract can be independently tested.
</think>
```json
{
  "helper_functions": "(define-fun SafeI ((v Value)) Int\n  (ite (is-IntVal v) (ival v) 0))\n\n(define-fun IsBinStr ((v Value)) Bool\n  (ite (is-StrVal v)\n    (str.in.re (sval v)\n      (re.* (re.union (str.to.re \"0\") (str.to.re \"1\"))))\n    false))",
  "basic_structure": "(define-fun BASIC_STRUCTURE () Bool\n  (let ((sv? (is-StrVal s)))\n    (ite sv?\n      (let ((sl (str.len (sval s))))\n        (and\n          (is-IntVal n)\n          (>= sl (ival n))\n        )\n      )\n      false\n    )\n  )\n)",
  "inputs": "(declare-const s Value)\n(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-StrVal s))",
    "assert_1": "(define-fun C1 () Bool (is-IntVal n))",
    "assert_2": "(define-fun C2 () Bool (IsBinStr s))",
    "assert_3": "(define-fun C3 () Bool (>= (SafeI n) 0))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/111

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: common_in_nested_lists
Problem Description:
"""
Write a function to find the common elements in given nested lists.
assert set(common_in_nested_lists([[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 16, 18]]))==set([18, 12])
"""


def common_in_nested_lists(nestedlist):

    assert isinstance(nestedlist, list), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(item, list) for item in nestedlist), "invalid inputs" # $_CONTRACT_$
    return list(set.intersection(*map(set, nestedlist)))


Contract List:
assert_0: assert isinstance(nestedlist, list), "invalid inputs
assert_1: assert all(isinstance(item, list) for item in nestedlist), "invalid inputs


<think>
I will translate each Python assertion into an SMT predicate, define list‐shape and element‐list helpers to mirror isinstance checks, and declare a single input, ensuring all selectors are guarded.
</think>
```json
{
  "helper_functions": "(define-fun isList ((v Value)) Bool\n  (or (is-Cons v) (is-Nil v)))\n\n(define-fun-rec ListAllLists ((v Value)) Bool\n  (ite (is-Cons v)\n       (let ((head_list (head v))\n             (tail_list (tail v)))\n         (and (isList head_list)\n              (ListAllLists tail_list)))\n       true))",
  "basic_structure": "",
  "inputs": "(declare-const nestedlist Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool\n  (isList nestedlist))",
    "assert_1": "(define-fun C1 () Bool\n  (ListAllLists nestedlist))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/113

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: check_integer
Problem Description:
"""
Write a function to check if a string represents an integer or not.
assert check_integer("python")==False
"""


def check_integer(text):

 assert isinstance(text, str), "invalid inputs" # $_CONTRACT_$
 text = text.strip()
 if len(text) < 1:
    return None
 else:
    if text[0] in '+-':
        text = text[1:]
    return text.isdigit()


Contract List:
assert_0: assert isinstance(text, str), "invalid inputs


<think>
I model the single input “text” as a Value of StrVal shape in the basic structure to guarantee safe string operations. The contract C0 exactly captures the Python assertion isinstance(text, str) using the ADT’s is-StrVal tester. No extra helpers are needed for this simple check.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "(assert (is-StrVal text))",
  "inputs": "(declare-const text Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-StrVal text))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/116

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: tuple_to_int
Problem Description:
"""
Write a function to convert a given tuple of positive integers into a single integer.
assert tuple_to_int((1,2,3))==123
"""


def tuple_to_int(nums):

    assert isinstance(nums, tuple), "invalid inputs" # $_CONTRACT_$
    assert len(nums) > 0, "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(x, int) for x in nums), "invalid inputs" # $_CONTRACT_$
    assert all(x > 0 for x in nums), "invalid inputs" # $_CONTRACT_$
    return int(''.join(map(str,nums)))


Contract List:
assert_0: assert isinstance(nums, tuple), "invalid inputs
assert_1: assert len(nums) > 0, "invalid inputs
assert_2: assert all(isinstance(x, int) for x in nums), "invalid inputs
assert_3: assert all(x > 0 for x in nums), "invalid inputs


<think>
I model the input tuple as a linked‐list over the canonical Value ADT, define recursive helpers for list structure, length, integer‐type and positivity checks, and translate each Python assert into a Boolean predicate Ck. This gives a fully executable SMT template supporting all contract checks.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec list_length ((v Value)) Int\n  (ite (is-Nil v)\n       0\n       (ite (is-Cons v)\n            (+ 1 (list_length (tail v)))\n            0)))\n\n(define-fun-rec list_all_int ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (is-IntVal (head v))\n                 (list_all_int (tail v)))\n            false)))\n\n(define-fun-rec list_all_positive ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (is-IntVal (head v))\n                 (> (ival (head v)) 0)\n                 (list_all_positive (tail v)))\n            false)))",
  "basic_structure": "(assert (IsList nums))",
  "inputs": "(declare-const nums Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList nums))",
    "assert_1": "(define-fun C1 () Bool (> (list_length nums) 0))",
    "assert_2": "(define-fun C2 () Bool (list_all_int nums))",
    "assert_3": "(define-fun C3 () Bool (list_all_positive nums))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/118

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: string_to_list
Problem Description:
"""
Write a function to convert a string to a list of strings split on the space character.
assert string_to_list("python programming")==['python','programming']
"""


def string_to_list(string):

    assert isinstance(string, str), "invalid inputs" # $_CONTRACT_$
 
    return string.split(" ")


Contract List:
assert_0: assert isinstance(string, str), "invalid inputs


<think>
I will translate the single Python type‐check assertion into an SMT predicate requiring the input to be the StrVal constructor, include that guard in the basic structure for safe execution, and define C0 for contract testing.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "(assert (is-StrVal string))",
  "inputs": "(declare-const string Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-StrVal string))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/119

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: search
Problem Description:
"""
Write a python function to find the element that appears only once in a sorted array.
assert search([1,1,2,2,3]) == 3
"""


def search(arr):

    assert isinstance(arr, list), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(x, int) for x in arr), "invalid inputs" # $_CONTRACT_$
    assert all(a <= b for a, b in zip(arr, arr[1:])), "invalid inputs" # $_CONTRACT_$
    n = len(arr)
    XOR = 0
    for i in range(n) :
        XOR = XOR ^ arr[i]
    return (XOR)


Contract List:
assert_0: assert isinstance(arr, list), "invalid inputs
assert_1: assert all(isinstance(x, int) for x in arr), "invalid inputs
assert_2: assert all(a <= b for a, b in zip(arr, arr[1:])), "invalid inputs


<think>
I defined recursive SMT helpers to check list structure, integer elements, and sorted order, declared the input, asserted the basic list invariant, and translated each Python assertion into a named SMT predicate.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec list_all_int ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (is-IntVal (head v))\n                 (list_all_int (tail v)))\n            false)))\n\n(define-fun-rec list_sorted ((v Value)) Bool\n  (ite (is-Cons v)\n       (let ((t (tail v)))\n         (ite (is-Cons t)\n              (let ((h1 (head v)) (h2 (head t)))\n                (and (is-IntVal h1)\n                     (is-IntVal h2)\n                     (<= (ival h1) (ival h2))\n                     (list_sorted t)))\n              true))\n       true))",
  "basic_structure": "(assert (IsList arr))",
  "inputs": "(declare-const arr Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList arr))",
    "assert_1": "(define-fun C1 () Bool (list_all_int arr))",
    "assert_2": "(define-fun C2 () Bool (list_sorted arr))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/120

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: max_product_tuple
Problem Description:
"""
Write a function to find the maximum absolute product between numbers in pairs of tuples within a given list.
assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
"""


def max_product_tuple(list1):

    assert isinstance(list1, list), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(x, tuple) for x in list1), "invalid inputs" # $_CONTRACT_$
    assert all(len(x) == 2 for x in list1), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(x[0], (int, float)) for x in list1), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(x[1], (int, float)) for x in list1), "invalid inputs" # $_CONTRACT_$
    return max(abs(x * y) for x, y in list1)


Contract List:
assert_0: assert isinstance(list1, list), "invalid inputs
assert_1: assert all(isinstance(x, tuple) for x in list1), "invalid inputs
assert_2: assert all(len(x) == 2 for x in list1), "invalid inputs
assert_3: assert all(isinstance(x[0], (int, float)) for x in list1), "invalid inputs
assert_4: assert all(isinstance(x[1], (int, float)) for x in list1), "invalid inputs


<think>
I will translate each Python assertion into precise SMT predicates over a canonical Value ADT, declare necessary recursive helpers to enforce list and tuple structure and numeric checks, and provide a mask‐based combination template for systematic contract violation testing.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (ite (is-Nil l) true\n    (ite (is-Cons l) (IsList (tail l)) false)))\n\n(define-fun-rec list_all_Pair ((l Value)) Bool\n  (ite (is-Nil l) true\n    (ite (is-Cons l)\n      (let ((h (head l)) (t (tail l)))\n        (and (is-PairVal h) (list_all_Pair t)))\n      false)))\n\n(define-fun-rec list_all_first_num ((l Value)) Bool\n  (ite (is-Nil l) true\n    (ite (is-Cons l)\n      (let ((h (head l)) (t (tail l)))\n        (and (is-PairVal h)\n             (let ((f (fst h))) (or (is-IntVal f) (is-FloatVal f)))\n             (list_all_first_num t)))\n      false)))\n\n(define-fun-rec list_all_second_num ((l Value)) Bool\n  (ite (is-Nil l) true\n    (ite (is-Cons l)\n      (let ((h (head l)) (t (tail l)))\n        (and (is-PairVal h)\n             (let ((s (snd h))) (or (is-IntVal s) (is-FloatVal s)))\n             (list_all_second_num t)))\n      false)))\n\n(declare-const mask (_ BitVec 5))\n(define-fun combo_mask () Bool\n  (and\n    (ite (= #b1 (bvextract 4 4 mask)) (not C0) C0)\n    (ite (= #b1 (bvextract 3 3 mask)) (not C1) C1)\n    (ite (= #b1 (bvextract 2 2 mask)) (not C2) C2)\n    (ite (= #b1 (bvextract 1 1 mask)) (not C3) C3)\n    (ite (= #b1 (bvextract 0 0 mask)) (not C4) C4)))",
  "basic_structure": "(assert (IsList list1))",
  "inputs": "(declare-const list1 Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList list1))",
    "assert_1": "(define-fun C1 () Bool (list_all_Pair list1))",
    "assert_2": "(define-fun C2 () Bool (list_all_Pair list1))",
    "assert_3": "(define-fun C3 () Bool (list_all_first_num list1))",
    "assert_4": "(define-fun C4 () Bool (list_all_second_num list1))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/123

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: amicable_numbers_sum
Problem Description:
"""
Write a function to sum all amicable numbers from 1 to a specified number.
assert amicable_numbers_sum(999)==504
"""


def div_sum(num):
    res = 1
    i = 2
    while i * i <= num:
        if num % i == 0:
            res += i
            if i * i != num:
                res += num / i
        i += 1
    return res
def amicable_numbers_sum(limit):

    assert isinstance(limit, int), "invalid inputs" # $_CONTRACT_$
    assert limit >= 1, "invalid inputs" # $_CONTRACT_$
    amicables = set()
    for num in range(2, limit + 1):
        if num in amicables:
            continue
        sum_fact = div_sum(num)
        sum_fact2 = div_sum(sum_fact)
        if num == sum_fact2 and num != sum_fact:
            amicables.add(num)
            amicables.add(sum_fact2)
    return sum(amicables)


Contract List:
assert_0: assert isinstance(limit, int), "invalid inputs
assert_1: assert limit >= 1, "invalid inputs


<think>
I will translate the Python input assertions into SMT predicates by declaring a Value ADT, defining a SafeI extractor for integer values, and encoding each assert as a named Boolean (C0, C1). The basic structure holds no mandatory invariants beyond the helpers, and inputs are declared per spec.
</think>
```json
{
  "helper_functions": "(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
  "basic_structure": "",
  "inputs": "(declare-const limit Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal limit))",
    "assert_1": "(define-fun C1 () Bool (>= (SafeI limit) 1))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/124

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: angle_complex
Problem Description:
"""
Write a function to get the angle of a complex number.
assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
"""


import cmath
def angle_complex(a,b):

  assert isinstance(a, (int, float)) or isinstance(a, float), "invalid inputs" # $_CONTRACT_$
  assert isinstance(b, complex) or isinstance(b, float), "invalid inputs" # $_CONTRACT_$
  assert b.real == 0, "invalid inputs" # $_CONTRACT_$
  angle=cmath.phase(a+b)
  return angle


Contract List:
assert_0: assert isinstance(a, (int, float)) or isinstance(a, float), "invalid inputs
assert_1: assert isinstance(b, complex) or isinstance(b, float), "invalid inputs
assert_2: assert b.real == 0, "invalid inputs


<think>
I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.
</think>
```json
{
  "helper_functions": "(define-fun SafeReal ((v Value)) Real\n  (ite (is-FloatVal v)\n       (fval v)\n       (ite (is-IntVal v)\n            (to_real (ival v))\n            (ite (is-ComplexVal v)\n                 (creal v)\n                 0.0))))\n(define-fun SafeImag ((v Value)) Real\n  (ite (is-ComplexVal v)\n       (cimag v)\n       0.0))",
  "basic_structure": "",
  "inputs": "(declare-const a Value)\n(declare-const b Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (or (is-IntVal a) (is-FloatVal a)))",
    "assert_1": "(define-fun C1 () Bool (or (is-ComplexVal b) (is-FloatVal b)))",
    "assert_2": "(define-fun C2 () Bool\n  (ite (is-ComplexVal b)\n       (= (creal b) 0.0)\n       (ite (is-FloatVal b)\n            (= (fval b) 0.0)\n            false)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/125

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: find_length
Problem Description:
"""
Write a function to find the maximum difference between the number of 0s and number of 1s in any sub-string of the given binary string.
assert find_length("11000010001") == 6
"""


def find_length(string):

	assert isinstance(string, str), "invalid inputs" # $_CONTRACT_$
	assert all([c in '01' for c in string]), "invalid inputs" # $_CONTRACT_$
 
	current_sum = 0
	max_sum = 0
	for c in string: 
		current_sum += 1 if c == '0' else -1
		if current_sum < 0: 
			current_sum = 0
		max_sum = max(current_sum, max_sum) 
	return max_sum


Contract List:
assert_0: assert isinstance(string, str), "invalid inputs
assert_1: assert all([c in '01' for c in string]), "invalid inputs


<think>
I define SafeS to extract a String from our Value ADT and a recursive all_01_char_at to verify each character is ‘0’ or ‘1.’ Then C0 and C1 directly mirror the Python asserts, guarding selectors and ensuring precise SMT-LIB semantics.
</think>
```json
{
  "helper_functions": "(define-fun SafeS ((v Value)) String (ite (is-StrVal v) (sval v) \"\"))\n(define-fun-rec all_01_char_at ((s String) (i Int) (len Int)) Bool\n  (ite (>= i len)\n       true\n       (let ((ch (str.at s i)))\n         (and (or (= ch \"0\") (= ch \"1\"))\n              (all_01_char_at s (+ i 1) len)))))",
  "basic_structure": "",
  "inputs": "(declare-const string Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-StrVal string))",
    "assert_1": "(define-fun C1 () Bool (let ((s (SafeS string)) (len (str.len s))) (all_01_char_at s 0 len)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/126

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: sum
Problem Description:
"""
Write a python function to find the sum of common divisors of two given numbers.
assert sum(10,15) == 6
"""


import math
def sum(a,b):

    assert isinstance(a, int), "invalid inputs" # $_CONTRACT_$
    assert isinstance(b, int), "invalid inputs" # $_CONTRACT_$
    assert a > 0, "invalid inputs" # $_CONTRACT_$
    assert b > 0, "invalid inputs" # $_CONTRACT_$
 
    sum = 0
    n = math.gcd(a, b)
    N = int(math.sqrt(n)) + 1
    for i in range (1, N): 
        if (n % i == 0): 
            sum += i
            if (n / i != i): 
                sum += (n / i)
    return sum


Contract List:
assert_0: assert isinstance(a, int), "invalid inputs
assert_1: assert isinstance(b, int), "invalid inputs
assert_2: assert a > 0, "invalid inputs
assert_3: assert b > 0, "invalid inputs


<think>
I translate each Python assertion into a named SMT predicate over the Value ADT, using a SafeI extractor to guard integer selectors. Basic structure remains empty since all type and range checks are in the Ck predicates.
</think>
```json
{
  "helper_functions": "(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
  "basic_structure": "",
  "inputs": "(declare-const a Value)\n(declare-const b Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal a))",
    "assert_1": "(define-fun C1 () Bool (is-IntVal b))",
    "assert_2": "(define-fun C2 () Bool (> (SafeI a) 0))",
    "assert_3": "(define-fun C3 () Bool (> (SafeI b) 0))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/127

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: multiply_int
Problem Description:
"""
Write a function to multiply two integers.
assert multiply_int(10,20)==200
"""


def multiply_int(x, y):

    assert isinstance(x, int), "invalid inputs" # $_CONTRACT_$
    assert isinstance(y, int), "invalid inputs" # $_CONTRACT_$
    return x * y


Contract List:
assert_0: assert isinstance(x, int), "invalid inputs
assert_1: assert isinstance(y, int), "invalid inputs


<think>
I will map each `isinstance(..., int)` check to an `is-IntVal` predicate, declare the inputs as `Value`, and leave helper and structure sections empty since no extra ADTs or invariants beyond the contracts are needed.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "",
  "inputs": "(declare-const x Value)\n(declare-const y Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal x))",
    "assert_1": "(define-fun C1 () Bool (is-IntVal y))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/128

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: long_words
Problem Description:
"""
Write a function to find words that are longer than n characters from a given list of words.
assert long_words(3,"python is a programming language")==['python','programming','language']
"""


def long_words(n, s):

    assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
    assert isinstance(s, str), "invalid inputs" # $_CONTRACT_$
    assert n >= 0, "invalid inputs" # $_CONTRACT_$
    return list(filter(lambda x: len(x) > n, s.split(' ')))


Contract List:
assert_0: assert isinstance(n, int), "invalid inputs
assert_1: assert isinstance(s, str), "invalid inputs
assert_2: assert n >= 0, "invalid inputs


<think>
I map each Python assertion to an SMT predicate over a generic Value ADT, introduce SafeI/SafeS for guarded selectors, assert the minimal shape required for executability, and expose C0–C2 matching the original contracts.
</think>
```json
{
  "helper_functions": "(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))\n(define-fun SafeS ((v Value)) String (ite (is-StrVal v) (sval v) \"\"))",
  "basic_structure": "(assert (is-IntVal n))\n(assert (is-StrVal s))",
  "inputs": "(declare-const n Value)\n(declare-const s Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
    "assert_1": "(define-fun C1 () Bool (is-StrVal s))",
    "assert_2": "(define-fun C2 () Bool (>= (SafeI n) 0))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/129

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: magic_square_test
Problem Description:
"""
Write a function to calculate whether the matrix is a magic square.
assert magic_square_test([[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]])==True
"""


def magic_square_test(my_matrix):

    assert isinstance(my_matrix, list), "invalid inputs" # $_CONTRACT_$
    assert len(my_matrix) > 0, "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(row, list) for row in my_matrix), "invalid inputs" # $_CONTRACT_$
    assert len(my_matrix[0]) > 0, "invalid inputs" # $_CONTRACT_$
    assert all(len(row) == len(my_matrix[0]) for row in my_matrix), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(item, (int, float)) for row in my_matrix for item in row), "invalid inputs" # $_CONTRACT_$
    s = sum(my_matrix[0])
    # row
    if any(sum(row) != s for row in my_matrix):
        return False
    # column
    if any(sum(row[i] for row in my_matrix) != s for i in range(len(my_matrix[0]))):
        return False
    # diagonal
    if sum(my_matrix[i][i] for i in range(len(my_matrix))) != s:
        return False
    # anti-diagonal
    if sum(my_matrix[i][len(my_matrix) - i - 1] for i in range(len(my_matrix))) != s:
        return False
    return True


Contract List:
assert_0: assert isinstance(my_matrix, list), "invalid inputs
assert_1: assert len(my_matrix) > 0, "invalid inputs
assert_2: assert all(isinstance(row, list) for row in my_matrix), "invalid inputs
assert_3: assert len(my_matrix[0]) > 0, "invalid inputs
assert_4: assert all(len(row) == len(my_matrix[0]) for row in my_matrix), "invalid inputs
assert_5: assert all(isinstance(item, (int, float)) for row in my_matrix for item in row), "invalid inputs


<think>
I model the Python list and numeric checks as recursive SMT predicates over the canonical Value ADT, defining length, list shape, and numeric-content helpers, then translate each assert into a precise Bool predicate guarded by the necessary shape tests.
</think>
```json
{
  "helper_functions": 
"(define-fun IsList ((v Value)) Bool\n  (or (is-Nil v) (is-Cons v)))\n\n(define-fun-rec length ((l Value)) Int\n  (ite (is-Nil l) 0\n    (ite (is-Cons l)\n      (+ 1 (length (tail l)))\n      0)))\n\n(define-fun-rec all_is_list ((l Value)) Bool\n  (ite (is-Nil l) true\n    (ite (is-Cons l)\n      (and (IsList (head l)) (all_is_list (tail l)))\n      false)))\n\n(define-fun-rec all_same_length ((l Value) (len0 Int)) Bool\n  (ite (is-Nil l) true\n    (ite (is-Cons l)\n      (and (= (length (head l)) len0)\n           (all_same_length (tail l) len0))\n      false)))\n\n(define-fun-rec all_numeric_values ((l Value)) Bool\n  (ite (is-Nil l) true\n    (ite (is-Cons l)\n      (and (or (is-IntVal (head l)) (is-FloatVal (head l)))\n           (all_numeric_values (tail l)))\n      false)))\n\n(define-fun-rec all_numeric_matrix ((m Value)) Bool\n  (ite (is-Nil m) true\n    (ite (is-Cons m)\n      (and (let ((row (head m)))\n             (and (IsList row) (all_numeric_values row)))\n           (all_numeric_matrix (tail m)))\n      false)))",
  "basic_structure": 
"(assert (IsList my_matrix))",
  "inputs": 
"(declare-const my_matrix Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool\n  (IsList my_matrix))",
    "assert_1": "(define-fun C1 () Bool\n  (and (IsList my_matrix)\n       (> (length my_matrix) 0)))",
    "assert_2": "(define-fun C2 () Bool\n  (all_is_list my_matrix))",
    "assert_3": "(define-fun C3 () Bool\n  (and (is-Cons my_matrix)\n       (let ((first_row (head my_matrix)))\n         (and (IsList first_row)\n              (> (length first_row) 0)))))",
    "assert_4": "(define-fun C4 () Bool\n  (and (is-Cons my_matrix)\n       (let ((row0 (head my_matrix))\n             (len0 (length (head my_matrix))))\n         (and (IsList row0)\n              (all_same_length my_matrix len0)))))",
    "assert_5": "(define-fun C5 () Bool\n  (all_numeric_matrix my_matrix))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/130

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: max_occurrences
Problem Description:
"""
Write a function to find the item with maximum frequency in a given list.
assert max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2])==2
"""


from collections import defaultdict
def max_occurrences(nums):

    assert isinstance(nums, list), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(n, (int, float, str)) for n in nums), "invalid inputs" # $_CONTRACT_$
    d = defaultdict(int)
    for n in nums:
        d[n] += 1
    return max(d, key=d.get)


Contract List:
assert_0: assert isinstance(nums, list), "invalid inputs
assert_1: assert all(isinstance(n, (int, float, str)) for n in nums), "invalid inputs


<think>
I translate the Python contracts into two named SMT predicates over an ADT list, defining recursive helpers for list shape and element typing, while keeping basic execution constraints separate.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec AllValid ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (let ((hd (head v)) (tl (tail v)))\n              (and\n                (or (is-IntVal hd) (is-FloatVal hd) (is-StrVal hd))\n                (AllValid tl)))\n            false)))",
  "basic_structure": "",
  "inputs": "(declare-const nums Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList nums))",
    "assert_1": "(define-fun C1 () Bool (AllValid nums))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/131

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: reverse_vowels
Problem Description:
"""
Write a python function to reverse only the vowels of a given string (where y is not a vowel).
assert reverse_vowels("Python") == "Python"
"""


def reverse_vowels(str1):

	assert isinstance(str1, str), "invalid inputs" # $_CONTRACT_$
	is_vowel = lambda x: x in 'aeiouAEIOU'
	pos = [i for i, c in enumerate(str1) if is_vowel(c)]
	return ''.join(c if not is_vowel(c) else str1[pos.pop()] for c in str1)
		


Contract List:
assert_0: assert isinstance(str1, str), "invalid inputs


<think>
I translate the Python isinstance check into the ADT’s is-StrVal predicate, ensuring that the input can be safely used as a string. I include this shape constraint in Basic_Structure for executability and define C0 to match the contract exactly.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "(assert (is-StrVal str1))",
  "inputs": "(declare-const str1 Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-StrVal str1))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/132

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: tup_string
Problem Description:
"""
Write a function to convert a tuple to a string.
assert tup_string(('e', 'x', 'e', 'r', 'c', 'i', 's', 'e', 's'))==("exercises")
"""


def tup_string(tup1):

  assert isinstance(tup1, tuple), "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(item, str) for item in tup1), "invalid inputs" # $_CONTRACT_$
  return ''.join(tup1)


Contract List:
assert_0: assert isinstance(tup1, tuple), "invalid inputs
assert_1: assert all(isinstance(item, str) for item in tup1), "invalid inputs


<think>
I will model Python tuples as linked lists in the Value ADT, define recursive helpers for list structure and string‐element checks with safe guards, and then translate each assert into a named SMT predicate while keeping execution constraints separate.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n(define-fun-rec list_all_str ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (let ((h (head v)) (t (tail v)))\n              (and (is-StrVal h) (list_all_str t)))\n            false)))",
  "basic_structure": "",
  "inputs": "(declare-const tup1 Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool\n  (IsList tup1))",
    "assert_1": "(define-fun C1 () Bool\n  (=> C0 (list_all_str tup1)))"
  },
  "combination": "(assert (or\n  (and C0 C1)\n  (and (not C0) C1)\n  (and C0 (not C1))\n  (and (not C0) (not C1))))"
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/133

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: sum_negativenum
Problem Description:
"""
Write a function to calculate the sum of the negative numbers of a given list of numbers.
assert sum_negativenum([2, 4, -6, -9, 11, -12, 14, -5, 17])==-32
"""


def sum_negativenum(nums):

  assert isinstance(nums, list), "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(x, (int, float)) for x in nums), "invalid inputs" # $_CONTRACT_$
  return sum(x for x in nums if x < 0)


Contract List:
assert_0: assert isinstance(nums, list), "invalid inputs
assert_1: assert all(isinstance(x, (int, float)) for x in nums), "invalid inputs


<think>
I will encode the list‐ness and numeric‐element checks as recursive predicates in SMT‐LIB, declare the input, assert the shape in the basic structure, and then lift each Python assert into its own Boolean predicate.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (ite (is-Nil l) true\n    (ite (is-Cons l) (IsList (tail l)) false)))\n\n(define-fun-rec list_all_numeric ((l Value)) Bool\n  (ite (is-Nil l) true\n    (ite (is-Cons l)\n      (and (or (is-IntVal (head l)) (is-FloatVal (head l)))\n           (list_all_numeric (tail l)))\n    false)))",
  "basic_structure": "(assert (IsList nums))",
  "inputs": "(declare-const nums Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList nums))",
    "assert_1": "(define-fun C1 () Bool (list_all_numeric nums))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/135

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: hexagonal_num
Problem Description:
"""
Write a function to find the nth hexagonal number.
assert hexagonal_num(10) == 190
"""


def hexagonal_num(n):

	assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
	assert n >= 0, "invalid inputs" # $_CONTRACT_$
 
	return n * (2 * n - 1) 


Contract List:
assert_0: assert isinstance(n, int), "invalid inputs
assert_1: assert n >= 0, "invalid inputs


<think>
I translate the Python input assertions into SMT-LIB predicates over a canonical Value ADT, introduce a safe integer extractor to guard the IntVal selector, and define each contract (C0, C1) independently. No unconditional basic‐structure invariants are needed beyond the ADT, and each Ck mirrors its Python assert. 
</think>
```json
{
  "helper_functions": "(define-fun UnwrapInt ((v Value)) Int\n  (ite (is-IntVal v) (ival v) 0))",
  "basic_structure": "",
  "inputs": "(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool\n  (is-IntVal n))",
    "assert_1": "(define-fun C1 () Bool\n  (>= (UnwrapInt n) 0))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/137

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: zero_count
Problem Description:
"""
Write a function to find the ratio of zeroes to non-zeroes in an array of integers.
assert math.isclose(zero_count([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.181818, rel_tol=0.001)
"""


def zero_count(nums):

    assert isinstance(nums, list), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(x, int) for x in nums), "invalid inputs" # $_CONTRACT_$
    assert len(nums) > 0, "invalid inputs" # $_CONTRACT_$
    if all(x == 0 for x in nums):
        return float('inf')
    return sum(x == 0 for x in nums) / sum(x != 0 for x in nums)


Contract List:
assert_0: assert isinstance(nums, list), "invalid inputs
assert_1: assert all(isinstance(x, int) for x in nums), "invalid inputs
assert_2: assert len(nums) > 0, "invalid inputs


<think>
I translated each Python assertion into a standalone SMT predicate Ck, defined recursive helpers for list structure and integer checks, and asserted the core structural invariant so the SMT model remains executable.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec list_all_int ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (is-IntVal (head v))\n                 (list_all_int (tail v)))\n            false)))",
  "basic_structure": "(assert (IsList nums))",
  "inputs": "(declare-const nums Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList nums))",
    "assert_1": "(define-fun C1 () Bool (list_all_int nums))",
    "assert_2": "(define-fun C2 () Bool (is-Cons nums))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/138

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: is_Sum_Of_Powers_Of_Two
Problem Description:
"""
Write a python function to check whether the given number can be represented as sum of non-zero powers of 2 or not.
assert is_Sum_Of_Powers_Of_Two(10) == True
"""


def is_Sum_Of_Powers_Of_Two(n):

    assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
 
    return n > 0 and n % 2 == 0


Contract List:
assert_0: assert isinstance(n, int), "invalid inputs


<think>
I mirror the ADT structure, declare the input as a Value, assert the necessary IntVal shape for executability in BASIC_STRUCTURE, and map the Python isinstance check directly to C0.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "(assert (is-IntVal n))",
  "inputs": "(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal n))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/139

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: circle_circumference
Problem Description:
"""
Write a function to find the circumference of a circle.
assert math.isclose(circle_circumference(10), 62.830000000000005, rel_tol=0.001)
"""


import math
def circle_circumference(r):

  assert isinstance(r, int), "invalid inputs" # $_CONTRACT_$
  assert r > 0, "invalid inputs" # $_CONTRACT_$
  return 2 * math.pi * r


Contract List:
assert_0: assert isinstance(r, int), "invalid inputs
assert_1: assert r > 0, "invalid inputs


<think>
I translate each Python assert into a precise SMT predicate, guarding the integer selector with its tester. No additional helpers or basic invariants are needed beyond the ADT and the two contract predicates.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "",
  "inputs": "(declare-const r Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal r))",
    "assert_1": "(define-fun C1 () Bool (and (is-IntVal r) (> (ival r) 0)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/140

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: extract_singly
Problem Description:
"""
Write a function to flatten the list of lists into a single set of numbers.
assert set(extract_singly([(3, 4, 5), (4, 5, 7), (1, 4)])) == set([3, 4, 5, 7, 1])
"""


def extract_singly(test_list):

  assert isinstance(test_list, (list, tuple)), "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(x, (list, tuple)) for x in test_list), "invalid inputs" # $_CONTRACT_$
  assert all(all(isinstance(y, (int, float)) for y in x) for x in test_list), "invalid inputs" # $_CONTRACT_$
  return set([item for sublist in test_list for item in sublist])


Contract List:
assert_0: assert isinstance(test_list, (list, tuple)), "invalid inputs
assert_1: assert all(isinstance(x, (list, tuple)) for x in test_list), "invalid inputs
assert_2: assert all(all(isinstance(y, (int, float)) for y in x) for x in test_list), "invalid inputs


<think>
I will translate the Python input‐validation asserts into named SMT‐LIB predicates, define safe recursive list and numeric‐checking helpers, and declare inputs under the canonical Value ADT to ensure sound, executable contracts.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((x Value)) Bool\n  (ite (is-Nil x)\n       true\n       (ite (is-Cons x)\n            (IsList (tail x))\n            false)))\n\n(define-fun-rec ListAllList ((lst Value)) Bool\n  (ite (is-Nil lst)\n       true\n       (ite (is-Cons lst)\n            (and (IsList (head lst))\n                 (ListAllList (tail lst)))\n            false)))\n\n(define-fun-rec ListAllNumeric ((lst Value)) Bool\n  (ite (is-Nil lst)\n       true\n       (ite (is-Cons lst)\n            (and (or (is-IntVal (head lst))\n                     (is-FloatVal (head lst)))\n                 (ListAllNumeric (tail lst)))\n            false)))\n\n(define-fun-rec ListAllElementsNumeric ((matrix Value)) Bool\n  (ite (is-Nil matrix)\n       true\n       (ite (is-Cons matrix)\n            (and (ListAllNumeric (head matrix))\n                 (ListAllElementsNumeric (tail matrix)))\n            false)))",
  "basic_structure": "",
  "inputs": "(declare-const test_list Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList test_list))",
    "assert_1": "(define-fun C1 () Bool (ListAllList test_list))",
    "assert_2": "(define-fun C2 () Bool (ListAllElementsNumeric test_list))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/141

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: pancake_sort
Problem Description:
"""
Write a function to sort a list of elements.
assert pancake_sort([15, 79, 25, 38, 69]) == [15, 25, 38, 69, 79]
"""


def pancake_sort(nums):

    assert isinstance(nums, list), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(x, (int, float)) for x in nums), "invalid inputs" # $_CONTRACT_$
    arr_len = len(nums)
    while arr_len > 1:
        mi = nums.index(max(nums[0:arr_len]))
        nums = nums[mi::-1] + nums[mi+1:len(nums)]
        nums = nums[arr_len-1::-1] + nums[arr_len:len(nums)]
        arr_len -= 1
    return nums


Contract List:
assert_0: assert isinstance(nums, list), "invalid inputs
assert_1: assert all(isinstance(x, (int, float)) for x in nums), "invalid inputs


<think>
I translate the Python input‐validation into precise SMT‐LIB predicates: I define recursive helpers for list structure and numeric‐only lists, declare the Value ADT, assert mandatory list shape for executability, and map each assert into standalone Ck predicates.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec list_all_numeric ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (or (is-IntVal (head v)) (is-FloatVal (head v)))\n                 (list_all_numeric (tail v)))\n            false)))",
  "basic_structure": "(assert (IsList nums))",
  "inputs": "(declare-const nums Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList nums))",
    "assert_1": "(define-fun C1 () Bool (list_all_numeric nums))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/142

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: count_samepair
Problem Description:
"""
Write a function to count number items that are identical in the same position of three given lists.
assert count_samepair([1,2,3,4,5,6,7,8],[2,2,3,1,2,6,7,9],[2,1,3,1,2,6,7,9])==3
"""


def count_samepair(list1,list2,list3):

    assert isinstance(list1, list), "invalid inputs" # $_CONTRACT_$
    assert isinstance(list2, list), "invalid inputs" # $_CONTRACT_$
    assert isinstance(list3, list), "invalid inputs" # $_CONTRACT_$
    return sum(m == n == o for m, n, o in zip(list1,list2,list3))


Contract List:
assert_0: assert isinstance(list1, list), "invalid inputs
assert_1: assert isinstance(list2, list), "invalid inputs
assert_2: assert isinstance(list3, list), "invalid inputs


I will translate the Python `isinstance` checks into a recursive SMT predicate `IsList`, declare each input as a `Value`, and create standalone contract predicates C0–C2 that mirror the assertions. I’ll then enumerate all single, pairwise, and full-violation combinations using only those Ck atoms.

```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))",
  "basic_structure": "",
  "inputs": "(declare-const list1 Value)\n(declare-const list2 Value)\n(declare-const list3 Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList list1))",
    "assert_1": "(define-fun C1 () Bool (IsList list2))",
    "assert_2": "(define-fun C2 () Bool (IsList list3))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/145

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: max_Abs_Diff
Problem Description:
"""
Write a python function to find the maximum difference between any two elements in a given array.
assert max_Abs_Diff((2,1,5,3)) == 4
"""


def max_Abs_Diff(arr):

    assert isinstance(arr, (tuple, list)), "invalid inputs" # $_CONTRACT_$
    assert len(arr) > 0, "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(x, (int, float)) for x in arr), "invalid inputs" # $_CONTRACT_$
 
    return max(arr) - min(arr)


Contract List:
assert_0: assert isinstance(arr, (tuple, list)), "invalid inputs
assert_1: assert len(arr) > 0, "invalid inputs
assert_2: assert all(isinstance(x, (int, float)) for x in arr), "invalid inputs


<think>
I model the Python list and numeric checks with recursive SMT helpers (IsList, length, all_numeric) and map each Python assert to a precise Boolean predicate C0–C2, ensuring all selectors are safely guarded.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (or (is-Nil v)\n      (and (is-Cons v)\n           (let ((tailVal (tail v)))\n             (IsList tailVal)))))\n\n(define-fun-rec length ((v Value)) Int\n  (ite (is-Nil v)\n       0\n       (ite (is-Cons v)\n            (let ((tailVal (tail v)))\n              (+ 1 (length tailVal)))\n            0)))\n\n(define-fun-rec all_numeric ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (or (is-IntVal (head v)) (is-FloatVal (head v)))\n                 (all_numeric (tail v)))\n            false)))",
  "basic_structure": "(assert (IsList arr))",
  "inputs": "(declare-const arr Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList arr))",
    "assert_1": "(define-fun C1 () Bool (> (length arr) 0))",
    "assert_2": "(define-fun C2 () Bool (all_numeric arr))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/160

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: find_solution
Problem Description:
"""
Write a function that returns integers x and y that satisfy ax + by = n as a tuple, or return None if no solution exists.
assert find_solution(2, 3, 7) == (2, 1)
"""


def find_solution(a, b, n):

	assert isinstance(a, int), "invalid inputs" # $_CONTRACT_$
	assert isinstance(b, int), "invalid inputs" # $_CONTRACT_$
	assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
	i = 0
	while i * a <= n:
		if (n - (i * a)) % b == 0: 
			return (i, (n - (i * a)) // b)
		i = i + 1
	return None


Contract List:
assert_0: assert isinstance(a, int), "invalid inputs
assert_1: assert isinstance(b, int), "invalid inputs
assert_2: assert isinstance(n, int), "invalid inputs


<think>
I translate each Python isinstance assertion into a Boolean predicate over the ADT, using the generated is-IntVal tester. No complex helpers are needed since we only check integer-ness. I leave BASIC_STRUCTURE empty because all invariants are in the contracts.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "",
  "inputs": "(declare-const a Value)\n(declare-const b Value)\n(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal a))",
    "assert_1": "(define-fun C1 () Bool (is-IntVal b))",
    "assert_2": "(define-fun C2 () Bool (is-IntVal n))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/161

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: remove_elements
Problem Description:
"""
Write a function to remove all elements from a given list present in another list.
assert remove_elements([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [2, 4, 6, 8]) == [1, 3, 5, 7, 9, 10]
"""


def remove_elements(list1, list2):

    assert isinstance(list1, list), "invalid inputs" # $_CONTRACT_$
    assert isinstance(list2, list), "invalid inputs" # $_CONTRACT_$
    return [x for x in list1 if x not in list2]


Contract List:
assert_0: assert isinstance(list1, list), "invalid inputs
assert_1: assert isinstance(list2, list), "invalid inputs


<think>
I translate the Python isinstance checks into precise SMT predicates C0 and C1 using our Value ADT, and supply a recursive IsList helper to guarantee proper list shape for executability.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))",
  "basic_structure": "(assert (IsList list1))\n(assert (IsList list2))",
  "inputs": "(declare-const list1 Value)\n(declare-const list2 Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (or (is-Nil list1) (is-Cons list1)))",
    "assert_1": "(define-fun C1 () Bool (or (is-Nil list2) (is-Cons list2)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/162

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: sum_series
Problem Description:
"""
Write a function to calculate the sum (n - 2*i) from i=0 to n // 2, for instance n + (n-2) + (n-4)... (until n-x =< 0).
assert sum_series(6) == 12
"""


def sum_series(n):

  assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
  if n <= 0:
    return 0
  return sum(n - 2 * i for i in range(n // 2 + 1))


Contract List:
assert_0: assert isinstance(n, int), "invalid inputs


<think>
I model the integer input as a Value ADT with a SafeI extractor to ensure safe access. The basic structure asserts that `n` is an `IntVal` for executability, and I define C0 exactly matching `assert isinstance(n,int)`.
</think>
```json
{
  "helper_functions": "(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
  "basic_structure": "(assert (is-IntVal n))",
  "inputs": "(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal n))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/165

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: count_char_position
Problem Description:
"""
Write a function to count the number of characters in a string that occur at the same position in the string as in the English alphabet (case insensitive).
assert count_char_position("xbcefg") == 2
"""


def count_char_position(str1):

    assert isinstance(str1, str), "invalid inputs" # $_CONTRACT_$
    assert all(x.isalpha() for x in str1), "invalid inputs" # $_CONTRACT_$
 
    return sum(ord(ch.lower()) - ord('a') == i for i, ch in enumerate(str1))


Contract List:
assert_0: assert isinstance(str1, str), "invalid inputs
assert_1: assert all(x.isalpha() for x in str1), "invalid inputs


<think>
I translate each Python assertion into a precise SMT predicate guarded by the ADT shape, define a helper to enforce “all characters are alphabetic” using regex, and assert the basic string shape for executability.
</think>
```json
{
  "helper_functions": "(define-fun str_all_alpha ((v Value)) Bool (and (is-StrVal v) (str.in.re (sval v) (re.* (re.union (re.range \"A\" \"Z\") (re.range \"a\" \"z\"))))))",
  "basic_structure": "(assert (is-StrVal str1))",
  "inputs": "(declare-const str1 Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-StrVal str1))",
    "assert_1": "(define-fun C1 () Bool (str_all_alpha str1))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/166

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: find_even_pair
Problem Description:
"""
Write a function that counts the number of pairs of integers in a list that xor to an even number.
assert find_even_pair([5, 4, 7, 2, 1]) == 4
"""


def find_even_pair(A):

  assert isinstance(A, list), "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(x, int) for x in A), "invalid inputs" # $_CONTRACT_$
 
  if len(A) < 2: 
    return 0
  return sum((a ^ b) % 2 == 0 for i, a in enumerate(A) for b in A[i + 1:])


Contract List:
assert_0: assert isinstance(A, list), "invalid inputs
assert_1: assert all(isinstance(x, int) for x in A), "invalid inputs


<think>
I mapped the Python list and integer‐type checks into precise SMT‐LIB predicates by defining recursive ADT‐safe helpers `IsList` and `ListAllInt`, then declared the input and basic structure, and finally modeled each assertion as named Boolean contracts.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n    true\n    (ite (is-Cons v)\n      (IsList (tail v))\n      false)))\n(define-fun-rec ListAllInt ((v Value)) Bool\n  (ite (is-Nil v)\n    true\n    (ite (is-Cons v)\n      (and (is-IntVal (head v)) (ListAllInt (tail v)))\n      false)))",
  "basic_structure": "(assert (IsList A))",
  "inputs": "(declare-const A Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList A))",
    "assert_1": "(define-fun C1 () Bool (ListAllInt A))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/167

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: next_power_of_2
Problem Description:
"""
Write a python function to find the smallest power of 2 greater than or equal to n.
assert next_power_of_2(0) == 1
"""


def next_power_of_2(n):

  assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
  assert n >= 0, "invalid inputs" # $_CONTRACT_$
 
  if n and not n & (n - 1):
    return n
  res = 1
  while n != 0: 
    n >>= 1
    res <<= 1
  return res; 


Contract List:
assert_0: assert isinstance(n, int), "invalid inputs
assert_1: assert n >= 0, "invalid inputs


<think>
I translate the Python input checks into precise SMT predicates, introduce a safe integer extractor to guard ival usage, and declare minimal structure to model executability without precluding contract testing.
</think>
```json
{
  "helper_functions": "(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
  "basic_structure": "(define-fun BasicStructure () Bool true)",
  "inputs": "(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
    "assert_1": "(define-fun C1 () Bool (and C0 (>= (SafeI n) 0)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/168

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: frequency
Problem Description:
"""
Write a function to count the number of occurrences of a number in a given list.
assert frequency([1,2,3], 4) == 0
"""


def frequency(a,x):

    assert isinstance(a, list), "invalid inputs" # $_CONTRACT_$
    assert isinstance(x, (int, float)), "invalid inputs" # $_CONTRACT_$
 
    return a.count(x)


Contract List:
assert_0: assert isinstance(a, list), "invalid inputs
assert_1: assert isinstance(x, (int, float)), "invalid inputs


<think>
I translate Python’s list and numeric type checks into precise SMT predicates, define a recursive IsList for ADT safety, and enumerate all satisfaction/violation combinations of the two input contracts.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v) true\n    (ite (is-Cons v)\n      (IsList (tail v))\n      false)))",
  "basic_structure": "(assert (IsList a))",
  "inputs": "(declare-const a Value)\n(declare-const x Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList a))",
    "assert_1": "(define-fun C1 () Bool (or (is-IntVal x) (is-FloatVal x)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/170

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: sum_range_list
Problem Description:
"""
Write a function to find the sum of numbers in a list within a range specified by two indices.
assert sum_range_list([2,1,5,6,8,3,4,9,10,11,8,12], 8, 10) == 29
"""


def sum_range_list(list1, m, n):

    assert isinstance(list1, list), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(item, (int, float)) for item in list1), "invalid inputs" # $_CONTRACT_$
    assert isinstance(m, int), "invalid inputs" # $_CONTRACT_$
    assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
    assert 0 <= m < len(list1), "invalid inputs" # $_CONTRACT_$
    assert 0 <= n < len(list1), "invalid inputs" # $_CONTRACT_$
                                                                                                                                                                                                
    return sum(list1[m : n + 1])


Contract List:
assert_0: assert isinstance(list1, list), "invalid inputs
assert_1: assert all(isinstance(item, (int, float)) for item in list1), "invalid inputs
assert_2: assert isinstance(m, int), "invalid inputs
assert_3: assert isinstance(n, int), "invalid inputs
assert_4: assert 0 <= m < len(list1), "invalid inputs
assert_5: assert 0 <= n < len(list1), "invalid inputs


<think>
I will translate the Python assertions into precise SMT-LIB predicates, defining recursive helpers for list structure, length, and numeric checking, then express each contract C0–C5 with appropriate guards and let-bindings.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec length ((v Value)) Int\n  (ite (is-Cons v)\n       (+ 1 (length (tail v)))\n       0))\n\n(define-fun-rec list_all_numeric ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (let ((h (head v)) (t (tail v)))\n              (ite (or (is-IntVal h) (is-FloatVal h))\n                   (list_all_numeric t)\n                   false))\n            false)))",
  "basic_structure": "(assert (IsList list1))",
  "inputs": "(declare-const list1 Value)\n(declare-const m Value)\n(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool\n  (IsList list1))",
    "assert_1": "(define-fun C1 () Bool\n  (list_all_numeric list1))",
    "assert_2": "(define-fun C2 () Bool\n  (is-IntVal m))",
    "assert_3": "(define-fun C3 () Bool\n  (is-IntVal n))",
    "assert_4": "(define-fun C4 () Bool\n  (and C2\n       (let ((m_int (ival m)) (len_v (length list1)))\n         (and (<= 0 m_int) (< m_int len_v)))))",
    "assert_5": "(define-fun C5 () Bool\n  (and C3\n       (let ((n_int (ival n)) (len_v (length list1)))\n         (and (<= 0 n_int) (< n_int len_v)))))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/171

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: perimeter_pentagon
Problem Description:
"""
Write a function to find the perimeter of a regular pentagon from the length of its sides.
assert perimeter_pentagon(5) == 25
"""


def perimeter_pentagon(a):

  assert isinstance(a, (int, float)), "invalid inputs" # $_CONTRACT_$
  return 5 * a


Contract List:
assert_0: assert isinstance(a, (int, float)), "invalid inputs


<think>
I will translate the Python type‐check into an SMT predicate by defining a helper isNumber, declare the parameter as a Value, and set a trivial basic structure. Then C0 enforces that a is an IntVal or FloatVal.
</think>
```json
{
  "helper_functions": "(define-fun isNumber ((v Value)) Bool (or (is-IntVal v) (is-FloatVal v)))",
  "basic_structure": "(assert true)",
  "inputs": "(declare-const a Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (isNumber a))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/172

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: count_occurance
Problem Description:
"""
Write a function to count the number of occurence of the string 'std' in a given string.
assert count_occurance("letstdlenstdporstd") == 3
"""


def count_occurance(s):

  assert isinstance(s, str), "invalid inputs" # $_CONTRACT_$
  return s.count('std')


Contract List:
assert_0: assert isinstance(s, str), "invalid inputs


<think>
I map the Python isinstance check to an SMT predicate requiring the `Value` to be a `StrVal`, ensuring the ADT shape is correct for string operations. No additional structural invariants or helpers are needed for this simple contract.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "",
  "inputs": "(declare-const s Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-StrVal s))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/222

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: check_type
Problem Description:
"""
Write a function to check if all the elements in tuple have same data type or not.
assert check_type((5, 6, 7, 3, 5, 6) ) == True
"""


def check_type(test_tuple):

    assert isinstance(test_tuple, tuple), "invalid inputs" # $_CONTRACT_$
    assert len(test_tuple) > 0, "invalid inputs" # $_CONTRACT_$
    return all(isinstance(item, type(test_tuple[0])) for item in test_tuple)


Contract List:
assert_0: assert isinstance(test_tuple, tuple), "invalid inputs
assert_1: assert len(test_tuple) > 0, "invalid inputs


<think>
I model Python tuples as our Cons/Nil list ADT, provide an IsList predicate and recursive length definition, then encode each assert as a Boolean predicate checking list-ness and non-emptiness.
</think>
```json
{
  "helper_functions": "(define-fun IsList ((v Value)) Bool\n  (or (is-Nil v) (is-Cons v)))\n\n(define-fun-rec length ((l Value)) Int\n  (ite (is-Nil l)\n       0\n       (+ 1 (length (tail l)))))",
  "basic_structure": "",
  "inputs": "(declare-const test_tuple Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool\n  (IsList test_tuple))",
    "assert_1": "(define-fun C1 () Bool\n  (> (length test_tuple) 0))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/223

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: is_majority
Problem Description:
"""
Write a function that takes in a sorted array, its length (n), and an element and returns whether the element is the majority element in the given sorted array. (The majority element is the element that occurs more than n/2 times.)
assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True
"""


from bisect import bisect_left, bisect_right
def is_majority(arr, n, x):

	assert isinstance(arr, list), "invalid inputs" # $_CONTRACT_$
	assert all(isinstance(item, (int, float)) for item in arr), "invalid inputs" # $_CONTRACT_$
	assert all(a <= b for a, b in zip(arr[:n], arr[1:n])), "invalid inputs" # $_CONTRACT_$
	assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
	assert isinstance(x, (int, float)), "invalid inputs" # $_CONTRACT_$
	assert len(arr) <= n, "invalid inputs" # $_CONTRACT_$
	if x not in arr:
		return False
	l = bisect_left(arr, x)
	r = bisect_right(arr, x)
	return r - l > n / 2


Contract List:
assert_0: assert isinstance(arr, list), "invalid inputs
assert_1: assert all(isinstance(item, (int, float)) for item in arr), "invalid inputs
assert_2: assert all(a <= b for a, b in zip(arr[:n], arr[1:n])), "invalid inputs
assert_3: assert isinstance(n, int), "invalid inputs
assert_4: assert isinstance(x, (int, float)), "invalid inputs
assert_5: assert len(arr) <= n, "invalid inputs


<think>
I translated each Python assertion into a precise SMT predicate C0…C5, defined safe, recursive helpers (IsList, length, list_all_numeric, is_sorted) to model lists and numeric comparisons, and isolated only the minimal structural assertions into BASIC_STRUCTURE for executability.
</think>
```json
{
  "helper_functions": "(declare-fun IsList (Value) Bool)\n(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v) true\n    (ite (is-Cons v)\n      (IsList (tail v))\n      false)))\n(define-fun-rec length ((v Value)) Int\n  (ite (is-Nil v) 0\n    (ite (is-Cons v)\n      (+ 1 (length (tail v)))\n      0)))\n(define-fun-rec list_all_numeric ((v Value)) Bool\n  (ite (is-Nil v) true\n    (ite (is-Cons v)\n      (and (or (is-IntVal (head v)) (is-FloatVal (head v)))\n           (list_all_numeric (tail v)))\n      false)))\n(define-fun num_le ((a Value) (b Value)) Bool\n  (ite (and (is-IntVal a) (is-IntVal b))\n    (<= (to_real (ival a)) (to_real (ival b)))\n    (ite (and (is-FloatVal a) (is-FloatVal b))\n      (<= (fval a) (fval b))\n      (ite (and (is-IntVal a) (is-FloatVal b))\n        (<= (to_real (ival a)) (fval b))\n        (ite (and (is-FloatVal a) (is-IntVal b))\n          (<= (fval a) (to_real (ival b)))\n          false)))))\n(define-fun-rec is_sorted ((v Value)) Bool\n  (ite (is-Cons v)\n    (let ((hd (head v)) (tl (tail v)))\n      (ite (is-Cons tl)\n        (let ((hd2 (head tl)) (tl2 (tail tl)))\n          (and (num_le hd hd2) (is_sorted tl)))\n        true))\n    true))",
  "basic_structure": "(assert (IsList arr))\n(assert (list_all_numeric arr))\n(assert (is-IntVal n))\n(assert (or (is-IntVal x) (is-FloatVal x)))\n(assert (<= (length arr) (ival n)))",
  "inputs": "(declare-const arr Value)\n(declare-const n Value)\n(declare-const x Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList arr))",
    "assert_1": "(define-fun C1 () Bool (list_all_numeric arr))",
    "assert_2": "(define-fun C2 () Bool (is_sorted arr))",
    "assert_3": "(define-fun C3 () Bool (is-IntVal n))",
    "assert_4": "(define-fun C4 () Bool (or (is-IntVal x) (is-FloatVal x)))",
    "assert_5": "(define-fun C5 () Bool (<= (length arr) (ival n)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/224

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: count_Set_Bits
Problem Description:
"""
Write a python function to count the number of set bits (binary digits with value 1) in a given number.
assert count_Set_Bits(2) == 1
"""


def count_Set_Bits(n):

    assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
    assert n >= 0, "invalid inputs" # $_CONTRACT_$
 
    return bin(n)[2:].count('1')


Contract List:
assert_0: assert isinstance(n, int), "invalid inputs
assert_1: assert n >= 0, "invalid inputs


<think>
I translate the Python integer type and non-negativity checks into precise SMT-LIB predicates, introducing a SafeIval helper to safely extract integer values from the ADT. Each assertion becomes a standalone Ck predicate, and basic structure remains minimal since the ADT itself ensures valid Value shapes.
</think>
```json
{
  "helper_functions": "(define-fun SafeIval ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
  "basic_structure": "",
  "inputs": "(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
    "assert_1": "(define-fun C1 () Bool (>= (SafeIval n) 0))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/226

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: odd_values_string
Problem Description:
"""
Write a python function to remove the characters which have odd index values of a given string.
assert odd_values_string('abcdef') == 'ace'
"""


def odd_values_string(str1):

    assert isinstance(str1, str), "invalid inputs" # $_CONTRACT_$
    return ''.join(str1[i] for i in range(0, len(str1), 2))


Contract List:
assert_0: assert isinstance(str1, str), "invalid inputs


<think>
I translate the Python type assertion into a precise SMT predicate over our Value ADT and supply a safe string‐extract helper so the function body can execute without direct type‐selector calls.
</think>
```json
{
  "helper_functions": "(define-fun SafeStr ((v Value)) String (ite (is-StrVal v) (sval v) \"\"))",
  "basic_structure": "",
  "inputs": "(declare-const str1 Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-StrVal str1))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/227

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: min_of_three
Problem Description:
"""
Write a function to find minimum of three numbers.
assert min_of_three(10,20,0)==0
"""


def min_of_three(a,b,c):

  assert isinstance(a, (int, float)), "invalid inputs" # $_CONTRACT_$
  assert isinstance(b, (int, float)), "invalid inputs" # $_CONTRACT_$
  assert isinstance(c, (int, float)), "invalid inputs" # $_CONTRACT_$
 
  return min(a, b, c)


Contract List:
assert_0: assert isinstance(a, (int, float)), "invalid inputs
assert_1: assert isinstance(b, (int, float)), "invalid inputs
assert_2: assert isinstance(c, (int, float)), "invalid inputs


<think>
I translate each Python isinstance check into an SMT predicate over the ADT constructors, declare inputs, and enumerate all combinations of contract satisfaction/violation for testing.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "",
  "inputs": "(declare-const a Value)\n(declare-const b Value)\n(declare-const c Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (or (is-IntVal a) (is-FloatVal a)))",
    "assert_1": "(define-fun C1 () Bool (or (is-IntVal b) (is-FloatVal b)))",
    "assert_2": "(define-fun C2 () Bool (or (is-IntVal c) (is-FloatVal c)))"
  },
  "combination": "(assert (and C0 C1 C2))\n(assert (and (not C0) C1 C2))\n(assert (and C0 (not C1) C2))\n(assert (and C0 C1 (not C2)))\n(assert (and (not C0) (not C1) C2))\n(assert (and (not C0) C1 (not C2)))\n(assert (and C0 (not C1) (not C2)))\n(assert (and (not C0) (not C1) (not C2)))"
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/230

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: replace_blank
Problem Description:
"""
Write a function that takes in a string and character, replaces blank spaces in the string with the character, and returns the string.
assert replace_blank("hello people",'@')==("hello@people")
"""


def replace_blank(str1, char):

    assert isinstance(str1, str), "invalid inputs" # $_CONTRACT_$
    assert isinstance(char, str), "invalid inputs" # $_CONTRACT_$
    assert len(char) == 1, "invalid inputs" # $_CONTRACT_$
    return str1.replace(' ', char)


Contract List:
assert_0: assert isinstance(str1, str), "invalid inputs
assert_1: assert isinstance(char, str), "invalid inputs
assert_2: assert len(char) == 1, "invalid inputs


<think>
I translate each Python assert into a precise SMT Bool predicate over a single Value ADT, add a SafeStr helper to extract strings safely, assert that both inputs are StrVal for executability, and define C0–C2 matching isinstance and length checks.
</think>
```json
{
  "helper_functions": "(define-fun SafeStr ((v Value)) String (ite (is-StrVal v) (sval v) \"\"))",
  "basic_structure": "(define-fun BasicStructure () Bool (and (is-StrVal str1) (is-StrVal char)))",
  "inputs": "(declare-const str1 Value)\n(declare-const char Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-StrVal str1))",
    "assert_1": "(define-fun C1 () Bool (is-StrVal char))",
    "assert_2": "(define-fun C2 () Bool (and (is-StrVal char) (= (str.len (SafeStr char)) 1)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/232

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: larg_nnum
Problem Description:
"""
Write a function that takes in a list and an integer n and returns a list containing the n largest items from the list.
assert set(larg_nnum([10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100],2))==set([100,90])
"""


import heapq
def larg_nnum(list1, n):

    assert isinstance(list1, list), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(x, (int, float)) for x in list1), "invalid inputs" # $_CONTRACT_$
    assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
    assert 0 <= n <= len(list1), "invalid inputs" # $_CONTRACT_$
    return heapq.nlargest(n,list1)


Contract List:
assert_0: assert isinstance(list1, list), "invalid inputs
assert_1: assert all(isinstance(x, (int, float)) for x in list1), "invalid inputs
assert_2: assert isinstance(n, int), "invalid inputs
assert_3: assert 0 <= n <= len(list1), "invalid inputs


<think>
I translate each Python assertion into an SMT-LIB predicate over a canonical ADT, introduce safe selectors and recursive helpers for list shape, length, and numeric checks, and declare inputs consistently. Contract predicates (C0–C3) are isolated and use testers/guards for soundness.
</think>
```json
{
  "helper_functions": "(declare-datatypes ((Value 0)) (((IntVal (ival Int)) (FloatVal (fval Real)) (StrVal (sval String)) (BoolVal (bval Bool)) (Nil) (Cons (head Value) (tail Value)))))\n(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))\n(define-fun-rec IsList ((l Value)) Bool (or (is-Nil l) (and (is-Cons l) (IsList (tail l)))))\n(define-fun-rec list_all_numeric ((l Value)) Bool (or (is-Nil l) (and (is-Cons l) (or (is-IntVal (head l)) (is-FloatVal (head l))) (list_all_numeric (tail l)))))\n(define-fun-rec list_length ((l Value)) Int (ite (is-Nil l) 0 (+ 1 (list_length (tail l)))))",
  "basic_structure": "",
  "inputs": "(declare-const list1 Value)\n(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList list1))",
    "assert_1": "(define-fun C1 () Bool (and (IsList list1) (list_all_numeric list1)))",
    "assert_2": "(define-fun C2 () Bool (is-IntVal n))",
    "assert_3": "(define-fun C3 () Bool (and (is-IntVal n) (<= 0 (SafeI n)) (<= (SafeI n) (list_length list1))))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/233

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: lateralsuface_cylinder
Problem Description:
"""
Write a function to find the lateral surface area of a cylinder.
assert math.isclose(lateralsuface_cylinder(10,5), 314.15000000000003, rel_tol=0.001)
"""


import math
def lateralsuface_cylinder(r, h):

  assert isinstance(r, (int, float)), "invalid inputs" # $_CONTRACT_$
  assert isinstance(h, (int, float)), "invalid inputs" # $_CONTRACT_$
  assert r > 0, "invalid inputs" # $_CONTRACT_$
  assert h > 0, "invalid inputs" # $_CONTRACT_$
  return 2 * math.pi * r * h


Contract List:
assert_0: assert isinstance(r, (int, float)), "invalid inputs
assert_1: assert isinstance(h, (int, float)), "invalid inputs
assert_2: assert r > 0, "invalid inputs
assert_3: assert h > 0, "invalid inputs


<think>
I introduce helpers is-Numeric and toReal to guard type tests and extract numeric values safely, declare inputs r and h as Value, keep basic_structure empty since executability relies on contracts, and define C0–C3 to match each Python assert exactly.
</think>
```json
{
  "helper_functions": "(define-fun is-Numeric ((v Value)) Bool\n  (or (is-IntVal v) (is-FloatVal v)))\n(define-fun toReal ((v Value)) Real\n  (ite (is-IntVal v) (to_real (ival v))\n    (ite (is-FloatVal v) (fval v) 0.0)))",
  "basic_structure": "",
  "inputs": "(declare-const r Value)\n(declare-const h Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-Numeric r))",
    "assert_1": "(define-fun C1 () Bool (is-Numeric h))",
    "assert_2": "(define-fun C2 () Bool (> (toReal r) 0.0))",
    "assert_3": "(define-fun C3 () Bool (> (toReal h) 0.0))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/234

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: volume_cube
Problem Description:
"""
Write a function to find the volume of a cube given its side length.
assert volume_cube(3)==27
"""


def volume_cube(l):

  assert isinstance(l, (int, float)), "invalid inputs" # $_CONTRACT_$
  assert l > 0, "invalid inputs" # $_CONTRACT_$
  return l ** 3


Contract List:
assert_0: assert isinstance(l, (int, float)), "invalid inputs
assert_1: assert l > 0, "invalid inputs


<think>
I will model the numeric side length as a Value ADT, define a SafeNum helper to extract its numeric value, and then express the two Python assertions as SMT predicates guarded appropriately. This ensures program executability by safe extraction and precise equivalence to the original Python contract semantics.
</think>
```json
{
  "helper_functions": "(define-fun SafeNum ((v Value)) Real\n  (ite (is-IntVal v) (to_real (ival v))\n    (ite (is-FloatVal v) (fval v) 0.0)))",
  "basic_structure": "",
  "inputs": "(declare-const l Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (or (is-IntVal l) (is-FloatVal l)))",
    "assert_1": "(define-fun C1 () Bool (and C0 (> (SafeNum l) 0.0)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/235

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: even_bit_set_number
Problem Description:
"""
Write a python function to set all even bits of a given number.
assert even_bit_set_number(10) == 10
"""


def even_bit_set_number(n):

    assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
    assert n >= 0, "invalid inputs" # $_CONTRACT_$
 
    mask = 2
    while mask < n:
        n |= mask
        mask <<= 2
    return n


Contract List:
assert_0: assert isinstance(n, int), "invalid inputs
assert_1: assert n >= 0, "invalid inputs


<think>
I translate the Python `isinstance` and non-negativity assertions into SMT predicates using a safe integer extractor, ensure the input ADT shape is correct, and define each contract as a separate Boolean.
</think>
```json
{
  "helper_functions": "(define-fun SafeInt ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
  "basic_structure": "(assert (is-IntVal n))",
  "inputs": "(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
    "assert_1": "(define-fun C1 () Bool (>= (SafeInt n) 0))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/237

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: check_occurences
Problem Description:
"""
Write a function that takes in a list of tuples and returns a dictionary mapping each unique tuple to the number of times it occurs in the list.
assert check_occurences([(3, 1), (1, 3), (2, 5), (5, 2), (6, 3)] ) == {(1, 3): 2, (2, 5): 2, (3, 6): 1}
"""


from collections import Counter 
def check_occurences(test_list):

  assert isinstance(test_list, list), "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(x, tuple) for x in test_list), "invalid inputs" # $_CONTRACT_$
  return dict(Counter(tuple(sorted(t)) for t in test_list))


Contract List:
assert_0: assert isinstance(test_list, list), "invalid inputs
assert_1: assert all(isinstance(x, tuple) for x in test_list), "invalid inputs


<think>
I translated the Python list and tuple checks into precise SMT-LIB predicates: I model Python lists as a recursive Cons/Nil ADT, define helpers for list structure, length, and tuple‐of‐length‐2, then map each contract to a named Boolean predicate.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec length ((v Value)) Int\n  (ite (is-Nil v)\n       0\n       (ite (is-Cons v)\n            (+ 1 (length (tail v)))\n            0)))\n\n(define-fun IsTuple ((v Value)) Bool\n  (and (IsList v)\n       (= (length v) 2)))\n\n(define-fun-rec list_all_tuple ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (and (IsTuple (head v))\n            (list_all_tuple (tail v)))))",
  "basic_structure": "(assert (IsList test_list))",
  "inputs": "(declare-const test_list Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool\n  (IsList test_list))",
    "assert_1": "(define-fun C1 () Bool\n  (list_all_tuple test_list))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/238

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: number_of_substrings
Problem Description:
"""
Write a python function to count the number of non-empty substrings of a given string.
assert number_of_substrings("abc") == 6
"""


def number_of_substrings(str1):

	assert isinstance(str1, str), "invalid inputs" # $_CONTRACT_$
 
	str_len = len(str1) 
	return str_len * (str_len + 1) // 2


Contract List:
assert_0: assert isinstance(str1, str), "invalid inputs


<think>
I will translate the single Python type‐check assertion into an SMT predicate over our Value ADT, declare the input, and keep the template minimal since no complex helpers or basic invariants beyond the contract are needed.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "",
  "inputs": "(declare-const str1 Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-StrVal str1))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/239

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: get_total_number_of_sequences
Problem Description:
"""
Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.
assert get_total_number_of_sequences(10, 4) == 4
"""


def get_total_number_of_sequences(m, n):

	assert isinstance(m, int) and m > 0, "invalid inputs" # $_CONTRACT_$ 
	assert isinstance(n, int) and n > 0, "invalid inputs" # $_CONTRACT_$
	T=[[0 for _ in range(n + 1)] for _ in range(m + 1)] 
	for i in range(m + 1): 
		for j in range(n + 1): 
			if i==0 or j==0: 
				T[i][j] = 0
			elif i<j: 
				T[i][j] = 0
			elif j==1: 
				T[i][j] = i 
			else: 
				T[i][j] = T[i-1][j] + T[i//2][j-1] 
	return T[m][n]


Contract List:
assert_0: assert isinstance(m, int) and m > 0, "invalid inputs
assert_1: assert isinstance(n, int) and n > 0, "invalid inputs


<think>
I translate the two input‐validation asserts into SMT predicates using a SafeI helper to extract integer values from the ADT, define C0 and C1 for the “is-IntVal and >0” checks, and leave basic_structure empty since no extra invariants are required to model executability.
</think>
```json
{
  "helper_functions": "(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
  "basic_structure": "",
  "inputs": "(declare-const m Value)\n(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (let ((mInt (SafeI m))) (and (is-IntVal m) (> mInt 0))))",
    "assert_1": "(define-fun C1 () Bool (let ((nInt (SafeI n))) (and (is-IntVal n) (> nInt 0))))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/240

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: replace_list
Problem Description:
"""
Write a function that takes in two lists and replaces the last element of the first list with the elements of the second list.
assert replace_list([1, 3, 5, 7, 9, 10],[2, 4, 6, 8])==[1, 3, 5, 7, 9, 2, 4, 6, 8]
"""


def replace_list(list1, list2):

    assert isinstance(list1, list), "invalid inputs" # $_CONTRACT_$
    assert len(list1) > 0, "invalid inputs" # $_CONTRACT_$
    assert isinstance(list2, list), "invalid inputs" # $_CONTRACT_$
    return list1[:-1] + list2


Contract List:
assert_0: assert isinstance(list1, list), "invalid inputs
assert_1: assert len(list1) > 0, "invalid inputs
assert_2: assert isinstance(list2, list), "invalid inputs


<think>
I model the list shape and length with recursive helper functions to ensure safe list operations, then define each Python assert as a Boolean predicate over these helpers, keeping execution constraints in the basic structure.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec Len ((v Value)) Int\n  (ite (is-Nil v)\n       0\n       (ite (is-Cons v)\n            (+ 1 (Len (tail v)))\n            0)))",
  "basic_structure": "(assert (IsList list1))\n(assert (IsList list2))",
  "inputs": "(declare-const list1 Value)\n(declare-const list2 Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList list1))",
    "assert_1": "(define-fun C1 () Bool (> (Len list1) 0))",
    "assert_2": "(define-fun C2 () Bool (IsList list2))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/242

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: count_charac
Problem Description:
"""
Write a function to count the total number of characters in a string.
assert count_charac("python programming")==18
"""


def count_charac(str1):

    assert isinstance(str1, str), "invalid inputs" # $_CONTRACT_$
    return len(str1)


Contract List:
assert_0: assert isinstance(str1, str), "invalid inputs


<think>
I will encode the Python `isinstance(str1, str)` check as an SMT-LIB predicate C0 using the `is-StrVal` tester, provide the minimal base template for executability, and declare the single input.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "",
  "inputs": "(declare-const str1 Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-StrVal str1))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/244

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: next_Perfect_Square
Problem Description:
"""
Write a python function to find the next perfect square greater than a given number.
assert next_Perfect_Square(35) == 36
"""


import math  
def next_Perfect_Square(N):

    assert isinstance(N, (int, float)), "invalid inputs" # $_CONTRACT_$
 
    if N < 0:
        return 0
    nextN = math.floor(math.sqrt(N)) + 1
    return nextN * nextN 


Contract List:
assert_0: assert isinstance(N, (int, float)), "invalid inputs


<think>
I translate the Python assertion into an SMT predicate ensuring N is either an IntVal or FloatVal, introduce a SafeToReal helper to enable numeric operations safely, and assert the basic structural requirement for executability.
</think>
```json
{
  "helper_functions": "(define-fun SafeToReal ((v Value)) Real\n  (ite (is-IntVal v)\n       (to_real (ival v))\n       (ite (is-FloatVal v)\n            (fval v)\n            0.0)))",
  "basic_structure": "(assert (or (is-IntVal N) (is-FloatVal N)))",
  "inputs": "(declare-const N Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (or (is-IntVal N) (is-FloatVal N)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/245

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: max_sum
Problem Description:
"""
Write a function that takes an array and finds the maximum sum of a bitonic subsequence for the given array, where a sequence is bitonic if it is first increasing and then decreasing.
assert max_sum([1, 15, 51, 45, 33, 100, 12, 18, 9]) == 194
"""


def max_sum(arr):

	assert isinstance(arr, list), "invalid inputs" # $_CONTRACT_$
	assert len(arr) > 0, "invalid inputs" # $_CONTRACT_$
	assert all(isinstance(x, (int, float)) for x in arr), "invalid inputs" # $_CONTRACT_$
 
	MSIBS = arr[:] 
	for i in range(len(arr)): 
		for j in range(0, i): 
			if arr[i] > arr[j] and MSIBS[i] < MSIBS[j] + arr[i]: 
				MSIBS[i] = MSIBS[j] + arr[i] 
	MSDBS = arr[:] 
	for i in range(1, len(arr) + 1): 
		for j in range(1, i): 
			if arr[-i] > arr[-j] and MSDBS[-i] < MSDBS[-j] + arr[-i]: 
				MSDBS[-i] = MSDBS[-j] + arr[-i] 
	max_sum = float("-Inf") 
	for i, j, k in zip(MSIBS, MSDBS, arr): 
		max_sum = max(max_sum, i + j - k) 
	return max_sum


Contract List:
assert_0: assert isinstance(arr, list), "invalid inputs
assert_1: assert len(arr) > 0, "invalid inputs
assert_2: assert all(isinstance(x, (int, float)) for x in arr), "invalid inputs


<think>
I translated each Python assertion into an SMT predicate Ck and supplied core helper functions (IsList, length, list_all_numeric) to ensure the ADT shapes and list recursions are well defined. The basic structure asserts only shape invariants, while each contract predicate captures exactly the Python assertion semantics.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (or (is-Nil l)\n      (and (is-Cons l)\n           (let ((t (tail l)))\n             (IsList t)))))\n(define-fun-rec length ((l Value)) Int\n  (ite (is-Nil l) 0\n       (ite (is-Cons l)\n            (let ((t (tail l)))\n              (+ 1 (length t)))\n            0)))\n(define-fun-rec list_all_numeric ((l Value)) Bool\n  (ite (is-Nil l) true\n       (ite (is-Cons l)\n            (let ((h (head l)) (t (tail l)))\n              (and (or (is-IntVal h) (is-FloatVal h))\n                   (list_all_numeric t)))\n            false)))",
  "basic_structure": "(assert (IsList arr))",
  "inputs": "(declare-const arr Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList arr))",
    "assert_1": "(define-fun C1 () Bool (> (length arr) 0))",
    "assert_2": "(define-fun C2 () Bool (list_all_numeric arr))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/247

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: lps
Problem Description:
"""
Write a function to find the length of the longest palindromic subsequence in the given string.
assert lps("TENS FOR TENS") == 5
"""


def lps(str1):

	assert isinstance(str1, str), "invalid inputs" # $_CONTRACT_$
 
	n = len(str1)
	dp = [[0] * n for _ in range(n)]
	for i in range(n - 1, -1, -1):
		dp[i][i] = 1
		for j in range(i + 1, n):
			if str1[i] == str1[j]:
				dp[i][j] = dp[i + 1][j - 1] + 2
			else:
				dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])
	return dp[0][n - 1]


Contract List:
assert_0: assert isinstance(str1, str), "invalid inputs


<think>
I model the Python isinstance check as an SMT‐level StrVal guard, declare the Value ADT, assert that str1 is a StrVal for basic executability, and expose the contract as C0 for violation testing.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "(assert (is-StrVal str1))",
  "inputs": "(declare-const str1 Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-StrVal str1))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/250

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: count_X
Problem Description:
"""
Write a python function that takes in a tuple and an element and counts the occcurences of the element in the tuple.
assert count_X((10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2),4) == 0
"""


def count_X(tup, x):

    assert isinstance(tup, tuple), "invalid inputs" # $_CONTRACT_$
 
    return tup.count(x)


Contract List:
assert_0: assert isinstance(tup, tuple), "invalid inputs


<think>
I translate the Python isinstance check into a recursive SMT predicate over our ADT, declaring inputs and helpers so C0 precisely captures “tup is a tuple” and supports violation testing.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))",
  "basic_structure": "",
  "inputs": "(declare-const tup Value)\n(declare-const x Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList tup))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/251

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: insert_element
Problem Description:
"""
Write a function that takes in a list and an element and inserts the element before each element in the list, and returns the resulting list.
assert insert_element(['Red', 'Green', 'Black'] ,'c')==['c', 'Red', 'c', 'Green', 'c', 'Black']
"""


def insert_element(list1, element):

    assert isinstance(list1, list), "invalid inputs" # $_CONTRACT_$
    list1 = [v for elt in list1 for v in (element, elt)]
    return list1


Contract List:
assert_0: assert isinstance(list1, list), "invalid inputs


<think>
I define a recursive IsList predicate to model Python lists in the ADT, assert list1 is a proper list under BASIC_STRUCTURE for executability, and mirror the isinstance check exactly in C0.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool (ite (is-Nil v) true (ite (is-Cons v) (IsList (tail v)) false)))",
  "basic_structure": "(assert (IsList list1))",
  "inputs": "(declare-const list1 Value)\n(declare-const element Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList list1))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/252

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: convert
Problem Description:
"""
Write a python function to convert complex numbers to polar coordinates.
assert convert(1) == (1.0, 0.0)
"""


import cmath  
def convert(numbers):

  assert isinstance(numbers, (int, float, complex)), "invalid inputs" # $_CONTRACT_$ 
    
  return cmath.polar(numbers)  


Contract List:
assert_0: assert isinstance(numbers, (int, float, complex)), "invalid inputs


<think>
I introduce a helper IsNumber predicate over our Value ADT (including ComplexVal) to capture the isinstance check, declare the input, and define C0 as that predicate. There are no further always‐on invariants, so BASIC_STRUCTURE is empty.
</think>
```json
{
  "helper_functions": "(define-fun IsNumber ((v Value)) Bool (or (is-IntVal v) (is-FloatVal v) (is-ComplexVal v)))",
  "basic_structure": "",
  "inputs": "(declare-const numbers Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsNumber numbers))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/253

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: count_integer
Problem Description:
"""
Write a python function that returns the number of integer elements in a given list.
assert count_integer([1,2,'abc',1.2]) == 2
"""


def count_integer(list1):

    assert isinstance(list1, list), "invalid inputs" # $_CONTRACT_$
    return sum(isinstance(x, int) for x in list1)


Contract List:
assert_0: assert isinstance(list1, list), "invalid inputs


<think>
I define an ADT for lists, a recursive IsList helper to ensure proper list structure, declare the input, assert structural executability in BASIC_STRUCTURE, and translate the single Python `isinstance(list1, list)` assertion into predicate C0.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))",
  "basic_structure": "(assert (IsList list1))",
  "inputs": "(declare-const list1 Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList list1))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/255

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: combinations_colors
Problem Description:
"""
Write a function that takes in a list and length n, and generates all combinations (with repetition) of the elements of the list and returns a list with a tuple for each combination.
assert combinations_colors( ["Red","Green","Blue"],1)==[('Red',), ('Green',), ('Blue',)]
"""


from itertools import combinations_with_replacement 
def combinations_colors(l, n):

    assert isinstance(l, list), "invalid inputs" # $_CONTRACT_$
    assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
    assert n >= 0, "invalid inputs" # $_CONTRACT_$
    return list(combinations_with_replacement(l, n))


Contract List:
assert_0: assert isinstance(l, list), "invalid inputs
assert_1: assert isinstance(n, int), "invalid inputs
assert_2: assert n >= 0, "invalid inputs


<think>
I translate each Python assertion into a precise SMT predicate, introduce a generic list‐shape and integer extractor helper to guard constructors, and assert only shape/type invariants in the basic structure so that each contract predicate (C0–C2) can stand alone.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n(define-fun SafeI ((v Value)) Int\n  (ite (is-IntVal v)\n       (ival v)\n       0))",
  "basic_structure": "(assert (IsList l))\n(assert (is-IntVal n))",
  "inputs": "(declare-const l Value)\n(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool\n  (IsList l))",
    "assert_1": "(define-fun C1 () Bool\n  (is-IntVal n))",
    "assert_2": "(define-fun C2 () Bool\n  (and (is-IntVal n)\n       (>= (SafeI n) 0)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/256

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: count_Primes_nums
Problem Description:
"""
Write a python function that takes in a non-negative number and returns the number of prime numbers less than the given non-negative number.
assert count_Primes_nums(5) == 2
"""


def count_Primes_nums(n):

    assert isinstance(n, int) and n >= 0, "invalid inputs" # $_CONTRACT_$  
    return sum(all(i % j != 0 for j in range(2, i)) for i in range(2, n))


Contract List:
assert_0: assert isinstance(n, int) and n >= 0, "invalid inputs


<think>
I translate the Python `assert isinstance(n, int) and n >= 0` into a single SMT predicate C0 that checks both the ADT shape and the non-negativity. Because we only need to inspect the integer field under a safe tester, no extra helper functions are required. I declare `n` as a Value and leave the basic structure empty, since C0 itself enforces the necessary type guard.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "",
  "inputs": "(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (and (is-IntVal n) (>= (ival n) 0)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/257

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: swap_numbers
Problem Description:
"""
Write a function that takes in two numbers and returns a tuple with the second number and then the first number.
assert swap_numbers(10,20)==(20,10)
"""


def swap_numbers(a,b):

    assert isinstance(a, (int, float)), "invalid inputs" # $_CONTRACT_$
    assert isinstance(b, (int, float)), "invalid inputs" # $_CONTRACT_$
    return (b, a)


Contract List:
assert_0: assert isinstance(a, (int, float)), "invalid inputs
assert_1: assert isinstance(b, (int, float)), "invalid inputs


<think>
I will translate each Python isinstance check into a Boolean SMT predicate over the Value ADT, introduce a helper to test for int-or-float, declare the two inputs, and define C0 and C1 accordingly, while leaving the basic structure trivially satisfiable.
</think>
```json
{
  "helper_functions": "(define-fun is-IntOrFloat ((v Value)) Bool\n  (or (is-IntVal v) (is-FloatVal v)))",
  "basic_structure": "(assert true)",
  "inputs": "(declare-const a Value)\n(declare-const b Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntOrFloat a))",
    "assert_1": "(define-fun C1 () Bool (is-IntOrFloat b))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/259

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: maximize_elements
Problem Description:
"""
Write a function to maximize the given two tuples.
assert maximize_elements(((1, 3), (4, 5), (2, 9), (1, 10)), ((6, 7), (3, 9), (1, 1), (7, 3))) == ((6, 7), (4, 9), (2, 9), (7, 10))
"""


def maximize_elements(test_tup1, test_tup2):

  assert isinstance(test_tup1, tuple), "invalid inputs" # $_CONTRACT_$
  assert isinstance(test_tup2, tuple), "invalid inputs" # $_CONTRACT_$
  assert len(test_tup1) == len(test_tup2), "invalid inputs" # $_CONTRACT_$
  assert len(test_tup1) > 0, "invalid inputs" # $_CONTRACT_$
  assert len(test_tup2) > 0, "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(x, tuple) for x in test_tup1), "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(x, tuple) for x in test_tup2), "invalid inputs" # $_CONTRACT_$
  assert all(len(x) == 2 for x in test_tup1), "invalid inputs" # $_CONTRACT_$
  assert all(len(x) == 2 for x in test_tup2), "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(a, (int, float)) and isinstance(b, (int, float)) for a, b in test_tup1), "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(a, (int, float)) and isinstance(b, (int, float)) for a, b in test_tup2), "invalid inputs" # $_CONTRACT_$
  return tuple((max(a, c), max(b, d)) for (a, b), (c, d) in zip(test_tup1, test_tup2))


Contract List:
assert_0: assert isinstance(test_tup1, tuple), "invalid inputs
assert_1: assert isinstance(test_tup2, tuple), "invalid inputs
assert_2: assert len(test_tup1) == len(test_tup2), "invalid inputs
assert_3: assert len(test_tup1) > 0, "invalid inputs
assert_4: assert len(test_tup2) > 0, "invalid inputs
assert_5: assert all(isinstance(x, tuple) for x in test_tup1), "invalid inputs
assert_6: assert all(isinstance(x, tuple) for x in test_tup2), "invalid inputs
assert_7: assert all(len(x) == 2 for x in test_tup1), "invalid inputs
assert_8: assert all(len(x) == 2 for x in test_tup2), "invalid inputs
assert_9: assert all(isinstance(a, (int, float)) and isinstance(b, (int, float)) for a, b in test_tup1), "invalid inputs
assert_10: assert all(isinstance(a, (int, float)) and isinstance(b, (int, float)) for a, b in test_tup2), "invalid inputs


<think>
I will translate the Python assertions into named SMT-LIB predicates, define recursive helpers for list structure and numeric checks, and assert basic list‐shape requirements to maintain executability.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v) true\n    (ite (is-Cons v) (IsList (tail v)) false)))\n(define-fun-rec length ((v Value)) Int\n  (ite (is-Nil v) 0\n    (ite (is-Cons v) (+ 1 (length (tail v))) 0)))\n(define-fun-rec list_all_list ((v Value)) Bool\n  (ite (is-Nil v) true\n    (ite (is-Cons v)\n      (and (IsList (head v)) (list_all_list (tail v)))\n      false)))\n(define-fun-rec list_all_len2 ((v Value)) Bool\n  (ite (is-Nil v) true\n    (ite (is-Cons v)\n      (and (IsList (head v)) (= (length (head v)) 2) (list_all_len2 (tail v)))\n      false)))\n(define-fun-rec list_all_numeric ((v Value)) Bool\n  (ite (is-Nil v) true\n    (ite (is-Cons v)\n      (and\n        (let ((x (head v)))\n          (and\n            (ite (is-Cons x)\n                 (let ((a (head x)) (t1 (tail x)))\n                   (and (or (is-IntVal a) (is-FloatVal a))\n                        (ite (is-Cons t1)\n                             (let ((b (head t1))) (or (is-IntVal b) (is-FloatVal b)))\n                             false)))\n                 false))\n        (list_all_numeric (tail v)))\n      false)))",
  "basic_structure": "(assert (IsList test_tup1))\n(assert (IsList test_tup2))",
  "inputs": "(declare-const test_tup1 Value)\n(declare-const test_tup2 Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList test_tup1))",
    "assert_1": "(define-fun C1 () Bool (IsList test_tup2))",
    "assert_2": "(define-fun C2 () Bool (= (length test_tup1) (length test_tup2)))",
    "assert_3": "(define-fun C3 () Bool (> (length test_tup1) 0))",
    "assert_4": "(define-fun C4 () Bool (> (length test_tup2) 0))",
    "assert_5": "(define-fun C5 () Bool (list_all_list test_tup1))",
    "assert_6": "(define-fun C6 () Bool (list_all_list test_tup2))",
    "assert_7": "(define-fun C7 () Bool (list_all_len2 test_tup1))",
    "assert_8": "(define-fun C8 () Bool (list_all_len2 test_tup2))",
    "assert_9": "(define-fun C9 () Bool (list_all_numeric test_tup1))",
    "assert_10": "(define-fun C10 () Bool (list_all_numeric test_tup2))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/260

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: newman_prime
Problem Description:
"""
Write a function to find the nth newman–shanks–williams prime number.
assert newman_prime(3) == 7
"""


def newman_prime(n):

	assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
	assert n >= 0, "invalid inputs" # $_CONTRACT_$
 
	if n == 0 or n == 1: 
		return 1
	a = 1
	b = 1
	c = 1
	for _ in range(2, n + 1):
		c = 2 * b + a
		a = b
		b = c
	return c


Contract List:
assert_0: assert isinstance(n, int), "invalid inputs
assert_1: assert n >= 0, "invalid inputs


<think>
I will translate the Python assertions into precise SMT-LIB predicates using a canonical Value ADT, add a SafeI helper to extract integers safely, and declare the input with minimal basic structure so each Ck stands alone.
</think>
```json
{
  "helper_functions": "(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
  "basic_structure": "",
  "inputs": "(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
    "assert_1": "(define-fun C1 () Bool (>= (SafeI n) 0))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/261

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: division_elements
Problem Description:
"""
Write a function that takes in two tuples and performs mathematical division operation element-wise across the given tuples.
assert division_elements((10, 4, 6, 9),(5, 2, 3, 3)) == (2, 2, 2, 3)
"""


def division_elements(test_tup1, test_tup2):

  assert isinstance(test_tup1, tuple), "invalid inputs" # $_CONTRACT_$
  assert isinstance(test_tup2, tuple), "invalid inputs" # $_CONTRACT_$
  assert len(test_tup1) == len(test_tup2), "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(ele, (int, float)) for ele in test_tup1), "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(ele, (int, float)) and ele != 0 for ele in test_tup2), "invalid inputs" # $_CONTRACT_$
  return tuple(ele1 / ele2 for ele1, ele2 in zip(test_tup1, test_tup2))


Contract List:
assert_0: assert isinstance(test_tup1, tuple), "invalid inputs
assert_1: assert isinstance(test_tup2, tuple), "invalid inputs
assert_2: assert len(test_tup1) == len(test_tup2), "invalid inputs
assert_3: assert all(isinstance(ele, (int, float)) for ele in test_tup1), "invalid inputs
assert_4: assert all(isinstance(ele, (int, float)) and ele != 0 for ele in test_tup2), "invalid inputs


<think>
I model Python tuples as linked lists in the Value ADT and define recursive predicates for list shape, length, numeric content, and nonzero checks. Each Python assert maps to a standalone Bool Ck using these helpers, while basic_structure ensures inputs are valid lists.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v) true\n    (ite (is-Cons v)\n      (IsList (tail v))\n      false)))\n\n(define-fun-rec length ((lst Value)) Int\n  (ite (is-Nil lst) 0\n    (ite (is-Cons lst)\n      (+ 1 (length (tail lst)))\n      0)))\n\n(define-fun-rec list_all_numeric ((lst Value)) Bool\n  (ite (is-Nil lst) true\n    (ite (is-Cons lst)\n      (let ((h (head lst)) (t (tail lst)))\n        (and (or (is-IntVal h) (is-FloatVal h))\n             (list_all_numeric t)))\n      false)))\n\n(define-fun-rec list_nonzero_numeric ((lst Value)) Bool\n  (ite (is-Nil lst) true\n    (ite (is-Cons lst)\n      (let ((h (head lst)) (t (tail lst)))\n        (and (or (is-IntVal h) (is-FloatVal h))\n             (ite (is-IntVal h)\n                  (not (= (ival h) 0))\n                  (not (= (fval h) 0)))\n             (list_nonzero_numeric t)))\n      false)))",
  "basic_structure": "(assert (IsList test_tup1))\n(assert (IsList test_tup2))",
  "inputs": "(declare-const test_tup1 Value)\n(declare-const test_tup2 Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList test_tup1))",
    "assert_1": "(define-fun C1 () Bool (IsList test_tup2))",
    "assert_2": "(define-fun C2 () Bool (= (length test_tup1) (length test_tup2)))",
    "assert_3": "(define-fun C3 () Bool (list_all_numeric test_tup1))",
    "assert_4": "(define-fun C4 () Bool (list_nonzero_numeric test_tup2))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/262

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: split_two_parts
Problem Description:
"""
Write a function that takes in a list and an integer L and splits the given list into two parts where the length of the first part of the list is L, and returns the resulting lists in a tuple.
assert split_two_parts([1,1,2,3,4,4,5,1],3)==([1, 1, 2], [3, 4, 4, 5, 1])
"""


def split_two_parts(list1, L):

    assert isinstance(list1, list), "invalid inputs" # $_CONTRACT_$
    assert isinstance(L, int), "invalid inputs" # $_CONTRACT_$
    assert 0 <= L <= len(list1), "invalid inputs" # $_CONTRACT_$
    return list1[:L], list1[L:]


Contract List:
assert_0: assert isinstance(list1, list), "invalid inputs
assert_1: assert isinstance(L, int), "invalid inputs
assert_2: assert 0 <= L <= len(list1), "invalid inputs


<think>
I translate the Python input checks into SMT predicates over a canonical Value ADT, defining recursive helpers for list shape (`IsList`) and length. Each contract `Ci` is a standalone Boolean matching the original `assert` semantics under safe selector use.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec length ((v Value)) Int\n  (ite (is-Nil v)\n       0\n       (ite (is-Cons v)\n            (+ 1 (length (tail v)))\n            0)))",
  "basic_structure": "",
  "inputs": "(declare-const list1 Value)\n(declare-const L Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList list1))",
    "assert_1": "(define-fun C1 () Bool (is-IntVal L))",
    "assert_2": "(define-fun C2 () Bool (and (is-IntVal L)\n                                      (<= 0 (ival L))\n                                      (<= (ival L) (length list1))))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/264

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: dog_age
Problem Description:
"""
Write a function to calculate a dog's age in dog's years.
assert dog_age(12)==61
"""


def dog_age(h_age):

	assert isinstance(h_age, int), "invalid inputs" # $_CONTRACT_$
	assert h_age >= 0, "invalid inputs" # $_CONTRACT_$
	if h_age <= 2:
		d_age = h_age * 10.5
	else:
		d_age = 21 + (h_age - 2) * 4
	return d_age


Contract List:
assert_0: assert isinstance(h_age, int), "invalid inputs
assert_1: assert h_age >= 0, "invalid inputs


<think>
I modeled each Python assert as an SMT‐LIB predicate over the canonical Value ADT, using the built‐in constructor tester is-IntVal and guarded extraction of the integer field. I declared the input, left out unnecessary global invariants, and defined C0/C1 so each stands alone.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "",
  "inputs": "(declare-const h_age Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal h_age))",
    "assert_1": "(define-fun C1 () Bool (and (is-IntVal h_age) (>= (ival h_age) 0)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/265

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: list_split
Problem Description:
"""
Write a function that takes in a list and an integer n and splits a list for every nth element, returning a list of the resulting lists.
assert list_split(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n'],3)==[['a', 'd', 'g', 'j', 'm'], ['b', 'e', 'h', 'k', 'n'], ['c', 'f', 'i', 'l']]
"""


def list_split(S, step):

    assert isinstance(S, list), "invalid inputs" # $_CONTRACT_$
    assert isinstance(step, int), "invalid inputs" # $_CONTRACT_$
    assert step > 0, "invalid inputs" # $_CONTRACT_$
    return [S[i::step] for i in range(step)]


Contract List:
assert_0: assert isinstance(S, list), "invalid inputs
assert_1: assert isinstance(step, int), "invalid inputs
assert_2: assert step > 0, "invalid inputs


<think>
I modeled the Python contracts as SMT-LIB predicates over a canonical Value ADT, introduced a recursive IsList helper for structural validation, and wrapped selector usage under guards to ensure safety.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))",
  "basic_structure": "",
  "inputs": "(declare-const S Value)\n(declare-const step Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList S))",
    "assert_1": "(define-fun C1 () Bool (is-IntVal step))",
    "assert_2": "(define-fun C2 () Bool (ite C1 (> (ival step) 0) false))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/266

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: lateralsurface_cube
Problem Description:
"""
Write a function to find the lateral surface area of a cube given its side length.
assert lateralsurface_cube(5)==100
"""


def lateralsurface_cube(l):

  assert isinstance(l, (int, float)), "invalid inputs" # $_CONTRACT_$
  assert l > 0, "invalid inputs" # $_CONTRACT_$
  return 4 * l * l


Contract List:
assert_0: assert isinstance(l, (int, float)), "invalid inputs
assert_1: assert l > 0, "invalid inputs


<think>
I translate each Python assertion into an independent SMT predicate over the Value ADT, using safe type testers and guarded selectors so they remain well‐formed even when other contracts are violated.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "",
  "inputs": "(declare-const l Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (or (is-IntVal l) (is-FloatVal l)))",
    "assert_1": "(define-fun C1 () Bool (or (and (is-IntVal l) (> (to_real (ival l)) 0)) (and (is-FloatVal l) (> (fval l) 0))))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/267

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: square_Sum
Problem Description:
"""
Write a python function that takes in an integer n and returns the sum of the squares of the first n odd natural numbers.
assert square_Sum(2) == 10
"""


def square_Sum(n):

    assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
    assert n > 0, "invalid inputs" # $_CONTRACT_$
  
    return n * (4 * n * n - 1) / 3


Contract List:
assert_0: assert isinstance(n, int), "invalid inputs
assert_1: assert n > 0, "invalid inputs


<think>
I translate each Python assert into a named predicate, introduce a SafeI helper to extract integer values under type tests, and declare `n` as a `Value`. This ensures correct ADT shape and precise semantics for `isinstance` and the `>0` check.
</think>
```json
{
  "helper_functions": "(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
  "basic_structure": "",
  "inputs": "(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
    "assert_1": "(define-fun C1 () Bool (and C0 (> (SafeI n) 0)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/268

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: find_star_num
Problem Description:
"""
Write a function to find the n'th star number.
assert find_star_num(3) == 37
"""


def find_star_num(n):

	assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
	assert n > 0, "invalid inputs" # $_CONTRACT_$
 
	return 6 * n * (n - 1) + 1 


Contract List:
assert_0: assert isinstance(n, int), "invalid inputs
assert_1: assert n > 0, "invalid inputs


<think>
I will translate the two Python asserts into SMT‐LIB predicates guarded by the ADT tester, provide a safe integer extractor helper, and leave the basic structure empty since no global invariants beyond the ADT are needed.
</think>
```json
{
  "helper_functions": "(define-fun SafeI ((v Value)) Int\n  (ite (is-IntVal v) (ival v) 0)\n)",
  "basic_structure": "",
  "inputs": "(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
    "assert_1": "(define-fun C1 () Bool (ite (is-IntVal n) (> (ival n) 0) false))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/269

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: ascii_value
Problem Description:
"""
Write a function to find the ascii value of a character.
assert ascii_value('A')==65
"""


def ascii_value(k):

  assert isinstance(k, str), "invalid inputs" # $_CONTRACT_$
  assert len(k)==1, "invalid inputs" # $_CONTRACT_$
  return ord(k)


Contract List:
assert_0: assert isinstance(k, str), "invalid inputs
assert_1: assert len(k)==1, "invalid inputs


<think>
I will introduce a safe string extractor to guard against non-string Values, assert the input is a StrVal for basic executability, and translate each Python assertion into SMT-LIB predicates C0 and C1 using the extractor.
</think>
```json
{
  "helper_functions": "(define-fun SafeS ((v Value)) String (ite (is-StrVal v) (sval v) \"\"))",
  "basic_structure": "(assert (is-StrVal k))",
  "inputs": "(declare-const k Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-StrVal k))",
    "assert_1": "(define-fun C1 () Bool (= (str.len (SafeS k)) 1))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/270

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: sum_even_and_even_index
Problem Description:
"""
Write a python function to find the sum of even numbers at even positions of a list.
assert sum_even_and_even_index([5, 6, 12, 1, 18, 8]) == 30
"""


def sum_even_and_even_index(arr):

    assert isinstance(arr, list), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(x, int) for x in arr), "invalid inputs" # $_CONTRACT_$
  
    return sum(x for x in arr[::2] if x % 2 == 0)


Contract List:
assert_0: assert isinstance(arr, list), "invalid inputs
assert_1: assert all(isinstance(x, int) for x in arr), "invalid inputs


<think>
I will translate the Python list‐and‐int checks into recursive SMT‐LIB predicates, declare `arr` as a `Value`, assert its list‐shaped form in the basic structure, and define C0/C1 exactly matching the two Python asserts.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec list_all_int ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (is-IntVal (head v))\n                 (list_all_int (tail v)))\n            false)))",
  "basic_structure": "(assert (IsList arr))",
  "inputs": "(declare-const arr Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList arr))",
    "assert_1": "(define-fun C1 () Bool (list_all_int arr))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/271

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: even_Power_Sum
Problem Description:
"""
Write a python function that takes in an integer n and finds the sum of the first n even natural numbers that are raised to the fifth power.
assert even_Power_Sum(2) == 1056
"""


def even_Power_Sum(n):

    assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
    assert n > 0, "invalid inputs" # $_CONTRACT_$
 
    return sum(x ** 5 for x in range(2, 2 * n + 1, 2))


Contract List:
assert_0: assert isinstance(n, int), "invalid inputs
assert_1: assert n > 0, "invalid inputs


<think>
I model the integer input as a Value ADT and expose two precise contract predicates: C0 checks the IntVal tag, and C1 safely extracts the integer and enforces positivity, all without extra helpers.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "",
  "inputs": "(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
    "assert_1": "(define-fun C1 () Bool (ite (is-IntVal n) (> (ival n) 0) false))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/272

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: rear_extract
Problem Description:
"""
Write a function that takes in a list of tuples and returns a list containing the rear element of each tuple.
assert rear_extract([(1, 'Rash', 21), (2, 'Varsha', 20), (3, 'Kil', 19)]) == [21, 20, 19]
"""


def rear_extract(test_list):

  assert isinstance(test_list, list), "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(x, tuple) and len(x) > 0 for x in test_list), "invalid inputs" # $_CONTRACT_$
  return [x[-1] for x in test_list]


Contract List:
assert_0: assert isinstance(test_list, list), "invalid inputs
assert_1: assert all(isinstance(x, tuple) and len(x) > 0 for x in test_list), "invalid inputs


<think>
I defined recursive helpers to model Python lists/tuples and ensure non-empty tuple elements, declared the input as a Value, added the basic IsList constraint for executability, and translated each Python assert into its own SMT‐LIB predicate.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec ListAllNonEmptyTuples ((lst Value)) Bool\n  (ite (is-Nil lst)\n       true\n       (ite (is-Cons lst)\n            (and (is-Cons (head lst))\n                 (ListAllNonEmptyTuples (tail lst)))\n            false)))",
  "basic_structure": "(assert (IsList test_list))",
  "inputs": "(declare-const test_list Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList test_list))",
    "assert_1": "(define-fun C1 () Bool (ListAllNonEmptyTuples test_list))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/273

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: substract_elements
Problem Description:
"""
Write a function that takes in two tuples and subtracts the elements of the first tuple by the elements of the second tuple with the same index.
assert substract_elements((10, 4, 5), (2, 5, 18)) == (8, -1, -13)
"""


def substract_elements(test_tup1, test_tup2):

  assert isinstance(test_tup1, tuple), "invalid inputs" # $_CONTRACT_$
  assert isinstance(test_tup2, tuple), "invalid inputs" # $_CONTRACT_$
  assert len(test_tup1) == len(test_tup2), "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(x, (int, float)) for x in test_tup1), "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(x, (int, float)) for x in test_tup2), "invalid inputs" # $_CONTRACT_$
  return tuple(x - y for x, y in zip(test_tup1, test_tup2))


Contract List:
assert_0: assert isinstance(test_tup1, tuple), "invalid inputs
assert_1: assert isinstance(test_tup2, tuple), "invalid inputs
assert_2: assert len(test_tup1) == len(test_tup2), "invalid inputs
assert_3: assert all(isinstance(x, (int, float)) for x in test_tup1), "invalid inputs
assert_4: assert all(isinstance(x, (int, float)) for x in test_tup2), "invalid inputs


<think>
I translate Python tuple checks into a list ADT in SMT-LIB, define recursive helpers for list shape, length, and numeric‐element checks, and then map each Python assert to a Boolean predicate C0–C4.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v) true\n    (ite (is-Cons v) (IsList (tail v)) false)))\n\n(define-fun-rec length ((v Value)) Int\n  (ite (is-Nil v) 0\n    (ite (is-Cons v) (+ 1 (length (tail v))) 0)))\n\n(define-fun-rec list_all_numeric ((v Value)) Bool\n  (ite (is-Nil v) true\n    (ite (is-Cons v)\n      (let ((h (head v)))\n        (and (or (is-IntVal h) (is-FloatVal h))\n             (list_all_numeric (tail v))))\n      false)))",
  "basic_structure": "",
  "inputs": "(declare-const test_tup1 Value)\n(declare-const test_tup2 Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList test_tup1))",
    "assert_1": "(define-fun C1 () Bool (IsList test_tup2))",
    "assert_2": "(define-fun C2 () Bool (= (length test_tup1) (length test_tup2)))",
    "assert_3": "(define-fun C3 () Bool (list_all_numeric test_tup1))",
    "assert_4": "(define-fun C4 () Bool (list_all_numeric test_tup2))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/274

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: even_binomial_Coeff_Sum
Problem Description:
"""
Write a python function that takes in a positive integer n and finds the sum of even index binomial coefficients.
assert even_binomial_Coeff_Sum(4) == 8
"""


import math  
def even_binomial_Coeff_Sum( n):

    assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
    assert n > 0, "invalid inputs" # $_CONTRACT_$
 
    return 1 << (n - 1)


Contract List:
assert_0: assert isinstance(n, int), "invalid inputs
assert_1: assert n > 0, "invalid inputs


<think>
I define a SafeI helper to extract integer values safely, declare the single Value input n, leave basic structure empty since no global invariants are needed beyond the contracts, and encode each Python assert as a Bool predicate guarded by the IntVal tester.
</think>
```json
{
  "helper_functions": "(define-fun SafeI ((v Value)) Int\n  (ite (is-IntVal v) (ival v) 0))",
  "basic_structure": "",
  "inputs": "(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
    "assert_1": "(define-fun C1 () Bool (and (is-IntVal n) (> (ival n) 0)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/276

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: volume_cylinder
Problem Description:
"""
Write a function that takes in the radius and height of a cylinder and returns the the volume.
assert math.isclose(volume_cylinder(10,5), 1570.7500000000002, rel_tol=0.001)
"""


import math
def volume_cylinder(r,h):

  assert isinstance(r, (int, float)), "invalid inputs" # $_CONTRACT_$
  assert isinstance(h, (int, float)), "invalid inputs" # $_CONTRACT_$
  assert r > 0, "invalid inputs" # $_CONTRACT_$
  assert h > 0, "invalid inputs" # $_CONTRACT_$
  return math.pi * r * r * h


Contract List:
assert_0: assert isinstance(r, (int, float)), "invalid inputs
assert_1: assert isinstance(h, (int, float)), "invalid inputs
assert_2: assert r > 0, "invalid inputs
assert_3: assert h > 0, "invalid inputs


<think>
I introduce a helper getNum to safely interpret IntVal or FloatVal as Real, then map each Python assert into a named SMT predicate with proper type guards for arithmetic. The ADT and inputs remain general, and core executability relies on the numeric extractor alone.
</think>
```json
{
  "helper_functions": "(define-fun getNum ((v Value)) Real\n  (ite (is-IntVal v) (to_real (ival v))\n       (fval v)))",
  "basic_structure": "",
  "inputs": "(declare-const r Value)\n(declare-const h Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (or (is-IntVal r) (is-FloatVal r)))",
    "assert_1": "(define-fun C1 () Bool (or (is-IntVal h) (is-FloatVal h)))",
    "assert_2": "(define-fun C2 () Bool (and C0 (> (getNum r) 0)))",
    "assert_3": "(define-fun C3 () Bool (and C1 (> (getNum h) 0)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/277

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: dict_filter
Problem Description:
"""
Write a function that takes in a dictionary and integer n and filters the dictionary to only include entries with values greater than or equal to n.
assert dict_filter({'Cierra Vega': 175, 'Alden Cantrell': 180, 'Kierra Gentry': 165, 'Pierre Cox': 190},170)=={'Cierra Vega': 175, 'Alden Cantrell': 180, 'Pierre Cox': 190}
"""


def dict_filter(dict1, n):

    assert isinstance(dict1, dict), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(x, int) for x in dict1.values()), "invalid inputs" # $_CONTRACT_$
    assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
    return {key : value for (key, value) in dict1.items() if value >=n}


Contract List:
assert_0: assert isinstance(dict1, dict), "invalid inputs
assert_1: assert all(isinstance(x, int) for x in dict1.values()), "invalid inputs
assert_2: assert isinstance(n, int), "invalid inputs


<think>
I translate Python’s dict and integer checks into an SMT‐LIB list‐based ADT with predicates ensuring safe recursion and selector use. I define reusable helpers for list structure and numeric value checks, then map each assert to a named Bool predicate.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec list_all_pairs_shape ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (let ((hd (head v))\n                  (tl (tail v)))\n              (and\n                (is-Cons hd)\n                (let ((second_elem (tail hd)))\n                  (and\n                    (is-Cons second_elem)\n                    (is-Nil (tail second_elem))))\n                (list_all_pairs_shape tl)))\n            false)))\n\n(define-fun-rec list_all_vals_int ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (let ((hd (head v))\n                  (tl (tail v)))\n              (and\n                (is-Cons hd)\n                (let ((second_elem (tail hd)))\n                  (and\n                    (is-Cons second_elem)\n                    (let ((val_elem (head second_elem)))\n                      (is-IntVal val_elem))\n                    (is-Nil (tail second_elem))))\n                (list_all_vals_int tl)))\n            false)))",
  "basic_structure": "(assert (IsList dict1))\n(assert (list_all_pairs_shape dict1))\n(assert (is-IntVal n))",
  "inputs": "(declare-const dict1 Value)\n(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList dict1))",
    "assert_1": "(define-fun C1 () Bool (list_all_vals_int dict1))",
    "assert_2": "(define-fun C2 () Bool (is-IntVal n))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/278

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: count_first_elements
Problem Description:
"""
Write a function to find the number of elements that occurs before the tuple element in the given tuple.
assert count_first_elements((1, 5, 7, (4, 6), 10) ) == 3
"""


def count_first_elements(test_tup):

  assert isinstance(test_tup, tuple), "invalid inputs" # $_CONTRACT_$
  for count, ele in enumerate(test_tup):
    if isinstance(ele, tuple):
      break
  return count


Contract List:
assert_0: assert isinstance(test_tup, tuple), "invalid inputs


<think>
I treat the Python tuple as our list ADT (Cons/Nil), define a recursive IsList predicate to ensure the input has the right shape for enumeration, declare the single input, assert the basic structure for executability, and then encode the isinstance‐tuple contract as C0.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool (ite (is-Cons v) (IsList (tail v)) (is-Nil v)))",
  "basic_structure": "(assert (IsList test_tup))",
  "inputs": "(declare-const test_tup Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList test_tup))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/279

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: is_num_decagonal
Problem Description:
"""
Write a function to find the nth decagonal number.
assert is_num_decagonal(3) == 27
"""


def is_num_decagonal(n):

	assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
	assert n > 0, "invalid inputs" # $_CONTRACT_$
 
	return 4 * n * n - 3 * n 


Contract List:
assert_0: assert isinstance(n, int), "invalid inputs
assert_1: assert n > 0, "invalid inputs


<think>
I translate the Python assertions into SMT-LIB contracts by modeling the input as a Value ADT, defining a safe integer extractor, and encoding each assertion as a Boolean predicate that mirrors Python’s type and value checks.
</think>
```json
{
  "helper_functions": "(define-fun SafeI ((v Value)) Int\n  (ite (is-IntVal v) (ival v) 0))",
  "basic_structure": "",
  "inputs": "(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
    "assert_1": "(define-fun C1 () Bool (and C0 (> (SafeI n) 0)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/280

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: sequential_search
Problem Description:
"""
Write a function that takes in an array and element and returns a tuple containing a boolean that indicates if the element is in the array and the index position of the element (or -1 if the element is not found).
assert sequential_search([11,23,58,31,56,77,43,12,65,19],31) == (True, 3)
"""


def sequential_search(dlist, item):

    assert isinstance(dlist, list), "invalid inputs" # $_CONTRACT_$
    return item in dlist, (dlist.index(item) if item in dlist else -1)


Contract List:
assert_0: assert isinstance(dlist, list), "invalid inputs


<think>
I will introduce an is-list helper to model Python lists in our ADT, declare inputs for dlist and item, enforce basic structural executability via is-list, and define a named predicate C0 that captures the original isinstance(dlist, list) assertion.
</think>
```json
{
  "helper_functions": "(define-fun is-list ((v Value)) Bool (or (is-Nil v) (is-Cons v)))",
  "basic_structure": "(assert (is-list dlist))",
  "inputs": "(declare-const dlist Value)\n(declare-const item Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-list dlist))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/281

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: all_unique
Problem Description:
"""
Write a python function to check if the elements of a given list are unique or not.
assert all_unique([1,2,3]) == True
"""


def all_unique(test_list):

    assert isinstance(test_list, list), "invalid inputs" # $_CONTRACT_$
    return len(test_list) == len(set(test_list))


Contract List:
assert_0: assert isinstance(test_list, list), "invalid inputs


<think>
I define an ADT-based list predicate `IsList` to ensure the input has proper list structure, declare the input, assert the universal structure invariant, and map the Python `isinstance` check to a shallow list-type predicate `C0`.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))",
  "basic_structure": "(assert (IsList test_list))",
  "inputs": "(declare-const test_list Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (or (is-Nil test_list) (is-Cons test_list)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/282

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: sub_list
Problem Description:
"""
Write a function to subtract two lists element-wise.
assert sub_list([1, 2, 3],[4,5,6])==[-3,-3,-3]
"""


def sub_list(nums1,nums2):

  assert isinstance(nums1, list), "invalid inputs" # $_CONTRACT_$
  assert isinstance(nums2, list), "invalid inputs" # $_CONTRACT_$
  assert len(nums1) > 0, "invalid inputs" # $_CONTRACT_$
  assert len(nums2) > 0, "invalid inputs" # $_CONTRACT_$
  assert len(nums1) == len(nums2), "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(num, (int, float)) for num in nums1), "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(num, (int, float)) for num in nums2), "invalid inputs" # $_CONTRACT_$
  return [num1 - num2 for num1, num2 in zip(nums1, nums2)]


Contract List:
assert_0: assert isinstance(nums1, list), "invalid inputs
assert_1: assert isinstance(nums2, list), "invalid inputs
assert_2: assert len(nums1) > 0, "invalid inputs
assert_3: assert len(nums2) > 0, "invalid inputs
assert_4: assert len(nums1) == len(nums2), "invalid inputs
assert_5: assert all(isinstance(num, (int, float)) for num in nums1), "invalid inputs
assert_6: assert all(isinstance(num, (int, float)) for num in nums2), "invalid inputs


<think>
I translate each Python assertion into a precise SMT predicate (C0–C6) over the ADT, supply recursive helpers for list structure, length, and numeric‐element checks, and assert only minimal ADT shape invariants for executability.
</think>
```json
{
  "helper_functions": "(define-fun IsList ((l Value)) Bool\n  (or (is-Nil l) (is-Cons l)))\n\n(define-fun-rec length ((l Value)) Int\n  (ite (is-Cons l)\n       (+ 1 (length (tail l)))\n       0))\n\n(define-fun-rec list_all_numeric ((l Value)) Bool\n  (ite (is-Cons l)\n       (and (or (is-IntVal (head l)) (is-FloatVal (head l)))\n            (list_all_numeric (tail l)))\n       true))",
  "basic_structure": "(assert (IsList nums1))\n(assert (IsList nums2))",
  "inputs": "(declare-const nums1 Value)\n(declare-const nums2 Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList nums1))",
    "assert_1": "(define-fun C1 () Bool (IsList nums2))",
    "assert_2": "(define-fun C2 () Bool (> (length nums1) 0))",
    "assert_3": "(define-fun C3 () Bool (> (length nums2) 0))",
    "assert_4": "(define-fun C4 () Bool (= (length nums1) (length nums2)))",
    "assert_5": "(define-fun C5 () Bool (list_all_numeric nums1))",
    "assert_6": "(define-fun C6 () Bool (list_all_numeric nums2))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/283

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: validate
Problem Description:
"""
Write a python function takes in an integer and check whether the frequency of each digit in the integer is less than or equal to the digit itself.
assert validate(1234) == True
"""


def validate(n):

    assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
    assert n >= 0, "invalid inputs" # $_CONTRACT_$
 
    digits = [int(digit) for digit in str(n)]
    return all(digit >= digits.count(digit) for digit in digits)


Contract List:
assert_0: assert isinstance(n, int), "invalid inputs
assert_1: assert n >= 0, "invalid inputs


<think>
I model each Python assert as an SMT predicate over the ADT-based Value, use a SafeI helper for selector safety, assert only the type shape in the basic structure, and define C0/C1 to mirror isinstance and non-negativity checks.
</think>
```json
{
  "helper_functions": "(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
  "basic_structure": "(assert (is-IntVal n))",
  "inputs": "(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
    "assert_1": "(define-fun C1 () Bool (and (is-IntVal n) (>= (ival n) 0)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/284

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: check_element
Problem Description:
"""
Write a function that takes in a list and element and checks whether all items in the list are equal to the given element.
assert check_element(["green", "orange", "black", "white"],'blue')==False
"""


def check_element(list1, element):

  assert isinstance(list1, list), "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(x, type(element)) for x in list1), "invalid inputs" # $_CONTRACT_$
  return all(v == element for v in list1)


Contract List:
assert_0: assert isinstance(list1, list), "invalid inputs
assert_1: assert all(isinstance(x, type(element)) for x in list1), "invalid inputs


<think>
I will define recursive helpers to model list structure and type uniformity, declare inputs, assert basic list structure, and translate each Python assertion into precise, standalone SMT-LIB predicates C0 and C1.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v) true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec list_all_same_type ((lst Value) (v Value)) Bool\n  (ite (is-Nil lst) true\n       (ite (is-Cons lst)\n            (and\n              (or (and (is-IntVal (head lst)) (is-IntVal v))\n                  (and (is-FloatVal (head lst)) (is-FloatVal v))\n                  (and (is-StrVal (head lst)) (is-StrVal v))\n                  (and (is-BoolVal (head lst)) (is-BoolVal v)))\n              (list_all_same_type (tail lst) v))\n            false)))",
  "basic_structure": "(assert (IsList list1))",
  "inputs": "(declare-const list1 Value)\n(declare-const element Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList list1))",
    "assert_1": "(define-fun C1 () Bool (and (IsList list1) (list_all_same_type list1 element)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/285

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: text_match_two_three
Problem Description:
"""
Write a function that checks whether a string contains the 'a' character followed by two or three 'b' characters.
assert text_match_two_three("ac")==(False)
"""


import re
def text_match_two_three(text):

    assert isinstance(text, str), "invalid inputs" # $_CONTRACT_$
    patterns = 'ab{2,3}'
    return re.search(patterns, text) is not None


Contract List:
assert_0: assert isinstance(text, str), "invalid inputs


<think>
I translate the Python type assertion into an SMT predicate by using the ADT’s StrVal tester and provide a SafeS helper for future regex operations. The input is declared as a Value, and the basic structure remains empty since no universal invariants beyond the ADT are needed.
</think>
```json
{
  "helper_functions": "(define-fun SafeS ((v Value)) String (ite (is-StrVal v) (sval v) \"\"))",
  "basic_structure": "",
  "inputs": "(declare-const text Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-StrVal text))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/286

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: max_sub_array_sum_repeated
Problem Description:
"""
Write a function to find the largest sum of a contiguous array in the modified array which is formed by repeating the given array k times.
assert max_sub_array_sum_repeated([10, 20, -30, -1], 4, 3) == 30
"""


def max_sub_array_sum_repeated(a, n, k):

	assert isinstance(a, list), "invalid inputs" # $_CONTRACT_$
	assert len(a) > 0, "invalid inputs" # $_CONTRACT_$
	assert all(isinstance(item, (int, float)) for item in a), "invalid inputs" # $_CONTRACT_$
	assert isinstance(n, int) and n == len(a), "invalid inputs" # $_CONTRACT_$
	assert isinstance(k, int) and k >= 0, "invalid inputs" # $_CONTRACT_$
 
	modifed = a * k
	pre = 0	# dp[i-1]
	res = modifed[0]
	for n in modifed:
		pre = max(pre + n, n)
		res = max(pre, res)
	return res


Contract List:
assert_0: assert isinstance(a, list), "invalid inputs
assert_1: assert len(a) > 0, "invalid inputs
assert_2: assert all(isinstance(item, (int, float)) for item in a), "invalid inputs
assert_3: assert isinstance(n, int) and n == len(a), "invalid inputs
assert_4: assert isinstance(k, int) and k >= 0, "invalid inputs


<think>
I translated each Python assertion into a precise SMT predicate C0–C4, built recursive helpers for list structure, element typing, and length, and declared the inputs over the canonical Value ADT.
</think>
```json
{
  "helper_functions": "(define-fun is_numeric ((v Value)) Bool (or (is-IntVal v) (is-FloatVal v)))\n(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n(define-fun-rec list_all_numeric ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (is_numeric (head v))\n                 (list_all_numeric (tail v)))\n            false)))\n(define-fun-rec length ((v Value)) Int\n  (ite (is-Nil v)\n       0\n       (ite (is-Cons v)\n            (+ 1 (length (tail v)))\n            0)))",
  "basic_structure": "",
  "inputs": "(declare-const a Value)\n(declare-const n Value)\n(declare-const k Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList a))",
    "assert_1": "(define-fun C1 () Bool (> (length a) 0))",
    "assert_2": "(define-fun C2 () Bool (list_all_numeric a))",
    "assert_3": "(define-fun C3 () Bool (and (is-IntVal n) (= (ival n) (length a))))",
    "assert_4": "(define-fun C4 () Bool (and (is-IntVal k) (>= (ival k) 0)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/287

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: square_Sum
Problem Description:
"""
Write a python function takes in an integer n and returns the sum of squares of first n even natural numbers.
assert square_Sum(2) == 20
"""


def square_Sum(n):

    assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
    assert n >= 0, "invalid inputs" # $_CONTRACT_$
  
    return 2 * n * (n + 1) * (2 * n + 1) /3


Contract List:
assert_0: assert isinstance(n, int), "invalid inputs
assert_1: assert n >= 0, "invalid inputs


<think>
I translate each Python assertion into a named SMT-LIB predicate, guarding numeric selectors with type‐tests to ensure soundness, and produce a minimal template with ADT, input declarations, and precise contract definitions.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "",
  "inputs": "(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
    "assert_1": "(define-fun C1 () Bool (and C0 (>= (ival n) 0)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/290

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: max_length
Problem Description:
"""
Write a function to find the list of maximum length in a list of lists.
assert max_length([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]])==(3, [13, 15, 17])
"""


def max_length(list1):

    assert isinstance(list1, list), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(x, list) for x in list1), "invalid inputs" # $_CONTRACT_$
    return max([(len(x), x) for x in list1], key=lambda x: x[0])


Contract List:
assert_0: assert isinstance(list1, list), "invalid inputs
assert_1: assert all(isinstance(x, list) for x in list1), "invalid inputs


<think>
I translate the Python type‐checking asserts into SMT predicates by defining an ADT‐based list tester and a recursive “all elements are lists” checker, then mirror each assert as C0 and C1. The template includes only the minimal helper functions needed for these contracts, a trivial basic structure, and the input declaration.
</think>
```json
{
  "helper_functions": "(define-fun is_list ((v Value)) Bool\n  (or (is-Nil v) (is-Cons v)))\n\n(define-fun-rec list_all_list ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (and (is_list (head l)) (list_all_list (tail l)))\n            false)))",
  "basic_structure": "(assert true)",
  "inputs": "(declare-const list1 Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is_list list1))",
    "assert_1": "(define-fun C1 () Bool (list_all_list list1))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/292

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: find
Problem Description:
"""
Write a python function to find quotient of two numbers (rounded down to the nearest integer).
assert find(10,3) == 3
"""


def find(n,m):

    assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
    assert isinstance(m, int), "invalid inputs" # $_CONTRACT_$
    assert m != 0, "invalid inputs" # $_CONTRACT_$
  
    return n // m 


Contract List:
assert_0: assert isinstance(n, int), "invalid inputs
assert_1: assert isinstance(m, int), "invalid inputs
assert_2: assert m != 0, "invalid inputs


<think>
I translate each Python assertion into a precise SMT‐LIB predicate, guard selector use with the appropriate tester, and keep no extra universal invariants so each contract can stand alone.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "",
  "inputs": "(declare-const n Value)\n(declare-const m Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
    "assert_1": "(define-fun C1 () Bool (is-IntVal m))",
    "assert_2": "(define-fun C2 () Bool (ite (is-IntVal m) (not (= (ival m) 0)) false))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/293

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: otherside_rightangle
Problem Description:
"""
Write a function to find the third side of a right angled triangle.
assert otherside_rightangle(7,8)==10.63014581273465
"""


import math
def otherside_rightangle(w,h):

  assert isinstance(w, (int, float)) and w > 0, "invalid inputs" # $_CONTRACT_$
  assert isinstance(h, (int, float)) and h > 0, "invalid inputs" # $_CONTRACT_$
  return math.sqrt(w * w + h * h)


Contract List:
assert_0: assert isinstance(w, (int, float)) and w > 0, "invalid inputs
assert_1: assert isinstance(h, (int, float)) and h > 0, "invalid inputs


<think>
I mapped Python’s numeric type checks to an “is-numeric” tester on the Value ADT and a “num-to-real” extractor, then encoded each assert as C0 and C1 ensuring the value is numeric and greater than zero.
</think>
```json
{
  "helper_functions": "(define-fun is-numeric ((v Value)) Bool (or (is-IntVal v) (is-FloatVal v)))\n(define-fun num-to-real ((v Value)) Real (ite (is-IntVal v) (to_real (ival v)) (fval v)))",
  "basic_structure": "",
  "inputs": "(declare-const w Value)\n(declare-const h Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (and (is-numeric w) (> (num-to-real w) 0)))",
    "assert_1": "(define-fun C1 () Bool (and (is-numeric h) (> (num-to-real h) 0)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/294

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: max_val
Problem Description:
"""
Write a function to find the maximum value in a given heterogeneous list.
assert max_val(['Python', 3, 2, 4, 5, 'version'])==5
"""


def max_val(listval):

     assert isinstance(listval, list), "invalid inputs" # $_CONTRACT_$
     assert len(listval) > 0, "invalid inputs" # $_CONTRACT_$
     assert any(isinstance(i, int) for i in listval), "invalid inputs" # $_CONTRACT_$
     max_val = max(i for i in listval if isinstance(i, int)) 
     return max_val


Contract List:
assert_0: assert isinstance(listval, list), "invalid inputs
assert_1: assert len(listval) > 0, "invalid inputs
assert_2: assert any(isinstance(i, int) for i in listval), "invalid inputs


<think>
I model the Python assertions as named SMT predicates on a generic Value ADT with list, integer, string, etc. I define recursive helpers for list structure, length, and checking for any integer to ensure safe evaluation and precise contract translation.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (or (is-Nil v)\n      (and (is-Cons v) (IsList (tail v)))))\n\n(define-fun-rec length ((lst Value)) Int\n  (ite (is-Nil lst) 0\n       (ite (is-Cons lst)\n            (+ 1 (length (tail lst)))\n            0)))\n\n(define-fun-rec any_int ((lst Value)) Bool\n  (ite (is-Cons lst)\n       (or (is-IntVal (head lst)) (any_int (tail lst)))\n       false))",
  "basic_structure": "",
  "inputs": "(declare-const listval Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList listval))",
    "assert_1": "(define-fun C1 () Bool (> (length listval) 0))",
    "assert_2": "(define-fun C2 () Bool (any_int listval))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/296

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: get_Inv_Count
Problem Description:
"""
Write a python function to count inversions in an array.
assert get_Inv_Count([1,20,6,4,5]) == 5
"""


def get_Inv_Count(arr):

    assert isinstance(arr, list), "invalid inputs" # $_CONTRACT_$
    assert len(arr) > 0, "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(x, (int, float)) for x in arr), "invalid inputs" # $_CONTRACT_$
 
    # consider use merge sort, but for simplicity, use brute force
    inv_count = 0
    for i in range(len(arr)): 
        for j in range(i + 1, len(arr)): 
            if (arr[i] > arr[j]): 
                inv_count += 1
    return inv_count 


Contract List:
assert_0: assert isinstance(arr, list), "invalid inputs
assert_1: assert len(arr) > 0, "invalid inputs
assert_2: assert all(isinstance(x, (int, float)) for x in arr), "invalid inputs


<think>
I will translate the Python assertion contracts into named SMT-LIB predicates while defining necessary ADT helpers to ensure safe list handling and numeric checks. I include recursive definitions for list structure, length, and numeric element checking, and assert the basic structural invariants and contract predicates precisely.
</think>
```json
{
  "helper_functions": "(define-fun-rec isList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (isList (tail v))\n            false)))\n\n(define-fun-rec length ((lst Value)) Int\n  (ite (is-Nil lst)\n       0\n       (ite (is-Cons lst)\n            (+ 1 (length (tail lst)))\n            0)))\n\n(define-fun-rec list_all_numeric ((lst Value)) Bool\n  (ite (is-Nil lst)\n       true\n       (ite (is-Cons lst)\n            (and (or (is-IntVal (head lst)) (is-FloatVal (head lst)))\n                 (list_all_numeric (tail lst)))\n            false)))",
  "basic_structure": "(assert (isList arr))",
  "inputs": "(declare-const arr Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (isList arr))",
    "assert_1": "(define-fun C1 () Bool (> (length arr) 0))",
    "assert_2": "(define-fun C2 () Bool (list_all_numeric arr))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/297

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: flatten_list
Problem Description:
"""
Write a function to flatten a given nested list structure.
assert flatten_list([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]])==[0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]
"""


def flatten_list(list1):

	def list_check(l): # $_CONTRACT_$
		if not isinstance(l, list): # $_CONTRACT_$
			return isinstance(l, (int, float)) # $_CONTRACT_$
		else: # $_CONTRACT_$
			return all(list_check(item) for item in l) # $_CONTRACT_$
	assert isinstance(list1, list), "invalid inputs" # $_CONTRACT_$
	assert list_check(list1), "invalid inputs" # $_CONTRACT_$
	result = []
	for item in list1:
		if isinstance(item, list):
			result.extend(flatten_list(item))
		else:
			result.append(item)
	return result


Contract List:
assert_0: assert isinstance(list1, list), "invalid inputs
assert_1: assert list_check(list1), "invalid inputs


<think>
I model nested lists and numeric checks as recursive SMT predicates, keeping executability constraints separate from contract definitions. I define IsList and list_check with define-fun-rec, declare the input, and translate each Python assert into a Boolean Ck.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Cons v)\n       (IsList (tail v))\n       (is-Nil v)))\n\n(define-fun-rec list_check ((v Value)) Bool\n  (ite (is-Cons v)\n       (let ((hd (head v)) (tl (tail v)))\n         (and (list_check hd) (list_check tl)))\n       (ite (is-Nil v)\n            true\n            (or (is-IntVal v) (is-FloatVal v)))))",
  "basic_structure": "",
  "inputs": "(declare-const list1 Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList list1))",
    "assert_1": "(define-fun C1 () Bool (list_check list1))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/299

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: max_aggregate
Problem Description:
"""
Write a function to calculate the maximum aggregate from the list of tuples.
assert max_aggregate([('Juan Whelan',90),('Sabah Colley',88),('Peter Nichols',7),('Juan Whelan',122),('Sabah Colley',84)])==('Juan Whelan', 212)
"""


from collections import defaultdict
def max_aggregate(stdata):

    assert isinstance(stdata, list), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(x, tuple) for x in stdata), "invalid inputs" # $_CONTRACT_$
    assert all(len(x) == 2 for x in stdata), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(x[1], (int, float)) for x in stdata), "invalid inputs" # $_CONTRACT_$
    temp = defaultdict(int)
    for name, marks in stdata:
        temp[name] += marks
    return max(temp.items(), key=lambda x: x[1])


Contract List:
assert_0: assert isinstance(stdata, list), "invalid inputs
assert_1: assert all(isinstance(x, tuple) for x in stdata), "invalid inputs
assert_2: assert all(len(x) == 2 for x in stdata), "invalid inputs
assert_3: assert all(isinstance(x[1], (int, float)) for x in stdata), "invalid inputs


<think>
I model Python lists and tuples as our Cons/Nil ADT, define precise recursive helpers to check list structure, element type, fixed-length tuples, and numeric second elements, then map each Python assert to a named SMT predicate (C0–C3). Basic structure remains empty (all shape checks live in contracts), and we declare just the stdata input, making this template reusable for violation combinations.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (ite (is-Cons l)\n       (IsList (tail l))\n       (is-Nil l)))\n\n(define-fun is_list_length_2 ((l Value)) Bool\n  (and (is-Cons l)\n       (let ((rest1 (tail l)))\n         (and (is-Cons rest1)\n              (is-Nil (tail rest1))))))\n\n(define-fun-rec list_all_is_cons ((l Value)) Bool\n  (ite (is-Cons l)\n       (and (is-Cons (head l))\n            (list_all_is_cons (tail l)))\n       (is-Nil l)))\n\n(define-fun-rec list_all_len2 ((l Value)) Bool\n  (ite (is-Cons l)\n       (and (is_list_length_2 (head l))\n            (list_all_len2 (tail l)))\n       (is-Nil l)))\n\n(define-fun is_tuple_numeric ((t Value)) Bool\n  (and (is-Cons t)\n       (let ((rest1 (tail t)))\n         (and (is-Cons rest1)\n              (or (is-IntVal (head rest1))\n                  (is-FloatVal (head rest1)))))))\n\n(define-fun-rec list_all_second_numeric ((l Value)) Bool\n  (ite (is-Cons l)\n       (and (is_tuple_numeric (head l))\n            (list_all_second_numeric (tail l)))\n       (is-Nil l)))",
  "basic_structure": "",
  "inputs": "(declare-const stdata Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList stdata))",
    "assert_1": "(define-fun C1 () Bool (list_all_is_cons stdata))",
    "assert_2": "(define-fun C2 () Bool (list_all_len2 stdata))",
    "assert_3": "(define-fun C3 () Bool (list_all_second_numeric stdata))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/300

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: count_binary_seq
Problem Description:
"""
Write a function to find the count of all binary sequences of length 2n such that sum of first n bits is same as sum of last n bits.
assert math.isclose(count_binary_seq(1), 2.0, rel_tol=0.001)
"""


def count_binary_seq(n):

	assert isinstance(n, int) and n > 0, "invalid inputs" # $_CONTRACT_$
 
	nCr = 1
	res = 1
	for r in range(1, n + 1): 
		nCr = (nCr * (n + 1 - r)) / r 
		res += nCr * nCr 
	return res 


Contract List:
assert_0: assert isinstance(n, int) and n > 0, "invalid inputs


<think>
I separate the type‐shape requirement (n must be an IntVal) into BASIC_STRUCTURE so selectors are safe, and then define C0 to capture the Python range check (n > 0). No extra helpers are needed since is-IntVal guards ival.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "(assert (is-IntVal n))",
  "inputs": "(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (> (ival n) 0))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/301

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: dict_depth
Problem Description:
"""
Write a function to find the depth of a dictionary.
assert dict_depth({'a':1, 'b': {'c': {'d': {}}}})==4
"""


def dict_depth_aux(d):
    if isinstance(d, dict):
        return 1 + (max(map(dict_depth_aux, d.values())) if d else 0)
    return 0
def dict_depth(d):

    assert isinstance(d, dict), "invalid inputs" # $_CONTRACT_$
    return dict_depth_aux(d)


Contract List:
assert_0: assert isinstance(d, dict), "invalid inputs


<think>
I model Python dicts as a DictVal holding a list of their value sub-dicts; define a recursive depth function with proper guards and a helper for iterating list tails. The single contract becomes a predicate C0 checking the input is a DictVal.
</think>
```json
{
  "helper_functions": "(define-fun entriesSafe ((d Value)) Value\n  (ite (is-DictVal d) (vals d) Nil))\n\n(define-fun-rec maxDepthList ((lst Value) (curr Int)) Int\n  (ite (is-Nil lst)\n    curr\n    (let ((hd (head lst)) (tl (tail lst)))\n      (let ((dhd (dict_depth_aux hd)))\n        (let ((nxt (ite (> dhd curr) dhd curr)))\n          (maxDepthList tl nxt))))))\n\n(define-fun-rec dict_depth_aux ((d Value)) Int\n  (ite (is-DictVal d)\n    (let ((vl (vals d)))\n      (ite (is-Nil vl)\n        1\n        (+ 1 (maxDepthList vl 0))))\n    0))",
  "basic_structure": "",
  "inputs": "(declare-const d Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-DictVal d))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/305

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: start_withp
Problem Description:
"""
Write a function to return two words from a list of words starting with letter 'p'.
assert start_withp(["Python PHP", "Java JavaScript", "c c++"])==('Python', 'PHP')
"""


import re
def start_withp(words):

    assert isinstance(words, list), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(x, str) for x in words), "invalid inputs" # $_CONTRACT_$
    for w in words:
        m = re.match("(P\w+)\W(P\w+)", w)
        if m:
            return m.groups()


Contract List:
assert_0: assert isinstance(words, list), "invalid inputs
assert_1: assert all(isinstance(x, str) for x in words), "invalid inputs


<think>
I define recursive SMT predicates to capture list structure and element-type checks, then map each Python assert to a named Boolean predicate while ensuring basic executability via a list‐shape invariant.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((ls Value)) Bool\n  (ite (is-Nil ls) true\n    (ite (is-Cons ls)\n      (IsList (tail ls))\n      false)))\n\n(define-fun-rec list_all_str ((ls Value)) Bool\n  (ite (is-Nil ls) true\n    (ite (is-Cons ls)\n      (and (is-StrVal (head ls)) (list_all_str (tail ls)))\n      false)))",
  "basic_structure": "(assert (IsList words))",
  "inputs": "(declare-const words Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList words))",
    "assert_1": "(define-fun C1 () Bool (and (IsList words) (list_all_str words)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/306

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: max_sum_increasing_subseq
Problem Description:
"""
Write a function to find the maximum sum of increasing subsequence from prefix until ith index and also including a given kth element which is after i, i.e., k > i .
assert max_sum_increasing_subseq([1, 101, 2, 3, 100, 4, 5 ], 7, 4, 6) == 11
"""


def max_sum_increasing_subseq(a, n, index, k):

	assert isinstance(a, list), "invalid inputs" # $_CONTRACT_$
	assert all(isinstance(x, (int, float)) for x in a), "invalid inputs" # $_CONTRACT_$
	assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
	assert n == len(a), "invalid inputs" # $_CONTRACT_$
	assert isinstance(index, int), "invalid inputs" # $_CONTRACT_$
	assert 0 <= index < n, "invalid inputs" # $_CONTRACT_$
	assert isinstance(k, int), "invalid inputs" # $_CONTRACT_$
	assert index < k < n, "invalid inputs" # $_CONTRACT_$
	dp = [[0 for _ in range(n)] for _ in range(n)]
	for i in range(n):
		if a[i] > a[0]:
			dp[0][i] = a[i] + a[0]
		else:
			dp[0][i] = a[i]
	for i in range(1, n):
		for j in range(n):
			if a[j] > a[i] and j > i:
				if dp[i - 1][i] + a[j] > dp[i - 1][j]:
					dp[i][j] = dp[i - 1][i] + a[j]
				else:
					dp[i][j] = dp[i - 1][j]
			else:
				dp[i][j] = dp[i - 1][j]
	return dp[index][k]


Contract List:
assert_0: assert isinstance(a, list), "invalid inputs
assert_1: assert all(isinstance(x, (int, float)) for x in a), "invalid inputs
assert_2: assert isinstance(n, int), "invalid inputs
assert_3: assert n == len(a), "invalid inputs
assert_4: assert isinstance(index, int), "invalid inputs
assert_5: assert 0 <= index < n, "invalid inputs
assert_6: assert isinstance(k, int), "invalid inputs
assert_7: assert index < k < n, "invalid inputs


<think>
I modeled the Python assertions as individual SMT-LIB predicates C0–C7, using a single Value ADT with safe selectors and testers. I provided recursive helpers for list structure and length plus a SafeI extractor to ensure all basic execution invariants are met before checking each contract.
</think>
```json
{
  "helper_functions": "(define-fun SafeI ((v Value)) Int\n  (ite (is-IntVal v) (ival v) 0))\n\n(define-fun-rec length ((v Value)) Int\n  (ite (is-Nil v)\n    0\n    (ite (is-Cons v)\n      (+ 1 (length (tail v)))\n      0)))\n\n(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n    true\n    (ite (is-Cons v)\n      (IsList (tail v))\n      false)))\n\n(define-fun-rec list_all_numeric ((v Value)) Bool\n  (ite (is-Nil v)\n    true\n    (ite (is-Cons v)\n      (and\n        (or (is-IntVal (head v)) (is-FloatVal (head v)))\n        (list_all_numeric (tail v)))\n      false)))",
  "basic_structure": "(assert (IsList a))\n(assert (list_all_numeric a))\n(assert (is-IntVal n))\n(assert (<= (SafeI n) (length a)))",
  "inputs": "(declare-const a Value)\n(declare-const n Value)\n(declare-const index Value)\n(declare-const k Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList a))",
    "assert_1": "(define-fun C1 () Bool (list_all_numeric a))",
    "assert_2": "(define-fun C2 () Bool (is-IntVal n))",
    "assert_3": "(define-fun C3 () Bool (= (SafeI n) (length a)))",
    "assert_4": "(define-fun C4 () Bool (is-IntVal index))",
    "assert_4_detail": "(define-fun C5 () Bool (and (<= 0 (SafeI index)) (< (SafeI index) (SafeI n))))",
    "assert_6": "(define-fun C6 () Bool (is-IntVal k))",
    "assert_7": "(define-fun C7 () Bool (and (< (SafeI index) (SafeI k)) (< (SafeI k) (SafeI n))))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/308

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: large_product
Problem Description:
"""
Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.
assert large_product([1, 2, 3, 4, 5, 6],[3, 6, 8, 9, 10, 6],3)==[60, 54, 50]
"""


def large_product(nums1, nums2, N):

    assert isinstance(nums1, list), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(x, (int, float)) for x in nums1), "invalid inputs" # $_CONTRACT_$
    assert isinstance(nums2, list), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(x, (int, float)) for x in nums2), "invalid inputs" # $_CONTRACT_$
    assert isinstance(N, int), "invalid inputs" # $_CONTRACT_$
    assert 0 <= N <= len(nums1) * len(nums2), "invalid inputs" # $_CONTRACT_$
    result = sorted([x*y for x in nums1 for y in nums2], reverse=True)[:N]
    return result


Contract List:
assert_0: assert isinstance(nums1, list), "invalid inputs
assert_1: assert all(isinstance(x, (int, float)) for x in nums1), "invalid inputs
assert_2: assert isinstance(nums2, list), "invalid inputs
assert_3: assert all(isinstance(x, (int, float)) for x in nums2), "invalid inputs
assert_4: assert isinstance(N, int), "invalid inputs
assert_5: assert 0 <= N <= len(nums1) * len(nums2), "invalid inputs


<think>
I translate each Python assertion into a standalone SMT-LIB predicate (C0…C5), provide ADT helpers for list structure, numeric checks, length, and a safe integer extractor, and assert only the minimal shape invariants in the basic structure to ensure executability.
</think>
```json
{
  "helper_functions": "(define-fun is_numeric ((v Value)) Bool (or (is-IntVal v) (is-FloatVal v)))\n(define-fun-rec length ((v Value)) Int\n  (ite (is-Cons v)\n       (+ 1 (length (tail v)))\n       0))\n(define-fun-rec list_all_numeric ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (is_numeric (head v)) (list_all_numeric (tail v)))\n            false)))\n(define-fun-rec IsList ((v Value)) Bool\n  (or (is-Nil v)\n      (and (is-Cons v) (IsList (tail v)))))\n(define-fun SafeI ((v Value)) Int\n  (ite (is-IntVal v) (ival v) 0))",
  "basic_structure": "(assert (IsList nums1))\n(assert (IsList nums2))",
  "inputs": "(declare-const nums1 Value)\n(declare-const nums2 Value)\n(declare-const N Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList nums1))",
    "assert_1": "(define-fun C1 () Bool (list_all_numeric nums1))",
    "assert_2": "(define-fun C2 () Bool (IsList nums2))",
    "assert_3": "(define-fun C3 () Bool (list_all_numeric nums2))",
    "assert_4": "(define-fun C4 () Bool (is-IntVal N))",
    "assert_5": "(define-fun C5 () Bool (and (<= 0 (SafeI N)) (<= (SafeI N) (* (length nums1) (length nums2)))))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/309

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: maximum
Problem Description:
"""
Write a python function to find the maximum of two numbers.
assert maximum(5,10) == 10
"""


def maximum(a,b):

    assert isinstance(a, (int, float)), "invalid inputs" # $_CONTRACT_$
    assert isinstance(b, (int, float)), "invalid inputs" # $_CONTRACT_$
   
    return max(a, b)


Contract List:
assert_0: assert isinstance(a, (int, float)), "invalid inputs
assert_1: assert isinstance(b, (int, float)), "invalid inputs


<think>
I translate each isinstance check into an SMT predicate over the Value ADT, provide a reusable IsNumeric helper, declare the inputs, and define C0/C1 to mirror the Python assertions precisely.
</think>
```json
{
  "helper_functions": "(define-fun IsNumeric ((v Value)) Bool\n  (or (is-IntVal v) (is-FloatVal v)))",
  "basic_structure": "",
  "inputs": "(declare-const a Value)\n(declare-const b Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool\n  (IsNumeric a))",
    "assert_1": "(define-fun C1 () Bool\n  (IsNumeric b))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/310

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: string_to_tuple
Problem Description:
"""
Write a function to convert a given string to a tuple of characters.
assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
"""


def string_to_tuple(str1):

    assert isinstance(str1, str), "invalid inputs" # $_CONTRACT_$
    result = tuple(x for x in str1 if not x.isspace()) 
    return result


Contract List:
assert_0: assert isinstance(str1, str), "invalid inputs


<think>
I map the Python `isinstance` check to an SMT `is-StrVal` predicate, introduce a `SafeS` helper for extracting string values safely, and declare `str1` as a `Value`. I leave a trivial basic structure to satisfy executability and define one contract predicate `C0` matching the assertion.
</think>
```json
{
  "helper_functions": "(define-fun SafeS ((v Value)) String (ite (is-StrVal v) (sval v) \"\"))",
  "basic_structure": "(assert true)",
  "inputs": "(declare-const str1 Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-StrVal str1))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/311

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: set_left_most_unset_bit
Problem Description:
"""
Write a python function to set the left most unset bit.
assert set_left_most_unset_bit(10) == 14
"""


def set_left_most_unset_bit(n):

    assert isinstance(n, int) and n >= 0, "invalid inputs" # $_CONTRACT_$
 
    if not (n & (n + 1)): 
        return n 
    pos, temp, count = 0, n, 0 
    while temp: 
        if not (temp & 1): 
            pos = count      
        count += 1
        temp >>= 1
    return (n | (1 << (pos))) 


Contract List:
assert_0: assert isinstance(n, int) and n >= 0, "invalid inputs


<think>
I translate the Python assertion into an SMT predicate ensuring the `Value` ADT shape and non-negativity, provide a safe accessor for integers, and assert basic executable structure.
</think>
```json
{
  "helper_functions": "(define-fun safe_ival ((v Value)) Int\n  (ite (is-IntVal v) (ival v) 0))",
  "basic_structure": "(assert (is-IntVal n))",
  "inputs": "(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool\n  (and (is-IntVal n)\n       (>= (safe_ival n) 0)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/312

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: volume_cone
Problem Description:
"""
Write a function to find the volume of a cone.
assert math.isclose(volume_cone(5,12), 314.15926535897927, rel_tol=0.001)
"""


import math
def volume_cone(r,h):

  assert isinstance(r, (int, float)) and r > 0, "invalid inputs" # $_CONTRACT_$
  return (1.0 / 3) * math.pi * r * r * h


Contract List:
assert_0: assert isinstance(r, (int, float)) and r > 0, "invalid inputs


<think>
I will encode the Python type and positivity check on r as an SMT predicate, introduce helpers for numeric extracts, ensure both inputs are numeric for safe execution, and declare the input and basic structure for volume_cone.
</think>
```json
{
  "helper_functions": "(define-fun IsNum ((v Value)) Bool\n  (or (is-IntVal v) (is-FloatVal v)))\n\n(define-fun SafeRealVal ((v Value)) Real\n  (ite (is-IntVal v)\n       (to_real (ival v))\n       (ite (is-FloatVal v)\n            (fval v)\n            0)))",
  "basic_structure": "(assert (IsNum r))\n(assert (IsNum h))",
  "inputs": "(declare-const r Value)\n(declare-const h Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool\n  (and\n    (or (is-IntVal r) (is-FloatVal r))\n    (> (SafeRealVal r) 0)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/388

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: highest_Power_of_2
Problem Description:
"""
Write a python function to find the highest power of 2 that is less than or equal to n.
assert highest_Power_of_2(10) == 8
"""


def highest_Power_of_2(n):

    assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
    assert n > 0, "invalid inputs" # $_CONTRACT_$
 
    i = 0
    while ((1 << i) <= n): 
        i += 1
    return (1 << (i - 1))


Contract List:
assert_0: assert isinstance(n, int), "invalid inputs
assert_1: assert n > 0, "invalid inputs


<think>
I translate each Python assert into an SMT predicate over the ADT, using a SafeInt extractor to guard the integer test. The base structure stays empty so each Ck can be independently toggled for violation testing.
</think>
```json
{
  "helper_functions": "(define-fun SafeInt ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
  "basic_structure": "",
  "inputs": "(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
    "assert_1": "(define-fun C1 () Bool (> (SafeInt n) 0))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/389

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: find_lucas
Problem Description:
"""
Write a function to find the n'th lucas number.
assert find_lucas(9) == 76
"""


def find_lucas(n):

	assert isinstance(n, int) and n >= 0, "invalid inputs" # $_CONTRACT_$
 
	if (n == 0): 
		return 2
	if (n == 1): 
		return 1
	return find_lucas(n - 1) + find_lucas(n - 2) 


Contract List:
assert_0: assert isinstance(n, int) and n >= 0, "invalid inputs


<think>
I model the input `n` as a `Value` and assert its type in the basic structure. The single contract C0 checks that `n` is an `IntVal` and that its unwrapped integer is ≥ 0, using an `ite` to guard the selector.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "(assert (is-IntVal n))",
  "inputs": "(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (and (is-IntVal n) (>= (ite (is-IntVal n) (ival n) 0) 0)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/390

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: add_string
Problem Description:
"""
Write a function to apply a given format string to all of the elements in a list.
assert add_string([1,2,3,4],'temp{0}')==['temp1', 'temp2', 'temp3', 'temp4']
"""


def add_string(list_, string):

    assert isinstance(list_, list), "invalid inputs" # $_CONTRACT_$
    assert isinstance(string, str), "invalid inputs" # $_CONTRACT_$
    return [string.format(i) for i in  list_]


Contract List:
assert_0: assert isinstance(list_, list), "invalid inputs
assert_1: assert isinstance(string, str), "invalid inputs


<think>
I will introduce a recursive IsList predicate to model Python lists in the ADT, then declare the inputs and encode each isinstance check as a separate Boolean predicate C0 and C1, ensuring exact SMT-LIB semantics.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n    true\n    (ite (is-Cons v)\n      (let ((rest (tail v))) (IsList rest))\n      false)))",
  "basic_structure": "",
  "inputs": "(declare-const list_ Value)\n(declare-const string Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList list_))",
    "assert_1": "(define-fun C1 () Bool (is-StrVal string))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/391

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: convert_list_dictionary
Problem Description:
"""
Write a function to convert more than one list to nested dictionary.
assert convert_list_dictionary(["S001", "S002", "S003", "S004"],["Adina Park", "Leyton Marsh", "Duncan Boyle", "Saim Richards"] ,[85, 98, 89, 92])==[{'S001': {'Adina Park': 85}}, {'S002': {'Leyton Marsh': 98}}, {'S003': {'Duncan Boyle': 89}}, {'S004': {'Saim Richards': 92}}]
"""


def convert_list_dictionary(l1, l2, l3):

     assert isinstance(l1, list), "invalid inputs" # $_CONTRACT_$
     assert isinstance(l2, list), "invalid inputs" # $_CONTRACT_$
     assert isinstance(l3, list), "invalid inputs" # $_CONTRACT_$
     result = [{x: {y: z}} for (x, y, z) in zip(l1, l2, l3)]
     return result


Contract List:
assert_0: assert isinstance(l1, list), "invalid inputs
assert_1: assert isinstance(l2, list), "invalid inputs
assert_2: assert isinstance(l3, list), "invalid inputs


<think>
I translate each Python isinstance assertion into an SMT List‐predicate, define a recursive IsList helper to capture the list structure, and then assert basic structural requirements. Each contract Ck is defined as exactly the corresponding IsList check.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))",
  "basic_structure": "(assert (IsList l1))\n(assert (IsList l2))\n(assert (IsList l3))",
  "inputs": "(declare-const l1 Value)\n(declare-const l2 Value)\n(declare-const l3 Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList l1))",
    "assert_1": "(define-fun C1 () Bool (IsList l2))",
    "assert_2": "(define-fun C2 () Bool (IsList l3))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/392

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: get_max_sum
Problem Description:
"""
Write a function to find the maximum sum possible by using the given equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).
assert get_max_sum(60) == 106
"""


def get_max_sum (n):

	assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
	assert n >= 0, "invalid inputs" # $_CONTRACT_$
	# if n = 0, f(0) = max(5(f(0), 0)), so f(0) = 5f(0) or f(0) = 0, for both cases f(0) = 0
	res = [0]
	for i in range(1, n + 1):
		res.append(max(res[i // 2] + res[i // 3] + res[i // 4] + res[i // 5], i))
	return res[n]


Contract List:
assert_0: assert isinstance(n, int), "invalid inputs
assert_1: assert n >= 0, "invalid inputs


<think>
I model `n` as a Value ADT, require it to be an integer for basic executability, and then capture the two Python assertions as SMT predicates C0 (type check) and C1 (non‐negativity).
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "(assert (is-IntVal n))",
  "inputs": "(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
    "assert_1": "(define-fun C1 () Bool (and (is-IntVal n) (>= (ival n) 0)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/394

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: check_distinct
Problem Description:
"""
Write a function to check if given tuple contains no duplicates.
assert check_distinct((1, 4, 5, 6, 1, 4)) == False
"""


def check_distinct(test_tup):

  assert isinstance(test_tup, tuple), "invalid inputs" # $_CONTRACT_$
  return len(test_tup) == len(set(test_tup))


Contract List:
assert_0: assert isinstance(test_tup, tuple), "invalid inputs


<think>
I introduce a recursive IsList predicate to model Python tuples as ADT lists, declare the input, assert its list-structure for executability, and define C0 to capture the isinstance(contract).
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))",
  "basic_structure": "(assert (IsList test_tup))",
  "inputs": "(declare-const test_tup Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList test_tup))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/395

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: first_non_repeating_character
Problem Description:
"""
Write a python function to find the first non-repeated character in a given string.
assert first_non_repeating_character("abcabc") == None
"""


def first_non_repeating_character(str1):

  assert isinstance(str1, str), "invalid inputs" # $_CONTRACT_$
  assert len(str1) > 0, "invalid inputs" # $_CONTRACT_$
  for ch in str1:
    if str1.count(ch) == 1:
      return ch
  return None


Contract List:
assert_0: assert isinstance(str1, str), "invalid inputs
assert_1: assert len(str1) > 0, "invalid inputs


<think>
I translate each Python assertion into a precise SMT predicate, define a safe string extractor and length function to guard selectors, and assert minimal structural invariants to ensure the model is executable.
</think>
```json
{
  "helper_functions": "(define-fun SafeS ((v Value)) String\n  (ite (is-StrVal v) (sval v) \"\"))\n\n(define-fun length ((v Value)) Int\n  (str.len (SafeS v)))",
  "basic_structure": "(assert (is-StrVal str1))",
  "inputs": "(declare-const str1 Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-StrVal str1))",
    "assert_1": "(define-fun C1 () Bool (> (length str1) 0))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/397

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: median_numbers
Problem Description:
"""
Write a function to find the median of three numbers.
assert median_numbers(25,55,65)==55.0
"""


def median_numbers(a,b,c):

    assert isinstance(a, (int, float)), "invalid inputs" # $_CONTRACT_$
    assert isinstance(b, (int, float)), "invalid inputs" # $_CONTRACT_$
    assert isinstance(c, (int, float)), "invalid inputs" # $_CONTRACT_$
    return sorted([a,b,c])[1]


Contract List:
assert_0: assert isinstance(a, (int, float)), "invalid inputs
assert_1: assert isinstance(b, (int, float)), "invalid inputs
assert_2: assert isinstance(c, (int, float)), "invalid inputs


<think>
I translated each Python isinstance check into an SMT predicate using a helper is-NumVal, declared inputs as Value, left basic_structure minimal for executability, and defined C0–C2 exactly matching the Python assertions.
</think>
```json
{
  "helper_functions": "(define-fun is-NumVal ((v Value)) Bool (or (is-IntVal v) (is-FloatVal v)))",
  "basic_structure": "",
  "inputs": "(declare-const a Value)\n(declare-const b Value)\n(declare-const c Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-NumVal a))",
    "assert_1": "(define-fun C1 () Bool (is-NumVal b))",
    "assert_2": "(define-fun C2 () Bool (is-NumVal c))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/398

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: sum_of_digits
Problem Description:
"""
Write a function to compute the sum of digits of each number of a given list.
assert sum_of_digits([10,2,56])==14
"""


def sum_of_digits(nums):

    assert isinstance(nums, list), "invalid inputs" # $_CONTRACT_$
    return sum(int(el) for n in nums for el in str(n) if el.isdigit())


Contract List:
assert_0: assert isinstance(nums, list), "invalid inputs


<think>
I model the Python list check as an SMT-recursive predicate IsList over the canonical ADT, declare the input, assert basic executability through IsList, and define C0 to exactly capture the isinstance(nums, list) assertion.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n    true\n    (ite (is-Cons v)\n      (IsList (tail v))\n      false)))",
  "basic_structure": "(assert (IsList nums))",
  "inputs": "(declare-const nums Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool\n  (IsList nums))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/404

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: minimum
Problem Description:
"""
Write a python function to find the minimum of two numbers.
assert minimum(1,2) == 1
"""


def minimum(a,b):

    assert isinstance(a, (int, float)), "invalid inputs" # $_CONTRACT_$
    assert isinstance(b, (int, float)), "invalid inputs" # $_CONTRACT_$ 
   
    return min(a,b)


Contract List:
assert_0: assert isinstance(a, (int, float)), "invalid inputs
assert_1: assert isinstance(b, (int, float)), "invalid inputs


<think>
I translate the Python isinstance assertions into SMT predicates C0 and C1 checking that a and b are either IntVal or FloatVal. Since there are no lists or other ADT constraints beyond numeric types, helper functions and basic structure remain empty. Inputs are declared as Value and contracts exactly mirror the Python type checks.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "",
  "inputs": "(declare-const a Value)\n(declare-const b Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (or (is-IntVal a) (is-FloatVal a)))",
    "assert_1": "(define-fun C1 () Bool (or (is-IntVal b) (is-FloatVal b)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/405

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: check_tuplex
Problem Description:
"""
Write a function to check whether an element exists within a tuple.
assert check_tuplex(("w", 3, "r", "e", "s", "o", "u", "r", "c", "e"),'r')==True
"""


def check_tuplex(tuplex, element):

  assert isinstance(tuplex, tuple), "invalid inputs" # $_CONTRACT_$
 
  return element in tuplex


Contract List:
assert_0: assert isinstance(tuplex, tuple), "invalid inputs


<think>
I encode the Python tuple-type check as an SMT ADT-based list predicate, define a recursive IsList helper, and lift the assert into a named predicate C0, ensuring the template remains extensible for further contracts.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))",
  "basic_structure": "(assert (IsList tuplex))",
  "inputs": "(declare-const tuplex Value)\n(declare-const element Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList tuplex))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/406

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: find_Parity
Problem Description:
"""
Write a python function to find whether the parity of a given number is odd.
assert find_Parity(12) == False
"""


def find_Parity(x):

    assert isinstance(x, int), "invalid inputs" # $_CONTRACT_$
 
    return x % 2 != 0


Contract List:
assert_0: assert isinstance(x, int), "invalid inputs


<think>
I translate the Python type‐check assertion into an SMT predicate C0 that ensures x is an IntVal, declare x as a Value, and keep the base structure empty since no additional invariants are needed.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "",
  "inputs": "(declare-const x Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal x))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/409

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: min_product_tuple
Problem Description:
"""
Write a function to find the minimum product from the pairs of tuples within a given list.
assert min_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==8
"""


def min_product_tuple(list1):

    assert isinstance(list1, list), "invalid inputs" # $_CONTRACT_$
    assert len(list1) > 0, "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(ele, tuple) for ele in list1), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(ele, (int, float)) for sub in list1 for ele in sub), "invalid inputs" # $_CONTRACT_$
    return min(x * y for x, y in list1)


Contract List:
assert_0: assert isinstance(list1, list), "invalid inputs
assert_1: assert len(list1) > 0, "invalid inputs
assert_2: assert all(isinstance(ele, tuple) for ele in list1), "invalid inputs
assert_3: assert all(isinstance(ele, (int, float)) for sub in list1 for ele in sub), "invalid inputs


<think>
I will translate the Python input contracts for min_product_tuple into precise SMT-LIB v2 predicates, defining recursive list and numeric helpers to model tuple‐lists and element types. The basic structure ensures list1 has the correct ADT shape for safe execution, while each Ck mirrors a specific Python assertion.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec Length ((v Value)) Int\n  (ite (is-Nil v)\n       0\n       (ite (is-Cons v)\n            (+ 1 (Length (tail v)))\n            0)))\n\n(define-fun Is2List ((v Value)) Bool\n  (and (is-Cons v)\n       (let ((t1 (tail v)))\n         (and (is-Cons t1)\n              (is-Nil (tail t1))))))\n\n(define-fun-rec ListAllTuple ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (and (is-Cons v) (Is2List (head v)))\n            (ListAllTuple (tail v))\n            false)))\n\n(define-fun-rec ListAllNumericSub ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (let ((h (head l)))\n              (and (or (is-IntVal h) (is-FloatVal h))\n                   (ListAllNumericSub (tail l))))\n            false)))\n\n(define-fun-rec ListAllNumeric ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (ListAllNumericSub (head v))\n                 (ListAllNumeric (tail v)))\n            false)))",
  "basic_structure": "(assert (IsList list1))",
  "inputs": "(declare-const list1 Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList list1))",
    "assert_1": "(define-fun C1 () Bool (> (Length list1) 0))",
    "assert_2": "(define-fun C2 () Bool (ListAllTuple list1))",
    "assert_3": "(define-fun C3 () Bool (ListAllNumeric list1))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/410

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: min_val
Problem Description:
"""
Write a function to find the minimum value in a given heterogeneous list.
assert min_val(['Python', 3, 2, 4, 5, 'version'])==2
"""


def min_val(listval):

     assert isinstance(listval, list), "invalid inputs" # $_CONTRACT_$
     assert len(listval) > 0, "invalid inputs" # $_CONTRACT_$
     assert any(isinstance(i, int) for i in listval), "invalid inputs" # $_CONTRACT_$
     min_val = min(i for i in listval if isinstance(i, int))
     return min_val


Contract List:
assert_0: assert isinstance(listval, list), "invalid inputs
assert_1: assert len(listval) > 0, "invalid inputs
assert_2: assert any(isinstance(i, int) for i in listval), "invalid inputs


<think>
I will define precise recursive helpers for list structure and element checks, then translate each Python assertion into a standalone SMT predicate, ensuring safe use of testers and selectors.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (or (is-Nil v)\n      (and (is-Cons v)\n           (IsList (tail v)))))\n\n(define-fun-rec length ((v Value)) Int\n  (ite (is-Cons v)\n       (+ 1 (length (tail v)))\n       0))\n\n(define-fun-rec list_any_int ((v Value)) Bool\n  (ite (is-Cons v)\n       (let ((headv (head v))\n             (tailv (tail v)))\n         (or (is-IntVal headv)\n             (list_any_int tailv)))\n       false))",
  "basic_structure": "",
  "inputs": "(declare-const listval Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList listval))",
    "assert_1": "(define-fun C1 () Bool (> (length listval) 0))",
    "assert_2": "(define-fun C2 () Bool (list_any_int listval))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/412

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: remove_odd
Problem Description:
"""
Write a python function to remove odd numbers from a given list.
assert remove_odd([1,2,3]) == [2]
"""


def remove_odd(l):

    assert isinstance(l, list), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(i, int) for i in l), "invalid inputs" # $_CONTRACT_$
    return [i for i in l if i % 2 == 0]


Contract List:
assert_0: assert isinstance(l, list), "invalid inputs
assert_1: assert all(isinstance(i, int) for i in l), "invalid inputs


<think>
I will define recursive SMT helpers to model Python lists and integer checks, declare the input, and translate each assert into a precise Boolean predicate over the Value ADT.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (ite (is-Nil l) true\n    (ite (is-Cons l)\n      (IsList (tail l))\n      false)))\n\n(define-fun-rec list_all_int ((l Value)) Bool\n  (ite (is-Nil l) true\n    (ite (is-Cons l)\n      (let ((headVal (head l)) (tailVal (tail l)))\n        (ite (is-IntVal headVal)\n             (list_all_int tailVal)\n             false))\n      false)))",
  "basic_structure": "",
  "inputs": "(declare-const l Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList l))",
    "assert_1": "(define-fun C1 () Bool (list_all_int l))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/413

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: extract_nth_element
Problem Description:
"""
Write a function to extract the nth element from a given list of tuples.
assert extract_nth_element([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)] ,0)==['Greyson Fulton', 'Brady Kent', 'Wyatt Knott', 'Beau Turnbull']
"""


def extract_nth_element(list1, n):

    assert isinstance(list1, list), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(tup, tuple) for tup in list1), "invalid inputs" # $_CONTRACT_$
    assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
    assert all(n < len(tup) for tup in list1), "invalid inputs" # $_CONTRACT_$
    return [x[n] for x in list1]


Contract List:
assert_0: assert isinstance(list1, list), "invalid inputs
assert_1: assert all(isinstance(tup, tuple) for tup in list1), "invalid inputs
assert_2: assert isinstance(n, int), "invalid inputs
assert_3: assert all(n < len(tup) for tup in list1), "invalid inputs


<think>
I’ve captured the Python tuple‐and‐list structure by extending the Value ADT with a TupleVal constructor, written recursive helpers for list and tuple checks, safe integer extraction, and index‐validity, then mapped each Python assert to a named predicate C0–C3.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (IsList (tail l))\n            false)))\n\n(define-fun-rec ListAllTupleVal ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (and (is-TupleVal (head l))\n                 (ListAllTupleVal (tail l)))\n            false)))\n\n(define-fun-rec ListAllTupleItems ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (and (is-TupleVal (head l))\n                 (IsList (items (head l)))\n                 (ListAllTupleItems (tail l)))\n            false)))\n\n(define-fun-rec lengthList ((l Value)) Int\n  (ite (is-Cons l)\n       (+ 1 (lengthList (tail l)))\n       0))\n\n(define-fun SafeIval ((v Value)) Int\n  (ite (is-IntVal v)\n       (ival v)\n       0))\n\n(define-fun-rec AllIndexValid ((l Value) (idx Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (and (is-TupleVal (head l))\n                 (< (SafeIval idx)\n                    (lengthList (items (head l))))\n                 (AllIndexValid (tail l) idx))\n            false)))",
  "basic_structure": "(assert (IsList list1))\n(assert (ListAllTupleItems list1))",
  "inputs": "(declare-const list1 Value)\n(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList list1))",
    "assert_1": "(define-fun C1 () Bool (ListAllTupleVal list1))",
    "assert_2": "(define-fun C2 () Bool (is-IntVal n))",
    "assert_3": "(define-fun C3 () Bool (AllIndexValid list1 n))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/414

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: overlapping
Problem Description:
"""
Write a python function to check whether any value in a sequence exists in a sequence or not.
assert overlapping([1,2,3,4,5],[6,7,8,9]) == False
"""


def overlapping(list1,list2):

    assert isinstance(list1, list), "invalid inputs" # $_CONTRACT_$
    assert isinstance(list2, list), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(i, (int, float)) for i in list1), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(i, (int, float)) for i in list2), "invalid inputs" # $_CONTRACT_$
  
    return any(v in list2 for v in list1)


Contract List:
assert_0: assert isinstance(list1, list), "invalid inputs
assert_1: assert isinstance(list2, list), "invalid inputs
assert_2: assert all(isinstance(i, (int, float)) for i in list1), "invalid inputs
assert_3: assert all(isinstance(i, (int, float)) for i in list2), "invalid inputs


<think>
I translate each Python assertion into a precise SMT predicate, define safe recursive list and numeric‐item checks, assert only basic shape invariants in BASIC_STRUCTURE, and then bind each contract to its own Ck predicate.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (IsList (tail l))\n            false)))\n\n(define-fun-rec list_all_numeric ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (and (or (is-IntVal (head l)) (is-FloatVal (head l)))\n                 (list_all_numeric (tail l)))\n            false)))",
  "basic_structure": "(assert (IsList list1))\n(assert (IsList list2))",
  "inputs": "(declare-const list1 Value)\n(declare-const list2 Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList list1))",
    "assert_1": "(define-fun C1 () Bool (IsList list2))",
    "assert_2": "(define-fun C2 () Bool (list_all_numeric list1))",
    "assert_3": "(define-fun C3 () Bool (list_all_numeric list2))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/415

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: max_Product
Problem Description:
"""
Write a python function to find a pair with highest product from a given array of integers.
assert max_Product([1,2,3,4,7,0,8,4]) == (7,8)
"""


def max_Product(arr):

    assert isinstance(arr, list), "invalid inputs" # $_CONTRACT_$
    assert len(arr) >= 2, "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(i, int) for i in arr), "invalid inputs" # $_CONTRACT_$
 
    pairs = [(a, b) for a in arr for b in arr if a != b]
    return max(pairs, key=lambda x: x[0] * x[1])


Contract List:
assert_0: assert isinstance(arr, list), "invalid inputs
assert_1: assert len(arr) >= 2, "invalid inputs
assert_2: assert all(isinstance(i, int) for i in arr), "invalid inputs


<think>
I define recursive helpers IsList, length, and list_all_int to model Python list shape and integer elements. I declare the input arr and map each Python assert to a precise SMT-LIB predicate C0–C2.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (or (is-Nil v) (and (is-Cons v) (IsList (tail v)))))\n(define-fun-rec length ((v Value)) Int\n  (ite (is-Nil v) 0\n       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))\n(define-fun-rec list_all_int ((v Value)) Bool\n  (ite (is-Nil v) true\n       (ite (is-Cons v) (and (is-IntVal (head v)) (list_all_int (tail v))) false)))",
  "basic_structure": "",
  "inputs": "(declare-const arr Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList arr))",
    "assert_1": "(define-fun C1 () Bool (>= (length arr) 2))",
    "assert_2": "(define-fun C2 () Bool (list_all_int arr))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/418

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: Find_Max
Problem Description:
"""
Write a python function to find the element of a list having maximum length.
assert Find_Max([['A'],['A','B'],['A','B','C']]) == ['A','B','C']
"""


def Find_Max(lst):

    assert isinstance(lst, list), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(i, list) for i in lst), "invalid inputs" # $_CONTRACT_$
 
    return max(lst, key = len)


Contract List:
assert_0: assert isinstance(lst, list), "invalid inputs
assert_1: assert all(isinstance(i, list) for i in lst), "invalid inputs


<think>
I define a recursive ADT-based IsList predicate and an AllListLists helper to capture the Python list-of-lists structure, then declare the input and assert the minimal shape in basic_structure. Each Python assert becomes a named predicate C0/C1 exactly mirroring its semantics.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (or (is-Nil v)\n      (and (is-Cons v)\n           (let ((tl (tail v)))\n             (IsList tl)))))\n(define-fun-rec AllListLists ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (let ((hd (head l))\n             (tl (tail l)))\n         (and (IsList hd)\n              (AllListLists tl)))))",
  "basic_structure": "(assert (IsList lst))",
  "inputs": "(declare-const lst Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList lst))",
    "assert_1": "(define-fun C1 () Bool (AllListLists lst))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/419

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: round_and_sum
Problem Description:
"""
Write a function to round every number of a given list of numbers and print the total sum multiplied by the length of the list.
assert round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50])==243
"""


def round_and_sum(list1):

  assert isinstance(list1, list), "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(i, (int, float)) for i in list1), "invalid inputs" # $_CONTRACT_$
  l = len(list1)
  return sum([round(i) for i in list1]) * l


Contract List:
assert_0: assert isinstance(list1, list), "invalid inputs
assert_1: assert all(isinstance(i, (int, float)) for i in list1), "invalid inputs


<think>
I define recursive helpers isList and list_all_numeric to capture the ADT list shape and numeric‐element constraint, declare the list1 input as a Value, assert its shape in basic_structure, and map each Python assert to a Boolean predicate C0 and C1 with proper tester guards.
</think>
```json
{
  "helper_functions": "(define-fun-rec isList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (let ((t (tail v)))\n              (isList t))\n            false)))\n\n(define-fun-rec list_all_numeric ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (let ((h (head v))\n                  (t (tail v)))\n              (and (or (is-IntVal h) (is-FloatVal h))\n                   (list_all_numeric t)))\n            false)))",
  "basic_structure": "(assert (isList list1))",
  "inputs": "(declare-const list1 Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (isList list1))",
    "assert_1": "(define-fun C1 () Bool (list_all_numeric list1))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/420

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: cube_Sum
Problem Description:
"""
Write a python function to find the cube sum of first n even natural numbers.
assert cube_Sum(2) == 72
"""


def cube_Sum(n):

    assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
    assert n >= 0, "invalid inputs" # $_CONTRACT_$
 
    return 2 * (n ** 2) * ((n + 1) ** 2)


Contract List:
assert_0: assert isinstance(n, int), "invalid inputs
assert_1: assert n >= 0, "invalid inputs


<think>
I map Python’s isinstance and non-negativity checks to SMT constructors and a safe integer extractor. I declare `SafeI` to extract `ival` under the `IntVal` guard, assert basic structure for executability, and define C0/C1 to exactly mirror the Python asserts.
</think>
```json
{
  "helper_functions": "(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
  "basic_structure": "(assert (is-IntVal n))",
  "inputs": "(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
    "assert_1": "(define-fun C1 () Bool (>= (SafeI n) 0))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/421

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: concatenate_tuple
Problem Description:
"""
Write a function to concatenate each element of tuple by the delimiter.
assert concatenate_tuple(("ID", "is", 4, "UTS") ) == 'ID-is-4-UTS'
"""


def concatenate_tuple(test_tup):

    assert isinstance(test_tup, tuple), "invalid inputs" # $_CONTRACT_$
    delim = "-"
    res = ''.join([str(ele) + delim for ele in test_tup])
    res = res[ : len(res) - len(delim)]
    return (str(res)) 


Contract List:
assert_0: assert isinstance(test_tup, tuple), "invalid inputs


<think>
I model Python tuples as a recursive list ADT and define an `IsList` predicate to capture the tuple structure. I then declare the input and translate the single `isinstance` assertion into `C0` requiring `test_tup` to be a list.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool (or (is-Nil v) (and (is-Cons v) (IsList (tail v)))))",
  "basic_structure": "(IsList test_tup)",
  "inputs": "(declare-const test_tup Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList test_tup))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/422

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: find_Average_Of_Cube
Problem Description:
"""
Write a python function to find the average of cubes of first n natural numbers.
assert find_Average_Of_Cube(2) == 4.5
"""


def find_Average_Of_Cube(n):

    assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
    assert n >= 0, "invalid inputs" # $_CONTRACT_$
  
    return sum([(i ** 3) for i in range(1, n + 1)]) / n


Contract List:
assert_0: assert isinstance(n, int), "invalid inputs
assert_1: assert n >= 0, "invalid inputs


<think>
I will translate the Python assertions into SMT‐LIB predicates C0 and C1, introduce minimal execution invariants to avoid division by zero, and declare the input under the canonical ADT.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "(assert (is-IntVal n))\n(assert (not (= (ival n) 0)))",
  "inputs": "(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
    "assert_1": "(define-fun C1 () Bool (and (is-IntVal n) (>= (ival n) 0)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/424

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: extract_rear
Problem Description:
"""
Write a function to extract only the rear index element of each string in the given tuple.
assert extract_rear(('Mers', 'for', 'Vers') ) == ['s', 'r', 's']
"""


def extract_rear(test_tuple):

  assert isinstance(test_tuple, tuple), "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(ele, str) for ele in test_tuple), "invalid inputs" # $_CONTRACT_$
  assert all(len(ele) > 0 for ele in test_tuple), "invalid inputs" # $_CONTRACT_$
  return [ele[-1] for ele in test_tuple]


Contract List:
assert_0: assert isinstance(test_tuple, tuple), "invalid inputs
assert_1: assert all(isinstance(ele, str) for ele in test_tuple), "invalid inputs
assert_2: assert all(len(ele) > 0 for ele in test_tuple), "invalid inputs


<think>
I translate the Python tuple‐and‐string checks into a linked‐list ADT and recursive SMT predicates for list shape, element types, and nonempty strings, yielding precise C0–C2 definitions and minimal executability constraints.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (or (is-Nil l)\n      (and (is-Cons l)\n           (IsList (tail l)))))\n\n(define-fun-rec list_all_str ((l Value)) Bool\n  (or (is-Nil l)\n      (and (is-Cons l)\n           (is-StrVal (head l))\n           (list_all_str (tail l)))))\n\n(define-fun-rec list_len_pos ((l Value)) Bool\n  (or (is-Nil l)\n      (and (is-Cons l)\n           (let ((elem (head l)))\n             (and (is-StrVal elem)\n                  (> (str.len (sval elem)) 0)))\n           (list_len_pos (tail l)))))",
  "basic_structure": "(assert (IsList test_tuple))",
  "inputs": "(declare-const test_tuple Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList test_tuple))",
    "assert_1": "(define-fun C1 () Bool (list_all_str test_tuple))",
    "assert_2": "(define-fun C2 () Bool (list_len_pos test_tuple))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/425

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: count_element_in_list
Problem Description:
"""
Write a function to count the number of sublists containing a particular element.
assert count_element_in_list([[1, 3], [5, 7], [1, 11], [1, 15, 7]],1)==3
"""


def count_element_in_list(list1, x):

    assert isinstance(list1, list), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(i, list) for i in list1), "invalid inputs" # $_CONTRACT_$
 
    return sum(x in sublist for sublist in list1)


Contract List:
assert_0: assert isinstance(list1, list), "invalid inputs
assert_1: assert all(isinstance(i, list) for i in list1), "invalid inputs


<think>
I translate each Python assertion into a standalone SMT predicate over our Value ADT, add recursive helpers to recognize lists and list-of-lists, declare inputs, and leave only a trivial universal invariant in the basic structure so every contract can be toggled independently.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (IsList (tail l))\n            false)))\n\n(define-fun-rec ListElemsAreLists ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (and (IsList (head l))\n                 (ListElemsAreLists (tail l)))\n            false)))",
  "basic_structure": "(assert true)",
  "inputs": "(declare-const list1 Value)\n(declare-const x Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool\n  (IsList list1))",
    "assert_1": "(define-fun C1 () Bool\n  (ListElemsAreLists list1))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/426

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: filter_oddnumbers
Problem Description:
"""
Write a function to filter odd numbers.
assert filter_oddnumbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])==[1,3,5,7,9]
"""


def filter_oddnumbers(nums):

    assert isinstance(nums, list), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(n, int) for n in nums), "invalid inputs" # $_CONTRACT_$
    return [n for n in nums if n % 2 == 1]


Contract List:
assert_0: assert isinstance(nums, list), "invalid inputs
assert_1: assert all(isinstance(n, int) for n in nums), "invalid inputs


<think>
I defined ADT-based predicates to ensure list shape (IsList) and element-wise integer checks (list_all_int), declared the input, asserted the minimal structure for safe execution, and mapped each Python assert to a standalone Boolean predicate with proper guards.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (let ((hd (head v)) (tl (tail v)))\n              (IsList tl))\n            false)))\n\n(define-fun-rec list_all_int ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (let ((hd (head v)) (tl (tail v)))\n              (and (is-IntVal hd) (list_all_int tl)))\n            false)))",
  "basic_structure": "(assert (IsList nums))",
  "inputs": "(declare-const nums Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList nums))",
    "assert_1": "(define-fun C1 () Bool (and (IsList nums) (list_all_int nums)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/427

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: change_date_format
Problem Description:
"""
Write a function to convert a date of yyyy-mm-dd format to dd-mm-yyyy format.
assert change_date_format("2026-01-02") == '02-01-2026'
"""


import re
def change_date_format(dt):

    assert isinstance(dt, str), "invalid inputs" # $_CONTRACT_$
    assert re.match(r'\d{4}-\d{1,2}-\d{1,2}', dt), "invalid inputs" # $_CONTRACT_$
    return re.sub(r'(\d{4})-(\d{1,2})-(\d{1,2})', '\\3-\\2-\\1', dt)


Contract List:
assert_0: assert isinstance(dt, str), "invalid inputs
assert_1: assert re.match(r'\d{4}-\d{1,2}-\d{1,2}', dt), "invalid inputs


<think>
I translate the Python asserts into SMT-LIB predicates with safe string selectors and a precise regex encoding, defining each contract as a named Bool. Helpers ensure no unsafe selector use, and each predicate can be independently tested.
</think>
```json
{
  "helper_functions": "(define-fun SafeS ((v Value)) String (ite (is-StrVal v) (sval v) \"\"))\n(define-fun digit_re () (RegEx String)\n  (re.union (str.to.re \"0\")\n    (re.union (str.to.re \"1\")\n      (re.union (str.to.re \"2\")\n        (re.union (str.to.re \"3\")\n          (re.union (str.to.re \"4\")\n            (re.union (str.to.re \"5\")\n              (re.union (str.to.re \"6\")\n                (re.union (str.to.re \"7\")\n                  (re.union (str.to.re \"8\")\n                           (str.to.re \"9\")))))))))))\n(define-fun four_digits_re () (RegEx String)\n  (re.++ digit_re digit_re digit_re digit_re))\n(define-fun one_two_digits_re () (RegEx String)\n  (re.++ digit_re (re.union digit_re (str.to.re \"\"))))\n(define-fun date_re () (RegEx String)\n  (re.++ four_digits_re (str.to.re \"-\") one_two_digits_re (str.to.re \"-\") one_two_digits_re))",
  "basic_structure": "",
  "inputs": "(declare-const dt Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-StrVal dt))",
    "assert_1": "(define-fun C1 () Bool (and C0 (str.in.re (SafeS dt) date_re)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/428

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: shell_sort
Problem Description:
"""
Write a function to sort the given array by using shell sort.
assert shell_sort([12, 23, 4, 5, 3, 2, 12, 81, 56, 95]) == [2, 3, 4, 5, 12, 12, 23, 56, 81, 95]
"""


def shell_sort(my_list):

    assert isinstance(my_list, list), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(ele, (int, float)) for ele in my_list), "invalid inputs" # $_CONTRACT_$
    gap = len(my_list) // 2
    while gap > 0:
        for i in range(gap, len(my_list)):
            current_item = my_list[i]
            j = i
            while j >= gap and my_list[j - gap] > current_item:
                my_list[j] = my_list[j - gap]
                j -= gap
            my_list[j] = current_item
        gap //= 2
    return my_list


Contract List:
assert_0: assert isinstance(my_list, list), "invalid inputs
assert_1: assert all(isinstance(ele, (int, float)) for ele in my_list), "invalid inputs


<think>
I will translate the two Python assertions into SMT-LIB predicates by defining an ADT-based list checker (IsList) and a numeric‐only list checker (list_all_numeric), declare the input, assert the minimal structural requirement, and then define C0 and C1 to exactly mirror the Python contracts.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n(define-fun-rec list_all_numeric ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (or (is-IntVal (head v)) (is-FloatVal (head v)))\n                 (list_all_numeric (tail v)))\n            false)))",
  "basic_structure": "(assert (IsList my_list))",
  "inputs": "(declare-const my_list Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList my_list))",
    "assert_1": "(define-fun C1 () Bool (list_all_numeric my_list))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/429

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: and_tuples
Problem Description:
"""
Write a function to extract the elementwise and tuples from the given two tuples.
assert and_tuples((10, 4, 6, 9), (5, 2, 3, 3)) == (0, 0, 2, 1)
"""


def and_tuples(test_tup1, test_tup2):

  assert isinstance(test_tup1, tuple), "invalid inputs" # $_CONTRACT_$
  assert isinstance(test_tup2, tuple), "invalid inputs" # $_CONTRACT_$
  assert len(test_tup1) == len(test_tup2), "invalid inputs" # $_CONTRACT_$
  return tuple(x & y for x, y in zip(test_tup1, test_tup2))


Contract List:
assert_0: assert isinstance(test_tup1, tuple), "invalid inputs
assert_1: assert isinstance(test_tup2, tuple), "invalid inputs
assert_2: assert len(test_tup1) == len(test_tup2), "invalid inputs


<think>
I represent Python tuples using the Value ADT with Nil/Cons, define recursive isList and length functions, assert list shape for executability, and map each Python assert to a Bool predicate C0–C2.
</think>
```json
{
  "helper_functions": "(define-fun-rec isList ((v Value)) Bool\n  (ite (is-Nil v) true\n    (ite (is-Cons v) (isList (tail v)) false)))\n\n(define-fun-rec length ((v Value)) Int\n  (ite (is-Nil v) 0\n    (ite (is-Cons v) (+ 1 (length (tail v))) 0)))",
  "basic_structure": "(assert (isList test_tup1))\n(assert (isList test_tup2))",
  "inputs": "(declare-const test_tup1 Value)\n(declare-const test_tup2 Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (isList test_tup1))",
    "assert_1": "(define-fun C1 () Bool (isList test_tup2))",
    "assert_2": "(define-fun C2 () Bool (= (length test_tup1) (length test_tup2))))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/430

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: parabola_directrix
Problem Description:
"""
Write a function to find the directrix of a parabola.
assert parabola_directrix(5,3,2)==-198
"""


def parabola_directrix(a, b, c):

  assert isinstance(a, (int, float)), "invalid inputs" # $_CONTRACT_$
  assert isinstance(b, (int, float)), "invalid inputs" # $_CONTRACT_$
  assert isinstance(c, (int, float)), "invalid inputs" # $_CONTRACT_$
 
  return ((int)(c - ((b * b) + 1) * 4 * a ))


Contract List:
assert_0: assert isinstance(a, (int, float)), "invalid inputs
assert_1: assert isinstance(b, (int, float)), "invalid inputs
assert_2: assert isinstance(c, (int, float)), "invalid inputs


<think>
I will model the type assertions as SMT predicates ensuring each parameter is IntVal or FloatVal, define helpers for numeric checks and real conversion to support the arithmetic in the function body, and map each Python assert to a named contract predicate.
</think>
```json
{
  "helper_functions": "(define-fun is-Numeric ((v Value)) Bool (or (is-IntVal v) (is-FloatVal v)))\n(define-fun toReal ((v Value)) Real (ite (is-IntVal v) (to_real (ival v)) (fval v)))",
  "basic_structure": "",
  "inputs": "(declare-const a Value)\n(declare-const b Value)\n(declare-const c Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-Numeric a))",
    "assert_1": "(define-fun C1 () Bool (is-Numeric b))",
    "assert_2": "(define-fun C2 () Bool (is-Numeric c))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/432

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: median_trapezium
Problem Description:
"""
Write a function to find the median length of a trapezium.
assert median_trapezium(15,25,35)==20
"""


def median_trapezium(base1,base2,height):

    assert isinstance(base1, (int, float)), "invalid inputs" # $_CONTRACT_$
    assert isinstance(base2, (int, float)), "invalid inputs" # $_CONTRACT_$
    return (base1 + base2) / 2


Contract List:
assert_0: assert isinstance(base1, (int, float)), "invalid inputs
assert_1: assert isinstance(base2, (int, float)), "invalid inputs


<think>
I introduce a safe numeric checker and real extractor to ensure expressions never crash on non-numerics, then encode each Python isinstance assertion as its own Boolean Ck predicate over the ADT.
</think>
```json
{
  "helper_functions": "(define-fun isNumeric ((v Value)) Bool (or (is-IntVal v) (is-FloatVal v)))\n(define-fun SafeReal ((v Value)) Real (ite (is-IntVal v) (to_real (ival v)) (ite (is-FloatVal v) (fval v) 0)))",
  "basic_structure": "",
  "inputs": "(declare-const base1 Value)\n(declare-const base2 Value)\n(declare-const height Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (isNumeric base1))",
    "assert_1": "(define-fun C1 () Bool (isNumeric base2))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/433

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: check_greater
Problem Description:
"""
Write a function to check whether the entered number is greater than the elements of the given array.
assert check_greater([1, 2, 3, 4, 5], 4) == False
"""


def check_greater(arr, number):

  assert isinstance(arr, list), "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(el, (int, float)) for el in arr), "invalid inputs" # $_CONTRACT_$
  assert isinstance(number, (int, float)), "invalid inputs" # $_CONTRACT_$
  return all(number > el for el in arr)


Contract List:
assert_0: assert isinstance(arr, list), "invalid inputs
assert_1: assert all(isinstance(el, (int, float)) for el in arr), "invalid inputs
assert_2: assert isinstance(number, (int, float)), "invalid inputs


<think>
I translate the Python contracts into SMT-LIB predicates and supply recursive helpers to model list structure and numeric checks, keeping the basic ADT intact and separating executability invariants from per-assertion contracts.
</think>
```json
{
  "helper_functions": "(define-fun IsNumeric ((v Value)) Bool\n  (or (is-IntVal v) (is-FloatVal v)))\n\n(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec list_all_numeric ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (let ((hd (head v))\n                  (tl (tail v)))\n              (and (IsNumeric hd)\n                   (list_all_numeric tl)))\n            false)))",
  "basic_structure": "",
  "inputs": "(declare-const arr Value)\n(declare-const number Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool\n  (IsList arr))",
    "assert_1": "(define-fun C1 () Bool\n  (list_all_numeric arr))",
    "assert_2": "(define-fun C2 () Bool\n  (IsNumeric number))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/435

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: last_Digit
Problem Description:
"""
Write a python function to find the last digit of a given number.
assert last_Digit(123) == 3
"""


def last_Digit(n) :

    assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
    if n < 0: 
        n = -n
    return n % 10


Contract List:
assert_0: assert isinstance(n, int), "invalid inputs


<think>
I translated the Python `isinstance(n, int)` check into an SMT `is-IntVal` predicate, defined a `SafeInt` helper to safely extract the integer, and laid out the SMT-LIB template with the contract predicate.
</think>
```json
{
  "helper_functions": "(define-fun SafeInt ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
  "basic_structure": "",
  "inputs": "(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal n))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/436

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: neg_nos
Problem Description:
"""
Write a python function to return the negative numbers in a list.
assert neg_nos([-1,4,5,-6]) == [-1,-6]
"""


def neg_nos(list1):

  assert isinstance(list1, list), "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(i, (int, float)) for i in list1), "invalid inputs" # $_CONTRACT_$
  return [i for i in list1 if i < 0]


Contract List:
assert_0: assert isinstance(list1, list), "invalid inputs
assert_1: assert all(isinstance(i, (int, float)) for i in list1), "invalid inputs


<think>
I defined recursive SMT helpers to model Python lists and numeric checks, enforcing list structure as a core invariant and isolating each input assertion into separate contract predicates C0 and C1 for systematic violation testing.
</think>
```json
{
  "helper_functions": "(define-fun-rec is_list ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (is_list (tail v))\n            false)))\n\n(define-fun-rec list_all_numeric ((lst Value)) Bool\n  (ite (is-Nil lst)\n       true\n       (ite (is-Cons lst)\n            (let ((hd (head lst)) (tl (tail lst)))\n              (and (or (is-IntVal hd) (is-FloatVal hd))\n                   (list_all_numeric tl)))\n            false)))",
  "basic_structure": "(assert (is_list list1))",
  "inputs": "(declare-const list1 Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is_list list1))",
    "assert_1": "(define-fun C1 () Bool (list_all_numeric list1))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/437

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: remove_odd
Problem Description:
"""
Write a function to remove odd characters in a string.
assert remove_odd("python")==("yhn")
"""


def remove_odd(str1):

    assert isinstance(str1, str), "invalid inputs" # $_CONTRACT_$
    return str1[1::2]


Contract List:
assert_0: assert isinstance(str1, str), "invalid inputs


<think>
I map the Python type assertion to an SMT predicate requiring str1 to be a StrVal and include a SafeStr helper for any future string operations. The template declares the Value ADT, the input, and separates the basic structure (none required) from the contract definition C0.
</think>
```json
{
  "helper_functions": "(define-fun SafeStr ((v Value)) String (ite (is-StrVal v) (sval v) \"\"))",
  "basic_structure": "",
  "inputs": "(declare-const str1 Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-StrVal str1))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/439

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: multiple_to_single
Problem Description:
"""
Write a function to join a list of multiple integers into a single integer.
assert multiple_to_single([11, 33, 50])==113350
"""


def multiple_to_single(L):

  assert isinstance(L, list), "invalid inputs" # $_CONTRACT_$
  assert len(L) > 0, "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(item, int) for item in L), "invalid inputs" # $_CONTRACT_$
  assert all(item > 0 for item in L[1:]), "invalid inputs" # $_CONTRACT_$
  return int(''.join(map(str,L)))


Contract List:
assert_0: assert isinstance(L, list), "invalid inputs
assert_1: assert len(L) > 0, "invalid inputs
assert_2: assert all(isinstance(item, int) for item in L), "invalid inputs
assert_3: assert all(item > 0 for item in L[1:]), "invalid inputs


<think>
I translate each Python assertion into an SMT predicate over the `Value` ADT, define recursive helpers to traverse lists safely, and separate basic executability constraints from individual contract checks.
</think>
```json
{
  "helper_functions": "(define-fun-rec is-List ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (is-List (tail v))\n            false)))\n\n(define-fun-rec list_all_int ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (and (is-Cons v) (is-IntVal (head v)))\n            (list_all_int (tail v))\n            false)))\n\n(define-fun-rec list_all_pos ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (and (is-Cons v)\n                 (is-IntVal (head v))\n                 (> (ival (head v)) 0))\n            (list_all_pos (tail v))\n            false)))",
  "basic_structure": "(assert (is-List L))",
  "inputs": "(declare-const L Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool\n  (is-List L))",
    "assert_1": "(define-fun C1 () Bool\n  (is-Cons L))",
    "assert_2": "(define-fun C2 () Bool\n  (list_all_int L))",
    "assert_3": "(define-fun C3 () Bool\n  (and (is-Cons L)\n       (list_all_pos (tail L))))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/440

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: find_adverb_position
Problem Description:
"""
Write a function to find the first adverb and their positions in a given sentence.
assert find_adverb_position("clearly!! we can see the sky")==(0, 7, 'clearly')
"""


import re
def find_adverb_position(text):

    assert isinstance(text, str), "invalid inputs" # $_CONTRACT_$
    for m in re.finditer(r"\w+ly", text):
        return (m.start(), m.end(), m.group(0))


Contract List:
assert_0: assert isinstance(text, str), "invalid inputs


<think>
I translate the Python isinstance check into an SMT-LIB predicate, declare the Value ADT and a SafeS helper for string extraction, assert text is a StrVal for executability, and define C0 to mirror the “isinstance(text, str)” contract.
</think>
```json
{
  "helper_functions": "(define-fun SafeS ((v Value)) String (ite (is-StrVal v) (sval v) \"\"))",
  "basic_structure": "(assert (is-StrVal text))",
  "inputs": "(declare-const text Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-StrVal text))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/441

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: surfacearea_cube
Problem Description:
"""
Write a function to find the surface area of a cube of a given size.
assert surfacearea_cube(5)==150
"""


def surfacearea_cube(l):

  assert isinstance(l, (int, float)), "invalid inputs" # $_CONTRACT_$
  return 6 * l * l


Contract List:
assert_0: assert isinstance(l, (int, float)), "invalid inputs


<think>
I will model the Python type assertion as an SMT predicate over a generic Value ADT, add helper functions for numeric checks and conversions, assert basic executable shape invariants, and define a contract predicate C0 matching the isinstance check.
</think>
```json
{
  "helper_functions": "(define-fun is-Numeric ((v Value)) Bool (or (is-IntVal v) (is-FloatVal v)))\n(define-fun valToReal ((v Value)) Real (ite (is-IntVal v) (to_real (ival v)) (fval v)))",
  "basic_structure": "(assert (is-Numeric l))",
  "inputs": "(declare-const l Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (or (is-IntVal l) (is-FloatVal l)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/445

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: index_multiplication
Problem Description:
"""
Write a function to perform index wise multiplication of tuple elements in the given two tuples.
assert index_multiplication(((1, 3), (4, 5), (2, 9), (1, 10)),((6, 7), (3, 9), (1, 1), (7, 3)) ) == ((6, 21), (12, 45), (2, 9), (7, 30))
"""


def index_multiplication(test_tup1, test_tup2):

  assert isinstance(test_tup1, tuple), "invalid inputs" # $_CONTRACT_$
  assert isinstance(test_tup2, tuple), "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(ele, tuple) for ele in test_tup1), "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(ele, tuple) for ele in test_tup2), "invalid inputs" # $_CONTRACT_$
  assert all(len(ele) == 2 for ele in test_tup1), "invalid inputs" # $_CONTRACT_$
  assert all(len(ele) == 2 for ele in test_tup2), "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(ele, (int, float)) for tup in test_tup1 for ele in tup), "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(ele, (int, float)) for tup in test_tup2 for ele in tup), "invalid inputs" # $_CONTRACT_$
  return tuple(tuple(a * b for a, b in zip(tup1, tup2))
   for tup1, tup2 in zip(test_tup1, test_tup2))


Contract List:
assert_0: assert isinstance(test_tup1, tuple), "invalid inputs
assert_1: assert isinstance(test_tup2, tuple), "invalid inputs
assert_2: assert all(isinstance(ele, tuple) for ele in test_tup1), "invalid inputs
assert_3: assert all(isinstance(ele, tuple) for ele in test_tup2), "invalid inputs
assert_4: assert all(len(ele) == 2 for ele in test_tup1), "invalid inputs
assert_5: assert all(len(ele) == 2 for ele in test_tup2), "invalid inputs
assert_6: assert all(isinstance(ele, (int, float)) for tup in test_tup1 for ele in tup), "invalid inputs
assert_7: assert all(isinstance(ele, (int, float)) for tup in test_tup2 for ele in tup), "invalid inputs


<think>
I translate each Python assertion into a named SMT predicate over a canonical list‐based ADT, add necessary recursive helpers to recognize lists, lengths, and numeric values, and then isolate only the minimal structural preconditions in the basic structure.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (or (is-Nil v)\n      (and (is-Cons v)\n           (let ((t (tail v)))\n             (IsList t)))))\n\n(define-fun-rec length ((v Value)) Int\n  (ite (is-Nil v)\n       0\n       (let ((t (tail v)))\n         (+ 1 (length t)))))\n\n(define-fun NumericVal ((v Value)) Bool\n  (or (is-IntVal v)\n      (is-FloatVal v)))\n\n(define-fun-rec list_numeric ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (and (NumericVal (head l))\n            (list_numeric (tail l)))))\n\n(define-fun-rec list_all_list ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (and (or (is-Nil (head l))\n                (is-Cons (head l)))\n            (list_all_list (tail l)))))\n\n(define-fun-rec list_all_len_two ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (and (= (length (head l)) 2)\n            (list_all_len_two (tail l)))))\n\n(define-fun-rec list_all_numeric ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (and (list_numeric (head l))\n            (list_all_numeric (tail l)))))",
  "basic_structure": "(assert (IsList test_tup1))\n(assert (IsList test_tup2))",
  "inputs": "(declare-const test_tup1 Value)\n(declare-const test_tup2 Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList test_tup1))",
    "assert_1": "(define-fun C1 () Bool (IsList test_tup2))",
    "assert_2": "(define-fun C2 () Bool (list_all_list test_tup1))",
    "assert_3": "(define-fun C3 () Bool (list_all_list test_tup2))",
    "assert_4": "(define-fun C4 () Bool (list_all_len_two test_tup1))",
    "assert_5": "(define-fun C5 () Bool (list_all_len_two test_tup2))",
    "assert_6": "(define-fun C6 () Bool (list_all_numeric test_tup1))",
    "assert_7": "(define-fun C7 () Bool (list_all_numeric test_tup2))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/446

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: count_Occurrence
Problem Description:
"""
Write a python function to count the occurence of all elements of list in a tuple.
assert count_Occurrence(('a', 'a', 'c', 'b', 'd'),['a', 'b'] ) == 3
"""


from collections import Counter 
def count_Occurrence(tup, lst):

    assert isinstance(tup, tuple), "invalid inputs" # $_CONTRACT_$
    assert isinstance(lst, list), "invalid inputs" # $_CONTRACT_$
 
    return sum(tup.count(ele) for ele in lst)


Contract List:
assert_0: assert isinstance(tup, tuple), "invalid inputs
assert_1: assert isinstance(lst, list), "invalid inputs


<think>
I model both parameters as list-like ADT values and define an IsList tester to capture tuple/list structure. Each Python isinstance assertion becomes a contract predicate checking IsList on the appropriate input.
</think>
```json
{
  "helper_functions": "(define-fun IsList ((v Value)) Bool\n  (or (is-Nil v) (is-Cons v)))",
  "basic_structure": "(assert (and (IsList tup) (IsList lst)))",
  "inputs": "(declare-const tup Value)\n(declare-const lst Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList tup))",
    "assert_1": "(define-fun C1 () Bool (IsList lst))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/447

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: cube_nums
Problem Description:
"""
Write a function to find cubes of individual elements in a list.
assert cube_nums([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])==[1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]
"""


def cube_nums(nums):

    assert isinstance(nums, list), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(n, (int, float)) for n in nums), "invalid inputs" # $_CONTRACT_$
    return [n**3 for n in nums]


Contract List:
assert_0: assert isinstance(nums, list), "invalid inputs
assert_1: assert all(isinstance(n, (int, float)) for n in nums), "invalid inputs


<think>
I translate Python’s list shape and element-type assertions into SMT-LIB helper predicates (IsList, ListAllNumeric) and then define each contract as a Boolean Ck that invokes those helpers on the input Value.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v) true\n    (ite (is-Cons v)\n      (let ((t (tail v)))\n        (IsList t))\n      false)))\n\n(define-fun-rec ListAllNumeric ((v Value)) Bool\n  (ite (is-Nil v) true\n    (ite (is-Cons v)\n      (let ((h (head v)) (t (tail v)))\n        (and (or (is-IntVal h) (is-FloatVal h))\n             (ListAllNumeric t)))\n      false)))",
  "basic_structure": "(assert (IsList nums))",
  "inputs": "(declare-const nums Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList nums))",
    "assert_1": "(define-fun C1 () Bool (ListAllNumeric nums))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/448

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: cal_sum
Problem Description:
"""
Write a function to calculate the sum of perrin numbers.
assert cal_sum(9) == 49
"""


def cal_sum(n):

	assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
 
	a = 3
	b = 0
	c = 2
	if (n == 0): 
		return 3
	if (n == 1): 
		return 3
	if (n == 2): 
		return 5
	sum = 5
	while (n > 2): 
		d = a + b 
		sum = sum + d 
		a = b 
		b = c 
		c = d 
		n = n - 1
	return sum


Contract List:
assert_0: assert isinstance(n, int), "invalid inputs


<think>
I translate the Python type check into an SMT predicate ensuring the input `n` is an integer value in our ADT, keeping the base structure minimal for executability.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "(assert true)",
  "inputs": "(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal n))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/450

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: extract_string
Problem Description:
"""
Write a function to extract specified size of strings from a given list of string values.
assert extract_string(['Python', 'list', 'exercises', 'practice', 'solution'] ,8)==['practice', 'solution']
"""


def extract_string(str1, l):

    assert isinstance(str1, list), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(ele, str) for ele in str1), "invalid inputs" # $_CONTRACT_$
    assert isinstance(l, int), "invalid inputs" # $_CONTRACT_$
    return [e for e in str1 if len(e) == l] 


Contract List:
assert_0: assert isinstance(str1, list), "invalid inputs
assert_1: assert all(isinstance(ele, str) for ele in str1), "invalid inputs
assert_2: assert isinstance(l, int), "invalid inputs


<think>
I will define ADT-safe helper functions (IsList, SafeStrLen, list_all_str) to ensure program execution is well-formed, then declare inputs, assert only structural invariants needed for safety, and encode each Python assertion as a standalone SMT-LIB predicate Ck.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun SafeStrLen ((v Value)) Int\n  (ite (is-StrVal v)\n       (str.len (sval v))\n       0))\n\n(define-fun-rec list_all_str ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (is-StrVal (head v))\n                 (list_all_str (tail v)))\n            false)))",
  "basic_structure": "(assert (IsList str1))\n(assert (is-IntVal l))",
  "inputs": "(declare-const str1 Value)\n(declare-const l Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList str1))",
    "assert_1": "(define-fun C1 () Bool (list_all_str str1))",
    "assert_2": "(define-fun C2 () Bool (is-IntVal l))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/451

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: remove_whitespaces
Problem Description:
"""
Write a function to remove all whitespaces from the given string.
assert remove_whitespaces(' Google    Flutter ') == 'GoogleFlutter'
"""


import re
def remove_whitespaces(text1):

  assert isinstance(text1, str), "invalid inputs" # $_CONTRACT_$
  return text1.replace(' ', '')


Contract List:
assert_0: assert isinstance(text1, str), "invalid inputs


<think>
I map the Python isinstance check to the SMT is-StrVal tester on our canonical ADT, declare the input as a Value, and define C0 to capture the contract. No extra helpers or basic structure invariants are needed beyond the ADT declaration.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "",
  "inputs": "(declare-const text1 Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-StrVal text1))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/453

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: sumofFactors
Problem Description:
"""
Write a python function to find the sum of even factors of a number.
assert sumofFactors(18) == 26
"""


import math 
def sumofFactors(n) :

    assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
    assert n >= 0, "invalid inputs" # $_CONTRACT_$
 
    if (n % 2 != 0) : 
        return 0
    return sum([i for i in range(2, n + 1) if n % i == 0 and i % 2 == 0])


Contract List:
assert_0: assert isinstance(n, int), "invalid inputs
assert_1: assert n >= 0, "invalid inputs


<think>
I translate each Python assert into a named SMT-LIB Boolean that mirrors its type‐ and range‐check, declare the input as a generic Value, and use the ADT tester and selector to ensure sound extraction without unsafe selectors. I leave the helper/functions section empty as no extra ADTs or recursion are needed beyond IntVal.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "",
  "inputs": "(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
    "assert_1": "(define-fun C1 () Bool (and C0 (>= (ival n) 0)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/454

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: text_match_wordz
Problem Description:
"""
Write a function that matches a word containing 'z'.
assert text_match_wordz("pythonz.")==True
"""


import re
def text_match_wordz(text):

        assert isinstance(text, str), "invalid inputs" # $_CONTRACT_$
        return 'z' in text


Contract List:
assert_0: assert isinstance(text, str), "invalid inputs


<think>
I will introduce a safe string extractor to guard against non-string Values, declare the input as a Value, leave the basic structure unconstrained (SafeS ensures selector safety), and encode `isinstance(text, str)` as predicate C0.
</think>
```json
{
  "helper_functions": "(define-fun SafeS ((v Value)) String (ite (is-StrVal v) (sval v) \"\"))",
  "basic_structure": "(assert true)",
  "inputs": "(declare-const text Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-StrVal text))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/455

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: check_monthnumb_number
Problem Description:
"""
Write a function to check whether the given month number contains 31 days or not.
assert check_monthnumb_number(5)==True
"""


def check_monthnumb_number(monthnum2):

  assert isinstance(monthnum2, int), "invalid inputs" # $_CONTRACT_$
  assert 1 <= monthnum2 <= 12, "invalid inputs" # $_CONTRACT_$
  return monthnum2 in [1, 3, 5, 7, 8, 10, 12]


Contract List:
assert_0: assert isinstance(monthnum2, int), "invalid inputs
assert_1: assert 1 <= monthnum2 <= 12, "invalid inputs


<think>
I translated the Python type and range checks into two safe SMT-LIB predicates C0 and C1, introduced a SafeI helper to guard the ival selector, and declared the monthnum2 input as a Value for executability.
</think>
```json
{
  "helper_functions": "(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
  "basic_structure": "",
  "inputs": "(declare-const monthnum2 Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal monthnum2))",
    "assert_1": "(define-fun C1 () Bool (and (is-IntVal monthnum2) (<= 1 (SafeI monthnum2) 12)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/456

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: reverse_string_list
Problem Description:
"""
Write a function to reverse each string in a given list of string values.
assert reverse_string_list(['Red', 'Green', 'Blue', 'White', 'Black'])==['deR', 'neerG', 'eulB', 'etihW', 'kcalB']
"""


def reverse_string_list(stringlist):

    assert isinstance(stringlist, list), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(x, str) for x in stringlist), "invalid inputs" # $_CONTRACT_$
    return [x[::-1] for x in stringlist]


Contract List:
assert_0: assert isinstance(stringlist, list), "invalid inputs
assert_1: assert all(isinstance(x, str) for x in stringlist), "invalid inputs


<think>
I translate the Python list and element-type checks into recursive SMT-LIB predicates (IsList and ListAllStr) to enforce executability, then define each assertion as a named Boolean (C0, C1) matching the original contracts.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec ListAllStr ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (is-StrVal (head v))\n                 (ListAllStr (tail v)))\n            false)))",
  "basic_structure": "(assert (IsList stringlist))",
  "inputs": "(declare-const stringlist Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList stringlist))",
    "assert_1": "(define-fun C1 () Bool (ListAllStr stringlist))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/457

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: Find_Min
Problem Description:
"""
Write a python function to find the sublist having minimum length.
assert Find_Min([[1],[1,2],[1,2,3]]) == [1]
"""


def Find_Min(lst):

    assert isinstance(lst, list), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(x, list) for x in lst), "invalid inputs" # $_CONTRACT_$
 
    return min(lst, key=len) 


Contract List:
assert_0: assert isinstance(lst, list), "invalid inputs
assert_1: assert all(isinstance(x, list) for x in lst), "invalid inputs


<think>
I define recursive predicates to model Python’s list structure and to check that every element is a list. Then I declare the input, assert the basic list shape for executability, and translate each assert into a named SMT predicate.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec list_all_lists ((lst Value)) Bool\n  (ite (is-Nil lst)\n       true\n       (ite (is-Cons lst)\n            (and (IsList (head lst))\n                 (list_all_lists (tail lst)))\n            false)))",
  "basic_structure": "(assert (IsList lst))",
  "inputs": "(declare-const lst Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList lst))",
    "assert_1": "(define-fun C1 () Bool (list_all_lists lst))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/458

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: rectangle_area
Problem Description:
"""
Write a function to find the area of a rectangle.
assert rectangle_area(10,20)==200
"""


def rectangle_area(l,b):

  assert isinstance(l, (int, float)), "invalid inputs" # $_CONTRACT_$
  assert isinstance(b, (int, float)), "invalid inputs" # $_CONTRACT_$
  assert l > 0, "invalid inputs" # $_CONTRACT_$
  assert b > 0, "invalid inputs" # $_CONTRACT_$
  return l * b


Contract List:
assert_0: assert isinstance(l, (int, float)), "invalid inputs
assert_1: assert isinstance(b, (int, float)), "invalid inputs
assert_2: assert l > 0, "invalid inputs
assert_3: assert b > 0, "invalid inputs


<think>
I translate each Python assertion into a precise SMT predicate over the Value ADT, using guarded selectors for numeric tests. I keep the ADT fixed, declare inputs, leave structure minimal for executability, and define four standalone Ck predicates matching isinstance and >0 checks.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "",
  "inputs": "(declare-const l Value)\n(declare-const b Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (or (is-IntVal l) (is-FloatVal l)))",
    "assert_1": "(define-fun C1 () Bool (or (is-IntVal b) (is-FloatVal b)))",
    "assert_2": "(define-fun C2 () Bool (ite (is-IntVal l) (> (to_real (ival l)) 0) (ite (is-FloatVal l) (> (fval l) 0) false)))",
    "assert_3": "(define-fun C3 () Bool (ite (is-IntVal b) (> (to_real (ival b)) 0) (ite (is-FloatVal b) (> (fval b) 0) false)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/459

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: remove_uppercase
Problem Description:
"""
Write a function to remove uppercase substrings from a given string.
assert remove_uppercase('cAstyoUrFavoRitETVshoWs') == 'cstyoravoitshos'
"""


def remove_uppercase(str1):

  assert isinstance(str1, str), "invalid inputs" # $_CONTRACT_$
  return ''.join(c for c in str1 if c.islower())


Contract List:
assert_0: assert isinstance(str1, str), "invalid inputs


<think>
I introduce the canonical ADT, declare the string input, enforce no extra invariants in the basic structure, and map the single isinstance check to C0 via the built-in tester is-StrVal.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "",
  "inputs": "(declare-const str1 Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-StrVal str1))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/460

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: Extract
Problem Description:
"""
Write a python function to get the first element of each sublist.
assert Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]]) == [1, 3, 6]
"""


def Extract(lst):

    assert isinstance(lst, list), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(l, list) for l in lst), "invalid inputs" # $_CONTRACT_$
    assert all(len(l) > 0 for l in lst), "invalid inputs" # $_CONTRACT_$
 
    return [item[0] for item in lst] 


Contract List:
assert_0: assert isinstance(lst, list), "invalid inputs
assert_1: assert all(isinstance(l, list) for l in lst), "invalid inputs
assert_2: assert all(len(l) > 0 for l in lst), "invalid inputs


<think>
I translate each Python assertion into an SMT predicate while ensuring the list‐ADT and recursive helpers are safe and well‐formed. I provide recursive definitions for list shape, length, and the two “all” checks, then declare inputs and map each assert to a Boolean Ck.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (or (is-Nil v) (is-Cons v))\n)\n\n(define-fun-rec length ((lst Value)) Int\n  (ite (is-Cons lst)\n    (+ 1 (length (tail lst)))\n    0\n  )\n)\n\n(define-fun-rec list_all_list ((lst Value)) Bool\n  (ite (is-Cons lst)\n    (and (IsList (head lst))\n         (list_all_list (tail lst)))\n    (is-Nil lst)\n  )\n)\n\n(define-fun-rec list_all_non_empty ((lst Value)) Bool\n  (ite (is-Cons lst)\n    (let ((hd (head lst)) (tl (tail lst)))\n      (and (is-Cons hd)\n           (list_all_non_empty tl)))\n    (is-Nil lst)\n  )\n)",
  "basic_structure": "",
  "inputs": "(declare-const lst Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList lst))",
    "assert_1": "(define-fun C1 () Bool (list_all_list lst))",
    "assert_2": "(define-fun C2 () Bool (list_all_non_empty lst))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/462

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: combinations_list
Problem Description:
"""
Write a function to find all possible combinations of the elements of a given list.
assert combinations_list(['orange', 'red', 'green', 'blue'])==[[], ['orange'], ['red'], ['red', 'orange'], ['green'], ['green', 'orange'], ['green', 'red'], ['green', 'red', 'orange'], ['blue'], ['blue', 'orange'], ['blue', 'red'], ['blue', 'red', 'orange'], ['blue', 'green'], ['blue', 'green', 'orange'], ['blue', 'green', 'red'], ['blue', 'green', 'red', 'orange']]
"""


def combinations_list(list1):

    assert isinstance(list1, list), "invalid inputs" # $_CONTRACT_$
    if len(list1) == 0:
        return [[]]
    result = []
    for el in combinations_list(list1[1:]):
        result += [el, el+[list1[0]]]
    return result


Contract List:
assert_0: assert isinstance(list1, list), "invalid inputs


<think>
I model the list structure and safe operations via recursive helper functions, declare the input, and encode the Python isinstance assertion as a Boolean predicate C0. This setup cleanly separates ADT definitions and executability helpers from the contract itself, enabling systematic testing of both the valid- and invalid-list scenarios.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec list_length ((v Value)) Int\n  (ite (is-Nil v)\n       0\n       (ite (is-Cons v)\n            (+ 1 (list_length (tail v)))\n            0)))\n\n(define-fun SafeHead ((v Value)) Value\n  (ite (is-Cons v)\n       (head v)\n       Nil))\n\n(define-fun SafeTail ((v Value)) Value\n  (ite (is-Cons v)\n       (tail v)\n       Nil))",
  "basic_structure": "",
  "inputs": "(declare-const list1 Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool\n  (IsList list1))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/463

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: max_subarray_product
Problem Description:
"""
Write a function to find the maximum product subarray of the given array.
assert max_subarray_product([1, -2, -3, 0, 7, -8, -2]) == 112
"""


def max_subarray_product(arr):

	assert isinstance(arr, list), "invalid inputs" # $_CONTRACT_$
	assert len(arr) > 0, "invalid inputs" # $_CONTRACT_$
	assert all(isinstance(x, (int, float)) for x in arr), "invalid inputs" # $_CONTRACT_$
	max_so_far = min_ending = max_ending = arr[0]
	for n in arr[1:]:
		min_ending, max_ending = min(n, min_ending * n, max_ending * n), max(n, min_ending * n, max_ending * n)
		max_so_far = max(max_so_far, max_ending)
	return max_so_far


Contract List:
assert_0: assert isinstance(arr, list), "invalid inputs
assert_1: assert len(arr) > 0, "invalid inputs
assert_2: assert all(isinstance(x, (int, float)) for x in arr), "invalid inputs


<think>I will translate the Python assertions into SMT-LIB predicates, define recursive helper functions for list structure and numeric checks, and encode basic ADT constraints to ensure safe execution.</think>
```json
{
  "helper_functions": "(define-fun-rec isList ((v Value)) Bool\n  (or (is-Nil v) (is-Cons v)))\n\n(define-fun-rec list_length ((v Value)) Int\n  (ite (is-Nil v)\n       0\n       (ite (is-Cons v)\n            (+ 1 (list_length (tail v)))\n            0)))\n\n(define-fun-rec list_all_numeric ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (let ((h (head v)))\n              (let ((t (tail v)))\n                (and (or (is-IntVal h) (is-FloatVal h))\n                     (list_all_numeric t))))\n            false)))",
  "basic_structure": "(assert (isList arr))",
  "inputs": "(declare-const arr Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (isList arr))",
    "assert_1": "(define-fun C1 () Bool (> (list_length arr) 0))",
    "assert_2": "(define-fun C2 () Bool (list_all_numeric arr))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/465

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: drop_empty
Problem Description:
"""
Write a function to drop empty items from a given dictionary.
assert drop_empty({'c1': 'Red', 'c2': 'Green', 'c3':None})=={'c1': 'Red', 'c2': 'Green'}
"""


def drop_empty(dict1):

  assert isinstance(dict1, dict), "invalid inputs" # $_CONTRACT_$
  dict1 = {key:value for (key, value) in dict1.items() if value is not None}
  return dict1


Contract List:
assert_0: assert isinstance(dict1, dict), "invalid inputs


<think>
I represent Python dicts as a DictVal of a list of PairVal entries, define helper functions to check a list of pairs and dict shape, and then encode the single `isinstance(dict1, dict)` assertion as C0 relying on those helpers.
</think>
```json
{
  "helper_functions": "(define-datatypes ((Value 0)) (( (IntVal (ival Int)) (FloatVal (fval Real)) (StrVal (sval String)) (BoolVal (bval Bool)) (Nil) (Cons (head Value) (tail Value)) (PairVal (key Value) (val Value)) (DictVal (entries Value)) )))\n(define-fun-rec IsPairsList ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (let ((h (head l))\n                  (t (tail l)))\n              (and (is-PairVal h)\n                   (IsPairsList t)))\n            false)))\n(define-fun IsDict ((d Value)) Bool\n  (and (is-DictVal d)\n       (IsPairsList (entries d))))",
  "basic_structure": "(assert (IsDict dict1))",
  "inputs": "(declare-const dict1 Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsDict dict1))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/468

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: max_product
Problem Description:
"""
Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.
assert max_product([3, 100, 4, 5, 150, 6]) == 3000
"""


def max_product(arr):

  assert isinstance(arr, list), "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(x, (int, float)) for x in arr), "invalid inputs" # $_CONTRACT_$
  assert len(arr) > 0, "invalid inputs" # $_CONTRACT_$
   
  # record the correspond ending element to maintain the increasing subsequence
  ret = max_ending = min_ending = (arr[0], arr[0])
  for n in arr[1:]:
    if n > max_ending[1]:
      max_ending = max((max_ending[0] * n, n), max_ending, key=lambda x: x[0])
    else:
      max_ending = (n, n)
    if n > min_ending[1]:
      min_ending = min((min_ending[0] * n, n), min_ending, key=lambda x: x[0])
    else:
      min_ending = (n, n)
    ret = max(ret, max_ending, min_ending, key=lambda x: x[0])
  return ret[0]


Contract List:
assert_0: assert isinstance(arr, list), "invalid inputs
assert_1: assert all(isinstance(x, (int, float)) for x in arr), "invalid inputs
assert_2: assert len(arr) > 0, "invalid inputs


<think>
I will encode the Python preconditions for `max_product` as named SMT-LIB predicates, define helpers to ensure `arr` is a proper list of numeric values, and map each assertion to C0–C2.
</think>
```json
{
  "helper_functions": "(define-fun IsList ((v Value)) Bool (or (is-Nil v) (is-Cons v)))\n(define-fun-rec list_all_numeric ((lst Value)) Bool\n  (ite (is-Nil lst)\n       true\n       (ite (is-Cons lst)\n            (let ((hd (head lst)))\n              (and (or (is-IntVal hd) (is-FloatVal hd))\n                   (list_all_numeric (tail lst))))\n            false)))",
  "basic_structure": "(IsList arr)\n(list_all_numeric arr)",
  "inputs": "(declare-const arr Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList arr))",
    "assert_1": "(define-fun C1 () Bool (list_all_numeric arr))",
    "assert_2": "(define-fun C2 () Bool (not (is-Nil arr)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/470

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: add_pairwise
Problem Description:
"""
Write a function to find the pairwise addition of the neighboring elements of the given tuple.
assert add_pairwise((1, 5, 7, 8, 10)) == (6, 12, 15, 18)
"""


def add_pairwise(test_tup):

  assert isinstance(test_tup, tuple), "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(x, (int, float)) for x in test_tup), "invalid inputs" # $_CONTRACT_$
  return tuple(a + b for a, b in zip(test_tup, test_tup[1:]))


Contract List:
assert_0: assert isinstance(test_tup, tuple), "invalid inputs
assert_1: assert all(isinstance(x, (int, float)) for x in test_tup), "invalid inputs


<think>
I model the tuple as a list ADT and define recursive predicates IsList and list_all_numeric to capture the structural and numeric constraints. I then declare the input, assert basic executability (the list shape), and define C0/C1 to mirror the Python assertions precisely.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec list_all_numeric ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (let ((h (head v)) (t (tail v)))\n              (and (or (is-IntVal h) (is-FloatVal h))\n                   (list_all_numeric t)))\n            false)))",
  "basic_structure": "(assert (IsList test_tup))",
  "inputs": "(declare-const test_tup Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList test_tup))",
    "assert_1": "(define-fun C1 () Bool (list_all_numeric test_tup))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/471

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: find_remainder
Problem Description:
"""
Write a python function to find the product of the array multiplication modulo n.
assert find_remainder([ 100, 10, 5, 25, 35, 14 ],11) ==9
"""


def find_remainder(arr, n):

    assert isinstance(arr, list), "invalid inputs" # $_CONTRACT_$
    assert len(arr) > 0, "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(x, (int, float)) for x in arr), "invalid inputs" # $_CONTRACT_$
    assert isinstance(n, (int, float)), "invalid inputs" # $_CONTRACT_$
 
    from functools import reduce
    return reduce(lambda x, y: x * y, arr) % n


Contract List:
assert_0: assert isinstance(arr, list), "invalid inputs
assert_1: assert len(arr) > 0, "invalid inputs
assert_2: assert all(isinstance(x, (int, float)) for x in arr), "invalid inputs
assert_3: assert isinstance(n, (int, float)), "invalid inputs


<think>
I will translate each Python assert into a precise SMT-LIB predicate, define recursive helpers for list structure, length, and numeric checks, and isolate only the ADT shape requirement in the basic structure to allow independent violation testing.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool (ite (is-Nil v) true (ite (is-Cons v) (IsList (tail v)) false)))\n(define-fun-rec Length ((v Value)) Int (ite (is-Nil v) 0 (ite (is-Cons v) (+ 1 (Length (tail v))) 0)))\n(define-fun-rec list_all_numeric ((v Value)) Bool (ite (is-Nil v) true (ite (is-Cons v) (and (or (is-IntVal (head v)) (is-FloatVal (head v))) (list_all_numeric (tail v))) false)))",
  "basic_structure": "(assert (IsList arr))",
  "inputs": "(declare-const arr Value)\n(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList arr))",
    "assert_1": "(define-fun C1 () Bool (> (Length arr) 0))",
    "assert_2": "(define-fun C2 () Bool (list_all_numeric arr))",
    "assert_3": "(define-fun C3 () Bool (or (is-IntVal n) (is-FloatVal n)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/472

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: check_Consecutive
Problem Description:
"""
Write a python function to check whether the given list contains consecutive numbers or not.
assert check_Consecutive([1,2,3,4,5]) == True
"""


def check_Consecutive(l):

    assert isinstance(l, list), "invalid inputs" # $_CONTRACT_$
    assert len(l) > 0, "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(x, int) for x in l), "invalid inputs" # $_CONTRACT_$
 
    return sorted(l) == list(range(min(l),max(l)+1)) 


Contract List:
assert_0: assert isinstance(l, list), "invalid inputs
assert_1: assert len(l) > 0, "invalid inputs
assert_2: assert all(isinstance(x, int) for x in l), "invalid inputs


<think>
I translate each Python assertion into a standalone SMT predicate Ck, define recursive helpers for list structure, length, and integer‐element checks over our canonical Value ADT, and declare the input. This ensures precise, guard‐safe modeling of the contracts.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((x Value)) Bool\n  (ite (is-Nil x) true\n       (ite (is-Cons x)\n            (IsList (tail x))\n            false)))\n\n(define-fun-rec length ((x Value)) Int\n  (ite (is-Nil x)\n       0\n       (ite (is-Cons x)\n            (+ 1 (length (tail x)))\n            0)))\n\n(define-fun-rec list_all_int ((x Value)) Bool\n  (ite (is-Nil x)\n       true\n       (ite (is-Cons x)\n            (let ((hd (head x)) (tl (tail x)))\n              (and (is-IntVal hd) (list_all_int tl)))\n            false)))",
  "basic_structure": "",
  "inputs": "(declare-const l Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList l))",
    "assert_1": "(define-fun C1 () Bool (> (length l) 0))",
    "assert_2": "(define-fun C2 () Bool (list_all_int l))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/473

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: tuple_intersection
Problem Description:
"""
Write a function to find the tuple intersection of elements in the given tuple list irrespective of their order.
assert tuple_intersection([(3, 4), (5, 6), (9, 10), (4, 5)] , [(5, 4), (3, 4), (6, 5), (9, 11)]) == {(4, 5), (3, 4), (5, 6)}
"""


def tuple_intersection(test_list1, test_list2):

  assert isinstance(test_list1, list), "invalid inputs" # $_CONTRACT_$
  assert isinstance(test_list2, list), "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(ele, tuple) for ele in test_list1), "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(ele, tuple) for ele in test_list2), "invalid inputs" # $_CONTRACT_$
  return set([tuple(sorted(ele)) for ele in test_list1]) & set([tuple(sorted(ele)) for ele in test_list2])


Contract List:
assert_0: assert isinstance(test_list1, list), "invalid inputs
assert_1: assert isinstance(test_list2, list), "invalid inputs
assert_2: assert all(isinstance(ele, tuple) for ele in test_list1), "invalid inputs
assert_3: assert all(isinstance(ele, tuple) for ele in test_list2), "invalid inputs


<think>
I translate each Python input check into precise SMT predicates over a canonical Value ADT, defining safe recursive helpers for lists and tuple shapes while ensuring selectors are only used under testers. I declare inputs, assert basic list structure for execution, and wrap each assertion in standalone Ck predicates ready for combination testing.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((x Value)) Bool\n  (ite (is-Nil x)\n       true\n       (ite (is-Cons x)\n            (IsList (tail x))\n            false)))\n\n(define-fun IsTuple ((x Value)) Bool\n  (and (is-Cons x)\n       (let ((t1 (tail x)))\n         (and (is-Cons t1)\n              (is-Nil (tail t1))))))\n\n(define-fun-rec ListAllTuple ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (and (IsTuple (head l))\n                 (ListAllTuple (tail l)))\n            false)))",
  "basic_structure": "(assert (IsList test_list1))\n(assert (IsList test_list2))",
  "inputs": "(declare-const test_list1 Value)\n(declare-const test_list2 Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList test_list1))",
    "assert_1": "(define-fun C1 () Bool (IsList test_list2))",
    "assert_2": "(define-fun C2 () Bool (ListAllTuple test_list1))",
    "assert_3": "(define-fun C3 () Bool (ListAllTuple test_list2))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/474

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: replace_char
Problem Description:
"""
Write a function to replace characters in a string.
assert replace_char("polygon",'y','l')==("pollgon")
"""


def replace_char(str1, ch, newch):

    assert isinstance(str1, str), "invalid inputs" # $_CONTRACT_$
    assert isinstance(ch, str), "invalid inputs" # $_CONTRACT_$
    assert len(ch) == 1, "invalid inputs" # $_CONTRACT_$
    assert isinstance(newch, str), "invalid inputs" # $_CONTRACT_$
    assert len(newch) == 1, "invalid inputs" # $_CONTRACT_$
    return str1.replace(ch, newch)


Contract List:
assert_0: assert isinstance(str1, str), "invalid inputs
assert_1: assert isinstance(ch, str), "invalid inputs
assert_2: assert len(ch) == 1, "invalid inputs
assert_3: assert isinstance(newch, str), "invalid inputs
assert_4: assert len(newch) == 1, "invalid inputs


<think>
I introduce a SafeStr helper to guard string extraction, then declare inputs as generic Value constants. Each Python assert is translated into a Bool predicate Ck using is-StrVal testers and str.len on the safe string, ensuring precise, type-safe checks.
</think>
```json
{
  "helper_functions": "(define-fun SafeStr ((v Value)) String (ite (is-StrVal v) (sval v) \"\"))",
  "basic_structure": "",
  "inputs": "(declare-const str1 Value)\n(declare-const ch Value)\n(declare-const newch Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-StrVal str1))",
    "assert_1": "(define-fun C1 () Bool (is-StrVal ch))",
    "assert_2": "(define-fun C2 () Bool (and (is-StrVal ch) (= (str.len (SafeStr ch)) 1)))",
    "assert_3": "(define-fun C3 () Bool (is-StrVal newch))",
    "assert_4": "(define-fun C4 () Bool (and (is-StrVal newch) (= (str.len (SafeStr newch)) 1)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/475

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: sort_counter
Problem Description:
"""
Write a function to sort a dictionary by value.
assert sort_counter({'Math':81, 'Physics':83, 'Chemistry':87})==[('Chemistry', 87), ('Physics', 83), ('Math', 81)]
"""


def sort_counter(dict1):

 assert isinstance(dict1, dict), "invalid inputs" # $_CONTRACT_$
 assert all(isinstance(x, (int, float)) for x in dict1.values()), "invalid inputs" # $_CONTRACT_$
 return sorted(dict1.items(), key=lambda x: x[1], reverse=True)


Contract List:
assert_0: assert isinstance(dict1, dict), "invalid inputs
assert_1: assert all(isinstance(x, (int, float)) for x in dict1.values()), "invalid inputs


<think>
I translate Python’s dict and numeric‐value checks into precise ADT predicates: I declare a recursive list‐of‐pairs (isDict), an all‐values numeric check (all_values_numeric), and then define C0 and C1 so that C1 only matters when C0 holds, matching Python’s assertion order.
</think>
```json
{
  "helper_functions": "(define-fun-rec isList ((l Value)) Bool\n  (or (is-Nil l)\n      (and (is-Cons l)\n           (isList (tail l)))))\n\n(define-fun isIntOrFloat ((v Value)) Bool\n  (or (is-IntVal v)\n      (is-FloatVal v)))\n\n(define-fun isPair ((p Value)) Bool\n  (and (is-Cons p)\n       (let ((p1 (tail p)))\n         (and (is-Cons p1)\n              (is-Nil (tail p1))))))\n\n(define-fun-rec isDict ((d Value)) Bool\n  (or (is-Nil d)\n      (and (is-Cons d)\n           (let ((hd (head d)) (tl (tail d)))\n             (and (isPair hd)\n                  (let ((v (head (tail hd))))\n                    (and (is-StrVal (head hd)) (isIntOrFloat v)))\n                  (isDict tl))))))\n\n(define-fun-rec all_values_numeric ((d Value)) Bool\n  (or (is-Nil d)\n      (and (is-Cons d)\n           (let ((hd (head d)) (tl (tail d)))\n             (let ((v (head (tail hd))))\n               (and (isIntOrFloat v)\n                    (all_values_numeric tl)))))))",
  "basic_structure": "",
  "inputs": "(declare-const dict1 Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool\n  (isDict dict1))",
    "assert_1": "(define-fun C1 () Bool\n  (or (not C0)\n      (all_values_numeric dict1)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/476

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: big_sum
Problem Description:
"""
Write a python function to find the sum of the largest and smallest value in a given array.
assert big_sum([1,2,3]) == 4
"""


def big_sum(nums):

      assert isinstance(nums, list), "invalid inputs" # $_CONTRACT_$
      assert len(nums) > 0, "invalid inputs" # $_CONTRACT_$
      assert all(isinstance(n, (int, float)) for n in nums), "invalid inputs" # $_CONTRACT_$
      return max(nums) + min(nums)


Contract List:
assert_0: assert isinstance(nums, list), "invalid inputs
assert_1: assert len(nums) > 0, "invalid inputs
assert_2: assert all(isinstance(n, (int, float)) for n in nums), "invalid inputs


<think>
I translate each Python assertion into a named SMT predicate and provide minimal ADT invariants to let the model checker explore all contract combinations. Recursive list predicates cover shape, length, and numeric‐element checks exactly as in the Python code.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (IsList (tail l))\n            false)))\n\n(define-fun-rec length ((l Value)) Int\n  (ite (is-Nil l)\n       0\n       (ite (is-Cons l)\n            (+ 1 (length (tail l)))\n            0)))\n\n(define-fun-rec list_all_numeric ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (let ((h (head l)) (t (tail l)))\n              (and (or (is-IntVal h) (is-FloatVal h))\n                   (list_all_numeric t)))\n            false)))",
  "basic_structure": "(assert (IsList nums))",
  "inputs": "(declare-const nums Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList nums))",
    "assert_1": "(define-fun C1 () Bool (> (length nums) 0))",
    "assert_2": "(define-fun C2 () Bool (list_all_numeric nums))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/477

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: is_lower
Problem Description:
"""
Write a python function to convert the given string to lower case.
assert is_lower("InValid") == "invalid"
"""


def is_lower(string):

    assert isinstance(string, str), "invalid inputs" # $_CONTRACT_$
    return string.lower()


Contract List:
assert_0: assert isinstance(string, str), "invalid inputs


<think>
I translate the Python `isinstance(string, str)` check into an SMT-LIB predicate using the `is-StrVal` tester, ensuring the input is the `StrVal` constructor. No additional helper or structural invariants are required for this simple contract, so those sections remain empty.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "",
  "inputs": "(declare-const string Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-StrVal string))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/478

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: remove_lowercase
Problem Description:
"""
Write a function to remove lowercase substrings from a given string.
assert remove_lowercase("PYTHon")==('PYTH')
"""


import re
def remove_lowercase(str1):

    assert isinstance(str1, str), "invalid inputs" # $_CONTRACT_$
    return re.sub('[a-z]', '', str1)


Contract List:
assert_0: assert isinstance(str1, str), "invalid inputs


<think>
I represent the Python string‐type check by requiring the Value ADT to be StrVal. No recursive or list helpers are needed, so helper_functions and basic_structure remain empty. Each contract assertion becomes a named Bool predicate over the input.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "",
  "inputs": "(declare-const str1 Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-StrVal str1))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/479

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: first_Digit
Problem Description:
"""
Write a python function to find the first digit of a given number.
assert first_Digit(123) == 1
"""


def first_Digit(n) :

    assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
    assert n >= 0, "invalid inputs" # $_CONTRACT_$
  
    return int(str(n)[0])


Contract List:
assert_0: assert isinstance(n, int), "invalid inputs
assert_1: assert n >= 0, "invalid inputs


<think>
I introduce a SafeI helper to safely extract integer values from the Value ADT, define minimal basic structure (none needed), declare the input, and translate each Python assert into named Boolean predicates C0 and C1.
</think>
```json
{
  "helper_functions": "(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
  "basic_structure": "",
  "inputs": "(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
    "assert_1": "(define-fun C1 () Bool (>= (SafeI n) 0))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/554

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: Split
Problem Description:
"""
Write a python function which takes a list of integers and only returns the odd ones.
assert Split([1,2,3,4,5,6]) == [1,3,5]
"""


def Split(l):

    assert isinstance(l, list), "invalid inputs" # $_CONTRACT_$
    assert len(l) > 0, "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(x, int) for x in l), "invalid inputs" # $_CONTRACT_$
 
    return list(filter(lambda x: x % 2 == 1, l))


Contract List:
assert_0: assert isinstance(l, list), "invalid inputs
assert_1: assert len(l) > 0, "invalid inputs
assert_2: assert all(isinstance(x, int) for x in l), "invalid inputs


<think>
I translated the Python asserts into SMT helpers that model list structure, length, and integer membership, then defined C0–C2 to match the original contracts exactly while ensuring executability via a basic IsList check.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (and (is-Cons l)\n            (IsList (tail l)))))\n(define-fun-rec length ((l Value)) Int\n  (ite (is-Nil l)\n       0\n       (ite (is-Cons l)\n            (+ 1 (length (tail l)))\n            0)))\n(define-fun-rec list_all_int ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (and (is-IntVal (head l))\n                 (list_all_int (tail l)))\n            false)))",
  "basic_structure": "(assert (IsList l))",
  "inputs": "(declare-const l Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList l))",
    "assert_1": "(define-fun C1 () Bool (> (length l) 0))",
    "assert_2": "(define-fun C2 () Bool (list_all_int l))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/555

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: difference
Problem Description:
"""
Write a python function to find the difference between the sum of cubes of the first n natural numbers and the sum of the first n natural numbers.
assert difference(3) == 30
"""


def difference(n) :

    assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
    assert n >= 0, "invalid inputs" # $_CONTRACT_$
  
    S = (n*(n + 1))//2;  
    res = S*(S-1);  
    return res;  


Contract List:
assert_0: assert isinstance(n, int), "invalid inputs
assert_1: assert n >= 0, "invalid inputs


<think>
I model the input type and non-negativity checks as two standalone SMT predicates C0 and C1, using a guarded selector for the integer value. No extra helpers or invariants are needed beyond the IntVal tester.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "",
  "inputs": "(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
    "assert_1": "(define-fun C1 () Bool (ite (is-IntVal n) (>= (ival n) 0) false))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/556

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: find_Odd_Pair
Problem Description:
"""
Write a python function to count the number of pairs whose xor value is odd.
assert find_Odd_Pair([5,4,7,2,1],5) == 6
"""


def find_Odd_Pair(A,N) :

    assert isinstance(A, list), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(x, int) for x in A), "invalid inputs" # $_CONTRACT_$
    assert isinstance(N, int), "invalid inputs" # $_CONTRACT_$
 
    oddPair = 0
    for i in range(0,N) :  
        for j in range(i+1,N) :  
            if ((A[i] ^ A[j]) % 2 != 0):  
                oddPair+=1  
    return oddPair  


Contract List:
assert_0: assert isinstance(A, list), "invalid inputs
assert_1: assert all(isinstance(x, int) for x in A), "invalid inputs
assert_2: assert isinstance(N, int), "invalid inputs


<think>
I will translate the Python list and integer type assertions into precise SMT-LIB predicates, define helper functions IsList and AllInt for structural checks, and assert only the minimal ADT invariants in the basic structure before defining C0–C2.
</think>
```json
{
  "helper_functions": "(define-fun IsList ((l Value)) Bool (or (is-Nil l) (is-Cons l)))\n(define-fun-rec AllInt ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (and (is-IntVal (head l))\n            (AllInt (tail l)))))",
  "basic_structure": "(assert (IsList A))\n(assert (is-IntVal N))",
  "inputs": "(declare-const A Value)\n(declare-const N Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList A))",
    "assert_1": "(define-fun C1 () Bool (AllInt A))",
    "assert_2": "(define-fun C2 () Bool (is-IntVal N))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/557

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: toggle_string
Problem Description:
"""
Write a function to toggle the case of all characters in a string.
assert toggle_string("Python")==("pYTHON")
"""


def toggle_string(string):

 assert isinstance(string, str), "invalid inputs" # $_CONTRACT_$
 return string.swapcase()


Contract List:
assert_0: assert isinstance(string, str), "invalid inputs


<think>
I translate the Python isinstance check into an SMT-LIB predicate C0 over the ADT and enforce only the minimal executability structure. No auxiliary helpers are needed for a single string‐type contract.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "",
  "inputs": "(declare-const string Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-StrVal string))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/558

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: digit_distance_nums
Problem Description:
"""
Write a python function to find the sum of the per-digit difference between two integers.
assert digit_distance_nums(1,2) == 1
"""


def digit_distance_nums(n1, n2):

    assert isinstance(n1, int), "invalid inputs" # $_CONTRACT_$
    assert isinstance(n2, int), "invalid inputs" # $_CONTRACT_$
    assert n1 >= 0, "invalid inputs" # $_CONTRACT_$
    assert n2 >= 0, "invalid inputs" # $_CONTRACT_$
    return sum([abs(int(c1) - int(c2)) for c1, c2 in zip(str(n1), str(n2))])


Contract List:
assert_0: assert isinstance(n1, int), "invalid inputs
assert_1: assert isinstance(n2, int), "invalid inputs
assert_2: assert n1 >= 0, "invalid inputs
assert_3: assert n2 >= 0, "invalid inputs


<think>
I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.
</think>
```json
{
  "helper_functions": "(define-fun SafeInt ((v Value)) Int\n  (ite (is-IntVal v) (ival v) 0))",
  "basic_structure": "(assert (is-IntVal n1))\n(assert (is-IntVal n2))",
  "inputs": "(declare-const n1 Value)\n(declare-const n2 Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal n1))",
    "assert_1": "(define-fun C1 () Bool (is-IntVal n2))",
    "assert_2": "(define-fun C2 () Bool (>= (SafeInt n1) 0))",
    "assert_3": "(define-fun C3 () Bool (>= (SafeInt n2) 0))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/559

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: max_sub_array_sum
Problem Description:
"""
Write a function to find the sum of the largest contiguous sublist in the given list.
assert max_sub_array_sum([-2, -3, 4, -1, -2, 1, 5, -3], 8) == 7
"""


def max_sub_array_sum(a, size):

  assert isinstance(a, list), "invalid inputs" # $_CONTRACT_$
  assert isinstance(size, int), "invalid inputs" # $_CONTRACT_$
  assert size <= len(a), "invalid inputs" # $_CONTRACT_$
  max_so_far = 0
  max_ending_here = 0
  for i in range(0, size):
    max_ending_here = max_ending_here + a[i]
    if max_ending_here < 0:
      max_ending_here = 0
    elif (max_so_far < max_ending_here):
      max_so_far = max_ending_here
  return max_so_far


Contract List:
assert_0: assert isinstance(a, list), "invalid inputs
assert_1: assert isinstance(size, int), "invalid inputs
assert_2: assert size <= len(a), "invalid inputs


<think>
I translate each Python assert into an SMT predicate Ck with the needed guards, introduce helper functions (IsList, ListAllInt, SafeIval, length) to ensure ADT safety, and use basic_structure to enforce the list-of-ints requirement for the core algorithm.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec ListAllInt ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (is-IntVal (head v))\n                 (ListAllInt (tail v)))\n            false)))\n\n(define-fun SafeIval ((v Value)) Int\n  (ite (is-IntVal v)\n       (ival v)\n       0))\n\n(define-fun-rec length ((v Value)) Int\n  (ite (is-Cons v)\n       (+ 1 (length (tail v)))\n       0))",
  "basic_structure": "(assert (ListAllInt a))",
  "inputs": "(declare-const a Value)\n(declare-const size Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList a))",
    "assert_1": "(define-fun C1 () Bool (is-IntVal size))",
    "assert_2": "(define-fun C2 () Bool\n  (and (is-IntVal size)\n       (IsList a)\n       (<= (SafeIval size) (length a))))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/560

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: union_elements
Problem Description:
"""
Write a function to find the union of the elements of two given tuples and output them in sorted order.
assert union_elements((3, 4, 5, 6),(5, 7, 4, 10) ) == (3, 4, 5, 6, 7, 10)
"""


def union_elements(test_tup1, test_tup2):

  assert isinstance(test_tup1, tuple), "invalid inputs" # $_CONTRACT_$
  assert isinstance(test_tup2, tuple), "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(x, (int, float)) for x in test_tup1), "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(x, (int, float)) for x in test_tup2), "invalid inputs" # $_CONTRACT_$
  return tuple(sorted(set(test_tup1 + test_tup2)))


Contract List:
assert_0: assert isinstance(test_tup1, tuple), "invalid inputs
assert_1: assert isinstance(test_tup2, tuple), "invalid inputs
assert_2: assert all(isinstance(x, (int, float)) for x in test_tup1), "invalid inputs
assert_3: assert all(isinstance(x, (int, float)) for x in test_tup2), "invalid inputs


<think>
I model Python tuples as a linked-list ADT and define recursive SMT helpers IsList and list_all_numeric to capture tuple-like structure and numeric-element checks. Each Python assert becomes an independent Boolean predicate Ck, enabling precise contract encoding and combinatorial testing.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec list_all_numeric ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (or (is-IntVal (head v)) (is-FloatVal (head v)))\n                 (list_all_numeric (tail v)))\n            false)))",
  "basic_structure": "(assert (IsList test_tup1))\n(assert (IsList test_tup2))",
  "inputs": "(declare-const test_tup1 Value)\n(declare-const test_tup2 Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList test_tup1))",
    "assert_1": "(define-fun C1 () Bool (IsList test_tup2))",
    "assert_2": "(define-fun C2 () Bool (list_all_numeric test_tup1))",
    "assert_3": "(define-fun C3 () Bool (list_all_numeric test_tup2))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/562

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: Find_Max_Length
Problem Description:
"""
Write a python function to find the length of the longest sublists.
assert Find_Max_Length([[1],[1,4],[5,6,7,8]]) == 4
"""


def Find_Max_Length(lst):

    assert isinstance(lst, list), "invalid inputs" # $_CONTRACT_$
    assert len(lst) > 0, "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(x, list) for x in lst), "invalid inputs" # $_CONTRACT_$
  
    return len(max(lst, key = len))


Contract List:
assert_0: assert isinstance(lst, list), "invalid inputs
assert_1: assert len(lst) > 0, "invalid inputs
assert_2: assert all(isinstance(x, list) for x in lst), "invalid inputs


<think>
I will translate the Python list assertions into corresponding SMT predicates by defining list shape and helper functions, then model each assertion as a Boolean predicate C0–C2. This ensures the function is executable on well‐formed lists and that each contract predicate precisely matches the Python assertion semantics.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec length ((v Value)) Int\n  (ite (is-Nil v)\n       0\n       (ite (is-Cons v)\n            (+ 1 (length (tail v)))\n            0)))\n\n(define-fun-rec list_all_list ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (IsList (head v))\n                 (list_all_list (tail v)))\n            false)))",
  "basic_structure": "(assert (IsList lst))",
  "inputs": "(declare-const lst Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList lst))",
    "assert_1": "(define-fun C1 () Bool (> (length lst) 0))",
    "assert_2": "(define-fun C2 () Bool (list_all_list lst))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/563

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: extract_values
Problem Description:
"""
Write a function to extract values between quotation marks from a string.
assert extract_values('"Python", "PHP", "Java"')==['Python', 'PHP', 'Java']
"""


import re
def extract_values(text):

 assert isinstance(text, str), "invalid inputs" # $_CONTRACT_$
 return (re.findall(r'"(.*?)"', text))


Contract List:
assert_0: assert isinstance(text, str), "invalid inputs


<think>
I will translate the single Python assertion into an SMT predicate C0, declare the input as a Value, enforce its shape in the basic structure, and produce the required JSON template.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "(assert (is-StrVal text))",
  "inputs": "(declare-const text Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-StrVal text))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/564

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: count_Pairs
Problem Description:
"""
Write a python function which takes a list of integers and counts the number of possible unordered pairs where both elements are unequal.
assert count_Pairs([1,2,1],3) == 2
"""


def count_Pairs(arr,n):

    assert isinstance(arr, list), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(x, int) for x in arr), "invalid inputs" # $_CONTRACT_$
    assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
    assert n <= len(arr), "invalid inputs" # $_CONTRACT_$
 
    cnt = 0; 
    for i in range(n): 
        for j in range(i + 1,n): 
            if (arr[i] != arr[j]): 
                cnt += 1; 
    return cnt; 


Contract List:
assert_0: assert isinstance(arr, list), "invalid inputs
assert_1: assert all(isinstance(x, int) for x in arr), "invalid inputs
assert_2: assert isinstance(n, int), "invalid inputs
assert_3: assert n <= len(arr), "invalid inputs


<think>
I will model the Python list and integer constraints with an ADT Value and helper functions for list structure and element checks, then define each contract as precise SMT predicates.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v) true\n    (ite (is-Cons v) (IsList (tail v)) false)))\n\n(define-fun-rec AllInts ((v Value)) Bool\n  (ite (is-Nil v) true\n    (ite (is-Cons v)\n         (and (is-IntVal (head v)) (AllInts (tail v)))\n         false)))\n\n(define-fun SafeIval ((v Value)) Int\n  (ite (is-IntVal v) (ival v) 0))\n\n(define-fun-rec length ((v Value)) Int\n  (ite (is-Nil v) 0\n    (ite (is-Cons v) (+ 1 (length (tail v))) 0)))",
  "basic_structure": "(assert (IsList arr))\n(assert (is-IntVal n))",
  "inputs": "(declare-const arr Value)\n(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList arr))",
    "assert_1": "(define-fun C1 () Bool (AllInts arr))",
    "assert_2": "(define-fun C2 () Bool (is-IntVal n))",
    "assert_3": "(define-fun C3 () Bool (<= (SafeIval n) (length arr)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/565

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: split
Problem Description:
"""
Write a python function to split a string into characters.
assert split('python') == ['p','y','t','h','o','n']
"""


def split(word):

    assert isinstance(word, str), "invalid inputs" # $_CONTRACT_$
 
    return list(word)


Contract List:
assert_0: assert isinstance(word, str), "invalid inputs


<think>
I model the single Python input check as an SMT predicate C0 using the is-StrVal tester on the Value ADT, provide the ADT and declare the input, and leave helper and basic structure empty since no other recursive or structural invariants are required.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "",
  "inputs": "(declare-const word Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-StrVal word))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/566

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: sum_digits
Problem Description:
"""
Write a function to get the sum of the digits of a non-negative integer.
assert sum_digits(345)==12
"""


def sum_digits(n):

  assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
  assert n >= 0, "invalid inputs" # $_CONTRACT_$
  return sum(map(int, str(n)))


Contract List:
assert_0: assert isinstance(n, int), "invalid inputs
assert_1: assert n >= 0, "invalid inputs


<think>
I translate each Python assertion into a precise SMT predicate: C0 ensures n is an IntVal, C1 enforces non-negativity via a SafeIval helper that guards the selector. No global invariants are needed since SafeIval avoids unsafe access.
</think>
```json
{
  "helper_functions": "(define-fun SafeIval ((v Value)) Int\n  (ite (is-IntVal v) (ival v) 0))",
  "basic_structure": "",
  "inputs": "(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
    "assert_1": "(define-fun C1 () Bool (>= (SafeIval n) 0))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/567

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: issort_list
Problem Description:
"""
Write a function to check whether a specified list is sorted or not.
assert issort_list([1,2,4,6,8,10,12,14,16,17])==True
"""


def issort_list(list1):

    assert isinstance(list1, list), "invalid inputs" # $_CONTRACT_$
    return all(a <= b for a, b in zip(list1, list1[1:]))


Contract List:
assert_0: assert isinstance(list1, list), "invalid inputs


<think>
I translate the Python `isinstance(list1, list)` check into a named SMT predicate C0 using a recursive `IsList` definition. I also add helpers (`IsList`, `list_all_numeric`) and basic assertions to ensure well-formed lists of numeric values for safe execution.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (let ((tailVal (tail l)))\n              (IsList tailVal))\n            false)))\n\n(define-fun-rec list_all_numeric ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (let ((headVal (head l))\n                  (tailVal (tail l)))\n              (and (or (is-IntVal headVal)\n                       (is-FloatVal headVal))\n                   (list_all_numeric tailVal)))\n            false)))",
  "basic_structure": "(assert (IsList list1))\n(assert (list_all_numeric list1))",
  "inputs": "(declare-const list1 Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList list1))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/568

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: empty_list
Problem Description:
"""
Write a function to create a list of N empty dictionaries.
assert empty_list(5)==[{},{},{},{},{}]
"""


def empty_list(length):

 assert isinstance(length, int), "invalid inputs" # $_CONTRACT_$
 assert length >= 0, "invalid inputs" # $_CONTRACT_$
 return [{} for _ in range(length)]


Contract List:
assert_0: assert isinstance(length, int), "invalid inputs
assert_1: assert length >= 0, "invalid inputs


<think>
I represent the input `length` as a Value and provide a `SafeI` helper to guard the use of `ival`. I keep the basic structure minimal—only what’s needed to safely extract an integer—and define each contract predicate to mirror the Python asserts, guarding the second assertion with the first.
</think>
```json
{
  "helper_functions": "(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
  "basic_structure": "(assert (is-IntVal length))",
  "inputs": "(declare-const length Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal length))",
    "assert_1": "(define-fun C1 () Bool (and (is-IntVal length) (>= (ival length) 0)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/569

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: sort_sublists
Problem Description:
"""
Write a function to sort each sublist of strings in a given list of lists.
assert sort_sublists([['green', 'orange'], ['black', 'white'], ['white', 'black', 'orange']])==[['green', 'orange'], ['black', 'white'], ['black', 'orange', 'white']]
"""


def sort_sublists(list1):

    assert isinstance(list1, list), "invalid inputs" # $_CONTRACT_$
    assert len(list1) > 0, "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(x, list) for x in list1), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(x, str) for sublist in list1 for x in sublist), "invalid inputs" # $_CONTRACT_$
    return list(map(sorted,list1)) 


Contract List:
assert_0: assert isinstance(list1, list), "invalid inputs
assert_1: assert len(list1) > 0, "invalid inputs
assert_2: assert all(isinstance(x, list) for x in list1), "invalid inputs
assert_3: assert all(isinstance(x, str) for sublist in list1 for x in sublist), "invalid inputs


I will define helper functions for list shape, length, and element type checks, then declare the input `list1`, assert the basic structure for executability, and define contract predicates C0–C3 matching the Python assertions, each safely guarded to avoid invalid selector use.

```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (or (is-Nil v)\n      (and (is-Cons v)\n           (IsList (tail v)))))\n\n(define-fun-rec length ((l Value)) Int\n  (ite (is-Nil l) 0\n       (ite (is-Cons l)\n            (+ 1 (length (tail l)))\n            0)))\n\n(define-fun-rec all_list ((l Value)) Bool\n  (ite (is-Nil l) true\n       (ite (is-Cons l)\n            (let ((hd (head l)) (tl (tail l)))\n              (and (IsList hd)\n                   (all_list tl)))\n            false)))\n\n(define-fun-rec all_str ((l Value)) Bool\n  (ite (is-Nil l) true\n       (ite (is-Cons l)\n            (let ((hd (head l)) (tl (tail l)))\n              (and (is-StrVal hd)\n                   (all_str tl)))\n            false)))\n\n(define-fun-rec all_str_sublists ((l Value)) Bool\n  (ite (is-Nil l) true\n       (ite (is-Cons l)\n            (let ((hd (head l)) (tl (tail l)))\n              (and (all_str hd)\n                   (all_str_sublists tl)))\n            false)))",
  "basic_structure": "(assert (IsList list1))",
  "inputs": "(declare-const list1 Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList list1))",
    "assert_1": "(define-fun C1 () Bool (ite (IsList list1) (> (length list1) 0) false))",
    "assert_2": "(define-fun C2 () Bool (ite (IsList list1) (all_list list1) false))",
    "assert_3": "(define-fun C3 () Bool (ite (IsList list1) (all_str_sublists list1) false))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/572

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: two_unique_nums
Problem Description:
"""
Write a python function to remove duplicate numbers from a given number of lists.
assert two_unique_nums([1,2,3,2,3,4,5]) == [1, 4, 5]
"""


def two_unique_nums(nums):

  assert isinstance(nums, list), "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(x, (int, float)) for x in nums), "invalid inputs" # $_CONTRACT_$
  return [n for n in nums if nums.count(n)==1]


Contract List:
assert_0: assert isinstance(nums, list), "invalid inputs
assert_1: assert all(isinstance(x, (int, float)) for x in nums), "invalid inputs


<think>
I translate each Python assert into a precise SMT predicate using an unmodified ADT and recursive helpers to validate list structure and numeric contents, then expose C0 and C1 for combination-based violation checks.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (IsList (tail l))\n            false)))\n\n(define-fun-rec list_all_numeric ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (and (or (is-IntVal (head l)) (is-FloatVal (head l)))\n                 (list_all_numeric (tail l)))\n            false)))",
  "basic_structure": "(assert (IsList nums))",
  "inputs": "(declare-const nums Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList nums))",
    "assert_1": "(define-fun C1 () Bool (list_all_numeric nums))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/573

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: unique_product
Problem Description:
"""
Write a python function to calculate the product of the unique numbers in a given list.
assert unique_product([10, 20, 30, 40, 20, 50, 60, 40]) ==  720000000
"""


def unique_product(list_data):

    assert isinstance(list_data, list), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(x, (int, float)) for x in list_data), "invalid inputs" # $_CONTRACT_$
    from functools import reduce
    return reduce(lambda x, y: x*y, set(list_data))


Contract List:
assert_0: assert isinstance(list_data, list), "invalid inputs
assert_1: assert all(isinstance(x, (int, float)) for x in list_data), "invalid inputs


<think>
I will encode the Python list and numeric‐type assertions as SMT‐LIB predicates over a Value ADT, define recursive helpers for list shape and element types, and cleanly separate basic executability (IsList) from the two contract checks.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (or\n    (is-Nil v)\n    (and\n      (is-Cons v)\n      (let ((hd (head v))\n            (tl (tail v)))\n        (IsList tl)\n      )\n    )\n  )\n)\n\n(define-fun-rec list_all_numeric ((v Value)) Bool\n  (or\n    (is-Nil v)\n    (and\n      (is-Cons v)\n      (let ((hd (head v))\n            (tl (tail v)))\n        (or (is-IntVal hd) (is-FloatVal hd))\n        (list_all_numeric tl)\n      )\n    )\n  )\n)",
  "basic_structure": "(assert (IsList list_data))",
  "inputs": "(declare-const list_data Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList list_data))",
    "assert_1": "(define-fun C1 () Bool (list_all_numeric list_data))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/576

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: is_Sub_Array
Problem Description:
"""
Write a python function to check whether a list is sublist of another or not.
assert is_Sub_Array([1,4,3,5],[1,2]) == False
"""


def is_Sub_Array(A,B):

    assert isinstance(A, list), "invalid inputs" # $_CONTRACT_$
    assert isinstance(B, list), "invalid inputs" # $_CONTRACT_$
 
    a = 0
    b = 0
    while a < len(A) and b < len(B):
        if A[a] == B[b]:
            a += 1
            b += 1
        else:
            a += 1
    return b == len(B)


Contract List:
assert_0: assert isinstance(A, list), "invalid inputs
assert_1: assert isinstance(B, list), "invalid inputs


<think>
I will introduce a recursive IsList helper to characterize Python lists in the Value ADT, declare inputs A and B, and then define contract predicates C0 and C1 to mirror the list‐type assertions.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (or (is-Nil v)\n      (and (is-Cons v)\n           (let ((tlVal (tail v)))\n             (IsList tlVal)))))",
  "basic_structure": "",
  "inputs": "(declare-const A Value)\n(declare-const B Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList A))",
    "assert_1": "(define-fun C1 () Bool (IsList B))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/577

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: last_Digit_Factorial
Problem Description:
"""
Write a python function to find the last digit in factorial of a given number.
assert last_Digit_Factorial(4) == 4
"""


def last_Digit_Factorial(n):

    assert isinstance(n, (int, float)), "invalid inputs" # $_CONTRACT_$
    assert n >= 0, "invalid inputs" # $_CONTRACT_$
 
    if (n == 0): 
      return 1
    elif (n <= 2): 
      return n  
    elif (n == 3): 
      return 6
    elif (n == 4): 
      return 4 
    else: 
      return 0


Contract List:
assert_0: assert isinstance(n, (int, float)), "invalid inputs
assert_1: assert n >= 0, "invalid inputs


<think>
I translate the Python input‐validation asserts into two standalone SMT predicates over the Value ADT—one ensuring n is an IntVal or FloatVal, the other enforcing non‐negativity guarded by the correct tester. No recursion or list structures are needed, so helper functions are omitted and the basic structure remains unconstrained.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "",
  "inputs": "(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (or (is-IntVal n) (is-FloatVal n)))",
    "assert_1": "(define-fun C1 () Bool (or (and (is-IntVal n) (>= (ival n) 0)) (and (is-FloatVal n) (>= (fval n) 0.0))))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/578

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: interleave_lists
Problem Description:
"""
Write a function to interleave 3 lists of the same length into a single flat list.
assert interleave_lists([1,2,3,4,5,6,7],[10,20,30,40,50,60,70],[100,200,300,400,500,600,700])==[1, 10, 100, 2, 20, 200, 3, 30, 300, 4, 40, 400, 5, 50, 500, 6, 60, 600, 7, 70, 700]
"""


def interleave_lists(list1, list2, list3):

    assert isinstance(list1, list), "invalid inputs" # $_CONTRACT_$
    assert isinstance(list2, list), "invalid inputs" # $_CONTRACT_$
    assert isinstance(list3, list), "invalid inputs" # $_CONTRACT_$
    assert len(list1) == len(list2) == len(list3), "invalid inputs" # $_CONTRACT_$
    return [el for pair in zip(list1, list2, list3) for el in pair]


Contract List:
assert_0: assert isinstance(list1, list), "invalid inputs
assert_1: assert isinstance(list2, list), "invalid inputs
assert_2: assert isinstance(list3, list), "invalid inputs
assert_3: assert len(list1) == len(list2) == len(list3), "invalid inputs


<think>
I translated each Python assertion into corresponding SMT predicates, ensuring ADT shapes with IsList and computing list lengths recursively. I then set up the basic executability constraints and defined each contract C0–C3 exactly matching the assertion semantics.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n(define-fun-rec length ((v Value)) Int\n  (ite (is-Nil v)\n       0\n       (ite (is-Cons v)\n            (+ 1 (length (tail v)))\n            0)))",
  "basic_structure": "(assert (IsList list1))\n(assert (IsList list2))\n(assert (IsList list3))",
  "inputs": "(declare-const list1 Value)\n(declare-const list2 Value)\n(declare-const list3 Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool\n  (IsList list1))",
    "assert_1": "(define-fun C1 () Bool\n  (IsList list2))",
    "assert_2": "(define-fun C2 () Bool\n  (IsList list3))",
    "assert_3": "(define-fun C3 () Bool\n  (and (= (length list1) (length list2))\n       (= (length list2) (length list3))))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/579

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: find_dissimilar
Problem Description:
"""
Write a function to find the dissimilar elements in the given two tuples.
assert find_dissimilar((3, 4, 5, 6), (5, 7, 4, 10)) == (3, 6, 7, 10)
"""


def find_dissimilar(test_tup1, test_tup2):

  assert isinstance(test_tup1, tuple), "invalid inputs" # $_CONTRACT_$
  assert isinstance(test_tup2, tuple), "invalid inputs" # $_CONTRACT_$
  return tuple(set(test_tup1) ^ set(test_tup2))


Contract List:
assert_0: assert isinstance(test_tup1, tuple), "invalid inputs
assert_1: assert isinstance(test_tup2, tuple), "invalid inputs


<think>
I model Python tuples as linked lists in the Value ADT and introduce a recursive IsList predicate to ensure valid list structure. Each assert maps to a Boolean predicate Ck enforcing that its input is a list, and basic_structure asserts IsList for both parameters to guarantee executability.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))",
  "basic_structure": "(assert (IsList test_tup1))\n(assert (IsList test_tup2))",
  "inputs": "(declare-const test_tup1 Value)\n(declare-const test_tup2 Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList test_tup1))",
    "assert_1": "(define-fun C1 () Bool (IsList test_tup2))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/580

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: extract_even
Problem Description:
"""
Write a function to remove uneven elements in the nested mixed tuple.
assert extract_even((4, 5, (7, 6, (2, 4)), 6, 8)) == (4, (6, (2, 4)), 6, 8)
"""


def even_ele(test_tuple, ): 
	res = tuple() 
	for ele in test_tuple: 
		if isinstance(ele, tuple): 
			res += (even_ele(ele), ) 
		elif ele % 2 == 0: 
			res += (ele, ) 
	return res 
def extract_even(test_tuple):

	def tuple_check(t): # $_CONTRACT_$
		if not isinstance(t, tuple): # $_CONTRACT_$
			return isinstance(t, (int, float)) # $_CONTRACT_$
		else: # $_CONTRACT_$
			return all(tuple_check(item) for item in t) # $_CONTRACT_$
	assert isinstance(test_tuple, tuple) # $_CONTRACT_$
	assert tuple_check(test_tuple) # $_CONTRACT_$
	return even_ele(test_tuple)


Contract List:
assert_0: assert isinstance(test_tuple, tuple)
assert_1: assert tuple_check(test_tuple)


<think>
I modeled nested Python tuples as linked lists using the Value ADT and defined a recursive tuple_check predicate to mirror Python’s type and structure checks. I then declared the input, asserted basic shape invariants for safe execution, and translated each Python assert into a named SMT-LIB Boolean predicate, finally enumerating all 2^2 combinations for thorough testing.
</think>
```json
{
  "helper_functions": "(define-fun IsTuple ((v Value)) Bool\n  (or (is-Cons v) (is-Nil v)))\n\n(define-fun-rec tuple_check ((v Value)) Bool\n  (ite (is-Cons v)\n       (and (tuple_check (head v)) (tuple_check (tail v)))\n       (ite (is-Nil v)\n            true\n            (or (is-IntVal v) (is-FloatVal v)))))",
  "basic_structure": "(assert (IsTuple test_tuple))",
  "inputs": "(declare-const test_tuple Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsTuple test_tuple))",
    "assert_1": "(define-fun C1 () Bool (tuple_check test_tuple))"
  },
  "combination": "(assert (and C0 C1))\n(assert (and (not C0) C1))\n(assert (and C0 (not C1)))\n(assert (and (not C0) (not C1)))"
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/581

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: surface_Area
Problem Description:
"""
Write a python function to find the surface area of a square pyramid with a given base edge and height.
assert surface_Area(3,4) == 33
"""


def surface_Area(b,s):

    assert isinstance(b, (int, float)), "invalid inputs" # $_CONTRACT_$
    assert isinstance(s, (int, float)), "invalid inputs" # $_CONTRACT_$
    assert b > 0, "invalid inputs" # $_CONTRACT_$
    assert s > 0, "invalid inputs" # $_CONTRACT_$
 
    return 2 * b * s + pow(b,2) 


Contract List:
assert_0: assert isinstance(b, (int, float)), "invalid inputs
assert_1: assert isinstance(s, (int, float)), "invalid inputs
assert_2: assert b > 0, "invalid inputs
assert_3: assert s > 0, "invalid inputs


<think>
I will define numeric testers and a toReal extractor to model Python’s numeric types and positivity checks over the Value ADT. Each Python assert will map to a Bool predicate Ck with proper guards for executability.
</think>
```json
{
  "helper_functions": "(define-fun isNumeric ((v Value)) Bool (or (is-IntVal v) (is-FloatVal v)))\n(define-fun toReal ((v Value)) Real\n  (ite (is-IntVal v)\n       (to_real (ival v))\n       (fval v)))",
  "basic_structure": "",
  "inputs": "(declare-const b Value)\n(declare-const s Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (isNumeric b))",
    "assert_1": "(define-fun C1 () Bool (isNumeric s))",
    "assert_2": "(define-fun C2 () Bool (and (isNumeric b) (> (toReal b) 0)))",
    "assert_3": "(define-fun C3 () Bool (and (isNumeric s) (> (toReal s) 0)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/583

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: catalan_number
Problem Description:
"""
Write a function which returns nth catalan number.
assert catalan_number(10)==16796
"""


def catalan_number(num):

    assert isinstance(num, int), "invalid inputs" # $_CONTRACT_$
    assert num >= 0, "invalid inputs" # $_CONTRACT_$
    if num <= 1:
         return 1   
    res_num = 0
    for i in range(num):
        res_num += catalan_number(i) * catalan_number(num - i - 1)
    return res_num


Contract List:
assert_0: assert isinstance(num, int), "invalid inputs
assert_1: assert num >= 0, "invalid inputs


<think>
I will translate the two Python asserts into SMT-LIB predicates C0 and C1, using the ADT’s is-IntVal tester to model isinstance and a guarded extractor for the ≥ 0 check, while declaring the input and leaving the base structure and helpers empty since no extra ADTs or recursion helpers are needed for input validation.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "",
  "inputs": "(declare-const num Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal num))",
    "assert_1": "(define-fun C1 () Bool (and (is-IntVal num) (>= (ival num) 0)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/585

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: expensive_items
Problem Description:
"""
Write a function to find the n most expensive items in a given dataset.
assert expensive_items([{'name': 'Item-1', 'price': 101.1},{'name': 'Item-2', 'price': 555.22}],1)==[{'name': 'Item-2', 'price': 555.22}]
"""


import heapq
def expensive_items(items,n):

  assert isinstance(items, list), "invalid inputs" # $_CONTRACT_$
  assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
  assert n > 0, "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(x, dict) for x in items), "invalid inputs" # $_CONTRACT_$
  assert all('name' in x.keys() for x in items), "invalid inputs" # $_CONTRACT_$
  assert all('price' in x.keys() for x in items), "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(x['price'], (int, float)) for x in items), "invalid inputs" # $_CONTRACT_$
  expensive_items = heapq.nlargest(n, items, key=lambda s: s['price'])
  return expensive_items


Contract List:
assert_0: assert isinstance(items, list), "invalid inputs
assert_1: assert isinstance(n, int), "invalid inputs
assert_2: assert n > 0, "invalid inputs
assert_3: assert all(isinstance(x, dict) for x in items), "invalid inputs
assert_4: assert all('name' in x.keys() for x in items), "invalid inputs
assert_5: assert all('price' in x.keys() for x in items), "invalid inputs
assert_6: assert all(isinstance(x['price'], (int, float)) for x in items), "invalid inputs


<think>
I map each Python assertion to a standalone SMT predicate C0–C6, define a minimal Value ADT with a DictVal constructor, build safe list/dict helpers (guarded by testers), assert only the structural preconditions in BASIC_STRUCTURE, and declare inputs and contracts as requested.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (or (is-Nil l) (is-Cons l)))\n\n(define-fun-rec list_member ((e Value) (lst Value)) Bool\n  (ite (is-Cons lst)\n       (or (= e (head lst)) (list_member e (tail lst)))\n       true))\n\n(define-fun dict_keys ((d Value)) Value\n  (ite (is-DictVal d) (dkeys d) Nil))\n\n(define-fun dict_vals ((d Value)) Value\n  (ite (is-DictVal d) (dvals d) Nil))\n\n(define-fun dict_has_key ((d Value) (k Value)) Bool\n  (list_member k (dict_keys d)))\n\n(define-fun-rec dict_get2 ((ks Value) (vs Value) (k Value)) Value\n  (ite (is-Cons ks)\n       (ite (= k (head ks))\n            (head vs)\n            (dict_get2 (tail ks) (tail vs) k))\n       ; default for missing key\n       (StrVal \"\")))\n\n(define-fun dict_get ((d Value) (k Value)) Value\n  (ite (is-DictVal d)\n       (dict_get2 (dkeys d) (dvals d) k)\n       (StrVal \"\")))\n\n(define-fun-rec list_all_dict ((l Value)) Bool\n  (ite (is-Cons l)\n       (and (is-DictVal (head l)) (list_all_dict (tail l)))\n       true))\n\n(define-fun-rec list_all_has_name ((l Value)) Bool\n  (ite (is-Cons l)\n       (and (is-DictVal (head l))\n            (dict_has_key (head l) (StrVal \"name\"))\n            (list_all_has_name (tail l)))\n       true))\n\n(define-fun-rec list_all_has_price ((l Value)) Bool\n  (ite (is-Cons l)\n       (and (is-DictVal (head l))\n            (dict_has_key (head l) (StrVal \"price\"))\n            (list_all_has_price (tail l)))\n       true))\n\n(define-fun-rec list_all_price_numeric ((l Value)) Bool\n  (ite (is-Cons l)\n       (let ((hd (head l)))\n         (and (is-DictVal hd)\n              (dict_has_key hd (StrVal \"price\"))\n              (let ((v (dict_get hd (StrVal \"price\"))))\n                (or (is-IntVal v) (is-FloatVal v)))\n              (list_all_price_numeric (tail l))))\n       true))",
  "basic_structure": "(assert (IsList items))\n(assert (is-IntVal n))",
  "inputs": "(declare-const items Value)\n(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool\n  (IsList items))",
    "assert_1": "(define-fun C1 () Bool\n  (is-IntVal n))",
    "assert_2": "(define-fun C2 () Bool\n  (and (is-IntVal n) (> (ival n) 0)))",
    "assert_3": "(define-fun C3 () Bool\n  (list_all_dict items))",
    "assert_4": "(define-fun C4 () Bool\n  (list_all_has_name items))",
    "assert_5": "(define-fun C5 () Bool\n  (list_all_has_price items))",
    "assert_6": "(define-fun C6 () Bool\n  (list_all_price_numeric items))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/586

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: split_Arr
Problem Description:
"""
Write a python function to split a list at the nth eelment and add the first part to the end.
assert split_Arr([12,10,5,6,52,36],2) == [5,6,52,36,12,10]
"""


def split_Arr(l, n):

  assert isinstance(l, list), "invalid inputs" # $_CONTRACT_$
  assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
  assert 0 <= n <= len(l), "invalid inputs" # $_CONTRACT_$
  return l[n:] + l[:n]


Contract List:
assert_0: assert isinstance(l, list), "invalid inputs
assert_1: assert isinstance(n, int), "invalid inputs
assert_2: assert 0 <= n <= len(l), "invalid inputs


<think>
I translate the Python list splitting assertions into SMT-LIB predicates, defining safe helpers for list structure, integer extraction, and list length. Each contract Ck exactly mirrors the Python assert semantics while ensuring selector safety and ADT executability.
</think>
```json
{
  "helper_functions": "(define-fun IsList ((v Value)) Bool (or (is-Nil v) (is-Cons v)))\n(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))\n(define-fun-rec length ((l Value)) Int\n  (ite (is-Nil l)\n       0\n       (ite (is-Cons l)\n            (+ 1 (length (tail l)))\n            0)))",
  "basic_structure": "",
  "inputs": "(declare-const l Value)\n(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList l))",
    "assert_1": "(define-fun C1 () Bool (is-IntVal n))",
    "assert_2": "(define-fun C2 () Bool\n  (and (<= 0 (SafeI n))\n       (<= (SafeI n) (length l))))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/587

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: list_tuple
Problem Description:
"""
Write a function to convert a list to a tuple.
assert list_tuple([5, 10, 7, 4, 15, 3])==(5, 10, 7, 4, 15, 3)
"""


def list_tuple(listx):

  assert isinstance(listx, list), "invalid inputs" # $_CONTRACT_$
  return tuple(listx)


Contract List:
assert_0: assert isinstance(listx, list), "invalid inputs


<think>
I introduce a recursive IsList predicate to ensure `listx` is a properly formed Cons/Nil list in the SMT ADT, then declare the input and define C0 to mirror `assert isinstance(listx, list)`. This meets executability requirements and precisely captures the Python contract.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))",
  "basic_structure": "",
  "inputs": "(declare-const listx Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList listx))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/588

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: big_diff
Problem Description:
"""
Write a python function to find the difference between largest and smallest value in a given list.
assert big_diff([1,2,3,4]) == 3
"""


def big_diff(nums):

     assert isinstance(nums, list), "invalid inputs" # $_CONTRACT_$
     assert len(nums) > 0, "invalid inputs" # $_CONTRACT_$
     assert all(isinstance(x, (int, float)) for x in nums), "invalid inputs" # $_CONTRACT_$
     return max(nums) - min(nums)


Contract List:
assert_0: assert isinstance(nums, list), "invalid inputs
assert_1: assert len(nums) > 0, "invalid inputs
assert_2: assert all(isinstance(x, (int, float)) for x in nums), "invalid inputs


<think>
I will define recursive SMT predicates for list structure, length, and numeric-content checks, then translate each Python assertion into a named Boolean (C0,C1,C2), ensuring full executability via a basic IsList invariant.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (or (is-Nil v)\n      (and (is-Cons v)\n           (let ((hd (head v))\n                 (tl (tail v)))\n             (IsList tl)))))\n\n(define-fun-rec length ((v Value)) Int\n  (ite (is-Nil v)\n       0\n       (ite (is-Cons v)\n            (+ 1 (length (tail v)))\n            0)))\n\n(define-fun-rec list_all_numeric ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (and (is-Cons v)\n            (let ((x (head v))\n                  (xs (tail v)))\n              (and (or (is-IntVal x) (is-FloatVal x))\n                   (list_all_numeric xs))))))",
  "basic_structure": "(assert (IsList nums))",
  "inputs": "(declare-const nums Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList nums))",
    "assert_1": "(define-fun C1 () Bool (> (length nums) 0))",
    "assert_2": "(define-fun C2 () Bool (list_all_numeric nums))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/589

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: perfect_squares
Problem Description:
"""
Write a function to find perfect squares between two given numbers.
assert perfect_squares(1,30)==[1, 4, 9, 16, 25]
"""


import math
def perfect_squares(a, b):

    assert isinstance(a, int), "invalid inputs" # $_CONTRACT_$
    assert isinstance(b, int), "invalid inputs" # $_CONTRACT_$
    if a > b:
        a, b = b, a
    if b < 0:
        return []
    if a < 0:
        a = 0
    return list(filter(lambda x: math.sqrt(x).is_integer(), range(a, b+1)))


Contract List:
assert_0: assert isinstance(a, int), "invalid inputs
assert_1: assert isinstance(b, int), "invalid inputs


<think>
I will translate the Python type‐checks into SMT predicates C0 and C1 over the ADT Value, introduce a simple tester helper for IntVal, declare inputs a and b, and keep the basic structure minimal since execution only requires proper int shapes.
</think>
```json
{
  "helper_functions": "(define-fun isIntVal ((v Value)) Bool (is-IntVal v))",
  "basic_structure": "",
  "inputs": "(declare-const a Value)\n(declare-const b Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (isIntVal a))",
    "assert_1": "(define-fun C1 () Bool (isIntVal b))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/590

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: polar_rect
Problem Description:
"""
Write a function to convert polar coordinates to rectangular coordinates.
assert polar_rect(3,4)==((5.0, 0.9272952180016122), (-2+2.4492935982947064e-16j))
"""


import cmath
def polar_rect(x,y):

    assert isinstance(x, (int, float)), "invalid inputs" # $_CONTRACT_$
    assert isinstance(y, (int, float)), "invalid inputs" # $_CONTRACT_$
    cn = cmath.polar(complex(x, y))
    cn1 = cmath.rect(2, cmath.pi)
    return (cn, cn1)


Contract List:
assert_0: assert isinstance(x, (int, float)), "invalid inputs
assert_1: assert isinstance(y, (int, float)), "invalid inputs


<think>
I will introduce a helper `isNumeric` for int/float checks, declare `x`,`y` as `Value`, assert a trivial basic structure, and define `C0`/`C1` to mirror the Python `isinstance` contracts precisely.
</think>
```json
{
  "helper_functions": "(define-fun isNumeric ((v Value)) Bool (or (is-IntVal v) (is-FloatVal v)))",
  "basic_structure": "(assert true)",
  "inputs": "(declare-const x Value)\n(declare-const y Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (isNumeric x))",
    "assert_1": "(define-fun C1 () Bool (isNumeric y))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/591

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: swap_List
Problem Description:
"""
Write a python function to interchange the first and last elements in a list.
assert swap_List([12, 35, 9, 56, 24]) == [24, 35, 9, 56, 12]
"""


def swap_List(newList):

    assert isinstance(newList, list), "invalid inputs" # $_CONTRACT_$
    assert len(newList) > 0, "invalid inputs" # $_CONTRACT_$
 
    return newList[-1:] + newList[1:-1] + newList[:1]


Contract List:
assert_0: assert isinstance(newList, list), "invalid inputs
assert_1: assert len(newList) > 0, "invalid inputs


<think>
I model the Python list as a Nil/Cons ADT, define recursive helpers for IsList and length, declare the input, assert the basic list shape for executability, and turn each Python assert into a named SMT predicate.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (IsList (tail l))\n            false)))\n\n(define-fun-rec length ((l Value)) Int\n  (ite (is-Cons l)\n       (+ 1 (length (tail l)))\n       0))",
  "basic_structure": "(assert (IsList newList))",
  "inputs": "(declare-const newList Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool\n  (IsList newList))",
    "assert_1": "(define-fun C1 () Bool\n  (> (length newList) 0))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/592

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: sum_Of_product
Problem Description:
"""
Write a python function to find the sum of the product of consecutive binomial co-efficients.
assert sum_Of_product(3) == 15
"""


def binomial_Coeff(n, k): 
    C = [0] * (k + 1); 
    C[0] = 1; # nC0 is 1 
    for i in range(1,n + 1):  
        for j in range(min(i, k),0,-1): 
            C[j] = C[j] + C[j - 1]; 
    return C[k]; 
def sum_Of_product(n):

    assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
    assert n >= 0, "invalid inputs" # $_CONTRACT_$
 
    return binomial_Coeff(2 * n, n - 1); 


Contract List:
assert_0: assert isinstance(n, int), "invalid inputs
assert_1: assert n >= 0, "invalid inputs


<think>
I will translate the Python assertions into precise SMT predicates over the Value ADT, introduce a `SafeI` helper for guarded integer extraction, assert the minimal structure for executability, and define each contract as a standalone Boolean.
</think>
```json
{
  "helper_functions": "(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
  "basic_structure": "(assert (is-IntVal n))",
  "inputs": "(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
    "assert_1": "(define-fun C1 () Bool (and C0 (>= (SafeI n) 0)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/593

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: removezero_ip
Problem Description:
"""
Write a function to remove leading zeroes from an ip address.
assert removezero_ip("216.08.094.196")==('216.8.94.196')
"""


import re
def removezero_ip(ip):

 assert isinstance(ip, str), "invalid inputs" # $_CONTRACT_$
 assert len(ip) > 0, "invalid inputs" # $_CONTRACT_$
 return re.sub('\.[0]*', '.', ip)


Contract List:
assert_0: assert isinstance(ip, str), "invalid inputs
assert_1: assert len(ip) > 0, "invalid inputs


<think>
I translate the Python assertions into precise SMT predicates, introduce a SafeS helper to extract strings safely, and assert the basic structure for executability. Contract predicates C0 and C1 mirror the isinstance and non-empty checks, respectively.
</think>
```json
{
  "helper_functions": "(define-fun SafeS ((v Value)) String\n  (ite (is-StrVal v) (sval v) \"\"))",
  "basic_structure": "(assert (is-StrVal ip))",
  "inputs": "(declare-const ip Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-StrVal ip))",
    "assert_1": "(define-fun C1 () Bool (> (str.len (SafeS ip)) 0))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/594

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: diff_even_odd
Problem Description:
"""
Write a function to find the difference of the first even and first odd number of a given list.
assert diff_even_odd([1,3,5,7,4,1,6,8])==3
"""


def diff_even_odd(list1):

    assert isinstance(list1, list), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(i, int) for i in list1), "invalid inputs" # $_CONTRACT_$
    assert any(el%2==0 for el in list1), "invalid inputs" # $_CONTRACT_$
    assert any(el%2!=0 for el in list1), "invalid inputs" # $_CONTRACT_$
    first_even = next((el for el in list1 if el%2==0), -1)
    first_odd = next((el for el in list1 if el%2!=0), -1)
    return (first_even - first_odd)


Contract List:
assert_0: assert isinstance(list1, list), "invalid inputs
assert_1: assert all(isinstance(i, int) for i in list1), "invalid inputs
assert_2: assert any(el%2==0 for el in list1), "invalid inputs
assert_3: assert any(el%2!=0 for el in list1), "invalid inputs


<think>
I translated each Python assertion into a separate SMT predicate over a canonical Value ADT, added recursive helpers for list shape and element properties, and kept only the structural list‐shape check in the basic structure to ensure executability.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n    true\n    (ite (is-Cons v)\n      (IsList (tail v))\n      false)))\n\n(define-fun-rec all_ints ((v Value)) Bool\n  (ite (is-Nil v)\n    true\n    (ite (is-Cons v)\n      (let ((hd (head v)))\n        (and (is-IntVal hd)\n             (all_ints (tail v))))\n      false)))\n\n(define-fun-rec exists_even ((v Value)) Bool\n  (ite (is-Nil v)\n    false\n    (ite (is-Cons v)\n      (let ((hd (head v)))\n        (ite (and (is-IntVal hd)\n                  (= (mod (ival hd) 2) 0))\n             true\n             (exists_even (tail v))))\n      false)))\n\n(define-fun-rec exists_odd ((v Value)) Bool\n  (ite (is-Nil v)\n    false\n    (ite (is-Cons v)\n      (let ((hd (head v)))\n        (ite (and (is-IntVal hd)\n                  (not (= (mod (ival hd) 2) 0)))\n             true\n             (exists_odd (tail v))))\n      false)))",
  "basic_structure": "(assert (IsList list1))",
  "inputs": "(declare-const list1 Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList list1))",
    "assert_1": "(define-fun C1 () Bool (all_ints list1))",
    "assert_2": "(define-fun C2 () Bool (exists_even list1))",
    "assert_3": "(define-fun C3 () Bool (exists_odd list1))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/596

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: tuple_size
Problem Description:
"""
Write a function to find the size in bytes of the given tuple.
assert tuple_size(("A", 1, "B", 2, "C", 3) ) == sys.getsizeof(("A", 1, "B", 2, "C", 3))
"""


import sys 
def tuple_size(tuple_list):

  assert isinstance(tuple_list, tuple), "invalid inputs" # $_CONTRACT_$
  return sys.getsizeof(tuple_list)


Contract List:
assert_0: assert isinstance(tuple_list, tuple), "invalid inputs


<think>
I model the Python tuple as our ADT list and capture “isinstance(tuple_list, tuple)” by requiring a proper list shape. I define a recursive IsList helper, declare the input, assert no extra invariants in BASIC_STRUCTURE, and translate the single contract into C0.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n    true\n    (ite (is-Cons v)\n      (IsList (tail v))\n      false)))",
  "basic_structure": "(assert true)",
  "inputs": "(declare-const tuple_list Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList tuple_list))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/597

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: find_kth
Problem Description:
"""
Write a function to find kth element from the given two sorted arrays.
assert find_kth([2, 3, 6, 7, 9], [1, 4, 8, 10], 5) == 6
"""


def find_kth(arr1, arr2, k):

	assert isinstance(arr1, list), "invalid inputs" # $_CONTRACT_$
	assert isinstance(arr2, list), "invalid inputs" # $_CONTRACT_$
	assert isinstance(k, int), "invalid inputs" # $_CONTRACT_$
	assert 0 < k <= len(arr1) + len(arr2), "invalid inputs" # $_CONTRACT_$j
	return sorted(arr1 + arr2)[k - 1]


Contract List:
assert_0: assert isinstance(arr1, list), "invalid inputs
assert_1: assert isinstance(arr2, list), "invalid inputs
assert_2: assert isinstance(k, int), "invalid inputs
assert_3: assert 0 < k <= len(arr1) + len(arr2), "invalid inputs" j


<think>
I will model the list executability constraints with recursive `define-fun-rec` helpers for `IsList` and `list_len`. The basic structure enforces that `arr1`, `arr2`, and `k` have the correct ADT shapes, and each Python `assert` is captured exactly as a standalone SMT predicate C0–C3.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v) true\n    (ite (is-Cons v) (IsList (tail v)) false)))\n(define-fun-rec list_len ((v Value)) Int\n  (ite (is-Nil v) 0\n    (ite (is-Cons v) (+ 1 (list_len (tail v))) 0)))",
  "basic_structure": "(assert (IsList arr1))\n(assert (IsList arr2))\n(assert (is-IntVal k))",
  "inputs": "(declare-const arr1 Value)\n(declare-const arr2 Value)\n(declare-const k Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList arr1))",
    "assert_1": "(define-fun C1 () Bool (IsList arr2))",
    "assert_2": "(define-fun C2 () Bool (is-IntVal k))",
    "assert_3": "(define-fun C3 () Bool (let ((ki (ite (is-IntVal k) (ival k) 0)) (l1 (list_len arr1)) (l2 (list_len arr2))) (and (< 0 ki) (<= ki (+ l1 l2)))))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/598

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: armstrong_number
Problem Description:
"""
Write a function to check whether the given number is armstrong or not.
assert armstrong_number(153)==True
"""


def armstrong_number(number):

    assert isinstance(number, int), "invalid inputs" # $_CONTRACT_$
    assert number > 0, "invalid inputs" # $_CONTRACT_$
    order = len(str(number))
    return sum([int(i) ** order for i in str(number)]) == number


Contract List:
assert_0: assert isinstance(number, int), "invalid inputs
assert_1: assert number > 0, "invalid inputs


<think>
I model the Python assertions as SMT Boolean predicates, guarding numeric selectors with type tests to ensure safety. No extra helpers or structure are needed for these simple input checks.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "",
  "inputs": "(declare-const number Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal number))",
    "assert_1": "(define-fun C1 () Bool (and (is-IntVal number) (> (ival number) 0)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/599

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: sum_average
Problem Description:
"""
Write a function to find sum and average of first n natural numbers.
assert sum_average(10)==(55, 5.5)
"""


def sum_average(number):

   assert isinstance(number, int), "invalid inputs" # $_CONTRACT_$
   assert number > 0, "invalid inputs" # $_CONTRACT_$
   sum_ = sum(range(1, number+1))
   average = sum_/number
   return sum_, average


Contract List:
assert_0: assert isinstance(number, int), "invalid inputs
assert_1: assert number > 0, "invalid inputs


<think>
I translated the Python input checks into SMT-LIB predicates over the canonical Value ADT, using `is-IntVal` to guard integer extraction and matching the original assertion semantics. No additional helpers or structural invariants are needed beyond ensuring the parameter is an integer and positive.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "",
  "inputs": "(declare-const number Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal number))",
    "assert_1": "(define-fun C1 () Bool (and C0 (> (ival number) 0)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/600

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: is_Even
Problem Description:
"""
Write a python function to check whether the given number is even or not.
assert is_Even(1) == False
"""


def is_Even(n) :

    assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
 
    return n % 2 == 0


Contract List:
assert_0: assert isinstance(n, int), "invalid inputs


<think>
I will model the single Python type-check assertion as an SMT predicate requiring that the input Value is constructed by the IntVal constructor. Since there are no lists or recursive structures involved, no extra helpers or basic-structure invariants beyond the ADT declaration are needed.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "",
  "inputs": "(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal n))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/602

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: first_repeated_char
Problem Description:
"""
Write a python function to find the first repeated character in a given string.
assert first_repeated_char("abcabc") == "a"
"""


def first_repeated_char(str1):

  assert isinstance(str1, str), "invalid inputs" # $_CONTRACT_$I
  for index, c in enumerate(str1):
    if str1[:index + 1].count(c) > 1:
      return c
  return None


Contract List:
assert_0: assert isinstance(str1, str), "invalid inputs" I


<think>
I map the Python isinstance check to an SMT tester ensuring the input is a string ADT and maintain only minimal structure constraints for executability.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "",
  "inputs": "(declare-const str1 Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-StrVal str1))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/603

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: get_ludic
Problem Description:
"""
Write a function to get all lucid numbers smaller than or equal to a given integer.
assert get_ludic(10) == [1, 2, 3, 5, 7]
"""


def get_ludic(n):

	assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
	assert n > 0, "invalid inputs" # $_CONTRACT_$
	ludics = []
	for i in range(1, n + 1):
		ludics.append(i)
	index = 1
	while(index != len(ludics)):
		first_ludic = ludics[index]
		remove_index = index + first_ludic
		while(remove_index < len(ludics)):
			ludics.remove(ludics[remove_index])
			remove_index = remove_index + first_ludic - 1
		index += 1
	return ludics


Contract List:
assert_0: assert isinstance(n, int), "invalid inputs
assert_1: assert n > 0, "invalid inputs


<think>
I translate Python input assertions into precise SMT predicates using a safe integer extractor (SafeI) to avoid selector errors, defining each contract as a standalone Boolean Ck, and declare the sole input n as a Value.
</think>
```json
{
  "helper_functions": "(define-fun SafeI ((v Value)) Int\n  (ite (is-IntVal v) (ival v) 0))",
  "basic_structure": "",
  "inputs": "(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
    "assert_1": "(define-fun C1 () Bool (> (SafeI n) 0))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/604

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: reverse_words
Problem Description:
"""
Write a function to reverse words seperated by spaces in a given string.
assert reverse_words("python program")==("program python")
"""


def reverse_words(s):

	assert isinstance(s, str), "invalid inputs" # $_CONTRACT_$
	return ' '.join(reversed(s.split()))


Contract List:
assert_0: assert isinstance(s, str), "invalid inputs


<think>
I translate the Python isinstance check into an SMT predicate C0 asserting that s is a StrVal, declare s as a Value, and since no list or numeric helpers are needed I leave helper functions and basic structure empty.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "",
  "inputs": "(declare-const s Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-StrVal s))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/605

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: prime_num
Problem Description:
"""
Write a function to check if the given integer is a prime number.
assert prime_num(13)==True
"""


import math
def prime_num(num):

  assert isinstance(num, int), "invalid inputs" # $_CONTRACT_$
  if num <= 1:
    return False
  for i in range(2, int(math.sqrt(num)) + 1):
    if num % i == 0:
      return False
  return True


Contract List:
assert_0: assert isinstance(num, int), "invalid inputs


<think>
I modeled the ADT extraction for integer values and implemented a tail-recursive primality check mirroring the Python loop. The type-check assertion is encoded as a standalone Boolean predicate `C0`, ensuring exact semantics of `isinstance(num, int)`.
</think>
```json
{
  "helper_functions": "(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))\n(define-fun-rec prime_helper ((n Int) (i Int)) Bool\n  (ite (> (* i i) n)\n       true\n       (ite (= (mod n i) 0)\n            false\n            (prime_helper n (+ i 1)))))\n(define-fun is_prime ((v Value)) Bool\n  (ite (is-IntVal v)\n       (let ((n (ival v)))\n         (ite (<= n 1)\n              false\n              (prime_helper n 2)))\n       false))",
  "basic_structure": "",
  "inputs": "(declare-const num Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal num))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/606

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: radian_degree
Problem Description:
"""
Write a function to convert degrees to radians.
assert radian_degree(90)==1.5707963267948966
"""


import math
def radian_degree(degree):

    assert isinstance(degree, int), "invalid inputs" # $_CONTRACT_$
    return degree * math.pi / 180


Contract List:
assert_0: assert isinstance(degree, int), "invalid inputs


<think>
I map the Python isinstance check to an SMT predicate requiring the input to be an IntVal, declare the degree input, and rely on the ADT declaration for executability. Then I define C0 to match the assertion semantics.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "",
  "inputs": "(declare-const degree Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal degree))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/607

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: find_literals
Problem Description:
"""
Write a function to search a string for a regex pattern. The function should return the matching subtring, a start index and an end index.
assert find_literals('The quick brown fox jumps over the lazy dog.', 'fox') == ('fox', 16, 19)
"""


import re
def find_literals(text, pattern):

  assert isinstance(text, str), "invalid inputs" # $_CONTRACT_$
  assert isinstance(pattern, str), "invalid inputs" # $_CONTRACT_$
  match = re.search(pattern, text)
  if match is None:
    return None
  s = match.start()
  e = match.end()
  return (match.re.pattern, s, e)


Contract List:
assert_0: assert isinstance(text, str), "invalid inputs
assert_1: assert isinstance(pattern, str), "invalid inputs


<think>
I translated each Python isinstance assertion into a corresponding SMT tester predicate using is-StrVal on the ADT. No additional helper functions or basic structure invariants are needed since only string types are validated.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "",
  "inputs": "(declare-const text Value)\n(declare-const pattern Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-StrVal text))",
    "assert_1": "(define-fun C1 () Bool (is-StrVal pattern))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/608

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: bell_Number
Problem Description:
"""
Write a python function to find nth bell number.
assert bell_Number(2) == 2
"""


def bell_Number(n):

    assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
    assert n >= 0, "invalid inputs" # $_CONTRACT_$
 
    bell = [[0 for i in range(n+1)] for j in range(n+1)] 
    bell[0][0] = 1
    for i in range(1, n+1):
        bell[i][0] = bell[i-1][i-1]
        for j in range(1, i+1): 
            bell[i][j] = bell[i-1][j-1] + bell[i][j-1] 
    return bell[n][0] 


Contract List:
assert_0: assert isinstance(n, int), "invalid inputs
assert_1: assert n >= 0, "invalid inputs


<think>
I will translate the Python asserts into SMT predicates by introducing a SafeInt extractor for Value, guard all integer operations, and define each contract as a standalone Bool reflecting the original assertion semantics.
</think>
```json
{
  "helper_functions": "(define-fun SafeInt ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
  "basic_structure": "",
  "inputs": "(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
    "assert_1": "(define-fun C1 () Bool (and (is-IntVal n) (>= (SafeInt n) 0)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/610

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: remove_kth_element
Problem Description:
"""
Write a python function which takes a list and returns a list with the same elements, but the k'th element removed.
assert remove_kth_element([1,1,2,3,4,4,5,1],3)==[1, 1, 3, 4, 4, 5, 1]
"""


def remove_kth_element(list1, k):

    assert isinstance(list1, list), "invalid inputs" # $_CONTRACT_$
    assert isinstance(k, int), "invalid inputs" # $_CONTRACT_$
    assert 0 < k <= len(list1), "invalid inputs" # $_CONTRACT_$
    return list1[:k-1] + list1[k:]


Contract List:
assert_0: assert isinstance(list1, list), "invalid inputs
assert_1: assert isinstance(k, int), "invalid inputs
assert_2: assert 0 < k <= len(list1), "invalid inputs


<think>
I translate the Python assertions into precise SMT predicates, define safe ADT helpers for lists and integers, and separate execution invariants from the contracts C0–C2.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (IsList (tail l))\n            false)))\n\n(define-fun-rec list_length ((l Value)) Int\n  (ite (is-Nil l)\n       0\n       (ite (is-Cons l)\n            (+ 1 (list_length (tail l)))\n            0)))\n\n(define-fun get_int ((v Value)) Int\n  (ite (is-IntVal v) (ival v) 0))",
  "basic_structure": "(assert (IsList list1))",
  "inputs": "(declare-const list1 Value)\n(declare-const k Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList list1))",
    "assert_1": "(define-fun C1 () Bool (is-IntVal k))",
    "assert_2": "(define-fun C2 () Bool (and (> (get_int k) 0) (<= (get_int k) (list_length list1))))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/611

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: max_of_nth
Problem Description:
"""
Write a function which given a matrix represented as a list of lists returns the max of the n'th column.
assert max_of_nth([[5, 6, 7], [1, 3, 5], [8, 9, 19]], 2) == 19
"""


def max_of_nth(test_list, N):

  assert isinstance(test_list, list), "invalid inputs" # $_CONTRACT_$
  assert len(test_list) > 0, "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(row, list) for row in test_list), "invalid inputs" # $_CONTRACT_$
  assert len(test_list[0]) > 0, "invalid inputs" # $_CONTRACT_$
  assert all(len(row) == len(test_list[0]) for row in test_list), "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(item, (int, float)) for row in test_list for item in row), "invalid inputs" # $_CONTRACT_$
  assert N < len(test_list[0]), "invalid inputs" # $_CONTRACT_$
  return max([sub[N] for sub in test_list])


Contract List:
assert_0: assert isinstance(test_list, list), "invalid inputs
assert_1: assert len(test_list) > 0, "invalid inputs
assert_2: assert all(isinstance(row, list) for row in test_list), "invalid inputs
assert_3: assert len(test_list[0]) > 0, "invalid inputs
assert_4: assert all(len(row) == len(test_list[0]) for row in test_list), "invalid inputs
assert_5: assert all(isinstance(item, (int, float)) for row in test_list for item in row), "invalid inputs
assert_6: assert N < len(test_list[0]), "invalid inputs


<think>
I translate each Python assert into an SMT predicate using ADT-based list and numeric helpers, ensuring safe selector use via `safe_*` and recursive helpers for list structure, numeric checks, and row-length consistency.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v) true\n    (ite (is-Cons v)\n         (IsList (tail v))\n         false)))\n\n(define-fun safe_head ((v Value)) Value\n  (ite (is-Cons v)\n       (head v)\n       Nil))\n\n(define-fun safe_tail ((v Value)) Value\n  (ite (is-Cons v)\n       (tail v)\n       Nil))\n\n(define-fun safe_ival ((v Value)) Int\n  (ite (is-IntVal v)\n       (ival v)\n       0))\n\n(define-fun-rec length ((v Value)) Int\n  (ite (is-Nil v) 0\n    (ite (is-Cons v)\n         (+ 1 (length (tail v)))\n         0)))\n\n(define-fun-rec list_all_numeric ((v Value)) Bool\n  (ite (is-Cons v)\n       (and (or (is-IntVal (head v)) (is-FloatVal (head v)))\n            (list_all_numeric (tail v)))\n       true))\n\n(define-fun-rec matrix_all_numeric ((m Value)) Bool\n  (ite (is-Cons m)\n       (and (list_all_numeric (safe_head m))\n            (matrix_all_numeric (safe_tail m)))\n       true))\n\n(define-fun-rec all_rows_are_list ((m Value)) Bool\n  (ite (is-Cons m)\n       (and (IsList (head m))\n            (all_rows_are_list (tail m)))\n       true))\n\n(define-fun-rec all_rows_len_equal ((m Value) (len0 Int)) Bool\n  (ite (is-Cons m)\n       (and (= (length (safe_head m)) len0)\n            (all_rows_len_equal (safe_tail m) len0))\n       true))",
  "basic_structure": "(assert (IsList test_list))",
  "inputs": "(declare-const test_list Value)\n(declare-const N Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList test_list))",
    "assert_1": "(define-fun C1 () Bool (> (length test_list) 0))",
    "assert_2": "(define-fun C2 () Bool (all_rows_are_list test_list))",
    "assert_3": "(define-fun C3 () Bool (> (length (safe_head test_list)) 0))",
    "assert_4": "(define-fun C4 () Bool (let ((len0 (length (safe_head test_list)))) (all_rows_len_equal test_list len0)))",
    "assert_5": "(define-fun C5 () Bool (matrix_all_numeric test_list))",
    "assert_6": "(define-fun C6 () Bool (< (safe_ival N) (length (safe_head test_list))))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/612

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: merge
Problem Description:
"""
Write a python function which takes a list of lists, where each sublist has two elements, and returns a list of two lists where the first list has the first element of each sublist and the second one has the second.
assert merge([['x', 'y'], ['a', 'b'], ['m', 'n']]) == [['x', 'a', 'm'], ['y', 'b', 'n']]
"""


def merge(lst):

    assert isinstance(lst, list), "invalid inputs" # $_CONTRACT_$
    assert len(lst) > 0, "invalid inputs" # $_CONTRACT_$
    assert all(len(sublist) == 2 for sublist in lst), "invalid inputs" # $_CONTRACT_$
  
    return [list(ele) for ele in list(zip(*lst))] 


Contract List:
assert_0: assert isinstance(lst, list), "invalid inputs
assert_1: assert len(lst) > 0, "invalid inputs
assert_2: assert all(len(sublist) == 2 for sublist in lst), "invalid inputs


<think>
I will define recursive helpers for list structure and length to model Python’s list semantics, then translate each assertion into a guarded SMT predicate ensuring safe use of ADT selectors.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n    (or (is-Nil v)\n        (and (is-Cons v)\n             (IsList (tail v)))))\n\n(define-fun-rec length ((v Value)) Int\n    (ite (is-Nil v) 0\n         (ite (is-Cons v) (+ 1 (length (tail v)))\n              0)))\n\n(define-fun-rec list_all_size2 ((v Value)) Bool\n    (ite (is-Nil v) true\n         (ite (is-Cons v)\n              (let ((sub (head v)))\n                (and (IsList sub)\n                     (= (length sub) 2)\n                     (list_all_size2 (tail v))))\n              true)))",
  "basic_structure": "(assert (IsList lst))",
  "inputs": "(declare-const lst Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList lst))",
    "assert_1": "(define-fun C1 () Bool (and (IsList lst) (> (length lst) 0)))",
    "assert_2": "(define-fun C2 () Bool (and (IsList lst) (list_all_size2 lst)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/614

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: cummulative_sum
Problem Description:
"""
Write a function to find the cumulative sum of all the values that are present in the given tuple list.
assert cummulative_sum([(1, 3), (5, 6, 7), (2, 6)]) == 30
"""


def cummulative_sum(test_list):

  assert isinstance(test_list, list), "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(el, tuple) for el in test_list), "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(el, (int, float)) for el in sum(test_list, ())), "invalid inputs" # $_CONTRACT_$
  return sum(map(sum, test_list))


Contract List:
assert_0: assert isinstance(test_list, list), "invalid inputs
assert_1: assert all(isinstance(el, tuple) for el in test_list), "invalid inputs
assert_2: assert all(isinstance(el, (int, float)) for el in sum(test_list, ())), "invalid inputs


< якщо I will analyze the Python assertions and translate them into precise SMT-LIB predicates while ensuring the ADT supports tuples and lists, then define helper functions for list/tuple shape, flattening, and numeric checks. Finally, I’ll create C0–C2 matching each assert, short-circuiting C2 under its precondition. >

```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (or (is-Nil v)\n      (and (is-Cons v)\n           (IsList (tail v)))))\n\n(define-fun-rec all_is_tuple ((lst Value)) Bool\n  (ite (is-Nil lst)\n       true\n       (and (is-Cons lst)\n            (let ((h (head lst))\n                  (t (tail lst)))\n              (and (is-TupleVal h)\n                   (all_is_tuple t))))))\n\n(define-fun-rec concatenate ((t1 Value) (t2 Value)) Value\n  (ite (is-Nil t1)\n       t2\n       (let ((h (head t1))\n             (r (tail t1)))\n         (Cons h (concatenate r t2)))))\n\n(define-fun-rec flatten ((lst Value)) Value\n  (ite (is-Nil lst)\n       (TupleVal Nil)\n       (let ((h (head lst))\n             (t (tail lst)))\n         (let ((rest-flat (flatten t)))\n           (let ((elts1 (elts h))\n                 (elts2 (elts rest-flat)))\n             (TupleVal (concatenate elts1 elts2)))))))\n\n(define-fun-rec list_all_numeric ((lst Value)) Bool\n  (ite (is-Nil lst)\n       true\n       (and (is-Cons lst)\n            (let ((h (head lst))\n                  (t (tail lst)))\n              (and (or (is-IntVal h)\n                       (is-FloatVal h))\n                   (list_all_numeric t))))))",
  "basic_structure": "(assert (IsList test_list))",
  "inputs": "(declare-const test_list Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool\n  (IsList test_list))",
    "assert_1": "(define-fun C1 () Bool\n  (all_is_tuple test_list))",
    "assert_2": "(define-fun C2 () Bool\n  (ite C1\n       (let ((flat (flatten test_list)))\n         (list_all_numeric (elts flat)))\n       false))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/615

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: average_tuple
Problem Description:
"""
Write a function which takes a tuple of tuples and returns the average value for each tuple as a list.
assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
"""


def average_tuple(nums):

    assert isinstance(nums, tuple), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(x, tuple) for x in nums), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(x, (int, float)) for x in sum(nums, ())), "invalid inputs" # $_CONTRACT_$
    result = [sum(x) / len(x) for x in zip(*nums)]
    return result


Contract List:
assert_0: assert isinstance(nums, tuple), "invalid inputs
assert_1: assert all(isinstance(x, tuple) for x in nums), "invalid inputs
assert_2: assert all(isinstance(x, (int, float)) for x in sum(nums, ())), "invalid inputs


<think>
I will translate the Python tuple‐of‐tuples and numeric assertions into SMT helper functions modeling lists and numbers, declare the single input, assert minimal list structure for executability, and encode each Python `assert` as a named predicate C0, C1, C2 using those helpers.
</think>
```json
{
  "helper_functions": "(define-fun IsList ((v Value)) Bool\n  (or (is-Nil v) (is-Cons v)))\n\n(define-fun-rec list_all_list ((lst Value)) Bool\n  (ite (is-Nil lst)\n       true\n       (ite (is-Cons lst)\n            (let ((hd (head lst)) (tl (tail lst)))\n              (and (IsList hd) (list_all_list tl)))\n            false)))\n\n(define-fun-rec append ((a Value) (b Value)) Value\n  (ite (is-Nil a)\n       b\n       (let ((hdA (head a)) (tlA (tail a)))\n         (Cons hdA (append tlA b)))))\n\n(define-fun-rec flatten ((lst Value)) Value\n  (ite (is-Nil lst)\n       lst\n       (let ((hd (head lst)) (tl (tail lst)))\n         (append hd (flatten tl)))))\n\n(define-fun-rec list_all_numeric ((lst Value)) Bool\n  (ite (is-Nil lst)\n       true\n       (ite (is-Cons lst)\n            (let ((hd (head lst)) (tl (tail lst)))\n              (and (or (is-IntVal hd) (is-FloatVal hd))\n                   (list_all_numeric tl)))\n            false)))",
  "basic_structure": "(assert (IsList nums))",
  "inputs": "(declare-const nums Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList nums))",
    "assert_1": "(define-fun C1 () Bool (list_all_list nums))",
    "assert_2": "(define-fun C2 () Bool (list_all_numeric (flatten nums)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/616

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: tuple_modulo
Problem Description:
"""
Write a function which takes two tuples of the same length and performs the element wise modulo.
assert tuple_modulo((10, 4, 5, 6), (5, 6, 7, 5)) == (0, 4, 5, 1)
"""


def tuple_modulo(test_tup1, test_tup2):

  assert isinstance(test_tup1, tuple), "invalid inputs" # $_CONTRACT_$
  assert isinstance(test_tup2, tuple), "invalid inputs" # $_CONTRACT_$
  assert len(test_tup1) == len(test_tup2), "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(x, int) for x in test_tup1 + test_tup2), "invalid inputs" # $_CONTRACT_$
  assert all(x > 0 for x in test_tup2), "invalid inputs" # $_CONTRACT_$
  res = tuple(ele1 % ele2 for ele1, ele2 in zip(test_tup1, test_tup2)) 
  return (res) 


Contract List:
assert_0: assert isinstance(test_tup1, tuple), "invalid inputs
assert_1: assert isinstance(test_tup2, tuple), "invalid inputs
assert_2: assert len(test_tup1) == len(test_tup2), "invalid inputs
assert_3: assert all(isinstance(x, int) for x in test_tup1 + test_tup2), "invalid inputs
assert_4: assert all(x > 0 for x in test_tup2), "invalid inputs


<think>
I will translate each Python assertion into precise SMT predicates over a canonical list ADT, define recursive helpers for list structure, length, type checking, and positivity, and assemble the inputs, basic structure checks, and contract definitions in a reusable template.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((lst Value)) Bool\n  (ite (is-Nil lst) true\n    (ite (is-Cons lst) (IsList (tail lst)) false)))\n\n(define-fun-rec list_length ((lst Value)) Int\n  (ite (is-Nil lst) 0\n    (ite (is-Cons lst) (+ 1 (list_length (tail lst))) 0)))\n\n(define-fun-rec list_all_int ((lst Value)) Bool\n  (ite (is-Nil lst) true\n    (ite (is-Cons lst)\n      (and (is-IntVal (head lst)) (list_all_int (tail lst))) false)))\n\n(define-fun-rec list_all_positive ((lst Value)) Bool\n  (ite (is-Nil lst) true\n    (ite (is-Cons lst)\n      (and (is-IntVal (head lst)) (> (ival (head lst)) 0) (list_all_positive (tail lst))) false)))",
  "basic_structure": "(assert (IsList test_tup1))\n(assert (IsList test_tup2))",
  "inputs": "(declare-const test_tup1 Value)\n(declare-const test_tup2 Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList test_tup1))",
    "assert_1": "(define-fun C1 () Bool (IsList test_tup2))",
    "assert_2": "(define-fun C2 () Bool (= (list_length test_tup1) (list_length test_tup2)))",
    "assert_3": "(define-fun C3 () Bool (and (list_all_int test_tup1) (list_all_int test_tup2)))",
    "assert_4": "(define-fun C4 () Bool (list_all_positive test_tup2))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/618

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: div_list
Problem Description:
"""
Write a function to divide two lists element wise.
assert div_list([4,5,6],[1, 2, 3])==[4.0,2.5,2.0]
"""


def div_list(nums1,nums2):

  assert isinstance(nums1, list), "invalid inputs" # $_CONTRACT_$
  assert isinstance(nums2, list), "invalid inputs" # $_CONTRACT_$
  assert len(nums1) > 0, "invalid inputs" # $_CONTRACT_$
  assert len(nums2) > 0, "invalid inputs" # $_CONTRACT_$
  assert len(nums1) == len(nums2), "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(x, (int, float)) for x in nums1 + nums2), "invalid inputs" # $_CONTRACT_$
  assert all(x != 0 for x in nums2), "invalid inputs" # $_CONTRACT_$
  result = map(lambda x, y: x / y, nums1, nums2)
  return list(result)


Contract List:
assert_0: assert isinstance(nums1, list), "invalid inputs
assert_1: assert isinstance(nums2, list), "invalid inputs
assert_2: assert len(nums1) > 0, "invalid inputs
assert_3: assert len(nums2) > 0, "invalid inputs
assert_4: assert len(nums1) == len(nums2), "invalid inputs
assert_5: assert all(isinstance(x, (int, float)) for x in nums1 + nums2), "invalid inputs
assert_6: assert all(x != 0 for x in nums2), "invalid inputs


<think>
I translated each Python assert into precise SMT predicates (C0–C6) and defined recursive helpers (IsList, length, list_all_numeric, list_all_non_zero) ensuring safe ADT destructuring. The basic structure asserts only the necessary list‐shape invariants for nums1 and nums2.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v) true\n    (ite (is-Cons v)\n      (let ((t (tail v)))\n        (IsList t))\n      false)))\n\n(define-fun-rec length ((l Value)) Int\n  (ite (is-Nil l) 0\n    (ite (is-Cons l)\n      (let ((t (tail l)))\n        (+ 1 (length t)))\n      0)))\n\n(define-fun-rec list_all_numeric ((l Value)) Bool\n  (ite (is-Nil l) true\n    (ite (is-Cons l)\n      (let ((h (head l)) (t (tail l)))\n        (and (or (is-IntVal h) (is-FloatVal h))\n             (list_all_numeric t)))\n      false)))\n\n(define-fun-rec list_all_non_zero ((l Value)) Bool\n  (ite (is-Nil l) true\n    (ite (is-Cons l)\n      (let ((h (head l)) (t (tail l)))\n        (and\n          (ite (is-IntVal h)\n               (distinct (ival h) 0)\n               (ite (is-FloatVal h)\n                    (distinct (fval h) 0.0)\n                    false))\n          (list_all_non_zero t)))\n      false)))",
  "basic_structure": "(assert (IsList nums1))\n(assert (IsList nums2))",
  "inputs": "(declare-const nums1 Value)\n(declare-const nums2 Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList nums1))",
    "assert_1": "(define-fun C1 () Bool (IsList nums2))",
    "assert_2": "(define-fun C2 () Bool (> (length nums1) 0))",
    "assert_3": "(define-fun C3 () Bool (> (length nums2) 0))",
    "assert_4": "(define-fun C4 () Bool (= (length nums1) (length nums2)))",
    "assert_5": "(define-fun C5 () Bool (and (list_all_numeric nums1) (list_all_numeric nums2)))",
    "assert_6": "(define-fun C6 () Bool (list_all_non_zero nums2))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/619

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: move_num
Problem Description:
"""
Write a function to move all the numbers to the end of the given string.
assert move_num('I1love143you55three3000thousand') == 'Iloveyouthreethousand1143553000'
"""


def move_num(test_str):

  assert isinstance(test_str, str), "invalid inputs" # $_CONTRACT_$
  num_str = ''.join(i for i in test_str if i.isdigit())
  else_str = ''.join(i for i in test_str if not i.isdigit())
  return else_str + num_str


Contract List:
assert_0: assert isinstance(test_str, str), "invalid inputs


<think>
I will translate the Python assertion into an SMT predicate ensuring the input is of StrVal shape, declare the input Value, and define the C0 predicate accordingly.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "",
  "inputs": "(declare-const test_str Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-StrVal test_str))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/620

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: largest_subset
Problem Description:
"""
Write a function to find the size of the largest subset of a list of numbers so that every pair is divisible.
assert largest_subset([ 1, 3, 6, 13, 17, 18 ]) == 4
"""


def largest_subset(a):

	assert isinstance(a, list), "invalid inputs" # $_CONTRACT_$
	assert len(a) >= 2, "invalid inputs" # $_CONTRACT_$
	assert all(isinstance(el, (int, float)) for el in a), "invalid inputs" # $_CONTRACT_$
	n = len(a)
	dp = [0 for _ in range(n)]
	dp[n - 1] = 1; 
	for i in range(n - 2, -1, -1):
		mxm = 0
		for j in range(i + 1, n):
			if a[j] % a[i] == 0 or a[i] % a[j] == 0:
				mxm = max(mxm, dp[j])
		dp[i] = 1 + mxm
	return max(dp)


Contract List:
assert_0: assert isinstance(a, list), "invalid inputs
assert_1: assert len(a) >= 2, "invalid inputs
assert_2: assert all(isinstance(el, (int, float)) for el in a), "invalid inputs


<think>
I will translate the Python input checks into precise SMT-LIB predicates, define the necessary recursive helpers for list shape, length, and numeric checks, and expose each assert as a standalone Boolean Ck while ensuring only the ADT shape invariant is enforced in the basic structure.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (IsList (tail l))\n            false)))\n\n(define-fun-rec length ((lst Value)) Int\n  (ite (is-Nil lst)\n       0\n       (ite (is-Cons lst)\n            (+ 1 (length (tail lst)))\n            0)))\n\n(define-fun-rec list_all_numeric ((lst Value)) Bool\n  (ite (is-Nil lst)\n       true\n       (ite (is-Cons lst)\n            (and (or (is-IntVal (head lst))\n                     (is-FloatVal (head lst)))\n                 (list_all_numeric (tail lst)))\n            false)))",
  "basic_structure": "(assert (IsList a))",
  "inputs": "(declare-const a Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList a))",
    "assert_1": "(define-fun C1 () Bool (>= (length a) 2))",
    "assert_2": "(define-fun C2 () Bool (list_all_numeric a))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/622

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: get_median
Problem Description:
"""
Write a function to find the median of two sorted lists of same size.
assert get_median([1, 12, 15, 26, 38], [2, 13, 17, 30, 45], 5) == 16.0
"""


def get_median(arr1, arr2, n):

  assert isinstance(arr1, list), "invalid inputs" # $_CONTRACT_$
  assert isinstance(arr2, list), "invalid inputs" # $_CONTRACT_$
  assert 0 <= n <= min(len(arr1), len(arr2)), "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(el, (int, float)) for el in arr1 + arr2), "invalid inputs" # $_CONTRACT_$
  assert all(x <= y for x, y in zip(arr1[0:n], arr1[1:n])), "invalid inputs" # $_CONTRACT_$
  assert all(x <= y for x, y in zip(arr2[0:n], arr2[1:n])), "invalid inputs" # $_CONTRACT_$
  i = 0
  j = 0
  m1 = -1
  m2 = -1
  count = 0
  while count < n + 1:
    count += 1
    if i == n:
      m1 = m2
      m2 = arr2[0]
      break
    elif j == n:
      m1 = m2
      m2 = arr1[0]
      break
    if arr1[i] <= arr2[j]:
      m1 = m2
      m2 = arr1[i]
      i += 1
    else:
      m1 = m2
      m2 = arr2[j]
      j += 1
  return (m1 + m2)/2


Contract List:
assert_0: assert isinstance(arr1, list), "invalid inputs
assert_1: assert isinstance(arr2, list), "invalid inputs
assert_2: assert 0 <= n <= min(len(arr1), len(arr2)), "invalid inputs
assert_3: assert all(isinstance(el, (int, float)) for el in arr1 + arr2), "invalid inputs
assert_4: assert all(x <= y for x, y in zip(arr1[0:n], arr1[1:n])), "invalid inputs
assert_5: assert all(x <= y for x, y in zip(arr2[0:n], arr2[1:n])), "invalid inputs


<think>
I will translate each Python assertion into a precise SMT-LIB predicate over the canonical Value ADT, define recursive helpers for list shape, length, numeric‐element checks, and sorted prefixes, and assert only the minimal structural invariants in the basic structure so that each contract Ck can be tested independently.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v) true\n       (ite (is-Cons v) (IsList (tail v)) false)))\n\n(define-fun-rec length ((l Value)) Int\n  (ite (is-Nil l) 0\n       (ite (is-Cons l) (+ 1 (length (tail l))) 0)))\n\n(define-fun SafeI ((v Value)) Int\n  (ite (is-IntVal v) (ival v) 0))\n\n(define-fun toReal ((v Value)) Real\n  (ite (is-IntVal v) (to_real (ival v))\n       (ite (is-FloatVal v) (fval v) 0.0)))\n\n(define-fun-rec list_all_numeric ((l Value)) Bool\n  (ite (is-Nil l) true\n       (ite (is-Cons l)\n            (let ((hd (head l)) (tl (tail l)))\n              (and (or (is-IntVal hd) (is-FloatVal hd))\n                   (list_all_numeric tl)))\n            false)))\n\n(define-fun-rec sorted_prefix ((l Value) (k Int)) Bool\n  (ite (<= k 1) true\n       (and (is-Cons l)\n            (let ((tl (tail l)))\n              (and (is-Cons tl)\n                   (let ((h (head l)) (h2 (head tl)))\n                     (<= (toReal h) (toReal h2)))))\n            (sorted_prefix tl (- k 1)))))",
  "basic_structure": "(assert (IsList arr1))\n(assert (IsList arr2))\n(assert (is-IntVal n))",
  "inputs": "(declare-const arr1 Value)\n(declare-const arr2 Value)\n(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList arr1))",
    "assert_1": "(define-fun C1 () Bool (IsList arr2))",
    "assert_2": "(define-fun C2 () Bool (and (is-IntVal n)\n                                   (<= 0 (ival n))\n                                   (<= (ival n) (length arr1))\n                                   (<= (ival n) (length arr2))))",
    "assert_3": "(define-fun C3 () Bool (and (list_all_numeric arr1)\n                                   (list_all_numeric arr2)))",
    "assert_4": "(define-fun C4 () Bool (sorted_prefix arr1 (SafeI n)))",
    "assert_5": "(define-fun C5 () Bool (sorted_prefix arr2 (SafeI n)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/623

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: nth_nums
Problem Description:
"""
Write a function to compute the n-th power of each number in a list.
assert nth_nums([1, 2, 3, 4, 5, 6, 7, 8, 9, 10],2)==[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
"""


def nth_nums(nums, n):

 assert isinstance(nums, list), "invalid inputs" # $_CONTRACT_$
 assert all(isinstance(el, (int, float)) for el in nums), "invalid inputs" # $_CONTRACT_$
 assert isinstance(n, (int, float)), "invalid inputs" # $_CONTRACT_$
 nth_nums = list(map(lambda x: x ** n, nums))
 return nth_nums


Contract List:
assert_0: assert isinstance(nums, list), "invalid inputs
assert_1: assert all(isinstance(el, (int, float)) for el in nums), "invalid inputs
assert_2: assert isinstance(n, (int, float)), "invalid inputs


<think>
I will translate the Python input assertions into precise SMT-LIB predicates, defining helper functions to validate list structure and numeric types while preserving program executability constraints.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec list_all_numeric ((lst Value)) Bool\n  (ite (is-Nil lst)\n       true\n       (ite (is-Cons lst)\n            (let ((h (head lst))\n                  (t (tail lst)))\n              (and (or (is-IntVal h)\n                       (is-FloatVal h))\n                   (list_all_numeric t)))\n            false)))",
  "basic_structure": "(assert (IsList nums))",
  "inputs": "(declare-const nums Value)\n(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList nums))",
    "assert_1": "(define-fun C1 () Bool (list_all_numeric nums))",
    "assert_2": "(define-fun C2 () Bool (or (is-IntVal n) (is-FloatVal n)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/624

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: is_upper
Problem Description:
"""
Write a python function to convert a given string to uppercase.
assert is_upper("person") =="PERSON"
"""


def is_upper(string):

  assert isinstance(string, str), "invalid inputs" # $_CONTRACT_$
  return string.upper()


Contract List:
assert_0: assert isinstance(string, str), "invalid inputs


<think>
I translate the Python type‐check into an SMT predicate C0 over our Value ADT, declare the input as Value, assert its StrVal shape in the basic structure to guarantee safe use of `sval`, and expose C0 for contract testing.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "(assert (is-StrVal string))",
  "inputs": "(declare-const string Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-StrVal string))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/626

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: triangle_area
Problem Description:
"""
Write a python function to find the area of the largest triangle that can be inscribed in a semicircle with a given radius.
assert triangle_area(-1) == None
"""


def triangle_area(r) :

    assert isinstance(r, (int, float)), "invalid inputs" # $_CONTRACT_$
  
    if r < 0 : 
        return None
    return r * r 


Contract List:
assert_0: assert isinstance(r, (int, float)), "invalid inputs


<think>
I model the input r as a generic Value, introduce helpers to identify and extract numeric values, and translate the isinstance check into an SMT predicate C0 that requires r to be either IntVal or FloatVal.
</think>
```json
{
  "helper_functions": "(define-fun is-NumericVal ((v Value)) Bool\n  (or (is-IntVal v) (is-FloatVal v)))\n\n(define-fun toReal ((v Value)) Real\n  (ite (is-IntVal v) (to_real (ival v)) (fval v)))",
  "basic_structure": "",
  "inputs": "(declare-const r Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool\n  (or (is-IntVal r) (is-FloatVal r)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/628

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: replace_spaces
Problem Description:
"""
Write a function to replace all spaces in the given string with '%20'.
assert replace_spaces("My Name is Dawood") == 'My%20Name%20is%20Dawood'
"""


def replace_spaces(string):

  assert isinstance(string, str), "invalid inputs" # $_CONTRACT_$
  return string.replace(" ", "%20")


Contract List:
assert_0: assert isinstance(string, str), "invalid inputs


<think>
I will translate the single Python type‐check assertion into an SMT predicate ensuring the input is a StrVal in the ADT while keeping the template minimal and executable.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "",
  "inputs": "(declare-const string Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-StrVal string))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/629

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: Split
Problem Description:
"""
Write a python function to find even numbers from a list of numbers.
assert Split([1,2,3,4,5]) == [2,4]
"""


def Split(l):

    assert isinstance(l, list), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(x, int) for x in l), "invalid inputs" # $_CONTRACT_$
 
    return [num for num in l if num % 2 == 0]


Contract List:
assert_0: assert isinstance(l, list), "invalid inputs
assert_1: assert all(isinstance(x, int) for x in l), "invalid inputs


<think>
I define recursive predicates isList and list_all_int to capture the Python isinstance and all-int checks, declare the input, assert the list shape for executability, and then map each assertion to a Boolean contract predicate C0 and C1.
</think>
```json
{
  "helper_functions": "(define-fun-rec isList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (isList (tail v))\n            false)))\n\n(define-fun-rec list_all_int ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (is-IntVal (head v)) (list_all_int (tail v)))\n            false)))",
  "basic_structure": "(assert (isList l))",
  "inputs": "(declare-const l Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (isList l))",
    "assert_1": "(define-fun C1 () Bool (list_all_int l))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/630

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: get_coordinates
Problem Description:
"""
Write a function to extract all the adjacent coordinates of the given coordinate tuple.
assert get_coordinates((3, 4)) == [[2, 3], [2, 4], [2, 5], [3, 3], [3, 4], [3, 5], [4, 3], [4, 4], [4, 5]]
"""


def adjac(ele, sub = []): 
  if not ele: 
     yield sub 
  else: 
     yield from [idx for j in range(ele[0] - 1, ele[0] + 2) 
                for idx in adjac(ele[1:], sub + [j])] 
def get_coordinates(test_tup):

  assert isinstance(test_tup, tuple), "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(x, int) for x in test_tup), "invalid inputs" # $_CONTRACT_$
  return list(adjac(test_tup))


Contract List:
assert_0: assert isinstance(test_tup, tuple), "invalid inputs
assert_1: assert all(isinstance(x, int) for x in test_tup), "invalid inputs


<think>
I map the Python tuple to a simple list‐ADT and define recursive predicates to check list structure and integer elements. I then declare the input, assert minimal structural invariants for safe recursion, and translate each Python assertion into a named SMT‐LIB predicate.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec Length ((v Value)) Int\n  (ite (is-Nil v)\n       0\n       (+ 1 (Length (tail v)))))\n\n(define-fun-rec AllInt ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (is-IntVal (head v))\n                 (AllInt (tail v)))\n            false)))",
  "basic_structure": "(assert (IsList test_tup))\n(assert (> (Length test_tup) 0))",
  "inputs": "(declare-const test_tup Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool\n  (IsList test_tup))",
    "assert_1": "(define-fun C1 () Bool\n  (AllInt test_tup))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/631

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: replace_spaces
Problem Description:
"""
Write a function to replace whitespaces with an underscore and vice versa in a given string.
assert replace_spaces('Jumanji The Jungle') == 'Jumanji_The_Jungle'
"""


def replace_spaces(text):

  assert isinstance(text, str), "invalid inputs" # $_CONTRACT_$
  return "".join(" " if c == "_" else ("_" if c == " " else c) for c in text)


Contract List:
assert_0: assert isinstance(text, str), "invalid inputs


<think>
I translated the Python type-assertion into an SMT predicate, declared the input ADT, added a SafeS helper for string extraction, and defined both basic-execution requirements and the contract C0 for `isinstance(text, str)`.
</think>
```json
{
  "helper_functions": "(define-fun SafeS ((v Value)) String (ite (is-StrVal v) (sval v) \"\"))",
  "basic_structure": "(assert (is-StrVal text))",
  "inputs": "(declare-const text Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-StrVal text))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/632

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: move_zero
Problem Description:
"""
Write a python function to move all zeroes to the end of the given list.
assert move_zero([1,0,2,0,3,4]) == [1,2,3,4,0,0]
"""


def move_zero(num_list):

    assert isinstance(num_list, list), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(x, (int, float)) for x in num_list), "invalid inputs" # $_CONTRACT_$
    zeros = [0] * num_list.count(0)
    front = [i for i in num_list if i != 0]
    return front + zeros


Contract List:
assert_0: assert isinstance(num_list, list), "invalid inputs
assert_1: assert all(isinstance(x, (int, float)) for x in num_list), "invalid inputs


<think>
I model the list and numeric constraints as recursive SMT predicates over the Value ADT to ensure both structural validity and type checking. C0 checks list shape while C1 ensures all elements are integers or reals.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n    true\n    (ite (is-Cons v)\n      (IsList (tail v))\n      false)))\n(define-fun-rec list_all_numeric ((v Value)) Bool\n  (ite (is-Nil v)\n    true\n    (ite (is-Cons v)\n      (let ((headVal (head v)) (tailVal (tail v)))\n        (and\n          (or (is-IntVal headVal) (is-FloatVal headVal))\n          (list_all_numeric tailVal)))\n      false)))",
  "basic_structure": "(assert (IsList num_list))",
  "inputs": "(declare-const num_list Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList num_list))",
    "assert_1": "(define-fun C1 () Bool (list_all_numeric num_list))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/633

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: pair_xor_Sum
Problem Description:
"""
Write a python function to find the sum of xor of all pairs of numbers in the given list.
assert pair_xor_Sum([5,9,7,6],4) == 47
"""


def pair_xor_Sum(arr,n) :

    assert isinstance(arr, list), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(x, (int, float)) for x in arr), "invalid inputs" # $_CONTRACT_$
    assert n <= len(arr), "invalid inputs" # $_CONTRACT_$
 
    ans = 0 
    for i in range(0,n) :    
        for j in range(i + 1,n) :   
            ans = ans + (arr[i] ^ arr[j])          
    return ans 


Contract List:
assert_0: assert isinstance(arr, list), "invalid inputs
assert_1: assert all(isinstance(x, (int, float)) for x in arr), "invalid inputs
assert_2: assert n <= len(arr), "invalid inputs


<think>
I translate the Python assertions into corresponding SMT-LIB predicates and add recursive definitions for list structure, length, and numeric element checks, ensuring safe selectors and correct ADT usage for executability.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (let ((t (tail v)))\n              (IsList t))\n            false)))\n\n(define-fun-rec length ((v Value)) Int\n  (ite (is-Nil v)\n       0\n       (ite (is-Cons v)\n            (let ((t (tail v)))\n              (+ 1 (length t)))\n            0)))\n\n(define-fun SafeI ((v Value)) Int\n  (ite (is-IntVal v)\n       (ival v)\n       0))\n\n(define-fun-rec list_all_numeric ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (let ((h (head v)) (t (tail v)))\n              (and (or (is-IntVal h) (is-FloatVal h))\n                   (list_all_numeric t)))\n            false)))",
  "basic_structure": "(assert (IsList arr))\n(assert (is-IntVal n))",
  "inputs": "(declare-const arr Value)\n(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList arr))",
    "assert_1": "(define-fun C1 () Bool (list_all_numeric arr))",
    "assert_2": "(define-fun C2 () Bool (<= (SafeI n) (length arr)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/635

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: heap_sort
Problem Description:
"""
Write a function to sort the given list.
assert heap_sort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0])==[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
"""


import heapq as hq
def heap_sort(iterable):

    assert isinstance(iterable, list), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(x, (int, float)) for x in iterable), "invalid inputs" # $_CONTRACT_$
    hq.heapify(iterable)
    return [hq.heappop(iterable) for _ in range(len(iterable))]


Contract List:
assert_0: assert isinstance(iterable, list), "invalid inputs
assert_1: assert all(isinstance(x, (int, float)) for x in iterable), "invalid inputs


<think>
I will model the Python list and numeric‐type contracts as SMT predicates by defining a recursive IsList and list_all_numeric over our Value ADT. Then I declare the input, assert the minimal structure for executability, and map each Python assertion to a named contract predicate C0 and C1.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (or (is-Nil v)\n      (and (is-Cons v)\n           (let ((head_val (head v))\n                 (tail_val (tail v)))\n             (IsList tail_val)))))\n\n(define-fun-rec list_all_numeric ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (let ((head_val (head v))\n                  (tail_val (tail v)))\n              (and (or (is-IntVal head_val)\n                       (is-FloatVal head_val))\n                   (list_all_numeric tail_val)))\n            false)))",
  "basic_structure": "(assert (IsList iterable))",
  "inputs": "(declare-const iterable Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList iterable))",
    "assert_1": "(define-fun C1 () Bool (list_all_numeric iterable))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/637

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: noprofit_noloss
Problem Description:
"""
Write a function to check whether the given amount has no profit and no loss
assert noprofit_noloss(1500,1200)==False
"""


def noprofit_noloss(actual_cost, sale_amount):

  assert isinstance(actual_cost, (int, float)), "invalid inputs" # $_CONTRACT_$
  assert isinstance(sale_amount, (int, float)), "invalid inputs" # $_CONTRACT_$
 
  return actual_cost == sale_amount


Contract List:
assert_0: assert isinstance(actual_cost, (int, float)), "invalid inputs
assert_1: assert isinstance(sale_amount, (int, float)), "invalid inputs


<think>
I translated the Python isinstance assertions into precise SMT-LIB predicates by defining an is-number helper over the ADT and modeling each contract as a named Boolean (C0, C1), while keeping the basic structure minimal to ensure executability.
</think>
```json
{
  "helper_functions": "(define-fun is-number ((v Value)) Bool (or (is-IntVal v) (is-FloatVal v)))",
  "basic_structure": "",
  "inputs": "(declare-const actual_cost Value)\n(declare-const sale_amount Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-number actual_cost))",
    "assert_1": "(define-fun C1 () Bool (is-number sale_amount))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/638

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: wind_chill
Problem Description:
"""
Write a function to calculate the wind chill index rounded to the next integer given the wind velocity in km/h and a temperature in celsius.
assert wind_chill(120,35)==40
"""


import math
def wind_chill(v,t):

 assert isinstance(v, (int, float)), "invalid inputs" # $_CONTRACT_$
 assert isinstance(t, (int, float)), "invalid inputs" # $_CONTRACT_$
 windchill = 13.12 + 0.6215*t -  11.37*math.pow(v, 0.16) + 0.3965*t*math.pow(v, 0.16)
 return int(round(windchill, 0))


Contract List:
assert_0: assert isinstance(v, (int, float)), "invalid inputs
assert_1: assert isinstance(t, (int, float)), "invalid inputs


<think>
I will encode Python’s type checks as SMT predicates using an ADT for values, helper functions for numeric testing and safe real extraction, and define C0/C1 exactly matching the isinstance assertions.
</think>
```json
{
  "helper_functions": "(declare-fun pow (Real Real) Real)\n(declare-fun roundI (Real) Int)\n(define-fun isNumeric ((x Value)) Bool\n  (or (is-IntVal x) (is-FloatVal x)))\n(define-fun safeReal ((x Value)) Real\n  (ite (is-IntVal x)\n       (to_real (ival x))\n       (ite (is-FloatVal x)\n            (fval x)\n            0.0)))",
  "basic_structure": "",
  "inputs": "(declare-const v Value)\n(declare-const t Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (isNumeric v))",
    "assert_1": "(define-fun C1 () Bool (isNumeric t))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/639

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: sample_nam
Problem Description:
"""
Write a function to sum the length of the names of a given list of names after removing the names that start with a lowercase letter.
assert sample_nam(['sally', 'Dylan', 'rebecca', 'Diana', 'Joanne', 'keith'])==16
"""


def sample_nam(sample_names):

  assert isinstance(sample_names, list), "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(x, str) for x in sample_names), "invalid inputs" # $_CONTRACT_$
  sample_names=list(filter(lambda el:el[0].isupper() and el[1:].islower(),sample_names))
  return len(''.join(sample_names))


Contract List:
assert_0: assert isinstance(sample_names, list), "invalid inputs
assert_1: assert all(isinstance(x, str) for x in sample_names), "invalid inputs


<think>
I translate the Python input checks into precise SMT predicates by defining recursive ADT helpers for list structure and element-type validation, then express each assert as a separate Boolean Ck predicate. This ensures executability conditions are in BASIC_STRUCTURE and contracts are cleanly isolated for systematic testing.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (or (is-Nil l)\n      (and (is-Cons l)\n           (IsList (tail l)))))\n\n(define-fun-rec ListAllStr ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (and (is-Cons l)\n            (let ((hd (head l)))\n              (and (is-StrVal hd)\n                   (ListAllStr (tail l)))))))",
  "basic_structure": "(assert (IsList sample_names))",
  "inputs": "(declare-const sample_names Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList sample_names))",
    "assert_1": "(define-fun C1 () Bool (ListAllStr sample_names))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/641

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: is_nonagonal
Problem Description:
"""
Write a function to find the nth nonagonal number.
assert is_nonagonal(10) == 325
"""


def is_nonagonal(n):

	assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
	assert n >= 0, "invalid inputs" # $_CONTRACT_$
 
	return int(n * (7 * n - 5) / 2) 


Contract List:
assert_0: assert isinstance(n, int), "invalid inputs
assert_1: assert n >= 0, "invalid inputs


<think>
I translate each Python assertion into an SMT predicate over the generic Value ADT, add a safe integer extractor for executability, and declare the input. Each contract Ck precisely matches its assert semantics.
</think>
```json
{
  "helper_functions": "(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
  "basic_structure": "",
  "inputs": "(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
    "assert_1": "(define-fun C1 () Bool (>= (SafeI n) 0))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/643

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: text_match_wordz_middle
Problem Description:
"""
Write a function that checks if a strings contains 'z', except at the start and end of the word.
assert text_match_wordz_middle("pythonzabc.")==True
"""


import re
def text_match_wordz_middle(text):

	assert isinstance(text, str), "invalid inputs" # $_CONTRACT_$
	return re.search(r'\Bz\B',  text) is not None


Contract List:
assert_0: assert isinstance(text, str), "invalid inputs


<think>
I will translate the Python `isinstance(text, str)` assertion into an SMT predicate `C0` using the `is-StrVal` tester, declare the input as a `Value`, and leave helpers/basic structure empty since no additional executability constraints are needed.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "",
  "inputs": "(declare-const text Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-StrVal text))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/644

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: reverse_Array_Upto_K
Problem Description:
"""
Write a python function to reverse an array upto a given position.
assert reverse_Array_Upto_K([1, 2, 3, 4, 5, 6],4) == [4, 3, 2, 1, 5, 6]
"""


def reverse_Array_Upto_K(input, k):

  assert isinstance(input, list), "invalid inputs" # $_CONTRACT_$
  assert 0 < k <= len(input), "invalid inputs" # $_CONTRACT_$
 
  return input[k-1::-1] + input[k:]


Contract List:
assert_0: assert isinstance(input, list), "invalid inputs
assert_1: assert 0 < k <= len(input), "invalid inputs


<think>
I define recursive helpers IsList and length to model list structure and size, declare input and k, assert basic executability (input is a list), and translate each Python assert into guarded SMT-LIB predicates C0 and C1.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool (ite (is-Nil v) true (ite (is-Cons v) (IsList (tail v)) false)))\n(define-fun-rec length ((v Value)) Int (ite (is-Nil v) 0 (ite (is-Cons v) (+ 1 (length (tail v))) 0)))",
  "basic_structure": "(assert (IsList input))",
  "inputs": "(declare-const input Value)\n(declare-const k Int)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList input))",
    "assert_1": "(define-fun C1 () Bool (ite (IsList input) (and (> k 0) (<= k (length input))) false))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/720

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: add_dict_to_tuple
Problem Description:
"""
Write a function to add a dictionary to the tuple. The output should be a tuple.
assert add_dict_to_tuple((4, 5, 6), {"MSAM" : 1, "is" : 2, "best" : 3} ) == (4, 5, 6, {'MSAM': 1, 'is': 2, 'best': 3})
"""


def add_dict_to_tuple(test_tup, test_dict):

  assert isinstance(test_tup, tuple), "invalid inputs" # $_CONTRACT_$
  assert isinstance(test_dict, dict), "invalid inputs" # $_CONTRACT_$
  return test_tup + (test_dict, )


Contract List:
assert_0: assert isinstance(test_tup, tuple), "invalid inputs
assert_1: assert isinstance(test_dict, dict), "invalid inputs


<think>
I translate the Python type‐checks into SMT‐LIB type predicates by modeling tuples as lists (Nil/Cons) and dictionaries with a DictVal constructor, provide a recursive IsList helper, declare inputs, and define C0/C1 exactly matching the assertions. This template leaves BASIC_STRUCTURE empty (no invariants beyond contracts) and includes combination scenarios for systematic testing.
</think>
```json
{
  "helper_functions": "(define-datatypes ((Value 0)) ((\n  (IntVal (ival Int))\n  (FloatVal (fval Real))\n  (StrVal (sval String))\n  (BoolVal (bval Bool))\n  (Nil)\n  (Cons (head Value) (tail Value))\n  (DictVal (entries Value))\n)))\n\n(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v) true\n    (ite (is-Cons v)\n         (IsList (tail v))\n         false)))",
  "basic_structure": "",
  "inputs": "(declare-const test_tup Value)\n(declare-const test_dict Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList test_tup))",
    "assert_1": "(define-fun C1 () Bool (is-DictVal test_dict))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/721

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: maxAverageOfPath
Problem Description:
"""
Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.
assert maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2
"""


def maxAverageOfPath(cost):

  assert isinstance(cost, list), "invalid inputs" # $_CONTRACT_$
  assert len(cost) > 0, "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(x, list) for x in cost), "invalid inputs" # $_CONTRACT_$
  assert all(len(x) == len(cost) == len(cost[0]) for x in cost), "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(x, (int, float)) for x in sum(cost, [])), "invalid inputs" # $_CONTRACT_$
  N = len(cost)
  dp = [[0 for _ in range(N + 1)] for _ in range(N + 1)]
  dp[0][0] = cost[0][0]
  for i in range(1, N):
    dp[i][0] = dp[i - 1][0] + cost[i][0]
  for j in range(1, N):
    dp[0][j] = dp[0][j - 1] + cost[0][j]
  for i in range(1, N):
    for j in range(1, N):
      dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j]
  # all paths are of length 2 * N - 1, so just divide by that
  return dp[N - 1][N - 1] / (2 * N - 1)


Contract List:
assert_0: assert isinstance(cost, list), "invalid inputs
assert_1: assert len(cost) > 0, "invalid inputs
assert_2: assert all(isinstance(x, list) for x in cost), "invalid inputs
assert_3: assert all(len(x) == len(cost) == len(cost[0]) for x in cost), "invalid inputs
assert_4: assert all(isinstance(x, (int, float)) for x in sum(cost, [])), "invalid inputs


<think>
I will translate each Python assertion into a precise SMT-LIB predicate Ck, define the necessary ADT helpers to check list structure, nesting, lengths, and numeric elements, and outline all contract-violation combinations for systematic testing.
</think>
```json
{
  "helper_functions": "(define-fun isList ((v Value)) Bool (or (is-Nil v) (is-Cons v)))\n(define-fun-rec length ((lst Value)) Int\n  (ite (is-Nil lst)\n       0\n       (ite (is-Cons lst)\n            (+ 1 (length (tail lst)))\n            0)))\n(define-fun-rec list_all_lists ((lst Value)) Bool\n  (ite (is-Nil lst)\n       true\n       (ite (is-Cons lst)\n            (and (isList (head lst)) (list_all_lists (tail lst)))\n            false)))\n(define-fun-rec list_all_numeric ((lst Value)) Bool\n  (ite (is-Nil lst)\n       true\n       (ite (is-Cons lst)\n            (and (or (is-IntVal (head lst)) (is-FloatVal (head lst)))\n                 (list_all_numeric (tail lst)))\n            false)))\n(define-fun-rec list_all_numeric_matrix ((m Value)) Bool\n  (ite (is-Nil m)\n       true\n       (ite (is-Cons m)\n            (and (list_all_numeric (head m))\n                 (list_all_numeric_matrix (tail m)))\n            false)))\n(define-fun-rec all_row_lengths_equal ((lst Value) (n Int)) Bool\n  (ite (is-Nil lst)\n       true\n       (ite (is-Cons lst)\n            (and (= (length (head lst)) n)\n                 (all_row_lengths_equal (tail lst) n))\n            false)))",
  "basic_structure": "(assert (isList cost))\n(assert (> (length cost) 0))",
  "inputs": "(declare-const cost Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (isList cost))",
    "assert_1": "(define-fun C1 () Bool (> (length cost) 0))",
    "assert_2": "(define-fun C2 () Bool (list_all_lists cost))",
    "assert_3": "(define-fun C3 () Bool\n  (ite (is-Cons cost)\n       (let ((n (length cost)))\n         (and (= (length (head cost)) n)\n              (all_row_lengths_equal (tail cost) n)))\n       false))",
    "assert_4": "(define-fun C4 () Bool (list_all_numeric_matrix cost))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/722

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: filter_data
Problem Description:
"""
The input is given as - a dictionary with a student name as a key and a tuple of float (student_height, student_weight) as a value, - minimal height, - minimal weight. Write a function to filter students that have height and weight above the minimum.
assert filter_data({'Cierra Vega': (6.2, 70), 'Alden Cantrell': (5.9, 65), 'Kierra Gentry': (6.0, 68), 'Pierre Cox': (5.8, 66)},6.0,70)=={'Cierra Vega': (6.2, 70)}
"""


def filter_data(students,h,w):

    assert isinstance(students, dict), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(x, str) for x in students.keys()), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(x, tuple) for x in students.values()), "invalid inputs" # $_CONTRACT_$
    assert all(len(x) == 2 for x in students.values()), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(height, (int, float)) and isinstance(weight, (int, float)) for height, weight in students.values()) # $_CONTRACT_$
    assert isinstance(h, (int, float)), "invalid inputs" # $_CONTRACT_$
    assert isinstance(w, (int, float)), "invalid inputs" # $_CONTRACT_$
    assert h >= 0, "invalid inputs" # $_CONTRACT_$
    assert w >= 0, "invalid inputs" # $_CONTRACT_$
    return {k: s for k, s in students.items() if s[0] >= h and s[1] >= w}


Contract List:
assert_0: assert isinstance(students, dict), "invalid inputs
assert_1: assert all(isinstance(x, str) for x in students.keys()), "invalid inputs
assert_2: assert all(isinstance(x, tuple) for x in students.values()), "invalid inputs
assert_3: assert all(len(x) == 2 for x in students.values()), "invalid inputs
assert_4: assert all(isinstance(height, (int, float)) and isinstance(weight, (int, float)) for height, weight in students.values())
assert_5: assert isinstance(h, (int, float)), "invalid inputs
assert_6: assert isinstance(w, (int, float)), "invalid inputs
assert_7: assert h >= 0, "invalid inputs
assert_8: assert w >= 0, "invalid inputs


<think>
I encoded the Python dict as a list of key-value pairs using a Pair constructor, then defined recursive helpers to enforce list structure, key type, tuple shape, and numeric checks. Structural invariants (C0–C6) go into basic_structure for safe execution, while range assertions (C7–C8) remain as separate contracts.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (ite (is-Nil l) true\n       (ite (is-Cons l)\n            (IsList (tail l))\n            false)))\n\n(define-fun-rec all_keys_str ((lst Value)) Bool\n  (ite (is-Nil lst) true\n       (ite (is-Cons lst)\n            (let ((h (head lst)) (t (tail lst)))\n              (ite (is-Pair h)\n                   (and (is-StrVal (fst h)) (all_keys_str t))\n                   false))\n            false)))\n\n(define-fun-rec all_vals_pair ((lst Value)) Bool\n  (ite (is-Nil lst) true\n       (ite (is-Cons lst)\n            (let ((h (head lst)) (t (tail lst)))\n              (ite (is-Pair h)\n                   (all_vals_pair t)\n                   false))\n            false)))\n\n(define-fun-rec all_len2 ((lst Value)) Bool\n  (ite (is-Nil lst) true\n       (ite (is-Cons lst)\n            (let ((h (head lst)) (t (tail lst)))\n              (ite (is-Pair h)\n                   (all_len2 t)\n                   false))\n            false)))\n\n(define-fun-rec all_vals_numeric ((lst Value)) Bool\n  (ite (is-Nil lst) true\n       (ite (is-Cons lst)\n            (let ((h (head lst)) (t (tail lst)))\n              (ite (is-Pair h)\n                   (let ((data (snd h)))\n                     (ite (is-Pair data)\n                          (and (is-Number (fst data)) (is-Number (snd data)) (all_vals_numeric t))\n                          false))\n                   false))\n            false)))\n\n(define-fun is-Number ((v Value)) Bool\n  (or (is-IntVal v) (is-FloatVal v)))",
  "basic_structure": "(assert C0)\n(assert C1)\n(assert C2)\n(assert C3)\n(assert C4)\n(assert C5)\n(assert C6)",
  "inputs": "(declare-const students Value)\n(declare-const h Value)\n(declare-const w Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList students))",
    "assert_1": "(define-fun C1 () Bool (all_keys_str students))",
    "assert_2": "(define-fun C2 () Bool (all_vals_pair students))",
    "assert_3": "(define-fun C3 () Bool (all_len2 students))",
    "assert_4": "(define-fun C4 () Bool (all_vals_numeric students))",
    "assert_5": "(define-fun C5 () Bool (is-Number h))",
    "assert_6": "(define-fun C6 () Bool (is-Number w))",
    "assert_7": "(define-fun C7 () Bool (ite (is-IntVal h) (>= (toReal (ival h)) 0) (ite (is-FloatVal h) (>= (fval h) 0) false)))",
    "assert_8": "(define-fun C8 () Bool (ite (is-IntVal w) (>= (toReal (ival w)) 0) (ite (is-FloatVal w) (>= (fval w) 0) false)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/723

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: count_same_pair
Problem Description:
"""
The input is defined as two lists of the same length. Write a function to count indices where the lists have the same values.
assert count_same_pair([1, 2, 3, 4, 5, 6, 7, 8],[2, 2, 3, 1, 2, 6, 7, 9])==4
"""


from operator import eq
def count_same_pair(nums1, nums2):

    assert isinstance(nums1, list), "invalid inputs" # $_CONTRACT_$
    assert isinstance(nums2, list), "invalid inputs" # $_CONTRACT_$
    assert len(nums1) == len(nums2), "invalid inputs" # $_CONTRACT_$
    assert all(hasattr(a, '__eq__') and isinstance(a, type(b)) for a, b in zip(nums1, nums2)), "invalid inputs" # $_CONTRACT_$
    result = sum(map(eq, nums1, nums2))
    return result


Contract List:
assert_0: assert isinstance(nums1, list), "invalid inputs
assert_1: assert isinstance(nums2, list), "invalid inputs
assert_2: assert len(nums1) == len(nums2), "invalid inputs
assert_3: assert all(hasattr(a, '__eq__') and isinstance(a, type(b)) for a, b in zip(nums1, nums2)), "invalid inputs


<think>
I translate the Python assertions into SMT-LIB predicates by defining an ADT-based list structure, recursive helpers for list checking, length, and element‐type equality, and then mapping each assert to a named Boolean predicate.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec ListLen ((v Value)) Int\n  (ite (is-Nil v)\n       0\n       (ite (is-Cons v)\n            (+ 1 (ListLen (tail v)))\n            0)))\n\n(define-fun SameType ((v1 Value) (v2 Value)) Bool\n  (or (and (is-IntVal v1)   (is-IntVal v2))\n      (and (is-FloatVal v1) (is-FloatVal v2))\n      (and (is-StrVal v1)   (is-StrVal v2))\n      (and (is-BoolVal v1)  (is-BoolVal v2))\n      (and (is-Nil v1)      (is-Nil v2))\n      (and (is-Cons v1)     (is-Cons v2))))\n\n(define-fun-rec AllSameTypeIndices ((l1 Value) (l2 Value)) Bool\n  (ite (and (is-Nil l1) (is-Nil l2))\n       true\n       (ite (and (is-Cons l1) (is-Cons l2))\n            (and (SameType (head l1) (head l2))\n                 (AllSameTypeIndices (tail l1) (tail l2)))\n            false)))",
  "basic_structure": "",
  "inputs": "(declare-const nums1 Value)\n(declare-const nums2 Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList nums1))",
    "assert_1": "(define-fun C1 () Bool (IsList nums2))",
    "assert_2": "(define-fun C2 () Bool (= (ListLen nums1) (ListLen nums2)))",
    "assert_3": "(define-fun C3 () Bool (AllSameTypeIndices nums1 nums2))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/724

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: power_base_sum
Problem Description:
"""
Write a function that takes base and power as arguments and calculate the sum of all digits of the base to the specified power.
assert power_base_sum(2,100)==115
"""


def power_base_sum(base, power):

    assert isinstance(base, int), "invalid inputs" # $_CONTRACT_$
    assert base >= 0, "invalid inputs" # $_CONTRACT_$
    assert isinstance(power, int), "invalid inputs" # $_CONTRACT_$
    return sum([int(i) for i in str(pow(base, power))])


Contract List:
assert_0: assert isinstance(base, int), "invalid inputs
assert_1: assert base >= 0, "invalid inputs
assert_2: assert isinstance(power, int), "invalid inputs


<think>
I translate each Python assertion into a named SMT-LIB predicate, introduce a SafeIval helper to guard integer extraction, and declare the Value‐typed inputs. The basic structure is minimal to allow all test combinations.
</think>
```json
{
  "helper_functions": "(define-fun SafeIval ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
  "basic_structure": "",
  "inputs": "(declare-const base Value)\n(declare-const power Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal base))",
    "assert_1": "(define-fun C1 () Bool (>= (SafeIval base) 0))",
    "assert_2": "(define-fun C2 () Bool (is-IntVal power))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/725

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: extract_quotation
Problem Description:
"""
Write a function to extract values between quotation marks " " of the given string.
assert extract_quotation('Cortex "A53" Based "multi" tasking "Processor"') == ['A53', 'multi', 'Processor']
"""


import re
def extract_quotation(text1):

  assert isinstance(text1, str), "invalid inputs" # $_CONTRACT_$
  return re.findall(r'"(.*?)"', text1)


Contract List:
assert_0: assert isinstance(text1, str), "invalid inputs


<think>
I translate the Python isinstance check into an SMT predicate C0, include a SafeS helper for safe string extraction, and keep the base template minimal to allow testing both satisfying and violating C0.
</think>
```json
{
  "helper_functions": "(define-fun SafeS ((v Value)) String (ite (is-StrVal v) (sval v) \"\"))",
  "basic_structure": "",
  "inputs": "(declare-const text1 Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-StrVal text1))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/726

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: multiply_elements
Problem Description:
"""
Write a function that takes as input a tuple of numbers (t_1,...,t_{N+1}) and returns a tuple of length N where the i-th element of the tuple is equal to t_i * t_{i+1}.
assert multiply_elements((1, 5, 7, 8, 10)) == (5, 35, 56, 80)
"""


def multiply_elements(test_tup):

  assert isinstance(test_tup, tuple), "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(x, (int, float)) for x in test_tup), "invalid inputs" # $_CONTRACT_$
  return tuple(i * j for i, j in zip(test_tup, test_tup[1:]))


Contract List:
assert_0: assert isinstance(test_tup, tuple), "invalid inputs
assert_1: assert all(isinstance(x, (int, float)) for x in test_tup), "invalid inputs


<think>
I model the Python tuple as a linked list ADT and define recursive predicates IsList and list_all_numeric to capture the tuple shape and numeric‐element requirement. I then translate each assertion into standalone Boolean contracts C0 and C1, while asserting the base executability invariant in the basic structure.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec list_all_numeric ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (or (is-IntVal (head v)) (is-FloatVal (head v)))\n                 (list_all_numeric (tail v)))\n            false)))",
  "basic_structure": "(assert (IsList test_tup))",
  "inputs": "(declare-const test_tup Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList test_tup))",
    "assert_1": "(define-fun C1 () Bool (list_all_numeric test_tup))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/728

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: sum_list
Problem Description:
"""
Write a function takes as input two lists [a_1,...,a_n], [b_1,...,b_n] and returns [a_1+b_1,...,a_n+b_n].
assert sum_list([10,20,30],[15,25,35])==[25,45,65]
"""


def sum_list(lst1,lst2):

  assert isinstance(lst1, list), "invalid inputs" # $_CONTRACT_$
  assert isinstance(lst2, list), "invalid inputs" # $_CONTRACT_$
  assert len(lst1) == len(lst2), "invalid inputs" # $_CONTRACT_$
  return [a + b for a, b in zip(lst1, lst2)] 


Contract List:
assert_0: assert isinstance(lst1, list), "invalid inputs
assert_1: assert isinstance(lst2, list), "invalid inputs
assert_2: assert len(lst1) == len(lst2), "invalid inputs


<think>
I define recursive helpers for list structure and length, declare inputs as Value, enforce basic list-shape constraints, and translate each Python assertion into an SMT Bool predicate for exact semantic matching.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((lst Value)) Bool\n  (or (is-Nil lst)\n      (and (is-Cons lst)\n           (IsList (tail lst)))))\n\n(define-fun-rec length ((lst Value)) Int\n  (ite (is-Nil lst) 0\n       (ite (is-Cons lst)\n            (+ 1 (length (tail lst)))\n            0)))",
  "basic_structure": "(assert (IsList lst1))\n(assert (IsList lst2))",
  "inputs": "(declare-const lst1 Value)\n(declare-const lst2 Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList lst1))",
    "assert_1": "(define-fun C1 () Bool (IsList lst2))",
    "assert_2": "(define-fun C2 () Bool (= (length lst1) (length lst2))))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/730

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: consecutive_duplicates
Problem Description:
"""
Write a function to remove consecutive duplicates of a given list.
assert consecutive_duplicates([0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4 ])==[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 4]
"""


from itertools import groupby
def consecutive_duplicates(nums):

    assert isinstance(nums, list), "invalid inputs" # $_CONTRACT_$
    return [key for key, _ in groupby(nums)] 


Contract List:
assert_0: assert isinstance(nums, list), "invalid inputs


<think>
I define an ADT-based IsList predicate for list well-formedness, assert it as both a basic structure requirement and as C0 for the isinstance(nums, list) contract, and declare the input.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (IsList (tail l))\n            false)))",
  "basic_structure": "(assert (IsList nums))",
  "inputs": "(declare-const nums Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList nums))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/731

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: lateralsurface_cone
Problem Description:
"""
Write a function to find the lateral surface area of a cone given radius r and the height h.
assert lateralsurface_cone(5,12)==204.20352248333654
"""


import math
def lateralsurface_cone(r,h):

  assert isinstance(r, (int, float)), "invalid inputs" # $_CONTRACT_$
  assert isinstance(h, (int, float)), "invalid inputs" # $_CONTRACT_$
  assert r > 0, "invalid inputs" # $_CONTRACT_$
  assert h > 0, "invalid inputs" # $_CONTRACT_$
  l = math.sqrt(r * r + h * h)
  return math.pi * r  * l


Contract List:
assert_0: assert isinstance(r, (int, float)), "invalid inputs
assert_1: assert isinstance(h, (int, float)), "invalid inputs
assert_2: assert r > 0, "invalid inputs
assert_3: assert h > 0, "invalid inputs


<think>
I translate each Python input assertion into SMT predicates using a Value ADT, defining numeric checking and a real extraction helper. Inputs are declared as Value, basic structure has no extra invariants, and each contract C0–C3 precisely mirrors the Python asserts.
</think>
```json
{
  "helper_functions": "(define-fun is-numeric ((v Value)) Bool\n  (or (is-IntVal v) (is-FloatVal v)))\n\n(define-fun value-to-real ((v Value)) Real\n  (ite (is-IntVal v)\n       (to_real (ival v))\n       (ite (is-FloatVal v)\n            (fval v)\n            0)))",
  "basic_structure": "",
  "inputs": "(declare-const r Value)\n(declare-const h Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-numeric r))",
    "assert_1": "(define-fun C1 () Bool (is-numeric h))",
    "assert_2": "(define-fun C2 () Bool (> (value-to-real r) 0))",
    "assert_3": "(define-fun C3 () Bool (> (value-to-real h) 0))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/732

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: replace_specialchar
Problem Description:
"""
Write a function to replace all occurrences of spaces, commas, or dots with a colon.
assert replace_specialchar('Python language, Programming language.')==('Python:language::Programming:language:')
"""


import re
def replace_specialchar(text):

 assert isinstance(text, str), "invalid inputs" # $_CONTRACT_$
 return re.sub("[ ,.]", ":", text)


Contract List:
assert_0: assert isinstance(text, str), "invalid inputs


<think>
I model the single Python assert as an SMT predicate ensuring the Value is a string, include the canonical ADT, and declare the input so the contract is testable.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "",
  "inputs": "(declare-const text Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-StrVal text))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/733

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: find_first_occurrence
Problem Description:
"""
Write a function to find the index of the first occurrence of a given number in a sorted array.
assert find_first_occurrence([2, 5, 5, 5, 6, 6, 8, 9, 9, 9], 5) == 1
"""


def find_first_occurrence(A, x):

    assert isinstance(A, list), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(a, (int, float)) for a in A), "invalid inputs" # $_CONTRACT_$
    assert all(a <= b for a, b in zip(A, A[1:])), "invalid inputs" # $_CONTRACT_$
    assert x in A, "invalid inputs" # $_CONTRACT_$
    assert isinstance(x, int), "invalid inputs" # $_CONTRACT_$
    (left, right) = (0, len(A) - 1)
    result = -1
    while left <= right:
        mid = (left + right) // 2
        if x == A[mid]:
            result = mid
            right = mid - 1
        elif x < A[mid]:
            right = mid - 1
        else:
            left = mid + 1
    return result


Contract List:
assert_0: assert isinstance(A, list), "invalid inputs
assert_1: assert all(isinstance(a, (int, float)) for a in A), "invalid inputs
assert_2: assert all(a <= b for a, b in zip(A, A[1:])), "invalid inputs
assert_3: assert x in A, "invalid inputs
assert_4: assert isinstance(x, int), "invalid inputs


<think>
I create SMT-LIB predicates mirroring each Python assertion and ensure basic ADT well-formedness. I provide a reusable set of recursive helper functions for list structure, numeric checks, sorting, and membership, then define each contract as a Boolean predicate.
</think>
```json
{
  "helper_functions": "(define-fun-rec isList ((l Value)) Bool\n  (ite (is-Nil l) true\n    (ite (is-Cons l) (isList (tail l)) false)))\n\n(define-fun-rec list_all_numeric ((l Value)) Bool\n  (ite (is-Nil l) true\n    (ite (is-Cons l)\n      (let ((h (head l)) (t (tail l)))\n        (and (or (is-IntVal h) (is-FloatVal h))\n             (list_all_numeric t)))\n      false)))\n\n(define-fun-rec list_sorted ((l Value)) Bool\n  (ite (is-Nil l) true\n    (ite (is-Cons l)\n      (let ((h1 (head l)) (rest1 (tail l)))\n        (ite (is-Cons rest1)\n          (let ((h2 (head rest1)))\n            (and (let ((v1 (ite (is-IntVal h1) (to_real (ival h1)) (fval h1)))\n                       (v2 (ite (is-IntVal h2) (to_real (ival h2)) (fval h2))))\n                   (<= v1 v2))\n                 (list_sorted rest1)))\n          true))\n      false)))\n\n(define-fun-rec list_contains ((l Value) (x Value)) Bool\n  (ite (is-Nil l) false\n    (ite (is-Cons l)\n      (let ((h (head l)) (t (tail l)))\n        (ite (is-IntVal h)\n          (ite (= (ival h) (ival x)) true (list_contains t x))\n          (ite (is-FloatVal h)\n            (ite (= (fval h) (to_real (ival x))) true (list_contains t x))\n            (list_contains t x))))\n      false)))",
  "basic_structure": "(assert (isList A))\n(assert (is-IntVal x))",
  "inputs": "(declare-const A Value)\n(declare-const x Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (isList A))",
    "assert_1": "(define-fun C1 () Bool (list_all_numeric A))",
    "assert_2": "(define-fun C2 () Bool (list_sorted A))",
    "assert_3": "(define-fun C3 () Bool (list_contains A x))",
    "assert_4": "(define-fun C4 () Bool (is-IntVal x))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/734

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: sum_Of_Subarray_Prod
Problem Description:
"""
Write a python function to find sum of products of all possible sublists of a given list. 
assert sum_Of_Subarray_Prod([1,2,3]) == 20
"""


def sum_Of_Subarray_Prod(arr):

    assert isinstance(arr, list), "invalid inputs" # $_CONTRACT_$
    assert len(arr) > 0, "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(x, (int, float)) for x in arr), "invalid inputs" # $_CONTRACT_$
    result = 0  # final result
    partial = 0 # partial sum
    # stimulate the recursion
    while arr != []:
        partial = arr[-1] * (1 + partial)
        result += partial
        arr.pop()
    return result


Contract List:
assert_0: assert isinstance(arr, list), "invalid inputs
assert_1: assert len(arr) > 0, "invalid inputs
assert_2: assert all(isinstance(x, (int, float)) for x in arr), "invalid inputs


<think>
I encode the Python list and numeric checks as recursive SMT functions over the ADT, separating structural invariants in basic_structure and mirroring each assert in its own predicate Ck for systematic violation testing.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec length ((l Value)) Int\n  (ite (is-Nil l)\n       0\n       (+ 1 (length (tail l)))))\n\n(define-fun-rec list_all_numeric ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (let ((h (head l)))\n              (ite (or (is-IntVal h) (is-FloatVal h))\n                   (list_all_numeric (tail l))\n                   false))\n            false)))",
  "basic_structure": "(assert (IsList arr))\n(assert (list_all_numeric arr))",
  "inputs": "(declare-const arr Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList arr))",
    "assert_1": "(define-fun C1 () Bool (> (length arr) 0))",
    "assert_2": "(define-fun C2 () Bool (list_all_numeric arr))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/735

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: toggle_middle_bits
Problem Description:
"""
Write a python function to toggle bits of the number except the first and the last bit. 
assert toggle_middle_bits(9) == 15
"""


def toggle_middle_bits(n):

    assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
    assert n >= 0, "invalid inputs" # $_CONTRACT_$
 
    binary = bin(n)[2:]
    toggled = ''.join(['0' if i == '1' else '1' for i in binary[1:-1]])
    return int(binary[0] + toggled + binary[-1], 2)


Contract List:
assert_0: assert isinstance(n, int), "invalid inputs
assert_1: assert n >= 0, "invalid inputs


<think>
I will translate the Python input assertions into precise SMT-LIB predicates, defining C0 to check that n is an integer value and C1 to ensure it is non-negative, each standing alone and guarding selectors appropriately.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "",
  "inputs": "(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
    "assert_1": "(define-fun C1 () Bool (and (is-IntVal n) (>= (ival n) 0)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/736

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: left_insertion
Problem Description:
"""
Write a function to locate the left insertion point for a specified value in sorted order. 
assert left_insertion([1,2,4,5],6)==4
"""


import bisect
def left_insertion(a, x):

    assert isinstance(a, list), "invalid inputs" # $_CONTRACT_$
    assert all(x <= y for x, y in zip(a, a[1:])), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(x, (int, float)) for x in a), "invalid inputs" # $_CONTRACT_$
    return bisect.bisect_left(a, x)


Contract List:
assert_0: assert isinstance(a, list), "invalid inputs
assert_1: assert all(x <= y for x, y in zip(a, a[1:])), "invalid inputs
assert_2: assert all(isinstance(x, (int, float)) for x in a), "invalid inputs


<think>
I translate each Python assertion into an SMT predicate over our canonical ADT, adding recursive definitions for list structure, numeric checking, and sorting. I declare the input and assert only the fundamental shape in the basic structure, leaving each contract in its own Ck definition.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (or (is-Nil v)\n      (and (is-Cons v) (IsList (tail v)))))\n\n(define-fun value_to_real ((v Value)) Real\n  (ite (is-IntVal v)\n       (to_real (ival v))\n       (ite (is-FloatVal v)\n            (fval v)\n            0.0)))\n\n(define-fun-rec list_all_numeric ((lst Value)) Bool\n  (ite (is-Nil lst)\n       true\n       (and (or (is-IntVal (head lst)) (is-FloatVal (head lst)))\n            (list_all_numeric (tail lst)))))\n\n(define-fun-rec list_sorted ((lst Value)) Bool\n  (or (is-Nil lst)\n      (and (is-Cons lst)\n           (or (is-Nil (tail lst))\n               (let ((h (head lst))\n                     (t (tail lst))\n                     (h2 (head t)))\n                 (and (<= (value_to_real h) (value_to_real h2))\n                      (list_sorted t)))))))",
  "basic_structure": "(assert (IsList a))",
  "inputs": "(declare-const a Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList a))",
    "assert_1": "(define-fun C1 () Bool (list_sorted a))",
    "assert_2": "(define-fun C2 () Bool (list_all_numeric a))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/737

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: check_str
Problem Description:
"""
Write a function to check whether the given string is starting with a vowel or not using regex.
assert check_str("annie")
"""


import re 
def check_str(string):

	assert isinstance(string, str), "invalid inputs" # $_CONTRACT_$
 
	regex = '^[aeiouAEIOU][A-Za-z0-9_]*'
	return re.search(regex, string)


Contract List:
assert_0: assert isinstance(string, str), "invalid inputs


<think>
I will encode the Python isinstance check as an SMT-LIB predicate C0 that requires the input to be a StrVal in the ADT. No extra helpers or executability invariants are needed since only the type‐check is asserted.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "",
  "inputs": "(declare-const string Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-StrVal string))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/739

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: find_Index
Problem Description:
"""
Write a python function to find the index of smallest triangular number with n digits. 
assert find_Index(2) == 4
"""


import math 
def find_Index(n):

    assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
    assert n >= 1, "invalid inputs" # $_CONTRACT_$
 
    x = math.sqrt(2 * math.pow(10,(n - 1)))
    return round(x)


Contract List:
assert_0: assert isinstance(n, int), "invalid inputs
assert_1: assert n >= 1, "invalid inputs


<think>
I will translate the Python int‐type and range assertions into SMT‐LIB predicates guarded by ADT testers, declare the single input, and leave basic structure and helpers empty since no extra shapes or recursion are needed.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "",
  "inputs": "(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
    "assert_1": "(define-fun C1 () Bool (ite (is-IntVal n) (>= (ival n) 1) false))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/740

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: tuple_to_dict
Problem Description:
"""
Write a function to convert the given tuple to a key-value dictionary using adjacent elements. 
assert tuple_to_dict((1, 5, 7, 10, 13, 5)) == {1: 5, 7: 10, 13: 5}
"""


def tuple_to_dict(test_tup):

  assert isinstance(test_tup, tuple), "invalid inputs" # $_CONTRACT_$
  assert len(test_tup) % 2 == 0, "invalid inputs" # $_CONTRACT_$
  return dict(test_tup[idx : idx + 2] for idx in range(0, len(test_tup), 2))


Contract List:
assert_0: assert isinstance(test_tup, tuple), "invalid inputs
assert_1: assert len(test_tup) % 2 == 0, "invalid inputs


<think>
I translate the Python tuple contracts into SMT-LIB by modeling Python tuples as our canonical list ADT, declaring a recursive IsList predicate for proper shape, a recursive length function, and then defining contract predicates C0 and C1 to mirror isinstance and even-length checks. I place shape invariants in the basic structure to guarantee safe execution of length, and map each assert into its own Boolean definition.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (or (is-Nil v)\n      (and (is-Cons v) (IsList (tail v)))))\n\n(define-fun-rec length ((v Value)) Int\n  (ite (is-Nil v)\n       0\n       (ite (is-Cons v)\n            (+ 1 (length (tail v)))\n            0)))",
  "basic_structure": "(assert (IsList test_tup))",
  "inputs": "(declare-const test_tup Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList test_tup))",
    "assert_1": "(define-fun C1 () Bool (= (mod (length test_tup) 2) 0))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/741

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: all_Characters_Same
Problem Description:
"""
Write a python function to check whether all the characters are same or not.
assert all_Characters_Same("python") == False
"""


def all_Characters_Same(s) :

    assert isinstance(s, str), "invalid inputs" # $_CONTRACT_$
    return all(ch == s[0] for ch in s[1:])


Contract List:
assert_0: assert isinstance(s, str), "invalid inputs


<think>
I mapped the Python string contract into SMT by defining safe string helpers (SafeCharAt, SafeStrSub) to ensure execution even if inputs are malformed, declared the input as a Value, built a basic structure with let-bindings for safe extraction, and translated the isinstance check into C0 using is-StrVal.
</think>
```json
{
  "helper_functions": "(define-fun SafeCharAt ((v Value) (i Int)) String\n  (ite (and (is-StrVal v) (<= 0 i) (< i (str.len (sval v))))\n       (str.at (sval v) i)\n       \"\"))\n(define-fun SafeStrSub ((v Value) (start Int)) String\n  (ite (and (is-StrVal v)\n            (<= 0 start)\n            (<= start (str.len (sval v))))\n       (str.substr (sval v) start (- (str.len (sval v)) start))\n       \"\"))",
  "basic_structure": "(let ((s0 (SafeCharAt s 0))\n      (restStr (SafeStrSub s 1)))\n  true)",
  "inputs": "(declare-const s Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-StrVal s))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/742

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: area_tetrahedron
Problem Description:
"""
Write a function to caluclate the area of a tetrahedron.
assert area_tetrahedron(3)==15.588457268119894
"""


import math
def area_tetrahedron(side):

  assert isinstance(side, (int, float)), "invalid inputs" # $_CONTRACT_$
  assert side > 0, "invalid inputs" # $_CONTRACT_$
  return math.sqrt(3)*(side*side)


Contract List:
assert_0: assert isinstance(side, (int, float)), "invalid inputs
assert_1: assert side > 0, "invalid inputs


<think>
I translate Python’s type and range checks into SMT predicates by defining numeric testers and a safe extractor for numeric values, ensuring executability without unsafe selectors. Each assert becomes a named predicate (C0, C1) over the ADT `Value`, preserving Python semantics precisely.
</think>
```json
{
  "helper_functions": "(define-fun isNumeric ((v Value)) Bool\n  (or (is-IntVal v) (is-FloatVal v)))\n\n(define-fun safe_to_real ((v Value)) Real\n  (ite (is-IntVal v) (to_real (ival v))\n    (ite (is-FloatVal v) (fval v) 0.0)))",
  "basic_structure": "(assert true)",
  "inputs": "(declare-const side Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool\n  (or (is-IntVal side) (is-FloatVal side)))",
    "assert_1": "(define-fun C1 () Bool\n  (> (safe_to_real side) 0))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/743

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: rotate_right
Problem Description:
"""
Write a function to rotate a given list by specified number of items to the right direction. 
assert rotate_right([1, 2, 3, 4, 5, 6, 7, 8, 9, 10],3)==[8, 9, 10, 1, 2, 3, 4, 5, 6, 7]
"""


def rotate_right(l, m):

  assert isinstance(l, list), "invalid inputs" # $_CONTRACT_$
  assert isinstance(m, int), "invalid inputs" # $_CONTRACT_$
  assert 0 <= m <= len(l), "invalid inputs" # $_CONTRACT_$
  return l[-m:] + l[:-m]


Contract List:
assert_0: assert isinstance(l, list), "invalid inputs
assert_1: assert isinstance(m, int), "invalid inputs
assert_2: assert 0 <= m <= len(l), "invalid inputs


<think>
I defined recursive helpers for list recognition and length, declared inputs as Value, and expressed each Python assert as a Boolean predicate with proper tester guards and safe selector usage.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((l Value)) Bool (ite (is-Nil l) true (ite (is-Cons l) (IsList (tail l)) false)))\n(define-fun-rec length ((l Value)) Int (ite (is-Nil l) 0 (ite (is-Cons l) (+ 1 (length (tail l))) 0)))",
  "basic_structure": "",
  "inputs": "(declare-const l Value)\n(declare-const m Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList l))",
    "assert_1": "(define-fun C1 () Bool (is-IntVal m))",
    "assert_2": "(define-fun C2 () Bool (let ((m_int (ite (is-IntVal m) (ival m) 0)) (len_l (length l))) (and (is-IntVal m) (<= 0 m_int) (<= m_int len_l))))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/744

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: check_none
Problem Description:
"""
Write a function to check if the given tuple has any none value or not.
assert check_none((10, 4, 5, 6, None)) == True
"""


def check_none(test_tup):

  assert isinstance(test_tup, tuple), "invalid inputs" # $_CONTRACT_$
  return any(ele is None for ele in test_tup)


Contract List:
assert_0: assert isinstance(test_tup, tuple), "invalid inputs


<think>
I treat the Python tuple as a linked‐list ADT and add a recursive IsList predicate to ensure any Value is a well‐formed list. The single contract assert on isinstance(test_tup, tuple) becomes C0 ≡ (IsList test_tup).
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))",
  "basic_structure": "",
  "inputs": "(declare-const test_tup Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList test_tup))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/745

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: divisible_by_digits
Problem Description:
"""
Write a function to find numbers within a given range from startnum ti endnum where every number is divisible by every digit it contains. 
assert divisible_by_digits(1,22)==[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]
"""


def divisible_by_digits(startnum, endnum):

    assert isinstance(startnum, int), "invalid inputs" # $_CONTRACT_$
    assert isinstance(endnum, int), "invalid inputs" # $_CONTRACT_$
    assert startnum <= endnum, "invalid inputs" # $_CONTRACT_$
    return [n for n in range(startnum, endnum+1) \
                if not any(map(lambda x: int(x) == 0 or n%int(x) != 0, str(n)))]


Contract List:
assert_0: assert isinstance(startnum, int), "invalid inputs
assert_1: assert isinstance(endnum, int), "invalid inputs
assert_2: assert startnum <= endnum, "invalid inputs


<think>
I translate the Python input checks into precise SMT-LIB predicates using a SafeI helper to extract integer values safely, keeping the basic structure minimal and putting each assertion into its own Ck predicate.
</think>
```json
{
  "helper_functions": "(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
  "basic_structure": "",
  "inputs": "(declare-const startnum Value)\n(declare-const endnum Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal startnum))",
    "assert_1": "(define-fun C1 () Bool (is-IntVal endnum))",
    "assert_2": "(define-fun C2 () Bool (<= (SafeI startnum) (SafeI endnum)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/748

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: capital_words_spaces
Problem Description:
"""
Write a function to put spaces between words starting with capital letters in a given string.
assert capital_words_spaces("Python") == 'Python'
"""


import re
def capital_words_spaces(str1):

  assert isinstance(str1, str), "invalid inputs" # $_CONTRACT_$
  return re.sub(r"(\w)([A-Z])", r"\1 \2", str1)


Contract List:
assert_0: assert isinstance(str1, str), "invalid inputs


<think>
I translated the single string‐type assertion into an SMT Bool predicate C0, provided a safe extractor for strings, ensured the input is a StrVal, and defined a helper SafeS for selector safety.
</think>
```json
{
  "helper_functions": "(define-fun SafeS ((v Value)) String\n  (ite (is-StrVal v) (sval v) \"\"))",
  "basic_structure": "(assert (is-StrVal str1))",
  "inputs": "(declare-const str1 Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool\n  (is-StrVal str1))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/749

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: sort_numeric_strings
Problem Description:
"""
Write a function to sort a given list of strings of numbers numerically. 
assert sort_numeric_strings( ['4','12','45','7','0','100','200','-12','-500'])==[-500, -12, 0, 4, 7, 12, 45, 100, 200]
"""


def sort_numeric_strings(nums_str):

    def check_numeric(num: str): # $_CONTRACT_$
        return num.lstrip('-').rstrip(' ').isdigit() # $_CONTRACT_$
    assert isinstance(nums_str, list), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(x, str) for x in nums_str), "invalid inputs" # $_CONTRACT_$
    assert all(check_numeric(num) for num in nums_str), "invalid inputs" # $_CONTRACT_$
    return sorted([int(x) for x in nums_str])


Contract List:
assert_0: assert isinstance(nums_str, list), "invalid inputs
assert_1: assert all(isinstance(x, str) for x in nums_str), "invalid inputs
assert_2: assert all(check_numeric(num) for num in nums_str), "invalid inputs


<think>
I will translate each Python assertion into dedicated SMT-LIB predicates and define safe ADT and recursive list helpers to ensure the list structure and string‐numeric contracts are precisely captured while preserving executability.
</think>
```json
{
  "helper_functions": "(define-fun isList ((v Value)) Bool (or (is-Nil v) (is-Cons v)))\n(define-fun check_numeric ((s Value)) Bool (and (is-StrVal s)\n                                        (str.in.re (sval s)\n                                                   (re.++ (re.* (str.to.re \"-\"))\n                                                         (re.+ (re.range \"0\" \"9\"))\n                                                         (re.* (str.to.re \" \"))))))\n(define-fun-rec list_all_str ((lst Value)) Bool\n  (ite (is-Nil lst)\n       true\n       (ite (is-Cons lst)\n            (and (is-StrVal (head lst)) (list_all_str (tail lst)))\n            false)))\n(define-fun-rec list_all_num_str ((lst Value)) Bool\n  (ite (is-Nil lst)\n       true\n       (ite (is-Cons lst)\n            (and (check_numeric (head lst)) (list_all_num_str (tail lst)))\n            false)))",
  "basic_structure": "(assert (isList nums_str))",
  "inputs": "(declare-const nums_str Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (isList nums_str))",
    "assert_1": "(define-fun C1 () Bool (list_all_str nums_str))",
    "assert_2": "(define-fun C2 () Bool (list_all_num_str nums_str))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/750

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: add_tuple
Problem Description:
"""
Write a function to add the given tuple to the given list.
assert add_tuple([5, 6, 7], (9, 10)) == [5, 6, 7, 9, 10]
"""


def add_tuple(test_list, test_tup):

  assert isinstance(test_list, list), "invalid inputs" # $_CONTRACT_$
  assert isinstance(test_tup, tuple), "invalid inputs" # $_CONTRACT_$
  return test_list + list(test_tup)


Contract List:
assert_0: assert isinstance(test_list, list), "invalid inputs
assert_1: assert isinstance(test_tup, tuple), "invalid inputs


<think>
I model Python lists with a recursive IsList predicate to ensure safe list operations. test_list’s list‐ness is enforced as a basic executable invariant, while both contracts C0 and C1 use IsList to capture the “is list” and “is tuple” checks (tuples and lists share the same shape in this ADT).
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))",
  "basic_structure": "(assert (IsList test_list))",
  "inputs": "(declare-const test_list Value)\n(declare-const test_tup Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList test_list))",
    "assert_1": "(define-fun C1 () Bool (IsList test_tup))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/751

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: check_min_heap
Problem Description:
"""
Write a function to check if the given array represents min heap or not. 
assert check_min_heap([1, 2, 3, 4, 5, 6]) == True
"""


def check_min_heap_helper(arr, i):
    if 2 * i + 2 > len(arr):
      return True
    left_child = (arr[i] <= arr[2 * i + 1]) and check_min_heap_helper(arr, 2 * i + 1)
    right_child = (2 * i + 2 == len(arr)) or  \
                (arr[i] <= arr[2 * i + 2] and \
                 check_min_heap_helper(arr, 2 * i + 2))
    return left_child and right_child
def check_min_heap(arr):

  assert isinstance(arr, list), "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(x, int) for x in arr), "invalid inputs" # $_CONTRACT_$
  return check_min_heap_helper(arr, 0)


Contract List:
assert_0: assert isinstance(arr, list), "invalid inputs
assert_1: assert all(isinstance(x, int) for x in arr), "invalid inputs


<think>
I will define recursive SMT helpers for list shape and integer-only lists, declare the input, leave the basic structure minimal (since shape and type checks are in helpers), and map each Python assert to a named predicate C0 and C1.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (let ((hd (head v))\n                  (tl (tail v)))\n              (IsList tl))\n            false)))\n\n(define-fun-rec list_all_int ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (let ((hd (head v))\n                  (tl (tail v)))\n              (and (is-IntVal hd)\n                   (list_all_int tl)))\n            false)))",
  "basic_structure": "",
  "inputs": "(declare-const arr Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool\n  (IsList arr))",
    "assert_1": "(define-fun C1 () Bool\n  (list_all_int arr))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/752

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: jacobsthal_num
Problem Description:
"""
Write a function to find the nth jacobsthal number.  0, 1, 1, 3, 5, 11, 21, 43, 85, 171, 341, 683, 1365, 2731, ...
assert jacobsthal_num(5) == 11
"""


def jacobsthal_num(n):

	assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
	assert n >= 0, "invalid inputs" # $_CONTRACT_$
 
	dp = [0] * (n + 1) 
	dp[0] = 0
	dp[1] = 1
	for i in range(2, n+1): 
		dp[i] = dp[i - 1] + 2 * dp[i - 2] 
	return dp[n]


Contract List:
assert_0: assert isinstance(n, int), "invalid inputs
assert_1: assert n >= 0, "invalid inputs


<think>
I modelled the integer parameter n with the Value ADT and defined two guarded predicates: C0 checks that n is an IntVal, and C1 enforces n≥0 without unsafe selector use. No extra helpers or basic invariants are needed for these simple contracts.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "",
  "inputs": "(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
    "assert_1": "(define-fun C1 () Bool (and (is-IntVal n) (>= (ival n) 0)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/753

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: min_k
Problem Description:
"""
Write a function to find minimum k records from tuple list.  - in this case a verbatim copy of test cases
assert min_k([('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)], 2) == [('Akash', 2), ('Akshat', 4)]
"""


def min_k(test_list, K):

  assert isinstance(test_list, list), "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(x, tuple) for x in test_list), "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(x[1], (int, float)) for x in test_list), "invalid inputs" # $_CONTRACT_$
  assert K <= len(test_list), "invalid inputs" # $_CONTRACT_$
  res = sorted(test_list, key = lambda x: x[1])[:K]
  return (res) 


Contract List:
assert_0: assert isinstance(test_list, list), "invalid inputs
assert_1: assert all(isinstance(x, tuple) for x in test_list), "invalid inputs
assert_2: assert all(isinstance(x[1], (int, float)) for x in test_list), "invalid inputs
assert_3: assert K <= len(test_list), "invalid inputs


<think>
I extend the ADT with a Tuple constructor and define recursive helpers for list structure, tuple and numeric checks, and list length. Then I declare inputs, assert base structure, and define named predicates C0–C3 mirroring the Python assertions exactly.
</think>
```json
{
  "helper_functions": "(define-fun-rec isList ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (isList (tail l))\n            false)))\n\n(define-fun-rec allIsTuple ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (and (is-Tuple (head l))\n                 (allIsTuple (tail l)))\n            false)))\n\n(define-fun tuple_snd ((t Value)) Value\n  (ite (is-Tuple t)\n       (snd t)\n       Nil))\n\n(define-fun isNumericVal ((v Value)) Bool\n  (or (is-IntVal v) (is-FloatVal v)))\n\n(define-fun-rec allSecondNumeric ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (and (isNumericVal (tuple_snd (head l)))\n                 (allSecondNumeric (tail l)))\n            false)))\n\n(define-fun-rec length ((l Value)) Int\n  (ite (is-Nil l)\n       0\n       (ite (is-Cons l)\n            (+ 1 (length (tail l)))\n            0)))",
  "basic_structure": "(assert (isList test_list))\n(assert (is-IntVal K))",
  "inputs": "(declare-const test_list Value)\n(declare-const K Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (isList test_list))",
    "assert_1": "(define-fun C1 () Bool (allIsTuple test_list))",
    "assert_2": "(define-fun C2 () Bool (allSecondNumeric test_list))",
    "assert_3": "(define-fun C3 () Bool (and (is-IntVal K) (<= (ival K) (length test_list))))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/754

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: extract_index_list
Problem Description:
"""
We say that an element is common for lists l1, l2, l3 if it appears in all three lists under the same index. Write a function to find common elements from three lists. The function should return a list.
assert extract_index_list([1, 1, 3, 4, 5, 6, 7],[0, 1, 2, 3, 4, 5, 7],[0, 1, 2, 3, 4, 5, 7])==[1, 7]
"""


def extract_index_list(l1, l2, l3):

    assert isinstance(l1, list), "invalid inputs" # $_CONTRACT_$
    assert isinstance(l2, list), "invalid inputs" # $_CONTRACT_$
    assert isinstance(l3, list), "invalid inputs" # $_CONTRACT_$
    return [a for a, b, c in zip(l1, l2, l3) if a == b == c]


Contract List:
assert_0: assert isinstance(l1, list), "invalid inputs
assert_1: assert isinstance(l2, list), "invalid inputs
assert_2: assert isinstance(l3, list), "invalid inputs


<think>
I translate each Python isinstance assertion into an SMT predicate Ck that checks list structure via a recursive IsList helper. Inputs are declared as Value, and IsList ensures proper Nil/Cons shapes so that zip‐style traversal is safe.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (or (is-Nil v)\n      (and (is-Cons v)\n           (IsList (tail v)))))",
  "basic_structure": "",
  "inputs": "(declare-const l1 Value)\n(declare-const l2 Value)\n(declare-const l3 Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList l1))",
    "assert_1": "(define-fun C1 () Bool (IsList l2))",
    "assert_2": "(define-fun C2 () Bool (IsList l3))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/755

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: second_smallest
Problem Description:
"""
Write a function to find the second smallest number in a list.
assert second_smallest([1, 2, -8, -2, 0, -2])==-2
"""


def second_smallest(numbers):

  assert isinstance(numbers, list), "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(i, (int, float)) for i in numbers), "invalid inputs" # $_CONTRACT_$
  sorted_set = sorted(set(numbers))
  if len(sorted_set) < 2:
    return None
  return sorted_set[1]


Contract List:
assert_0: assert isinstance(numbers, list), "invalid inputs
assert_1: assert all(isinstance(i, (int, float)) for i in numbers), "invalid inputs


<think>
I model the Python list and numeric checks as recursive SMT predicates over a canonical Value ADT and encapsulate them in named contract predicates C0 and C1. I provide helper functions IsList and list_all_numeric, declare the input, assert minimal executability structure, and define each contract exactly as in the Python code.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec list_all_numeric ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (or (is-IntVal (head v)) (is-FloatVal (head v)))\n                 (list_all_numeric (tail v)))\n            false)))",
  "basic_structure": "(assert (IsList numbers))",
  "inputs": "(declare-const numbers Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList numbers))",
    "assert_1": "(define-fun C1 () Bool (list_all_numeric numbers))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/757

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: count_reverse_pairs
Problem Description:
"""
Write a function to count the pairs of reverse strings in the given string list. 
assert count_reverse_pairs(["julia", "best", "tseb", "for", "ailuj"])== 2
"""


def count_reverse_pairs(test_list):

  assert isinstance(test_list, list), "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(x, str) for x in test_list), "invalid inputs" # $_CONTRACT_$
  return sum(test_list[i+1:].count(s[::-1]) for i, s in enumerate(test_list))


Contract List:
assert_0: assert isinstance(test_list, list), "invalid inputs
assert_1: assert all(isinstance(x, str) for x in test_list), "invalid inputs


<think>
I will translate the Python assertions into SMT‐LIB predicates by defining recursive helpers for list shape and string‐element checks, then map each assert to a named Boolean predicate while enforcing basic list structure for execution.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec list_all_str ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (is-StrVal (head v))\n                 (list_all_str (tail v)))\n            false)))",
  "basic_structure": "(assert (IsList test_list))",
  "inputs": "(declare-const test_list Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList test_list))",
    "assert_1": "(define-fun C1 () Bool (list_all_str test_list))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/758

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: unique_sublists
Problem Description:
"""
Write a function to count lists within a list. The function should return a dictionary where every list is converted to a tuple and the value of such tuple is the number of its occurencies in the original list.
assert unique_sublists([[1, 3], [5, 7], [1, 3], [13, 15, 17], [5, 7], [9, 11]] )=={(1, 3): 2, (5, 7): 2, (13, 15, 17): 1, (9, 11): 1}
"""


def unique_sublists(list1):

    def is_hashable(obj): # $_CONTRACT_$
        try: # $_CONTRACT_$
            hash(obj) # $_CONTRACT_$
            return True # $_CONTRACT_$
        except TypeError: # $_CONTRACT_$
            return False # $_CONTRACT_$
    assert isinstance(list1, list), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(x, list) for x in list1), "invalid inputs" # $_CONTRACT_$
    assert all(is_hashable(tuple(x)) for x in list1), "invalid inputs" # $_CONTRACT_$
    return {tuple(x): list1.count(x) for x in list1}


Contract List:
assert_0: assert isinstance(list1, list), "invalid inputs
assert_1: assert all(isinstance(x, list) for x in list1), "invalid inputs
assert_2: assert all(is_hashable(tuple(x)) for x in list1), "invalid inputs


<think>
I will translate each Python assertion into a precise SMT-LIB predicate, define recursive list and element‐checking helpers to guarantee safe execution, and then wrap each contract as a Boolean Ck without comments.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (or (is-Nil v)\n      (and (is-Cons v)\n           (IsList (tail v)))))\n\n(define-fun-rec AllLists ((l Value)) Bool\n  (or (is-Nil l)\n      (and (is-Cons l)\n           (IsList (head l))\n           (AllLists (tail l)))))\n\n(define-fun-rec AllAtomic ((l Value)) Bool\n  (or (is-Nil l)\n      (and (is-Cons l)\n           (or (is-IntVal (head l))\n               (is-FloatVal (head l))\n               (is-StrVal (head l))\n               (is-BoolVal (head l)))\n           (AllAtomic (tail l)))))\n\n(define-fun-rec AllHashableLists ((l Value)) Bool\n  (or (is-Nil l)\n      (and (is-Cons l)\n           (AllAtomic (head l))\n           (AllHashableLists (tail l)))))",
  "basic_structure": "(assert (IsList list1))",
  "inputs": "(declare-const list1 Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList list1))",
    "assert_1": "(define-fun C1 () Bool (AllLists list1))",
    "assert_2": "(define-fun C2 () Bool (AllHashableLists list1))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/759

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: is_decimal
Problem Description:
"""
Write a function to check whether a given string is a decimal number with a precision of 2.
assert is_decimal('123.11')==True
"""


def is_decimal(num):

    assert isinstance(num, str), "invalid inputs" # $_CONTRACT_$
    import re
    dnumre = re.compile(r"""^[0-9]+(\.[0-9]{1,2})?$""")
    return dnumre.search(num) is not None


Contract List:
assert_0: assert isinstance(num, str), "invalid inputs


<think>
I model the Python isinstance check as an SMT tester ensuring the input is a StrVal, declare the input as Value, and leave helper_functions and basic_structure empty since no additional ADTs or recursive helpers are required.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "",
  "inputs": "(declare-const num Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-StrVal num))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/760

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: unique_Element
Problem Description:
"""
Write a python function to check whether a list of numbers contains only one distinct element or not.
assert unique_Element([1,1,1]) == True
"""


def unique_Element(arr):

    assert isinstance(arr, list), "invalid inputs" # $_CONTRACT_$
    assert len(arr) > 0, "invalid inputs" # $_CONTRACT_$
    return arr.count(arr[0]) == len(arr)


Contract List:
assert_0: assert isinstance(arr, list), "invalid inputs
assert_1: assert len(arr) > 0, "invalid inputs


<think>
I define recursive helpers for list structure (IsList) and length, declare the input, enforce basic executability by asserting the list shape, and translate each Python assert into a precise SMT-LIB predicate C0 and C1.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n(define-fun-rec length ((v Value)) Int\n  (ite (is-Nil v)\n       0\n       (ite (is-Cons v)\n            (+ 1 (length (tail v)))\n            0)))",
  "basic_structure": "(assert (IsList arr))",
  "inputs": "(declare-const arr Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList arr))",
    "assert_1": "(define-fun C1 () Bool (> (length arr) 0))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/762

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: check_monthnumber_number
Problem Description:
"""
Write a function to check whether the given month number contains 30 days or not. Months are given as number from 1 to 12.
assert check_monthnumber_number(6)==True
"""


def check_monthnumber_number(monthnum3):

  assert isinstance(monthnum3, int), "invalid inputs" # $_CONTRACT_$
  assert 1 <= monthnum3 <= 12, "invalid inputs" # $_CONTRACT_$
  return monthnum3==4 or monthnum3==6 or monthnum3==9 or monthnum3==11


Contract List:
assert_0: assert isinstance(monthnum3, int), "invalid inputs
assert_1: assert 1 <= monthnum3 <= 12, "invalid inputs


<think>
I will translate each Python assertion into an SMT-LIB predicate with named contracts and define a helper getInt for safe IntVal extraction.
</think>
```json
{
  "helper_functions": "(define-fun getInt ((v Value)) Int\n  (ite (is-IntVal v) (ival v) 0))",
  "basic_structure": "",
  "inputs": "(declare-const monthnum3 Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool\n  (is-IntVal monthnum3))",
    "assert_1": "(define-fun C1 () Bool\n  (and (>= (getInt monthnum3) 1)\n       (<= (getInt monthnum3) 12)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/763

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: find_min_diff
Problem Description:
"""
Write a python function to find the minimum difference between any two elements in a given array. 
assert find_min_diff((1,5,3,19,18,25),6) == 1
"""


def find_min_diff(arr,n):

    assert isinstance(arr, tuple), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(x, (int, float)) for x in arr), "invalid inputs" # $_CONTRACT_$
    assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
    assert n == len(arr), "invalid inputs" # $_CONTRACT_$ 
 
    arr = sorted(arr) 
    diff = 10**20 
    for i in range(n-1): 
        if arr[i+1] - arr[i] < diff: 
            diff = arr[i+1] - arr[i]  
    return diff 


Contract List:
assert_0: assert isinstance(arr, tuple), "invalid inputs
assert_1: assert all(isinstance(x, (int, float)) for x in arr), "invalid inputs
assert_2: assert isinstance(n, int), "invalid inputs
assert_3: assert n == len(arr), "invalid inputs


<think>
I translated the tuple and element-type checks into recursive List ADT predicates, defined safe length and numeric‐content helpers, declared inputs, asserted minimal shape invariants for executability, and mapped each Python assertion to a named SMT Boolean predicate.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v) true\n    (ite (is-Cons v)\n      (IsList (tail v))\n      false)))\n\n(define-fun-rec list_length ((v Value)) Int\n  (ite (is-Nil v) 0\n    (ite (is-Cons v)\n      (+ 1 (list_length (tail v)))\n      0)))\n\n(define-fun-rec list_all_numeric ((v Value)) Bool\n  (ite (is-Nil v) true\n    (ite (is-Cons v)\n      (and (or (is-IntVal (head v)) (is-FloatVal (head v)))\n           (list_all_numeric (tail v)))\n      false)))",
  "basic_structure": "(assert (IsList arr))\n(assert (is-IntVal n))",
  "inputs": "(declare-const arr Value)\n(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList arr))",
    "assert_1": "(define-fun C1 () Bool (list_all_numeric arr))",
    "assert_2": "(define-fun C2 () Bool (is-IntVal n))",
    "assert_3": "(define-fun C3 () Bool (and (is-IntVal n) (= (ival n) (list_length arr))))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/764

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: number_ctr
Problem Description:
"""
Write a python function to count number of digits in a given string.
assert number_ctr('program2bedone') == 1
"""


def number_ctr(s):

    assert isinstance(s, str), "invalid inputs" # $_CONTRACT_$
    return sum(c.isdigit() for c in s)


Contract List:
assert_0: assert isinstance(s, str), "invalid inputs


<think>
I translate the Python isinstance check into an SMT predicate that ensures the input is a StrVal in the ADT, and provide a minimal template with the ADT, input declaration, and the named contract C0.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "",
  "inputs": "(declare-const s Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-StrVal s))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/765

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: is_polite
Problem Description:
"""
Write a function to find nth polite number. geeksforgeeks.org/n-th-polite-number/
assert is_polite(7) == 11
"""


import math 
def is_polite(n):

	assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
	assert n >= 1, "invalid inputs" # $_CONTRACT_$
 
	n = n + 1
	return (int)(n+(math.log((n + math.log(n, 2)), 2))) 


Contract List:
assert_0: assert isinstance(n, int), "invalid inputs
assert_1: assert n >= 1, "invalid inputs


<think>
I translate each Python assertion into an equivalent SMT-LIB predicate, using a SafeIval helper to guard the integer selector and avoid unsafe access. The basic structure remains empty because SafeIval ensures execution safety over any Value. Each contract Ck is defined as a standalone Bool.
</think>
```json
{
  "helper_functions": "(define-fun SafeIval ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
  "basic_structure": "",
  "inputs": "(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
    "assert_1": "(define-fun C1 () Bool (ite (is-IntVal n) (>= (ival n) 1) false))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/766

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: pair_wise
Problem Description:
"""
Write a function to return a list of all pairs of consecutive items in a given list.
assert pair_wise([1,1,2,3,3,4,4,5])==[(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]
"""


def pair_wise(l1):

    assert isinstance(l1, list), "invalid inputs" # $_CONTRACT_$
    return list(zip(l1, l1[1:]))


Contract List:
assert_0: assert isinstance(l1, list), "invalid inputs


<think>
I translated the list-type assertion into an SMT-LIB predicate using a recursive IsList helper over the canonical ADT, enforced as both a basic-structure invariant and as the contract C0. The template declares the input, defines the necessary helper, asserts executability, and precisely models the Python isinstance check.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((x Value)) Bool (ite (is-Nil x) true (ite (is-Cons x) (IsList (tail x)) false)))",
  "basic_structure": "(assert (IsList l1))",
  "inputs": "(declare-const l1 Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList l1))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/767

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: get_pairs_count
Problem Description:
"""
Write a python function to count the number of pairs whose sum is equal to ‘sum’. The funtion gets as input a list of numbers and the sum,
assert get_pairs_count([1,1,1,1],2) == 6
"""


def get_pairs_count(arr, sum_):

    assert isinstance(arr, list), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(x, (int, float)) for x in arr), "invalid inputs" # $_CONTRACT_$
    assert isinstance(sum_, (int, float)), "invalid inputs" # $_CONTRACT_$
    cnt = 0
    for n in arr:
        cnt += arr.count(sum_ - n)
        if sum_ - n == n:
            cnt -= 1
    return cnt / 2


Contract List:
assert_0: assert isinstance(arr, list), "invalid inputs
assert_1: assert all(isinstance(x, (int, float)) for x in arr), "invalid inputs
assert_2: assert isinstance(sum_, (int, float)), "invalid inputs


<think>
I define recursive helper functions to model list structure and numeric element checks, then declare inputs and express each Python assertion as a precise SMT-LIB predicate while keeping basic list-shape constraints separate for executability.
</think>
```json
{
  "helper_functions": "(define-fun-rec isList ((l Value)) Bool\n  (or\n    (is-Nil l)\n    (and\n      (is-Cons l)\n      (let ((t (tail l)))\n        (isList t)))))\n\n(define-fun-rec list_all_numeric ((l Value)) Bool\n  (ite\n    (is-Nil l)\n    true\n    (and\n      (is-Cons l)\n      (let ((h (head l)) (t (tail l)))\n        (and\n          (or (is-IntVal h) (is-FloatVal h))\n          (list_all_numeric t))))))",
  "basic_structure": "(assert (isList arr))",
  "inputs": "(declare-const arr Value)\n(declare-const sum_ Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (isList arr))",
    "assert_1": "(define-fun C1 () Bool (list_all_numeric arr))",
    "assert_2": "(define-fun C2 () Bool (or (is-IntVal sum_) (is-FloatVal sum_)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/769

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: Diff
Problem Description:
"""
Write a python function to get the difference between two lists.
assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
"""


def Diff(li1,li2):

    assert isinstance(li1, list), "invalid inputs" # $_CONTRACT_$
    assert isinstance(li2, list), "invalid inputs" # $_CONTRACT_$
    return list(set(li1)-set(li2)) + list(set(li2)-set(li1))
 


Contract List:
assert_0: assert isinstance(li1, list), "invalid inputs
assert_1: assert isinstance(li2, list), "invalid inputs


<think>
I translate each Python type check into named SMT predicates using a recursive IsList helper, declare inputs as Value, keep basic structure minimal for executability, and define C0/C1 for li1/li2 being lists.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (or (is-Nil v)\n      (and (is-Cons v)\n           (let ((tl (tail v)))\n             (IsList tl)))))",
  "basic_structure": "",
  "inputs": "(declare-const li1 Value)\n(declare-const li2 Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList li1))",
    "assert_1": "(define-fun C1 () Bool (IsList li2))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/770

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: odd_num_sum
Problem Description:
"""
Write a python function to find the sum of fourth power of first n odd natural numbers.
assert odd_num_sum(2) == 82
"""


def odd_num_sum(n) :

    assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
    assert n >= 1, "invalid inputs" # $_CONTRACT_$
 
    j = 0
    sm = 0
    for i in range(1,n + 1) : 
        j = (2*i-1) 
        sm = sm + (j*j*j*j)   
    return sm 


Contract List:
assert_0: assert isinstance(n, int), "invalid inputs
assert_1: assert n >= 1, "invalid inputs


<think>
I translate the Python `isinstance` and `>=` assertions into SMT predicates using a guarded integer extractor (`SafeI`), ensuring selector safety and preserving executability without extra invariants.
</think>
```json
{
  "helper_functions": "(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
  "basic_structure": "",
  "inputs": "(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
    "assert_1": "(define-fun C1 () Bool (>= (SafeI n) 1))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/771

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: check_expression
Problem Description:
"""
Write a function to check if the given expression is balanced or not. 
assert check_expression("{()}[{}]") == True
"""


from collections import deque
def check_expression(exp):

    assert isinstance(exp, str), "invalid inputs" # $_CONTRACT_$
    if len(exp) == 0 or len(exp) % 2 == 1:
        return False
    stack = deque()
    for ch in exp:
        if ch == '(' or ch == '{' or ch == '[':
            stack.append(ch)
        if ch == ')' or ch == '}' or ch == ']':
            if not stack:
                return False
            top = stack.pop()
            if (top == '(' and ch != ')') or (top == '{' and ch != '}' or (top == '[' and ch != ']')):
                return False
    return not stack


Contract List:
assert_0: assert isinstance(exp, str), "invalid inputs


<think>
I model the Python string‐type check as an SMT “is-StrVal” predicate, provide a SafeS helper for safe string extraction, declare the input, assert only the universal basic-structure invariant, and define C0 to represent the isinstance(exp, str) contract.
</think>
```json
{
  "helper_functions": "(define-fun SafeS ((v Value)) String\n  (ite (is-StrVal v) (sval v) \"\"))",
  "basic_structure": "(assert true)",
  "inputs": "(declare-const exp Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool\n  (is-StrVal exp))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/772

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: remove_length
Problem Description:
"""
Write a function to remove all the words with k length in the given string.
assert remove_length('The person is most value tet', 3) == 'person is most value'
"""


def remove_length(test_str, K):

  assert isinstance(test_str, str), "invalid inputs" # $_CONTRACT_$
  assert isinstance(K, int), "invalid inputs" # $_CONTRACT_$
  return ' '.join([i for i in test_str.split() if len(i) != K])


Contract List:
assert_0: assert isinstance(test_str, str), "invalid inputs
assert_1: assert isinstance(K, int), "invalid inputs


<think>
I map Python type assertions to SMT “is-<Ctor>” predicates, ensure inputs as Value ADTs, declare test_str and K, assert their constructors in the basic structure, and define C0/C1 accordingly.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "(assert (is-StrVal test_str))\n(assert (is-IntVal K))",
  "inputs": "(declare-const test_str Value)\n(declare-const K Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-StrVal test_str))",
    "assert_1": "(define-fun C1 () Bool (is-IntVal K))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/773

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: occurance_substring
Problem Description:
"""
Write a function to find the occurrence and position of the substrings within a string. Return None if there is no match.
assert occurance_substring('python programming, python language','python')==('python', 0, 6)
"""


import re
def occurance_substring(text,pattern):

 assert isinstance(text, str), "invalid inputs" # $_CONTRACT_$
 assert isinstance(pattern, str), "invalid inputs" # $_CONTRACT_$
 for match in re.finditer(pattern, text):
    s = match.start()
    e = match.end()
    return (text[s:e], s, e)
 return None


Contract List:
assert_0: assert isinstance(text, str), "invalid inputs
assert_1: assert isinstance(pattern, str), "invalid inputs


<think>
I will define a SafeS helper to extract string values, assert basic ADT shape for text and pattern, and model each isinstance check as a named predicate matching Python’s semantics.
</think>
```json
{
  "helper_functions": "(define-fun SafeS ((v Value)) String (ite (is-StrVal v) (sval v) \"\"))",
  "basic_structure": "(assert (is-StrVal text))\n(assert (is-StrVal pattern))",
  "inputs": "(declare-const text Value)\n(declare-const pattern Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-StrVal text))",
    "assert_1": "(define-fun C1 () Bool (is-StrVal pattern))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/775

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: odd_position
Problem Description:
"""
Write a python function to check whether every odd index contains odd numbers of a given list.
assert odd_position([2,1,4,3,6,7,6,3]) == True
"""


def odd_position(nums):

	assert isinstance(nums, list), "invalid inputs" # $_CONTRACT_$
	assert all(isinstance(n, int) for n in nums), "invalid inputs" # $_CONTRACT_$
	return all(n % 2 == 1 for n in nums[1::2])


Contract List:
assert_0: assert isinstance(nums, list), "invalid inputs
assert_1: assert all(isinstance(n, int) for n in nums), "invalid inputs


<think>
I translate the Python assertions into precise SMT-LIB predicates by first defining recursive helpers for list structure and integer‐element checks. Then I declare the input, assert basic executability invariants, and map each Python assert to a named Boolean contract.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (or (is-Nil v)\n      (and (is-Cons v) (IsList (tail v)))))\n\n(define-fun-rec list_all_int ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (and (is-Cons v)\n            (let ((h (head v)) (t (tail v)))\n              (and (is-IntVal h)\n                   (list_all_int t))))))",
  "basic_structure": "(assert (IsList nums))",
  "inputs": "(declare-const nums Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList nums))",
    "assert_1": "(define-fun C1 () Bool (list_all_int nums))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/777

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: find_sum
Problem Description:
"""
Write a python function to find the sum of non-repeated elements in a given list.
assert find_sum([1,2,3,1,1,4,5,6]) == 21
"""


def find_sum(arr):

    assert isinstance(arr, list), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(x, (int, float)) for x in arr), "invalid inputs" # $_CONTRACT_$
 
    return sum(set(arr))


Contract List:
assert_0: assert isinstance(arr, list), "invalid inputs
assert_1: assert all(isinstance(x, (int, float)) for x in arr), "invalid inputs


<think>
I define an ADT-based list checker and a numeric validator to enforce that `arr` is a proper list of numbers, then translate each Python assert into an SMT predicate C0 and C1 preserving exact semantics.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v) true\n    (ite (is-Cons v) (IsList (tail v)) false)))\n\n(define-fun IsNumeric ((v Value)) Bool\n  (or (is-IntVal v) (is-FloatVal v)))\n\n(define-fun-rec list_all_numeric ((lst Value)) Bool\n  (ite (is-Nil lst) true\n    (ite (is-Cons lst)\n      (and (IsNumeric (head lst)) (list_all_numeric (tail lst)))\n      false)))",
  "basic_structure": "(assert (IsList arr))",
  "inputs": "(declare-const arr Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList arr))",
    "assert_1": "(define-fun C1 () Bool (list_all_numeric arr))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/778

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: pack_consecutive_duplicates
Problem Description:
"""
Write a function to pack consecutive duplicates of a given list elements into sublists.
assert pack_consecutive_duplicates([0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4])==[[0, 0], [1], [2], [3], [4, 4], [5], [6, 6, 6], [7], [8], [9], [4, 4]]
"""


from itertools import groupby
def pack_consecutive_duplicates(list1):

    assert isinstance(list1, list), "invalid inputs" # $_CONTRACT_$
    return [list(group) for _, group in groupby(list1)]


Contract List:
assert_0: assert isinstance(list1, list), "invalid inputs


<think>
I will translate the Python isinstance(list1, list) assertion into a recursive SMT predicate for list shape, ensure executability by asserting IsList on the input, and define C0 to exactly mirror the contract.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (or (is-Nil v)\n      (and (is-Cons v)\n           (IsList (tail v)))))",
  "basic_structure": "(assert (IsList list1))",
  "inputs": "(declare-const list1 Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList list1))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/780

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: find_combinations
Problem Description:
"""
Write a function to find the combinations of sums with tuples in the given tuple list. 
assert find_combinations([(2, 4), (6, 7), (5, 1), (6, 10)]) == [(8, 11), (7, 5), (8, 14), (11, 8), (12, 17), (11, 11)]
"""


from itertools import combinations 
def find_combinations(test_list):

  assert isinstance(test_list, list), "invalid inputs" # $_CONTRACT_$
  assert len(test_list) > 0, "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(t, tuple) for t in test_list), "invalid inputs" # $_CONTRACT_$
  assert all(len(t) == len(test_list[0]) for t in test_list), "invalid inputs" # $_CONTRACT_$))
  assert all(isinstance(x, (int, float)) for t in test_list for x in t), "invalid inputs" # $_CONTRACT_$
  return [tuple(map(sum, zip(*t))) for t in combinations(test_list, 2)]


Contract List:
assert_0: assert isinstance(test_list, list), "invalid inputs
assert_1: assert len(test_list) > 0, "invalid inputs
assert_2: assert all(isinstance(t, tuple) for t in test_list), "invalid inputs
assert_3: assert all(len(t) == len(test_list[0]) for t in test_list), "invalid inputs" ))
assert_4: assert all(isinstance(x, (int, float)) for t in test_list for x in t), "invalid inputs


<think>
I will translate the Python input‐validation assertions into precise SMT‐LIB predicates, define necessary recursive helpers (IsList, list_length, all_same_length, all_numeric, all_numeric_tuples) to enforce ADT shape and flatten checks, and capture each assert as C0…C4. The basic structure ensures the input is a well‐formed list before any contract.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec list_length ((v Value)) Int\n  (ite (is-Nil v)\n       0\n       (ite (is-Cons v)\n            (+ 1 (list_length (tail v)))\n            0)))\n\n(define-fun-rec all_same_length ((lst Value) (base_len Int)) Bool\n  (ite (is-Nil lst)\n       true\n       (ite (is-Cons lst)\n            (let ((h (head lst)) (t (tail lst)))\n              (and (= (list_length h) base_len)\n                   (all_same_length t base_len)))\n            false)))\n\n(define-fun-rec all_numeric ((lst Value)) Bool\n  (ite (is-Nil lst)\n       true\n       (ite (is-Cons lst)\n            (let ((h (head lst)) (t (tail lst)))\n              (and (or (is-IntVal h) (is-FloatVal h))\n                   (all_numeric t)))\n            false)))\n\n(define-fun-rec all_numeric_tuples ((lst Value)) Bool\n  (ite (is-Nil lst)\n       true\n       (ite (is-Cons lst)\n            (let ((h (head lst)) (t (tail lst)))\n              (and (all_numeric h)\n                   (all_numeric_tuples t)))\n            false)))",
  "basic_structure": "(assert (IsList test_list))",
  "inputs": "(declare-const test_list Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool\n  (IsList test_list))",
    "assert_1": "(define-fun C1 () Bool\n  (> (list_length test_list) 0))",
    "assert_2": "(define-fun C2 () Bool\n  (all_same_length (Cons test_list Nil) 0))",
    "assert_3": "(define-fun C3 () Bool\n  (all_same_length test_list\n                   (ite (is-Cons test_list)\n                        (list_length (head test_list))\n                        0)))",
    "assert_4": "(define-fun C4 () Bool\n  (all_numeric_tuples test_list))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/781

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: count_divisors
Problem Description:
"""
Write a python function to check whether the count of divisors is even. 
assert count_divisors(10)
"""


import math 
def count_divisors(n) :

    assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
    assert n > 0, "invalid inputs" # $_CONTRACT_$
 
    cnt = 0
    for i in range(1, (int)(math.sqrt(n)) + 1) : 
        if (n % i == 0) : 
            if (n / i == i) : 
                cnt = cnt + 1
            else : 
                cnt = cnt + 2
    return cnt % 2 == 0


Contract List:
assert_0: assert isinstance(n, int), "invalid inputs
assert_1: assert n > 0, "invalid inputs


<think>
I model Python’s isinstance and range checks as SMT predicates over an ADT Value, introduce a safe extractor for IntVal to ensure well‐formedness, and define each assertion contract as a standalone Boolean Ck.
</think>
```json
{
  "helper_functions": "(define-fun safe-ival ((v Value)) Int\n  (ite (is-IntVal v) (ival v) 0))",
  "basic_structure": "",
  "inputs": "(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
    "assert_1": "(define-fun C1 () Bool (and (is-IntVal n) (> (ival n) 0)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/782

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: odd_length_sum
Problem Description:
"""
Write a python function to find the sum of all odd length subarrays. 
assert odd_length_sum([1,2,4]) == 14
"""


def odd_length_sum(arr):

    assert isinstance(arr, list), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(x, (int, float)) for x in arr), "invalid inputs" # $_CONTRACT_$
    sum_ = 0
    n = len(arr)
    for i in range(n):
        # arr[i] occurs (i + 1) * (n - i) times in all subarrays
        times = ((i + 1) * (n - i) + 1) // 2
        sum_ += arr[i] * times
    return sum_


Contract List:
assert_0: assert isinstance(arr, list), "invalid inputs
assert_1: assert all(isinstance(x, (int, float)) for x in arr), "invalid inputs


<think>
I translate the Python type and structural checks into recursive SMT predicates over a canonical Value ADT, define list shape and numeric-element helpers, then expose each assertion as a named Boolean (C0, C1) matching the Python `assert` semantics. This template ensures well-formed lists and element types without entangling them, supporting isolated or combined violation testing.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (ite (is-Nil l)\n    true\n    (ite (is-Cons l)\n      (IsList (tail l))\n      false)))\n\n(define-fun IsNumeric ((v Value)) Bool\n  (or (is-IntVal v) (is-FloatVal v)))\n\n(define-fun-rec list_all_numeric ((l Value)) Bool\n  (ite (is-Nil l)\n    true\n    (ite (is-Cons l)\n      (and (IsNumeric (head l))\n           (list_all_numeric (tail l)))\n      false)))",
  "basic_structure": "",
  "inputs": "(declare-const arr Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList arr))",
    "assert_1": "(define-fun C1 () Bool (list_all_numeric arr))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/784

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: mul_even_odd
Problem Description:
"""
Write a function to find the product of first even and odd number of a given list.
assert mul_even_odd([1,3,5,7,4,1,6,8])==4
"""


def mul_even_odd(list1):

    assert isinstance(list1, list), "invalid inputs" # $_CONTRACT_$
    assert any(x % 2 == 0 for x in list1), "invalid inputs" # $_CONTRACT_$
    assert any(x % 2 != 0 for x in list1), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(x, (int, float)) for x in list1), "invalid inputs" # $_CONTRACT_$
    first_even = next((el for el in list1 if el%2==0),-1)
    first_odd = next((el for el in list1 if el%2!=0),-1)
    return (first_even*first_odd)


Contract List:
assert_0: assert isinstance(list1, list), "invalid inputs
assert_1: assert any(x % 2 == 0 for x in list1), "invalid inputs
assert_2: assert any(x % 2 != 0 for x in list1), "invalid inputs
assert_3: assert all(isinstance(x, (int, float)) for x in list1), "invalid inputs


<think>
I model the Python list structure and numeric checks with recursive SMT predicates over the Value ADT, ensuring safe selectors and structural guards. Each Python assert becomes a Boolean predicate C0–C3, using helper functions IsList, list_any_even, list_any_odd, and list_all_numeric for precise semantics.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (IsList (tail l))\n            false)))\n\n(define-fun-rec list_all_numeric ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (and (or (is-IntVal (head l)) (is-FloatVal (head l)))\n                 (list_all_numeric (tail l)))\n            false)))\n\n(define-fun-rec list_any_even ((l Value)) Bool\n  (ite (is-Nil l)\n       false\n       (ite (is-Cons l)\n            (let ((h (head l)))\n              (ite (and (is-IntVal h)\n                       (= (mod (ival h) 2) 0))\n                   true\n                   (list_any_even (tail l))))\n            false)))\n\n(define-fun-rec list_any_odd ((l Value)) Bool\n  (ite (is-Nil l)\n       false\n       (ite (is-Cons l)\n            (let ((h (head l)))\n              (ite (and (is-IntVal h)\n                       (= (mod (ival h) 2) 1))\n                   true\n                   (list_any_odd (tail l))))\n            false)))",
  "basic_structure": "(assert (IsList list1))",
  "inputs": "(declare-const list1 Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList list1))",
    "assert_1": "(define-fun C1 () Bool (list_any_even list1))",
    "assert_2": "(define-fun C2 () Bool (list_any_odd list1))",
    "assert_3": "(define-fun C3 () Bool (list_all_numeric list1))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/785

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: tuple_str_int
Problem Description:
"""
Write a function to convert tuple string to integer tuple.
assert tuple_str_int("(7, 8, 9)") == (7, 8, 9)
"""


def tuple_str_int(test_str):

  assert isinstance(test_str, str), "invalid inputs" # $_CONTRACT_$
  assert test_str.startswith('('), "invalid inputs" # $_CONTRACT_$
  assert test_str.endswith(')'), "invalid inputs" # $_CONTRACT_$
  assert test_str.lstrip('(').rstrip(')').replace('...', '').replace(',', '').replace(' ', '').isdigit(), "invalid inputs" # $_CONTRACT_$
  return tuple(int(num) for num in test_str.replace('(', '').replace(')', '').replace('...', '').split(', '))


Contract List:
assert_0: assert isinstance(test_str, str), "invalid inputs
assert_1: assert test_str.startswith('('), "invalid inputs
assert_2: assert test_str.endswith(')'), "invalid inputs
assert_3: assert test_str.lstrip('(').rstrip(')').replace('...', '').replace(',', '').replace(' ', '').isdigit(), "invalid inputs


<think>
I will model the string‐tuple parser’s input checks as precise SMT predicates, using an ADT for Value and helper functions for safe string extraction and regex‐based digit validation, ensuring each contract can be tested in isolation or in combination.
</think>
```json
{
  "helper_functions": "(define-fun SafeStr ((v Value)) String\n  (ite (is-StrVal v) (sval v) \"\"))\n\n(define-fun-rec replace_all ((s String) (target String) (rep String)) String\n  (ite (str.contains s target)\n       (let ((idx (str.indexof s target 0)))\n         (let ((pre  (str.substr s 0 idx))\n               (post (str.substr s\n                               (+ idx (str.len target))\n                               (- (str.len s) (+ idx (str.len target))))))\n           (str.++ pre rep (replace_all post target rep))))\n       s))\n\n(define-fun is_digit_string ((s String)) Bool\n  (str.in.re s (re.+ (re.range \"0\" \"9\"))))",
  "basic_structure": "",
  "inputs": "(declare-const test_str Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool\n  (is-StrVal test_str))",
    "assert_1": "(define-fun C1 () Bool\n  (and (is-StrVal test_str)\n       (str.prefixof \"(\" (SafeStr test_str))))",
    "assert_2": "(define-fun C2 () Bool\n  (and (is-StrVal test_str)\n       (str.suffixof \")\" (SafeStr test_str))))",
    "assert_3": "(define-fun C3 () Bool\n  (let ((s0 (SafeStr test_str)))\n    (let ((inner (ite (and (str.prefixof \"(\" s0)\n                           (str.suffixof \")\" s0))\n                       (str.substr s0 1 (- (str.len s0) 2))\n                       \"\")))\n      (let ((s1 (replace_all inner \"...\" \"\")))\n        (let ((s2 (replace_all s1 \",\" \"\")))\n          (let ((s3 (replace_all s2 \" \" \"\")))\n            (is_digit_string s3))))))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/786

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: right_insertion
Problem Description:
"""
Write a function to locate the right insertion point for a specified value in sorted order.
assert right_insertion([1,2,4,5],6)==4
"""


import bisect
def right_insertion(a, x):

    assert isinstance(a, list), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(item, (int, float)) for item in a), "invalid inputs" # $_CONTRACT_$
    assert isinstance(x, (int, float)), "invalid inputs" # $_CONTRACT_$
    return bisect.bisect_right(a, x)


Contract List:
assert_0: assert isinstance(a, list), "invalid inputs
assert_1: assert all(isinstance(item, (int, float)) for item in a), "invalid inputs
assert_2: assert isinstance(x, (int, float)), "invalid inputs


<think>
I will translate the Python input checks into SMT-LIB predicates, define a minimal ADT-based list structure with recursive helpers for list‐shape and numeric content, declare the inputs, and capture each `assert` as a named Boolean (C0, C1, C2).
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec list_all_numeric ((lst Value)) Bool\n  (ite (is-Nil lst)\n       true\n       (ite (is-Cons lst)\n            (and (or (is-IntVal (head lst)) (is-FloatVal (head lst)))\n                 (list_all_numeric (tail lst)))\n            false)))",
  "basic_structure": "(assert (IsList a))",
  "inputs": "(declare-const a Value)\n(declare-const x Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList a))",
    "assert_1": "(define-fun C1 () Bool (list_all_numeric a))",
    "assert_2": "(define-fun C2 () Bool (or (is-IntVal x) (is-FloatVal x)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/787

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: text_match_three
Problem Description:
"""
Write a function that matches a string that has an a followed by three 'b'.
assert not text_match_three("ac")
"""


import re
def text_match_three(text):

        assert isinstance(text, str), "invalid inputs" # $_CONTRACT_$
        patterns = 'ab{3}?'
        return re.search(patterns,  text)


Contract List:
assert_0: assert isinstance(text, str), "invalid inputs


<think>
I model the Python assert as an SMT predicate C0 requiring the ADT value to be a StrVal, provide a SafeS helper for safe string extraction, and declare the input for systematic contract violation testing.
</think>
```json
{
  "helper_functions": "(define-fun SafeS ((v Value)) String\n  (ite (is-StrVal v) (sval v) \"\"))",
  "basic_structure": "",
  "inputs": "(declare-const text Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool\n  (is-StrVal text))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/788

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: new_tuple
Problem Description:
"""
Write a function to create a new tuple from the given string and list.
assert new_tuple(["WEB", "is"], "best") == ('WEB', 'is', 'best')
"""


def new_tuple(test_list, test_str):

  assert isinstance(test_list, list), "invalid inputs" # $_CONTRACT_$
  assert isinstance(test_str, str), "invalid inputs" # $_CONTRACT_$
  return tuple(test_list + [test_str])


Contract List:
assert_0: assert isinstance(test_list, list), "invalid inputs
assert_1: assert isinstance(test_str, str), "invalid inputs


<think>
I translated the Python `isinstance` checks into precise SMT-LIB predicates and added a recursive `IsList` helper to guarantee list‐shaped inputs. The input declarations and contract predicates (C0, C1) directly mirror the two asserts.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((l Value)) Bool (ite (is-Nil l) true (ite (is-Cons l) (IsList (tail l)) false)))",
  "basic_structure": "",
  "inputs": "(declare-const test_list Value)\n(declare-const test_str Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList test_list))",
    "assert_1": "(define-fun C1 () Bool (is-StrVal test_str))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/790

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: even_position
Problem Description:
"""
Write a python function to check whether every even index contains even numbers of a given list.
assert even_position([3,2,1]) == False
"""


def even_position(nums):

	assert isinstance(nums, list), "invalid inputs" # $_CONTRACT_$
	assert all(isinstance(i, int) for i in nums), "invalid inputs" # $_CONTRACT_$
	return all(nums[i]%2==i%2 for i in range(len(nums)))


Contract List:
assert_0: assert isinstance(nums, list), "invalid inputs
assert_1: assert all(isinstance(i, int) for i in nums), "invalid inputs


<think>
I translate the Python asserts into precise SMT predicates, define ADT and recursive helpers for list structure and integer checks, and separate basic executability (shape) from the contract predicates C0/C1.
</think>
```json
{
  "helper_functions": "(define-fun isNil ((v Value)) Bool (is-Nil v))\n(define-fun isCons ((v Value)) Bool (is-Cons v))\n(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n(define-fun-rec ListAllInt ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (is-IntVal (head v))\n                 (ListAllInt (tail v)))\n            false)))\n(define-fun-rec ListAllEven ((v Value) (idx Int)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (let ((h (head v)) (t (tail v)))\n              (ite (is-IntVal h)\n                   (and (= (mod (ival h) 2) (mod idx 2))\n                        (ListAllEven t (+ idx 1)))\n                   false))\n            false)))",
  "basic_structure": "(assert IsList nums)",
  "inputs": "(declare-const nums Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList nums))",
    "assert_1": "(define-fun C1 () Bool (ListAllInt nums))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/791

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: remove_nested
Problem Description:
"""
Write a function to remove tuples from the given tuple.
assert remove_nested((1, 5, 7, (4, 6), 10)) == (1, 5, 7, 10)
"""


def remove_nested(test_tup):

  assert isinstance(test_tup, tuple), "invalid inputs" # $_CONTRACT_$
  return tuple(e for e in test_tup if not isinstance(e, tuple))


Contract List:
assert_0: assert isinstance(test_tup, tuple), "invalid inputs


<think>
I model Python tuples as linked-list ADTs and translate the isinstance check into an IsList predicate. I provide an SMT-LIB template with ADT, a recursive IsList helper, the input declaration, a basic executability axiom, and a contract predicate C0 matching the Python assertion.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))",
  "basic_structure": "(assert (IsList test_tup))",
  "inputs": "(declare-const test_tup Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList test_tup))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/792

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: count_list
Problem Description:
"""
Write a python function to count the number of lists in a given number of lists.
assert count_list([[1, 3], [5, 7], [9, 11], [13, 15, 17]]) == 4
"""


def count_list(input_list):

    assert isinstance(input_list, list), "invalid inputs" # $_CONTRACT_$
 
    return sum(isinstance(e, list) for e in input_list)


Contract List:
assert_0: assert isinstance(input_list, list), "invalid inputs


<think>
I model the Python list type assertion as an SMT predicate C0 over a recursive ADT-based IsList function, ensuring precise encoding of list structure without extra invariants in the basic structure.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (or (is-Nil v)\n      (and (is-Cons v)\n           (IsList (tail v)))))",
  "basic_structure": "",
  "inputs": "(declare-const input_list Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList input_list))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/793

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: last
Problem Description:
"""
Write a python function to find the last position of an element in a sorted array.
assert last([1,2,3],1) == 0
"""


def last(arr,x):

    assert isinstance(arr, list), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(i, (int, arr)) for i in arr), "invalid inputs" # $_CONTRACT_$
    assert all(a <= b for a, b in zip(arr, arr[1:])), "invalid inputs" # $_CONTRACT_$
    assert isinstance(x, (int, float)), "invalid inputs" # $_CONTRACT_$
    assert x in arr, "invalid inputs" # $_CONTRACT_$
    return len(arr)-arr[::-1].index(x) - 1


Contract List:
assert_0: assert isinstance(arr, list), "invalid inputs
assert_1: assert all(isinstance(i, (int, arr)) for i in arr), "invalid inputs
assert_2: assert all(a <= b for a, b in zip(arr, arr[1:])), "invalid inputs
assert_3: assert isinstance(x, (int, float)), "invalid inputs
assert_4: assert x in arr, "invalid inputs


<think>
I will encode the Python “last” function’s input‐validation asserts into SMT, defining a Value ADT and helper functions (IsList, SafeReal, list_all_numeric, list_sorted, Value_eq, in_list), then map each assert to a named predicate C0–C4 while ensuring basic structure constraints for executability.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (or (is-Nil v)\n      (and (is-Cons v)\n           (IsList (tail v)))))\n\n(define-fun SafeReal ((v Value)) Real\n  (ite (is-IntVal v)\n       (to_real (ival v))\n       (ite (is-FloatVal v)\n            (fval v)\n            0)))\n\n(define-fun-rec list_all_numeric ((v Value)) Bool\n  (or (is-Nil v)\n      (and (is-Cons v)\n           (let ((h (head v)) (t (tail v)))\n             (and (or (is-IntVal h) (is-FloatVal h))\n                  (list_all_numeric t))))))\n\n(define-fun-rec list_sorted ((v Value)) Bool\n  (or (is-Nil v)\n      (and (is-Cons v)\n           (let ((t1 (tail v)))\n             (or (is-Nil t1)\n                 (and (is-Cons t1)\n                      (let ((h1 (head v)) (h2 (head t1)))\n                        (and (<= (SafeReal h1) (SafeReal h2))\n                             (list_sorted t1)))))))))\n\n(define-fun-rec Value_eq ((a Value) (b Value)) Bool\n  (or (and (is-IntVal a) (is-IntVal b) (= (ival a) (ival b)))\n      (and (is-FloatVal a) (is-FloatVal b) (= (fval a) (fval b)))))\n\n(define-fun-rec in_list ((v Value) (x Value)) Bool\n  (or (and (is-Cons v)\n           (let ((h (head v)) (t (tail v)))\n             (or (Value_eq h x)\n                 (in_list t x))))\n      false))",
  "basic_structure": "(assert (IsList arr))\n(assert (or (is-IntVal x) (is-FloatVal x)))",
  "inputs": "(declare-const arr Value)\n(declare-const x Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList arr))",
    "assert_1": "(define-fun C1 () Bool (list_all_numeric arr))",
    "assert_2": "(define-fun C2 () Bool (list_sorted arr))",
    "assert_3": "(define-fun C3 () Bool (or (is-IntVal x) (is-FloatVal x)))",
    "assert_4": "(define-fun C4 () Bool (in_list arr x))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/794

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: text_starta_endb
Problem Description:
"""
Write a function that matches a string that has an 'a' followed by anything, ending in 'b'.
assert text_starta_endb("aabbbb")
"""


import re
def text_starta_endb(text):

    assert isinstance(text, str), "invalid inputs" # $_CONTRACT_$
    patterns = 'a.*?b$'
    return re.search(patterns,  text)


Contract List:
assert_0: assert isinstance(text, str), "invalid inputs


<think>
I will translate the Python type‐check assertion into a Boolean predicate over our Value ADT and supply a safe string‐extraction helper to guarantee executability.
</think>
```json
{
  "helper_functions": "(define-fun SafeS ((v Value)) String (ite (is-StrVal v) (sval v) \"\"))",
  "basic_structure": "",
  "inputs": "(declare-const text Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-StrVal text))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/796

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: return_sum
Problem Description:
"""
Write function to find the sum of all items in the given dictionary.
assert return_sum({'a': 100, 'b':200, 'c':300}) == 600
"""


def return_sum(d):

  assert isinstance(d, dict), "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(x, (int, float)) for x in d.values()), "invalid inputs" # $_CONTRACT_$
  return sum(d.values())


Contract List:
assert_0: assert isinstance(d, dict), "invalid inputs
assert_1: assert all(isinstance(x, (int, float)) for x in d.values()), "invalid inputs


<think>
I model Python dicts as lists of Pair entries in the Value ADT, add helpers to check well-formed dictionaries (IsDict) and numeric values (dict_all_numeric), then define C0/C1 to mirror the two asserts.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsDict ((v Value)) Bool\n  (ite (is-Nil v) true\n    (ite (is-Cons v)\n      (let ((h (head v)) (t (tail v)))\n        (and (is-Pair h)\n             (IsDict t)))\n      false)))\n\n(define-fun-rec dict_all_numeric ((v Value)) Bool\n  (ite (is-Nil v) true\n    (ite (is-Cons v)\n      (let ((h (head v)) (t (tail v)))\n        (and (is-Pair h)\n             (or (is-IntVal (pval h))\n                 (is-FloatVal (pval h)))\n             (dict_all_numeric t)))\n      false)))",
  "basic_structure": "(assert (IsDict d))",
  "inputs": "(declare-const d Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsDict d))",
    "assert_1": "(define-fun C1 () Bool (dict_all_numeric d))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/797

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: sum_in_range
Problem Description:
"""
Write a python function to find the sum of all odd natural numbers within the range l and r.
assert sum_in_range(2,5) == 8
"""


def sum_odd(n): 
    terms = (n + 1) // 2
    sum1 = terms * terms 
    return sum1  
def sum_in_range(l,r):

    assert isinstance(l, int), "invalid inputs" # $_CONTRACT_$
    assert isinstance(r, int), "invalid inputs" # $_CONTRACT_$
    assert 0 <= l <= r, "invalid inputs" # $_CONTRACT_$
 
    return sum_odd(r) - sum_odd(l - 1)


Contract List:
assert_0: assert isinstance(l, int), "invalid inputs
assert_1: assert isinstance(r, int), "invalid inputs
assert_2: assert 0 <= l <= r, "invalid inputs


<think>
I mapped each Python assertion to a standalone SMT predicate Ck, ensuring type‐guards precede any selector use. Since there are no lists or floats, no extra ADT helpers were needed, and I left the basic structure unconstrained beyond trivially true.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "(assert true)",
  "inputs": "(declare-const l Value)\n(declare-const r Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal l))",
    "assert_1": "(define-fun C1 () Bool (is-IntVal r))",
    "assert_2": "(define-fun C2 () Bool (and (is-IntVal l) (is-IntVal r) (<= 0 (ival l)) (<= (ival l) (ival r))))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/798

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: _sum
Problem Description:
"""
Write a python function to find the sum of an array.
assert _sum([1, 2, 3]) == 6
"""


def _sum(arr):

    assert isinstance(arr, list), "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(n, (int, float)) for n in arr), "invalid inputs" # $_CONTRACT_$
  
    return sum(arr)


Contract List:
assert_0: assert isinstance(arr, list), "invalid inputs
assert_1: assert all(isinstance(n, (int, float)) for n in arr), "invalid inputs


<think>
I will translate the Python list and numeric‐type assertions into corresponding SMT‐LIB predicates, defining both a structural list tester and a recursive numeric‐element checker, while keeping only the list shape in the basic structure and leaving each assert as a standalone contract predicate.
</think>
```json
{
  "helper_functions": "(define-fun isList ((v Value)) Bool (or (is-Nil v) (is-Cons v)))\n(define-fun-rec list_all_numeric ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (let ((hd (head v)) (tl (tail v)))\n              (and (or (is-IntVal hd) (is-FloatVal hd))\n                   (list_all_numeric tl)))\n            false)))",
  "basic_structure": "(assert (isList arr))",
  "inputs": "(declare-const arr Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (isList arr))",
    "assert_1": "(define-fun C1 () Bool (list_all_numeric arr))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/799

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: left_rotate
Problem Description:
"""
Write a function to that rotate left bits by d bits a given number. We assume that the number is 32 bit.
assert left_rotate(16,2) == 64
"""


def left_rotate(n,d):

    assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
    assert isinstance(d, int), "invalid inputs" # $_CONTRACT_$
    assert 0 <= n <= 0xffffffff, "invalid inputs" # $_CONTRACT_$
   
    INT_BITS = 32
    return (n << d)|(n >> (INT_BITS - d))  


Contract List:
assert_0: assert isinstance(n, int), "invalid inputs
assert_1: assert isinstance(d, int), "invalid inputs
assert_2: assert 0 <= n <= 0xffffffff, "invalid inputs


<think>
I introduce a SafeI helper to extract IntVal safely, declare inputs n and d of sort Value, leave BASIC_STRUCTURE empty since extraction is guarded, and define C0–C2 to exactly encode the Python asserts.
</think>
```json
{
  "helper_functions": "(define-fun SafeI ((v Value)) Int\n  (ite (is-IntVal v) (ival v) 0))",
  "basic_structure": "",
  "inputs": "(declare-const n Value)\n(declare-const d Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
    "assert_1": "(define-fun C1 () Bool (is-IntVal d))",
    "assert_2": "(define-fun C2 () Bool (and (>= (SafeI n) 0) (<= (SafeI n) 4294967295)))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/800

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: remove_all_spaces
Problem Description:
"""
Write a function to remove all whitespaces from a string.
assert remove_all_spaces('python  program')==('pythonprogram')
"""


def remove_all_spaces(text):

 assert isinstance(text, str), "invalid inputs" # $_CONTRACT_$
 return text.replace(' ', '')


Contract List:
assert_0: assert isinstance(text, str), "invalid inputs


<think>
I translate the Python `isinstance(text, str)` assertion into an SMT-LIB predicate requiring the ADT node to be a `StrVal`. No additional helpers or global invariants are needed since we only test constructor membership. The input is declared as a generic `Value`, and the contract `C0` checks that it is indeed a string.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "",
  "inputs": "(declare-const text Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-StrVal text))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/801

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: test_three_equal
Problem Description:
"""
Write a python function to count the number of equal numbers from three given integers.
assert test_three_equal(1,1,1) == 3
"""


def test_three_equal(x,y,z):

  assert isinstance(x, int), "invalid inputs" # $_CONTRACT_$
  assert isinstance(y, int), "invalid inputs" # $_CONTRACT_$
  assert isinstance(z, int), "invalid inputs" # $_CONTRACT_$
  result = set([x,y,z])
  if len(result) == 3:
    return 0
  elif len(result) == 2:
    return 2
  else:
    return 3


Contract List:
assert_0: assert isinstance(x, int), "invalid inputs
assert_1: assert isinstance(y, int), "invalid inputs
assert_2: assert isinstance(z, int), "invalid inputs


<think>
I will translate each Python isinstance assertion into SMT-LIB predicates testing for IntVal, declare the inputs, and leave helper_functions and basic_structure minimal since no additional ADT or list logic is required.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "",
  "inputs": "(declare-const x Value)\n(declare-const y Value)\n(declare-const z Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal x))",
    "assert_1": "(define-fun C1 () Bool (is-IntVal y))",
    "assert_2": "(define-fun C2 () Bool (is-IntVal z))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/803

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: is_perfect_square
Problem Description:
"""
Write a function to check whether the given number is a perfect square or not. 
assert not is_perfect_square(10)
"""


def is_perfect_square(n) :

    assert isinstance(n, int), "invalid inputs" # $_CONTRACT_$
    if n < 0:
        return False
    return n**(1/2) == int(n**(1/2))


Contract List:
assert_0: assert isinstance(n, int), "invalid inputs


<think>
I will encode the single Python type‐check assertion as an SMT predicate ensuring the input Value is an IntVal. The base template provides the ADT, declares the input, and defines C0 for `isinstance(n, int)`.
</think>
```json
{
  "helper_functions": "",
  "basic_structure": "",
  "inputs": "(declare-const n Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-IntVal n))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/804

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: is_product_even
Problem Description:
"""
Write a function to check whether the product of numbers in a list is even or not.
assert is_product_even([1,2,3])
"""


def is_product_even(arr):

    assert isinstance(arr, list), "invalid inputs" # $_CONTRACT_$
    assert len(arr) > 0, "invalid inputs" # $_CONTRACT_$
    assert all(isinstance(x, int) for x in arr), "invalid inputs" # $_CONTRACT_$
 
    return any(x % 2 == 0 for x in arr)


Contract List:
assert_0: assert isinstance(arr, list), "invalid inputs
assert_1: assert len(arr) > 0, "invalid inputs
assert_2: assert all(isinstance(x, int) for x in arr), "invalid inputs


<think>
I will translate the Python type, length, and all-int checks into precise SMT-LIB predicates and recursive helper functions for list shape and traversal. Each contract becomes a standalone Boolean Ck, and I include only the minimal basic structure needed for safe list operations.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v) true\n    (ite (is-Cons v) (IsList (tail v)) false)))\n\n(define-fun-rec length ((lst Value)) Int\n  (ite (is-Nil lst) 0\n    (ite (is-Cons lst) (+ 1 (length (tail lst))) 0)))\n\n(define-fun-rec ListAllInt ((lst Value)) Bool\n  (ite (is-Nil lst) true\n    (ite (is-Cons lst)\n         (and (is-IntVal (head lst)) (ListAllInt (tail lst)))\n         false)))",
  "basic_structure": "(assert (IsList arr))",
  "inputs": "(declare-const arr Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList arr))",
    "assert_1": "(define-fun C1 () Bool (> (length arr) 0))",
    "assert_2": "(define-fun C2 () Bool (ListAllInt arr))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/805

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: max_sum_list
Problem Description:
"""
Write a function that returns the list in a list of lists whose sum of elements is the highest.
assert max_sum_list([[1,2,3], [4,5,6], [10,11,12], [7,8,9]])==[10, 11, 12]
"""


def max_sum_list(lists):

 assert isinstance(lists, list), "invalid inputs" # $_CONTRACT_$
 assert all(isinstance(x, list) for x in lists), "invalid inputs" # $_CONTRACT_$
 assert all(all(isinstance(y, (int, float)) for y in x) for x in lists), "invalid inputs" # $_CONTRACT_$
 return max(lists, key=sum)


Contract List:
assert_0: assert isinstance(lists, list), "invalid inputs
assert_1: assert all(isinstance(x, list) for x in lists), "invalid inputs
assert_2: assert all(all(isinstance(y, (int, float)) for y in x) for x in lists), "invalid inputs


<think>
I translate each Python assertion into a standalone SMT predicate (C0–C2) and provide ADT and recursive helpers to ensure lists are well-formed and elements are numeric. The basic structure asserts only the necessary list shape for executability, while contracts capture the precise input checks.
</think>
```json
{
  "helper_functions": "(define-fun-rec ListP ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (ListP (tail l))\n            false)))\n\n(define-fun isNumericVal ((v Value)) Bool\n  (or (is-IntVal v) (is-FloatVal v)))\n\n(define-fun-rec ListAllNumeric ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (and (isNumericVal (head l)) (ListAllNumeric (tail l)))\n            false)))\n\n(define-fun-rec ListAllList ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (and (ListP (head l)) (ListAllList (tail l)))\n            false)))\n\n(define-fun-rec ListAllSublistNumeric ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (and (ListAllNumeric (head l)) (ListAllSublistNumeric (tail l)))\n            false)))",
  "basic_structure": "(assert (ListP lists))",
  "inputs": "(declare-const lists Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (ListP lists))",
    "assert_1": "(define-fun C1 () Bool (ListAllList lists))",
    "assert_2": "(define-fun C2 () Bool (ListAllSublistNumeric lists))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/806

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: max_run_uppercase
Problem Description:
"""
Write a function to find maximum run of uppercase characters in the given string.
assert max_run_uppercase('GeMKSForGERksISBESt') == 5
"""


def max_run_uppercase(test_str):

  assert isinstance(test_str, str), "invalid inputs" # $_CONTRACT_$
  assert len(test_str) > 0, "invalid inputs" # $_CONTRACT_$
  cnt = 0
  res = 0
  for idx in range(0, len(test_str)):
    if test_str[idx].isupper():
      cnt += 1
    else:
      res = cnt
      cnt = 0
  if test_str[len(test_str) - 1].isupper():
    res = cnt
  return res


Contract List:
assert_0: assert isinstance(test_str, str), "invalid inputs
assert_1: assert len(test_str) > 0, "invalid inputs


<think>
I will translate the Python `assert` checks into precise SMT-LIB predicates, define a safe string extractor helper, and declare the input and basic shape assertion to ensure the function can safely index the string.
</think>
```json
{
  "helper_functions": "(define-fun SafeS ((v Value)) String (ite (is-StrVal v) (sval v) \"\"))",
  "basic_structure": "(assert (is-StrVal test_str))",
  "inputs": "(declare-const test_str Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (is-StrVal test_str))",
    "assert_1": "(define-fun C1 () Bool (> (str.len (SafeS test_str)) 0))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/807

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: first_odd
Problem Description:
"""
Write a python function to find the first odd number in a given list of numbers.
assert first_odd([1,3,5]) == 1
"""


def first_odd(nums):

  assert isinstance(nums, list), "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(el, int) for el in nums), "invalid inputs" # $_CONTRACT_$
  assert any(el % 2 != 0 for el in nums), "invalid inputs" # $_CONTRACT_$
  first_odd = next((el for el in nums if el%2!=0), None)
  return first_odd


Contract List:
assert_0: assert isinstance(nums, list), "invalid inputs
assert_1: assert all(isinstance(el, int) for el in nums), "invalid inputs
assert_2: assert any(el % 2 != 0 for el in nums), "invalid inputs


<think>
I translated the Python list and numeric checks into recursive SMT predicates over the Value ADT, ensuring safe selector use and a clear base-case/recursive structure. Contract assertions map directly to these predicates while the basic structure guarantees the input is a well-formed list.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (IsList (tail l))\n            false)))\n\n(define-fun-rec list_all_ints ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (and (is-IntVal (head l))\n                 (list_all_ints (tail l)))\n            false)))\n\n(define-fun-rec any_odd ((l Value)) Bool\n  (ite (is-Nil l)\n       false\n       (ite (is-Cons l)\n            (let ((h (head l)) (t (tail l)))\n              (ite (is-IntVal h)\n                   (or (not (= (mod (ival h) 2) 0))\n                       (any_odd t))\n                   (any_odd t)))\n            false)))",
  "basic_structure": "(assert (IsList nums))",
  "inputs": "(declare-const nums Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList nums))",
    "assert_1": "(define-fun C1 () Bool (list_all_ints nums))",
    "assert_2": "(define-fun C2 () Bool (any_odd nums))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/808

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: check_K
Problem Description:
"""
Write a function to check if the given tuples contain the k or not.
assert check_K((10, 4, 5, 6, 8), 6) == True
"""


def check_K(test_tup, K):

  assert isinstance(test_tup, tuple), "invalid inputs" # $_CONTRACT_$
  return K in test_tup


Contract List:
assert_0: assert isinstance(test_tup, tuple), "invalid inputs


<think>
I model the Python tuple as a Cons/Nil list in SMT, define a recursive IsList helper to enforce correct list shape, and translate the isinstance assertion into a contract predicate C0. Inputs are declared as Value, the basic structure asserts IsList for executability, and each contract is a named Bool function. This template allows systematic testing of C0 satisfaction or violation.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (IsList (tail l))\n            false)))",
  "basic_structure": "(assert (IsList test_tup))",
  "inputs": "(declare-const test_tup Value)\n(declare-const K Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList test_tup))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


Mbpp/809

You are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.

Your task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:
1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)
2. Ensures program executability through proper ADT constraints
3. Provides a reusable template for generating test scenarios
4. Supports systematic contract violation testing

Focus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.


STRICT RULES (concise, extensible)
- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.
- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.
- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).
- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.
- Regex: use str.in.re with (str.to.re "..."); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re "..."); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for "only allowed characters" patterns.
- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re "(")))) ...) is WRONG; use nested lets.
- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).
- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.
- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).
- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.
- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).
- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.



I will provide:
- Method Name: the function name to analyze
- Problem Description: natural language description of function behavior and constraints
- Contract List: input validation assertions that enforce type, range, and structural constraints

Your tasks:
1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:
   - Correct ADT shapes and types
   - Valid list structures and nesting
   - Appropriate numeric/string/boolean constraints
   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)
2) **Generate ONE SMT-LIB v2 base template** containing:
   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)
   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts
   - (c) Input declarations: `(declare-const <param> Value)` for each parameter
   - (d) Basic structure assertions for executability
   - (e) Contract predicate definitions (C0, C1, C2, ...)
3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics
4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions
5) Cover ALL combinations: singles, pairs, triples, … up to "all violated".
6) **Output format**: Return a JSON object with the specified structure
7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.
Base Template:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
<<HELPER_FUNCTIONS>>

; === Inputs ===
<<INPUT>>

; === BASIC STRUCTURE ===
<<BASIC_STRUCTURE>>

; === Contract predicates ===
<<CONTRACT_DEFS>>

; === COMBINATION ===
<<COMBINATION>>

(check-sat)
(get-model)


Output Format:

<think>
Briefly explain your approach (2-3 sentences). Example: "I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints."
</think>
```json
{
  "helper_functions": "<<HELPER_FUNCTIONS>>",
  "basic_structure": "<<BASIC_STRUCTURE>>",
  "inputs": "(declare-const <param1> Value)\n(declare-const <param2> Value)\n...",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool <...>)",
    "assert_1": "(define-fun C1 () Bool <...>)",
    "assert_2": "(define-fun C2 () Bool <...>)",
    ...
  }
}
```
----------------------------------------

----------------------------------------

Method Name: check_smaller
Problem Description:
"""
Write a function to check if each element of second tuple is smaller than its corresponding element in the first tuple.
assert check_smaller((1, 2, 3), (2, 3, 4)) == False
"""


def check_smaller(test_tup1, test_tup2):

  assert isinstance(test_tup1, tuple), "invalid inputs" # $_CONTRACT_$
  assert isinstance(test_tup2, tuple), "invalid inputs" # $_CONTRACT_$
  assert len(test_tup1) == len(test_tup2), "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(x, int) for x in test_tup1), "invalid inputs" # $_CONTRACT_$
  assert all(isinstance(x, int) for x in test_tup2), "invalid inputs" # $_CONTRACT_$
  return all(x > y for x, y in zip(test_tup1, test_tup2))


Contract List:
assert_0: assert isinstance(test_tup1, tuple), "invalid inputs
assert_1: assert isinstance(test_tup2, tuple), "invalid inputs
assert_2: assert len(test_tup1) == len(test_tup2), "invalid inputs
assert_3: assert all(isinstance(x, int) for x in test_tup1), "invalid inputs
assert_4: assert all(isinstance(x, int) for x in test_tup2), "invalid inputs


<think>
I model Python tuples as linked lists in the ADT and provide recursive helpers (IsList, list_length, list_all_int) to capture structural and type checks. Each Python assertion becomes a named predicate C0–C4, and basic_structure ensures minimal list shape for executability.
</think>
```json
{
  "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v) true\n       (ite (is-Cons v) (IsList (tail v)) false)))\n(define-fun-rec list_length ((v Value)) Int\n  (ite (is-Nil v) 0\n       (ite (is-Cons v) (+ 1 (list_length (tail v))) 0)))\n(define-fun-rec list_all_int ((v Value)) Bool\n  (ite (is-Nil v) true\n       (ite (is-Cons v) (and (is-IntVal (head v)) (list_all_int (tail v))) false)))",
  "basic_structure": "(assert (IsList test_tup1))\n(assert (IsList test_tup2))",
  "inputs": "(declare-const test_tup1 Value)\n(declare-const test_tup2 Value)",
  "contract_defs": {
    "assert_0": "(define-fun C0 () Bool (IsList test_tup1))",
    "assert_1": "(define-fun C1 () Bool (IsList test_tup2))",
    "assert_2": "(define-fun C2 () Bool (= (list_length test_tup1) (list_length test_tup2)))",
    "assert_3": "(define-fun C3 () Bool (list_all_int test_tup1))",
    "assert_4": "(define-fun C4 () Bool (list_all_int test_tup2))"
  }
}
```
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------


