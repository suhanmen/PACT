{"name": "Mbpp/63", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for \"only allowed characters\" patterns.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re \"(\")))) ...) is WRONG; use nested lets.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: max_difference\nProblem Description:\n\"\"\"\nWrite a function to find the maximum difference between available pairs in the given tuple list.\nassert max_difference([(3, 5), (1, 7), (10, 3), (1, 2)]) == 7\n\"\"\"\n\n\ndef max_difference(test_list):\n\n  assert isinstance(test_list, list), \"invalid inputs\" # $_CONTRACT_$\n  assert all(isinstance(item, tuple) and len(item) == 2 for item in test_list), \"invalid inputs\" # $_CONTRACT_$\n  assert all(isinstance(a, (int, float)) and isinstance(b, (int, float)) for a, b in test_list), \"invalid inputs\" # $_CONTRACT_$\n  return max(abs(a - b) for a, b in test_list)\n\n\nContract List:\nassert_0: assert isinstance(test_list, list), \"invalid inputs\nassert_1: assert all(isinstance(item, tuple) and len(item) == 2 for item in test_list), \"invalid inputs\nassert_2: assert all(isinstance(a, (int, float)) and isinstance(b, (int, float)) for a, b in test_list), \"invalid inputs\n\n"}], "grammar": [{"production": ["{\n  \"helper_functions\": \"(define-fun-rec IsList ((l Value)) Bool\\n  (or (is-Nil l)\\n      (and (is-Cons l) (IsList (tail l)))))\\n\\n(define-fun IsPair ((v Value)) Bool\\n  (and (is-Cons v)\\n       (is-Cons (tail v))\\n       (is-Nil (tail (tail v)))))\\n\\n(define-fun first  ((p Value)) Value (head p))\\n(define-fun second ((p Value)) Value (head (tail p)))\\n\\n(define-fun IsNumeric ((v Value)) Bool\\n  (or (is-IntVal v) (is-FloatVal v)))\\n\\n(define-fun-rec AllPair2 ((l Value)) Bool\\n  (ite (is-Nil l) true\\n       (and (is-Cons l)\\n            (IsPair (head l))\\n            (AllPair2 (tail l)))))\\n\\n(define-fun-rec AllNumericPairs ((l Value)) Bool\\n  (ite (is-Nil l) true\\n       (and (is-Cons l)\\n            (let ((p (head l)))\\n              (and (IsPair p)\\n                   (IsNumeric (first p))\\n                   (IsNumeric (second p))))\\n            (AllNumericPairs (tail l)))))\", \n  \"basic_structure\": \"\", \n  \"inputs\": \"(declare-const test_list Value)\", \n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool (IsList test_list))\",\n    \"assert_1\": \"(define-fun C1 () Bool (AllPair2 test_list))\",\n    \"assert_2\": \"(define-fun C2 () Bool (AllNumericPairs test_list))\"\n  }\n}"], "constraints": [{"assert_0": "assert isinstance(test_list, list), \"invalid inputs", "assert_1": "assert all(isinstance(item, tuple) and len(item) == 2 for item in test_list), \"invalid inputs", "assert_2": "assert all(isinstance(a, (int, float)) and isinstance(b, (int, float)) for a, b in test_list), \"invalid inputs"}]}], "reasoning": ["I will introduce a TupleVal constructor, define recursive helpers for list shape and element checks, then map each Python assertion to a Bool predicate using those helpers.</think>"]}
{"name": "Mbpp/70", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for \"only allowed characters\" patterns.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re \"(\")))) ...) is WRONG; use nested lets.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: get_equal\nProblem Description:\n\"\"\"\nWrite a function to find whether all the given tuples have equal length or not.\nassert get_equal([(11, 22, 33), (44, 55, 66)]) == True\n\"\"\"\n\n\ndef get_equal(Input):\n\n  assert isinstance(Input, list), \"invalid inputs\" # $_CONTRACT_$\n  assert all(isinstance(item, tuple) for item in Input), \"invalid inputs\" # $_CONTRACT_$\n  return len(set(len(item) for item in Input)) == 1\n\n\nContract List:\nassert_0: assert isinstance(Input, list), \"invalid inputs\nassert_1: assert all(isinstance(item, tuple) for item in Input), \"invalid inputs\n\n"}], "grammar": [{"production": ["{\n  \"helper_functions\": \"(define-fun-rec IsList ((v Value)) Bool\\n  (or (is-Nil v)\\n      (and (is-Cons v) (IsList (tail v)))))\\n\\n(define-fun IsPair ((v Value)) Bool\\n  (and (is-Cons v)\\n       (is-Cons (tail v))\\n       (is-Nil (tail (tail v)))))\\n\\n(define-fun-rec AllPair ((v Value)) Bool\\n  (or (is-Nil v)\\n      (and (is-Cons v)\\n           (IsPair (head v))\\n           (AllPair (tail v)))))\",\n  \"basic_structure\": \"\",\n  \"inputs\": \"(declare-const Input Value)\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool (IsList Input))\",\n    \"assert_1\": \"(define-fun C1 () Bool (AllPair Input))\"\n  }\n}"], "constraints": [{"assert_0": "assert isinstance(Input, list), \"invalid inputs", "assert_1": "assert all(isinstance(item, tuple) for item in Input), \"invalid inputs"}]}], "reasoning": ["I model Python’s list and tuple structures via recursive ADTs and helper functions IsList and AllTuple, then declare Input and define C0 and C1 exactly matching the two asserts. This preserves executability without mixing in test properties and keeps each contract standalone.</think>"]}
{"name": "Mbpp/87", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for \"only allowed characters\" patterns.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re \"(\")))) ...) is WRONG; use nested lets.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: merge_dictionaries_three\nProblem Description:\n\"\"\"\nWrite a function to merge three dictionaries into a single dictionary.\nassert merge_dictionaries_three({ \"R\": \"Red\", \"B\": \"Black\", \"P\": \"Pink\" }, { \"G\": \"Green\", \"W\": \"White\" },{ \"O\": \"Orange\", \"W\": \"White\", \"B\": \"Black\" })=={'B': 'Black', 'R': 'Red', 'P': 'Pink', 'G': 'Green', 'W': 'White', 'O': 'Orange'}\n\"\"\"\n\n\nimport collections as ct\ndef merge_dictionaries_three(dict1,dict2, dict3):\n\n    assert isinstance(dict1, dict), \"invalid inputs\" # $_CONTRACT_$\n    assert isinstance(dict2, dict), \"invalid inputs\" # $_CONTRACT_$\n    assert isinstance(dict3, dict), \"invalid inputs\" # $_CONTRACT_$\n    merged_dict = dict(ct.ChainMap({},dict1,dict2,dict3))\n    return merged_dict\n\n\nContract List:\nassert_0: assert isinstance(dict1, dict), \"invalid inputs\nassert_1: assert isinstance(dict2, dict), \"invalid inputs\nassert_2: assert isinstance(dict3, dict), \"invalid inputs\n\n"}], "grammar": [{"production": ["{\n  \"helper_functions\": \"(define-fun-rec IsList ((v Value)) Bool\\n  (or (is-Nil v) (and (is-Cons v) (IsList (tail v)))))\\n\\n(define-fun IsPair ((v Value)) Bool\\n  (and (is-Cons v) (is-Cons (tail v)) (is-Nil (tail (tail v)))))\\n\\n(define-fun first ((p Value)) Value (head p))\\n(define-fun second ((p Value)) Value (head (tail p)))\\n\\n(define-fun IsKVPair ((v Value)) Bool\\n  (and (IsPair v) (is-StrVal (first v))))\\n\\n(define-fun-rec IsDict ((v Value)) Bool\\n  (or (is-Nil v) (and (is-Cons v) (IsKVPair (head v)) (IsDict (tail v)))))\",\n  \"basic_structure\": \"\",\n  \"inputs\": \"(declare-const dict1 Value)\\n(declare-const dict2 Value)\\n(declare-const dict3 Value)\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool (IsDict dict1))\",\n    \"assert_1\": \"(define-fun C1 () Bool (IsDict dict2))\",\n    \"assert_2\": \"(define-fun C2 () Bool (IsDict dict3))\"\n  }\n}"], "constraints": [{"assert_0": "assert isinstance(dict1, dict), \"invalid inputs", "assert_1": "assert isinstance(dict2, dict), \"invalid inputs", "assert_2": "assert isinstance(dict3, dict), \"invalid inputs"}]}], "reasoning": ["I introduce a DictVal variant in the ADT and a simple IsDict helper to capture Python’s isinstance(dict) check, then define three Boolean predicates C0–C2 to mirror each input‐validation assert.</think>"]}
{"name": "Mbpp/120", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for \"only allowed characters\" patterns.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re \"(\")))) ...) is WRONG; use nested lets.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: max_product_tuple\nProblem Description:\n\"\"\"\nWrite a function to find the maximum absolute product between numbers in pairs of tuples within a given list.\nassert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36\n\"\"\"\n\n\ndef max_product_tuple(list1):\n\n    assert isinstance(list1, list), \"invalid inputs\" # $_CONTRACT_$\n    assert all(isinstance(x, tuple) for x in list1), \"invalid inputs\" # $_CONTRACT_$\n    assert all(len(x) == 2 for x in list1), \"invalid inputs\" # $_CONTRACT_$\n    assert all(isinstance(x[0], (int, float)) for x in list1), \"invalid inputs\" # $_CONTRACT_$\n    assert all(isinstance(x[1], (int, float)) for x in list1), \"invalid inputs\" # $_CONTRACT_$\n    return max(abs(x * y) for x, y in list1)\n\n\nContract List:\nassert_0: assert isinstance(list1, list), \"invalid inputs\nassert_1: assert all(isinstance(x, tuple) for x in list1), \"invalid inputs\nassert_2: assert all(len(x) == 2 for x in list1), \"invalid inputs\nassert_3: assert all(isinstance(x[0], (int, float)) for x in list1), \"invalid inputs\nassert_4: assert all(isinstance(x[1], (int, float)) for x in list1), \"invalid inputs\n\n"}], "grammar": [{"production": ["{\n  \"helper_functions\": \"(define-fun-rec IsList ((l Value)) Bool\\n  (or (is-Nil l) (and (is-Cons l) (IsList (tail l)))))\\n\\n(define-fun IsPair ((v Value)) Bool\\n  (and (is-Cons v)\\n       (is-Cons (tail v))\\n       (is-Nil (tail (tail v)))))\\n\\n(define-fun first ((p Value)) Value (head p))\\n(define-fun second ((p Value)) Value (head (tail p)))\\n\\n(define-fun IsNumeric ((v Value)) Bool\\n  (or (is-IntVal v) (is-FloatVal v)))\\n\\n(define-fun-rec list_all_Pair ((l Value)) Bool\\n  (or (is-Nil l)\\n      (and (is-Cons l)\\n           (IsPair (head l))\\n           (list_all_Pair (tail l)))))\\n\\n(define-fun-rec list_all_first_num ((l Value)) Bool\\n  (or (is-Nil l)\\n      (and (is-Cons l)\\n           (IsPair (head l))\\n           (IsNumeric (first (head l)))\\n           (list_all_first_num (tail l)))))\\n\\n(define-fun-rec list_all_second_num ((l Value)) Bool\\n  (or (is-Nil l)\\n      (and (is-Cons l)\\n           (IsPair (head l))\\n           (IsNumeric (second (head l)))\\n           (list_all_second_num (tail l)))))\",\n  \"basic_structure\": \"(assert (IsList list1))\",\n  \"inputs\": \"(declare-const list1 Value)\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool (IsList list1))\",\n    \"assert_1\": \"(define-fun C1 () Bool (list_all_Pair list1))\",\n    \"assert_2\": \"(define-fun C2 () Bool (list_all_Pair list1))\",\n    \"assert_3\": \"(define-fun C3 () Bool (list_all_first_num list1))\",\n    \"assert_4\": \"(define-fun C4 () Bool (list_all_second_num list1))\"\n  }\n}"], "constraints": [{"assert_0": "assert isinstance(list1, list), \"invalid inputs", "assert_1": "assert all(isinstance(x, tuple) for x in list1), \"invalid inputs", "assert_2": "assert all(len(x) == 2 for x in list1), \"invalid inputs", "assert_3": "assert all(isinstance(x[0], (int, float)) for x in list1), \"invalid inputs", "assert_4": "assert all(isinstance(x[1], (int, float)) for x in list1), \"invalid inputs"}]}], "reasoning": ["I will translate each Python assertion into precise SMT predicates over a canonical Value ADT, declare necessary recursive helpers to enforce list and tuple structure and numeric checks, and provide a mask‐based combination template for systematic contract violation testing.</think>"]}
{"name": "Mbpp/124", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for \"only allowed characters\" patterns.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re \"(\")))) ...) is WRONG; use nested lets.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: angle_complex\nProblem Description:\n\"\"\"\nWrite a function to get the angle of a complex number.\nassert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)\n\"\"\"\n\n\nimport cmath\ndef angle_complex(a,b):\n\n  assert isinstance(a, (int, float)) or isinstance(a, float), \"invalid inputs\" # $_CONTRACT_$\n  assert isinstance(b, complex) or isinstance(b, float), \"invalid inputs\" # $_CONTRACT_$\n  assert b.real == 0, \"invalid inputs\" # $_CONTRACT_$\n  angle=cmath.phase(a+b)\n  return angle\n\n\nContract List:\nassert_0: assert isinstance(a, (int, float)) or isinstance(a, float), \"invalid inputs\nassert_1: assert isinstance(b, complex) or isinstance(b, float), \"invalid inputs\nassert_2: assert b.real == 0, \"invalid inputs\n\n"}], "grammar": [{"production": ["{\n  \"helper_functions\": \"(define-fun-rec IsList ((l Value)) Bool\\n  (or (is-Nil l) (and (is-Cons l) (IsList (tail l)))))\\n\\n(define-fun IsPair ((v Value)) Bool\\n  (and (is-Cons v) (is-Cons (tail v)) (is-Nil (tail (tail v)))))\\n\\n(define-fun first ((p Value)) Value (head p))\\n(define-fun second ((p Value)) Value (head (tail p)))\\n\\n(define-fun IsNumeric ((v Value)) Bool\\n  (or (is-IntVal v) (is-FloatVal v)))\\n\\n(define-fun ToReal ((v Value)) Real\\n  (ite (is-FloatVal v) (fval v)\\n       (ite (is-IntVal v) (to_real (ival v)) 0.0)))\\n\\n(define-fun IsComplexPair ((v Value)) Bool\\n  (and (IsPair v) (IsNumeric (first v)) (IsNumeric (second v))))\\n\\n(define-fun creal ((v Value)) Real (ToReal (first v)))\\n(define-fun cimag ((v Value)) Real (ToReal (second v)))\\n\\n(define-fun SafeReal ((v Value)) Real\\n  (ite (is-FloatVal v) (fval v)\\n       (ite (is-IntVal v) (to_real (ival v))\\n            (ite (IsComplexPair v) (creal v) 0.0))))\\n\\n(define-fun SafeImag ((v Value)) Real\\n  (ite (IsComplexPair v) (cimag v) 0.0))\",\n  \"basic_structure\": \"\",\n  \"inputs\": \"(declare-const a Value)\\n(declare-const b Value)\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool (or (is-IntVal a) (is-FloatVal a)))\",\n    \"assert_1\": \"(define-fun C1 () Bool (or (IsComplexPair b) (is-FloatVal b)))\",\n    \"assert_2\": \"(define-fun C2 () Bool (ite (IsComplexPair b) (= (creal b) 0.0) (ite (is-FloatVal b) (= (fval b) 0.0) false)))\"\n  }\n}"], "constraints": [{"assert_0": "assert isinstance(a, (int, float)) or isinstance(a, float), \"invalid inputs", "assert_1": "assert isinstance(b, complex) or isinstance(b, float), \"invalid inputs", "assert_2": "assert b.real == 0, \"invalid inputs"}]}], "reasoning": ["I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.</think>"]}
{"name": "Mbpp/125", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for \"only allowed characters\" patterns.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re \"(\")))) ...) is WRONG; use nested lets.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: find_length\nProblem Description:\n\"\"\"\nWrite a function to find the maximum difference between the number of 0s and number of 1s in any sub-string of the given binary string.\nassert find_length(\"11000010001\") == 6\n\"\"\"\n\n\ndef find_length(string):\n\n\tassert isinstance(string, str), \"invalid inputs\" # $_CONTRACT_$\n\tassert all([c in '01' for c in string]), \"invalid inputs\" # $_CONTRACT_$\n \n\tcurrent_sum = 0\n\tmax_sum = 0\n\tfor c in string: \n\t\tcurrent_sum += 1 if c == '0' else -1\n\t\tif current_sum < 0: \n\t\t\tcurrent_sum = 0\n\t\tmax_sum = max(current_sum, max_sum) \n\treturn max_sum\n\n\nContract List:\nassert_0: assert isinstance(string, str), \"invalid inputs\nassert_1: assert all([c in '01' for c in string]), \"invalid inputs\n\n"}], "grammar": [{"production": ["{\n  \"helper_functions\": \"(define-fun SafeS ((v Value)) String (ite (is-StrVal v) (sval v) \\\"\\\"))\\n(define-fun-rec all_01_char_at ((s String) (i Int) (len Int)) Bool\\n  (ite (>= i len)\\n       true\\n       (let ((ch (str.at s i)))\\n         (and (or (= ch \\\"0\\\") (= ch \\\"1\\\"))\\n              (all_01_char_at s (+ i 1) len)))))\",\n  \"basic_structure\": \"\",\n  \"inputs\": \"(declare-const string Value)\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool (is-StrVal string))\",\n    \"assert_1\": \"(define-fun C1 () Bool (let ((s (SafeS string))) (let ((len (str.len s))) (all_01_char_at s 0 len))))\"\n  }\n}"], "constraints": [{"assert_0": "assert isinstance(string, str), \"invalid inputs", "assert_1": "assert all([c in '01' for c in string]), \"invalid inputs"}]}], "reasoning": ["I define SafeS to extract a String from our Value ADT and a recursive all_01_char_at to verify each character is ‘0’ or ‘1.’ Then C0 and C1 directly mirror the Python asserts, guarding selectors and ensuring precise SMT-LIB semantics.</think>"]}
{"name": "Mbpp/232", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for \"only allowed characters\" patterns.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re \"(\")))) ...) is WRONG; use nested lets.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: larg_nnum\nProblem Description:\n\"\"\"\nWrite a function that takes in a list and an integer n and returns a list containing the n largest items from the list.\nassert set(larg_nnum([10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100],2))==set([100,90])\n\"\"\"\n\n\nimport heapq\ndef larg_nnum(list1, n):\n\n    assert isinstance(list1, list), \"invalid inputs\" # $_CONTRACT_$\n    assert all(isinstance(x, (int, float)) for x in list1), \"invalid inputs\" # $_CONTRACT_$\n    assert isinstance(n, int), \"invalid inputs\" # $_CONTRACT_$\n    assert 0 <= n <= len(list1), \"invalid inputs\" # $_CONTRACT_$\n    return heapq.nlargest(n,list1)\n\n\nContract List:\nassert_0: assert isinstance(list1, list), \"invalid inputs\nassert_1: assert all(isinstance(x, (int, float)) for x in list1), \"invalid inputs\nassert_2: assert isinstance(n, int), \"invalid inputs\nassert_3: assert 0 <= n <= len(list1), \"invalid inputs\n\n"}], "grammar": [{"production": ["{\n  \"helper_functions\": \"(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))\\n(define-fun-rec IsList ((l Value)) Bool (or (is-Nil l) (and (is-Cons l) (IsList (tail l)))))\\n(define-fun-rec list_all_numeric ((l Value)) Bool (or (is-Nil l) (and (is-Cons l) (or (is-IntVal (head l)) (is-FloatVal (head l))) (list_all_numeric (tail l)))))\\n(define-fun-rec list_length ((l Value)) Int (ite (is-Nil l) 0 (ite (is-Cons l) (+ 1 (list_length (tail l))) 0)))\",\n  \"basic_structure\": \"\",\n  \"inputs\": \"(declare-const list1 Value)\\n(declare-const n Value)\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool (IsList list1))\",\n    \"assert_1\": \"(define-fun C1 () Bool (and (IsList list1) (list_all_numeric list1)))\",\n    \"assert_2\": \"(define-fun C2 () Bool (is-IntVal n))\",\n    \"assert_3\": \"(define-fun C3 () Bool (and (is-IntVal n) (<= 0 (SafeI n)) (<= (SafeI n) (list_length list1))))\"\n  }\n}"], "constraints": [{"assert_0": "assert isinstance(list1, list), \"invalid inputs", "assert_1": "assert all(isinstance(x, (int, float)) for x in list1), \"invalid inputs", "assert_2": "assert isinstance(n, int), \"invalid inputs", "assert_3": "assert 0 <= n <= len(list1), \"invalid inputs"}]}], "reasoning": ["I translate each Python assertion into an SMT-LIB predicate over a canonical ADT, introduce safe selectors and recursive helpers for list shape, length, and numeric checks, and declare inputs consistently. Contract predicates (C0–C3) are isolated and use testers/guards for soundness.</think>"]}
{"name": "Mbpp/252", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for \"only allowed characters\" patterns.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re \"(\")))) ...) is WRONG; use nested lets.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: convert\nProblem Description:\n\"\"\"\nWrite a python function to convert complex numbers to polar coordinates.\nassert convert(1) == (1.0, 0.0)\n\"\"\"\n\n\nimport cmath  \ndef convert(numbers):\n\n  assert isinstance(numbers, (int, float, complex)), \"invalid inputs\" # $_CONTRACT_$ \n    \n  return cmath.polar(numbers)  \n\n\nContract List:\nassert_0: assert isinstance(numbers, (int, float, complex)), \"invalid inputs\n\n"}], "grammar": [{"production": ["{\n  \"helper_functions\": \"(define-fun IsPair ((v Value)) Bool\\n  (and (is-Cons v) (is-Cons (tail v)) (is-Nil (tail (tail v)))))\\n\\n(define-fun first ((p Value)) Value (head p))\\n(define-fun second ((p Value)) Value (head (tail p)))\\n\\n(define-fun IsNumeric ((v Value)) Bool (or (is-IntVal v) (is-FloatVal v)))\\n\\n(define-fun IsComplexPair ((v Value)) Bool\\n  (and (IsPair v) (IsNumeric (first v)) (IsNumeric (second v))))\\n\\n(define-fun IsNumber ((v Value)) Bool (or (is-IntVal v) (is-FloatVal v) (IsComplexPair v)))\",\n  \"basic_structure\": \"\",\n  \"inputs\": \"(declare-const numbers Value)\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool (IsNumber numbers))\"\n  }\n}"], "constraints": [{"assert_0": "assert isinstance(numbers, (int, float, complex)), \"invalid inputs"}]}], "reasoning": ["I introduce a helper IsNumber predicate over our Value ADT (including ComplexVal) to capture the isinstance check, declare the input, and define C0 as that predicate. There are no further always‐on invariants, so BASIC_STRUCTURE is empty.</think>"]}
{"name": "Mbpp/259", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for \"only allowed characters\" patterns.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re \"(\")))) ...) is WRONG; use nested lets.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: maximize_elements\nProblem Description:\n\"\"\"\nWrite a function to maximize the given two tuples.\nassert maximize_elements(((1, 3), (4, 5), (2, 9), (1, 10)), ((6, 7), (3, 9), (1, 1), (7, 3))) == ((6, 7), (4, 9), (2, 9), (7, 10))\n\"\"\"\n\n\ndef maximize_elements(test_tup1, test_tup2):\n\n  assert isinstance(test_tup1, tuple), \"invalid inputs\" # $_CONTRACT_$\n  assert isinstance(test_tup2, tuple), \"invalid inputs\" # $_CONTRACT_$\n  assert len(test_tup1) == len(test_tup2), \"invalid inputs\" # $_CONTRACT_$\n  assert len(test_tup1) > 0, \"invalid inputs\" # $_CONTRACT_$\n  assert len(test_tup2) > 0, \"invalid inputs\" # $_CONTRACT_$\n  assert all(isinstance(x, tuple) for x in test_tup1), \"invalid inputs\" # $_CONTRACT_$\n  assert all(isinstance(x, tuple) for x in test_tup2), \"invalid inputs\" # $_CONTRACT_$\n  assert all(len(x) == 2 for x in test_tup1), \"invalid inputs\" # $_CONTRACT_$\n  assert all(len(x) == 2 for x in test_tup2), \"invalid inputs\" # $_CONTRACT_$\n  assert all(isinstance(a, (int, float)) and isinstance(b, (int, float)) for a, b in test_tup1), \"invalid inputs\" # $_CONTRACT_$\n  assert all(isinstance(a, (int, float)) and isinstance(b, (int, float)) for a, b in test_tup2), \"invalid inputs\" # $_CONTRACT_$\n  return tuple((max(a, c), max(b, d)) for (a, b), (c, d) in zip(test_tup1, test_tup2))\n\n\nContract List:\nassert_0: assert isinstance(test_tup1, tuple), \"invalid inputs\nassert_1: assert isinstance(test_tup2, tuple), \"invalid inputs\nassert_2: assert len(test_tup1) == len(test_tup2), \"invalid inputs\nassert_3: assert len(test_tup1) > 0, \"invalid inputs\nassert_4: assert len(test_tup2) > 0, \"invalid inputs\nassert_5: assert all(isinstance(x, tuple) for x in test_tup1), \"invalid inputs\nassert_6: assert all(isinstance(x, tuple) for x in test_tup2), \"invalid inputs\nassert_7: assert all(len(x) == 2 for x in test_tup1), \"invalid inputs\nassert_8: assert all(len(x) == 2 for x in test_tup2), \"invalid inputs\nassert_9: assert all(isinstance(a, (int, float)) and isinstance(b, (int, float)) for a, b in test_tup1), \"invalid inputs\nassert_10: assert all(isinstance(a, (int, float)) and isinstance(b, (int, float)) for a, b in test_tup2), \"invalid inputs\n\n"}], "grammar": [{"production": ["{\n  \"helper_functions\": \"(define-fun-rec IsList ((v Value)) Bool\\n  (or (is-Nil v) (and (is-Cons v) (IsList (tail v)))))\\n\\n(define-fun-rec length ((v Value)) Int\\n  (ite (is-Nil v) 0 (ite (is-Cons v) (+ 1 (length (tail v))) 0)))\\n\\n(define-fun-rec list_all_list ((v Value)) Bool\\n  (or (is-Nil v)\\n      (and (is-Cons v) (IsList (head v)) (list_all_list (tail v)))))\\n\\n(define-fun-rec list_all_len2 ((v Value)) Bool\\n  (or (is-Nil v)\\n      (and (is-Cons v) (IsList (head v)) (= (length (head v)) 2) (list_all_len2 (tail v)))))\\n\\n; pair (a,b) ≡ Cons a (Cons b Nil)\\n(define-fun IsPair ((v Value)) Bool\\n  (and (is-Cons v) (is-Cons (tail v)) (is-Nil (tail (tail v)))))\\n(define-fun first ((p Value)) Value (head p))\\n(define-fun second ((p Value)) Value (head (tail p)))\\n(define-fun IsNumeric ((v Value)) Bool (or (is-IntVal v) (is-FloatVal v)))\\n\\n; 모든 원소가 (numeric, numeric) pair인가?\\n(define-fun-rec list_all_numeric ((v Value)) Bool\\n  (or (is-Nil v)\\n      (and (is-Cons v)\\n           (let ((p (head v)))\\n             (and (IsPair p) (IsNumeric (first p)) (IsNumeric (second p))))\\n           (list_all_numeric (tail v)))))\",\n  \"basic_structure\": \"(assert (IsList test_tup1))\\n(assert (IsList test_tup2))\",\n  \"inputs\": \"(declare-const test_tup1 Value)\\n(declare-const test_tup2 Value)\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool (IsList test_tup1))\",\n    \"assert_1\": \"(define-fun C1 () Bool (IsList test_tup2))\",\n    \"assert_2\": \"(define-fun C2 () Bool (= (length test_tup1) (length test_tup2)))\",\n    \"assert_3\": \"(define-fun C3 () Bool (> (length test_tup1) 0))\",\n    \"assert_4\": \"(define-fun C4 () Bool (> (length test_tup2) 0))\",\n    \"assert_5\": \"(define-fun C5 () Bool (list_all_list test_tup1))\",\n    \"assert_6\": \"(define-fun C6 () Bool (list_all_list test_tup2))\",\n    \"assert_7\": \"(define-fun C7 () Bool (list_all_len2 test_tup1))\",\n    \"assert_8\": \"(define-fun C8 () Bool (list_all_len2 test_tup2))\",\n    \"assert_9\": \"(define-fun C9 () Bool (list_all_numeric test_tup1))\",\n    \"assert_10\": \"(define-fun C10 () Bool (list_all_numeric test_tup2))\"\n  }\n}"], "constraints": [{"assert_0": "assert isinstance(test_tup1, tuple), \"invalid inputs", "assert_1": "assert isinstance(test_tup2, tuple), \"invalid inputs", "assert_2": "assert len(test_tup1) == len(test_tup2), \"invalid inputs", "assert_3": "assert len(test_tup1) > 0, \"invalid inputs", "assert_4": "assert len(test_tup2) > 0, \"invalid inputs", "assert_5": "assert all(isinstance(x, tuple) for x in test_tup1), \"invalid inputs", "assert_6": "assert all(isinstance(x, tuple) for x in test_tup2), \"invalid inputs", "assert_7": "assert all(len(x) == 2 for x in test_tup1), \"invalid inputs", "assert_8": "assert all(len(x) == 2 for x in test_tup2), \"invalid inputs", "assert_9": "assert all(isinstance(a, (int, float)) and isinstance(b, (int, float)) for a, b in test_tup1), \"invalid inputs", "assert_10": "assert all(isinstance(a, (int, float)) and isinstance(b, (int, float)) for a, b in test_tup2), \"invalid inputs"}]}], "reasoning": ["I will translate the Python assertions into named SMT-LIB predicates, define recursive helpers for list structure and numeric checks, and assert basic list‐shape requirements to maintain executability.</think>"]}
{"name": "Mbpp/301", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for \"only allowed characters\" patterns.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re \"(\")))) ...) is WRONG; use nested lets.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: dict_depth\nProblem Description:\n\"\"\"\nWrite a function to find the depth of a dictionary.\nassert dict_depth({'a':1, 'b': {'c': {'d': {}}}})==4\n\"\"\"\n\n\ndef dict_depth_aux(d):\n    if isinstance(d, dict):\n        return 1 + (max(map(dict_depth_aux, d.values())) if d else 0)\n    return 0\ndef dict_depth(d):\n\n    assert isinstance(d, dict), \"invalid inputs\" # $_CONTRACT_$\n    return dict_depth_aux(d)\n\n\nContract List:\nassert_0: assert isinstance(d, dict), \"invalid inputs\n\n"}], "grammar": [{"production": ["{\n  \"helper_functions\": \"(define-fun-rec IsList ((v Value)) Bool\\n  (or (is-Nil v) (and (is-Cons v) (IsList (tail v)))))\\n\\n; pair (a,b) ≡ Cons a (Cons b Nil)\\n(define-fun IsPair ((v Value)) Bool\\n  (and (is-Cons v) (is-Cons (tail v)) (is-Nil (tail (tail v)))))\\n(define-fun first  ((p Value)) Value (head p))\\n(define-fun second ((p Value)) Value (head (tail p)))\\n\\n; (StrVal key, Value val)인 (key,value) 쌍인지\\n(define-fun IsKVPair ((v Value)) Bool\\n  (and (IsPair v) (is-StrVal (first v))))\\n\\n; dict ≡ KVPair들의 리스트인지\\n(define-fun-rec IsDict ((v Value)) Bool\\n  (or (is-Nil v) (and (is-Cons v) (IsKVPair (head v)) (IsDict (tail v)))))\",\n  \"basic_structure\": \"\",\n  \"inputs\": \"(declare-const d Value)\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool (IsDict d))\"\n  }\n}"], "constraints": [{"assert_0": "assert isinstance(d, dict), \"invalid inputs"}]}], "reasoning": ["I model Python dicts as a DictVal holding a list of their value sub-dicts; define a recursive depth function with proper guards and a helper for iterating list tails. The single contract becomes a predicate C0 checking the input is a DictVal.</think>"]}
{"name": "Mbpp/413", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for \"only allowed characters\" patterns.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re \"(\")))) ...) is WRONG; use nested lets.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: extract_nth_element\nProblem Description:\n\"\"\"\nWrite a function to extract the nth element from a given list of tuples.\nassert extract_nth_element([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)] ,0)==['Greyson Fulton', 'Brady Kent', 'Wyatt Knott', 'Beau Turnbull']\n\"\"\"\n\n\ndef extract_nth_element(list1, n):\n\n    assert isinstance(list1, list), \"invalid inputs\" # $_CONTRACT_$\n    assert all(isinstance(tup, tuple) for tup in list1), \"invalid inputs\" # $_CONTRACT_$\n    assert isinstance(n, int), \"invalid inputs\" # $_CONTRACT_$\n    assert all(n < len(tup) for tup in list1), \"invalid inputs\" # $_CONTRACT_$\n    return [x[n] for x in list1]\n\n\nContract List:\nassert_0: assert isinstance(list1, list), \"invalid inputs\nassert_1: assert all(isinstance(tup, tuple) for tup in list1), \"invalid inputs\nassert_2: assert isinstance(n, int), \"invalid inputs\nassert_3: assert all(n < len(tup) for tup in list1), \"invalid inputs\n\n"}], "grammar": [{"production": ["{\n  \"helper_functions\": \"(define-fun-rec IsList ((l Value)) Bool\\n  (or (is-Nil l) (and (is-Cons l) (IsList (tail l)))))\\n\\n(define-fun-rec lengthList ((l Value)) Int\\n  (ite (is-Cons l) (+ 1 (lengthList (tail l))) 0))\\n\\n(define-fun SafeIval ((v Value)) Int\\n  (ite (is-IntVal v) (ival v) 0))\\n\\n; all elements are sequences (tuple≈list)\\n(define-fun-rec AllSeq ((l Value)) Bool\\n  (or (is-Nil l) (and (is-Cons l) (IsList (head l)) (AllSeq (tail l)))))\\n\\n; for each element tup: idx < len(tup)\\n(define-fun-rec AllIndexValid ((l Value) (idx Value)) Bool\\n  (or (is-Nil l)\\n      (and (is-Cons l) (IsList (head l))\\n           (< (SafeIval idx) (lengthList (head l)))\\n           (AllIndexValid (tail l) idx))))\",\n  \"basic_structure\": \"\",\n  \"inputs\": \"(declare-const list1 Value)\\n(declare-const n Value)\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool (IsList list1))\",\n    \"assert_1\": \"(define-fun C1 () Bool (AllSeq list1))\",\n    \"assert_2\": \"(define-fun C2 () Bool (is-IntVal n))\",\n    \"assert_3\": \"(define-fun C3 () Bool (AllIndexValid list1 n))\"\n  }\n}"], "constraints": [{"assert_0": "assert isinstance(list1, list), \"invalid inputs", "assert_1": "assert all(isinstance(tup, tuple) for tup in list1), \"invalid inputs", "assert_2": "assert isinstance(n, int), \"invalid inputs", "assert_3": "assert all(n < len(tup) for tup in list1), \"invalid inputs"}]}], "reasoning": ["I’ve captured the Python tuple‐and‐list structure by extending the Value ADT with a TupleVal constructor, written recursive helpers for list and tuple checks, safe integer extraction, and index‐validity, then mapped each Python assert to a named predicate C0–C3.</think>"]}
{"name": "Mbpp/429", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for \"only allowed characters\" patterns.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re \"(\")))) ...) is WRONG; use nested lets.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: and_tuples\nProblem Description:\n\"\"\"\nWrite a function to extract the elementwise and tuples from the given two tuples.\nassert and_tuples((10, 4, 6, 9), (5, 2, 3, 3)) == (0, 0, 2, 1)\n\"\"\"\n\n\ndef and_tuples(test_tup1, test_tup2):\n\n  assert isinstance(test_tup1, tuple), \"invalid inputs\" # $_CONTRACT_$\n  assert isinstance(test_tup2, tuple), \"invalid inputs\" # $_CONTRACT_$\n  assert len(test_tup1) == len(test_tup2), \"invalid inputs\" # $_CONTRACT_$\n  return tuple(x & y for x, y in zip(test_tup1, test_tup2))\n\n\nContract List:\nassert_0: assert isinstance(test_tup1, tuple), \"invalid inputs\nassert_1: assert isinstance(test_tup2, tuple), \"invalid inputs\nassert_2: assert len(test_tup1) == len(test_tup2), \"invalid inputs\n\n"}], "grammar": [{"production": ["{\n  \"helper_functions\": \"(define-fun-rec isList ((v Value)) Bool\\n  (ite (is-Nil v) true\\n    (ite (is-Cons v) (isList (tail v)) false)))\\n\\n(define-fun-rec length ((v Value)) Int\\n  (ite (is-Nil v) 0\\n    (ite (is-Cons v) (+ 1 (length (tail v))) 0)))\",\n  \"basic_structure\": \"(assert (isList test_tup1))\\n(assert (isList test_tup2))\",\n  \"inputs\": \"(declare-const test_tup1 Value)\\n(declare-const test_tup2 Value)\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool (isList test_tup1))\",\n    \"assert_1\": \"(define-fun C1 () Bool (isList test_tup2))\",\n    \"assert_2\": \"(define-fun C2 () Bool (= (length test_tup1) (length test_tup2)))\"\n  }\n}"], "constraints": [{"assert_0": "assert isinstance(test_tup1, tuple), \"invalid inputs", "assert_1": "assert isinstance(test_tup2, tuple), \"invalid inputs", "assert_2": "assert len(test_tup1) == len(test_tup2), \"invalid inputs"}]}], "reasoning": ["I represent Python tuples using the Value ADT with Nil/Cons, define recursive isList and length functions, assert list shape for executability, and map each Python assert to a Bool predicate C0–C2.</think>"]}
{"name": "Mbpp/465", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for \"only allowed characters\" patterns.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re \"(\")))) ...) is WRONG; use nested lets.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: drop_empty\nProblem Description:\n\"\"\"\nWrite a function to drop empty items from a given dictionary.\nassert drop_empty({'c1': 'Red', 'c2': 'Green', 'c3':None})=={'c1': 'Red', 'c2': 'Green'}\n\"\"\"\n\n\ndef drop_empty(dict1):\n\n  assert isinstance(dict1, dict), \"invalid inputs\" # $_CONTRACT_$\n  dict1 = {key:value for (key, value) in dict1.items() if value is not None}\n  return dict1\n\n\nContract List:\nassert_0: assert isinstance(dict1, dict), \"invalid inputs\n\n"}], "grammar": [{"production": ["{\n  \"helper_functions\": \"(define-fun-rec IsList ((v Value)) Bool\\n  (or (is-Nil v) (and (is-Cons v) (IsList (tail v)))))\\n\\n(define-fun IsPair ((v Value)) Bool\\n  (and (is-Cons v) (is-Cons (tail v)) (is-Nil (tail (tail v)))))\\n\\n(define-fun first ((p Value)) Value (head p))\\n(define-fun second ((p Value)) Value (head (tail p)))\\n\\n(define-fun IsKVPair ((v Value)) Bool\\n  (and (IsPair v) (is-StrVal (first v))))\\n\\n(define-fun-rec IsDict ((v Value)) Bool\\n  (or (is-Nil v) (and (is-Cons v) (IsKVPair (head v)) (IsDict (tail v)))))\",\n  \"basic_structure\": \"(assert (IsDict dict1))\",\n  \"inputs\": \"(declare-const dict1 Value)\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool (IsDict dict1))\"\n  }\n}"], "constraints": [{"assert_0": "assert isinstance(dict1, dict), \"invalid inputs"}]}], "reasoning": ["I represent Python dicts as a DictVal of a list of PairVal entries, define helper functions to check a list of pairs and dict shape, and then encode the single `isinstance(dict1, dict)` assertion as C0 relying on those helpers.</think>"]}
{"name": "Mbpp/585", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for \"only allowed characters\" patterns.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re \"(\")))) ...) is WRONG; use nested lets.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: expensive_items\nProblem Description:\n\"\"\"\nWrite a function to find the n most expensive items in a given dataset.\nassert expensive_items([{'name': 'Item-1', 'price': 101.1},{'name': 'Item-2', 'price': 555.22}],1)==[{'name': 'Item-2', 'price': 555.22}]\n\"\"\"\n\n\nimport heapq\ndef expensive_items(items,n):\n\n  assert isinstance(items, list), \"invalid inputs\" # $_CONTRACT_$\n  assert isinstance(n, int), \"invalid inputs\" # $_CONTRACT_$\n  assert n > 0, \"invalid inputs\" # $_CONTRACT_$\n  assert all(isinstance(x, dict) for x in items), \"invalid inputs\" # $_CONTRACT_$\n  assert all('name' in x.keys() for x in items), \"invalid inputs\" # $_CONTRACT_$\n  assert all('price' in x.keys() for x in items), \"invalid inputs\" # $_CONTRACT_$\n  assert all(isinstance(x['price'], (int, float)) for x in items), \"invalid inputs\" # $_CONTRACT_$\n  expensive_items = heapq.nlargest(n, items, key=lambda s: s['price'])\n  return expensive_items\n\n\nContract List:\nassert_0: assert isinstance(items, list), \"invalid inputs\nassert_1: assert isinstance(n, int), \"invalid inputs\nassert_2: assert n > 0, \"invalid inputs\nassert_3: assert all(isinstance(x, dict) for x in items), \"invalid inputs\nassert_4: assert all('name' in x.keys() for x in items), \"invalid inputs\nassert_5: assert all('price' in x.keys() for x in items), \"invalid inputs\nassert_6: assert all(isinstance(x['price'], (int, float)) for x in items), \"invalid inputs\n\n"}], "grammar": [{"production": ["{\n  \"helper_functions\": \"(define-fun-rec IsList ((l Value)) Bool (or (is-Nil l) (and (is-Cons l) (IsList (tail l)))))\\n(define-fun IsPair ((v Value)) Bool (and (is-Cons v) (is-Cons (tail v)) (is-Nil (tail (tail v)))))\\n(define-fun first ((p Value)) Value (head p))\\n(define-fun second ((p Value)) Value (head (tail p)))\\n(define-fun IsKVPair ((v Value)) Bool (and (IsPair v) (is-StrVal (first v))))\\n(define-fun-rec IsDict ((v Value)) Bool (or (is-Nil v) (and (is-Cons v) (IsKVPair (head v)) (IsDict (tail v)))))\\n(define-fun-rec dict_has_key ((d Value) (k Value)) Bool (ite (is-Cons d) (and (IsKVPair (head d)) (or (= (first (head d)) k) (dict_has_key (tail d) k))) false))\\n(define-fun-rec dict_get ((d Value) (k Value)) Value (ite (is-Cons d) (let ((p (head d))) (ite (and (IsKVPair p) (= (first p) k)) (second p) (dict_get (tail d) k))) (StrVal \\\"\\\")))\\n(define-fun IsNumeric ((v Value)) Bool (or (is-IntVal v) (is-FloatVal v)))\\n(define-fun-rec list_all_dict ((l Value)) Bool (or (is-Nil l) (and (is-Cons l) (IsDict (head l)) (list_all_dict (tail l)))))\\n(define-fun-rec list_all_has_name ((l Value)) Bool (or (is-Nil l) (and (is-Cons l) (IsDict (head l)) (dict_has_key (head l) (StrVal \\\"name\\\")) (list_all_has_name (tail l)))))\\n(define-fun-rec list_all_has_price ((l Value)) Bool (or (is-Nil l) (and (is-Cons l) (IsDict (head l)) (dict_has_key (head l) (StrVal \\\"price\\\")) (list_all_has_price (tail l)))))\\n(define-fun-rec list_all_price_numeric ((l Value)) Bool (or (is-Nil l) (and (is-Cons l) (IsDict (head l)) (IsNumeric (dict_get (head l) (StrVal \\\"price\\\"))) (list_all_price_numeric (tail l)))))\",\n  \"basic_structure\": \"\",\n  \"inputs\": \"(declare-const items Value)\\n(declare-const n Value)\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool (IsList items))\",\n    \"assert_1\": \"(define-fun C1 () Bool (is-IntVal n))\",\n    \"assert_2\": \"(define-fun C2 () Bool (and (is-IntVal n) (> (ival n) 0)))\",\n    \"assert_3\": \"(define-fun C3 () Bool (list_all_dict items))\",\n    \"assert_4\": \"(define-fun C4 () Bool (list_all_has_name items))\",\n    \"assert_5\": \"(define-fun C5 () Bool (list_all_has_price items))\",\n    \"assert_6\": \"(define-fun C6 () Bool (list_all_price_numeric items))\"\n  }\n}"], "constraints": [{"assert_0": "assert isinstance(items, list), \"invalid inputs", "assert_1": "assert isinstance(n, int), \"invalid inputs", "assert_2": "assert n > 0, \"invalid inputs", "assert_3": "assert all(isinstance(x, dict) for x in items), \"invalid inputs", "assert_4": "assert all('name' in x.keys() for x in items), \"invalid inputs", "assert_5": "assert all('price' in x.keys() for x in items), \"invalid inputs", "assert_6": "assert all(isinstance(x['price'], (int, float)) for x in items), \"invalid inputs"}]}], "reasoning": ["I map each Python assertion to a standalone SMT predicate C0–C6, define a minimal Value ADT with a DictVal constructor, build safe list/dict helpers (guarded by testers), assert only the structural preconditions in BASIC_STRUCTURE, and declare inputs and contracts as requested.</think>"]}
{"name": "Mbpp/614", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for \"only allowed characters\" patterns.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re \"(\")))) ...) is WRONG; use nested lets.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: cummulative_sum\nProblem Description:\n\"\"\"\nWrite a function to find the cumulative sum of all the values that are present in the given tuple list.\nassert cummulative_sum([(1, 3), (5, 6, 7), (2, 6)]) == 30\n\"\"\"\n\n\ndef cummulative_sum(test_list):\n\n  assert isinstance(test_list, list), \"invalid inputs\" # $_CONTRACT_$\n  assert all(isinstance(el, tuple) for el in test_list), \"invalid inputs\" # $_CONTRACT_$\n  assert all(isinstance(el, (int, float)) for el in sum(test_list, ())), \"invalid inputs\" # $_CONTRACT_$\n  return sum(map(sum, test_list))\n\n\nContract List:\nassert_0: assert isinstance(test_list, list), \"invalid inputs\nassert_1: assert all(isinstance(el, tuple) for el in test_list), \"invalid inputs\nassert_2: assert all(isinstance(el, (int, float)) for el in sum(test_list, ())), \"invalid inputs\n\n"}], "grammar": [{"production": ["{\n  \"helper_functions\": \"(define-fun-rec IsList ((v Value)) Bool\\n  (or (is-Nil v) (and (is-Cons v) (IsList (tail v)))))\\n\\n(define-fun-rec AllSeq ((l Value)) Bool\\n  (or (is-Nil l) (and (is-Cons l) (IsList (head l)) (AllSeq (tail l)))))\\n\\n(define-fun-rec concatenate ((t1 Value) (t2 Value)) Value\\n  (ite (is-Nil t1) t2 (Cons (head t1) (concatenate (tail t1) t2))))\\n\\n(define-fun-rec flatten ((lst Value)) Value\\n  (ite (is-Nil lst) Nil (concatenate (head lst) (flatten (tail lst)))))\\n\\n(define-fun IsNumeric ((v Value)) Bool (or (is-IntVal v) (is-FloatVal v)))\\n\\n(define-fun-rec list_all_numeric ((lst Value)) Bool\\n  (or (is-Nil lst) (and (is-Cons lst) (IsNumeric (head lst)) (list_all_numeric (tail lst)))))\",\n  \"basic_structure\": \"(assert (IsList test_list))\",\n  \"inputs\": \"(declare-const test_list Value)\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool (IsList test_list))\",\n    \"assert_1\": \"(define-fun C1 () Bool (AllSeq test_list))\",\n    \"assert_2\": \"(define-fun C2 () Bool (ite C1 (list_all_numeric (flatten test_list)) false))\"\n  }\n}"], "constraints": [{"assert_0": "assert isinstance(test_list, list), \"invalid inputs", "assert_1": "assert all(isinstance(el, tuple) for el in test_list), \"invalid inputs", "assert_2": "assert all(isinstance(el, (int, float)) for el in sum(test_list, ())), \"invalid inputs"}]}], "reasoning": ["</think>"]}
{"name": "Mbpp/622", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for \"only allowed characters\" patterns.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re \"(\")))) ...) is WRONG; use nested lets.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: get_median\nProblem Description:\n\"\"\"\nWrite a function to find the median of two sorted lists of same size.\nassert get_median([1, 12, 15, 26, 38], [2, 13, 17, 30, 45], 5) == 16.0\n\"\"\"\n\n\ndef get_median(arr1, arr2, n):\n\n  assert isinstance(arr1, list), \"invalid inputs\" # $_CONTRACT_$\n  assert isinstance(arr2, list), \"invalid inputs\" # $_CONTRACT_$\n  assert 0 <= n <= min(len(arr1), len(arr2)), \"invalid inputs\" # $_CONTRACT_$\n  assert all(isinstance(el, (int, float)) for el in arr1 + arr2), \"invalid inputs\" # $_CONTRACT_$\n  assert all(x <= y for x, y in zip(arr1[0:n], arr1[1:n])), \"invalid inputs\" # $_CONTRACT_$\n  assert all(x <= y for x, y in zip(arr2[0:n], arr2[1:n])), \"invalid inputs\" # $_CONTRACT_$\n  i = 0\n  j = 0\n  m1 = -1\n  m2 = -1\n  count = 0\n  while count < n + 1:\n    count += 1\n    if i == n:\n      m1 = m2\n      m2 = arr2[0]\n      break\n    elif j == n:\n      m1 = m2\n      m2 = arr1[0]\n      break\n    if arr1[i] <= arr2[j]:\n      m1 = m2\n      m2 = arr1[i]\n      i += 1\n    else:\n      m1 = m2\n      m2 = arr2[j]\n      j += 1\n  return (m1 + m2)/2\n\n\nContract List:\nassert_0: assert isinstance(arr1, list), \"invalid inputs\nassert_1: assert isinstance(arr2, list), \"invalid inputs\nassert_2: assert 0 <= n <= min(len(arr1), len(arr2)), \"invalid inputs\nassert_3: assert all(isinstance(el, (int, float)) for el in arr1 + arr2), \"invalid inputs\nassert_4: assert all(x <= y for x, y in zip(arr1[0:n], arr1[1:n])), \"invalid inputs\nassert_5: assert all(x <= y for x, y in zip(arr2[0:n], arr2[1:n])), \"invalid inputs\n\n"}], "grammar": [{"production": ["{\n  \"helper_functions\": \"(define-fun-rec IsList ((v Value)) Bool\\n  (ite (is-Nil v) true\\n       (ite (is-Cons v) (IsList (tail v)) false)))\\n\\n(define-fun-rec length ((l Value)) Int\\n  (ite (is-Nil l) 0\\n       (ite (is-Cons l) (+ 1 (length (tail l))) 0)))\\n\\n(define-fun SafeI ((v Value)) Int\\n  (ite (is-IntVal v) (ival v) 0))\\n\\n(define-fun toReal ((v Value)) Real\\n  (ite (is-IntVal v) (to_real (ival v))\\n       (ite (is-FloatVal v) (fval v) 0.0)))\\n\\n(define-fun-rec list_all_numeric ((l Value)) Bool\\n  (ite (is-Nil l) true\\n       (ite (is-Cons l)\\n            (let ((hd (head l)) (tl (tail l)))\\n              (and (or (is-IntVal hd) (is-FloatVal hd))\\n                   (list_all_numeric tl)))\\n            false)))\\n\\n(define-fun-rec sorted_prefix ((l Value) (k Int)) Bool\\n  (ite (<= k 1) true\\n       (and (is-Cons l)\\n            (is-Cons (tail l))\\n            (<= (toReal (head l)) (toReal (head (tail l))))\\n            (sorted_prefix (tail l) (- k 1)))))\",\n  \"basic_structure\": \"(assert (IsList arr1))\\n(assert (IsList arr2))\\n(assert (is-IntVal n))\",\n  \"inputs\": \"(declare-const arr1 Value)\\n(declare-const arr2 Value)\\n(declare-const n Value)\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool (IsList arr1))\",\n    \"assert_1\": \"(define-fun C1 () Bool (IsList arr2))\",\n    \"assert_2\": \"(define-fun C2 () Bool (and (is-IntVal n) (<= 0 (ival n)) (<= (ival n) (length arr1)) (<= (ival n) (length arr2))))\",\n    \"assert_3\": \"(define-fun C3 () Bool (and (list_all_numeric arr1) (list_all_numeric arr2)))\",\n    \"assert_4\": \"(define-fun C4 () Bool (sorted_prefix arr1 (SafeI n)))\",\n    \"assert_5\": \"(define-fun C5 () Bool (sorted_prefix arr2 (SafeI n)))\"\n  }\n}"], "constraints": [{"assert_0": "assert isinstance(arr1, list), \"invalid inputs", "assert_1": "assert isinstance(arr2, list), \"invalid inputs", "assert_2": "assert 0 <= n <= min(len(arr1), len(arr2)), \"invalid inputs", "assert_3": "assert all(isinstance(el, (int, float)) for el in arr1 + arr2), \"invalid inputs", "assert_4": "assert all(x <= y for x, y in zip(arr1[0:n], arr1[1:n])), \"invalid inputs", "assert_5": "assert all(x <= y for x, y in zip(arr2[0:n], arr2[1:n])), \"invalid inputs"}]}], "reasoning": ["I will translate each Python assertion into a precise SMT-LIB predicate over the canonical Value ADT, define recursive helpers for list shape, length, numeric‐element checks, and sorted prefixes, and assert only the minimal structural invariants in the basic structure so that each contract Ck can be tested independently.</think>"]}
{"name": "Mbpp/720", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for \"only allowed characters\" patterns.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re \"(\")))) ...) is WRONG; use nested lets.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: add_dict_to_tuple\nProblem Description:\n\"\"\"\nWrite a function to add a dictionary to the tuple. The output should be a tuple.\nassert add_dict_to_tuple((4, 5, 6), {\"MSAM\" : 1, \"is\" : 2, \"best\" : 3} ) == (4, 5, 6, {'MSAM': 1, 'is': 2, 'best': 3})\n\"\"\"\n\n\ndef add_dict_to_tuple(test_tup, test_dict):\n\n  assert isinstance(test_tup, tuple), \"invalid inputs\" # $_CONTRACT_$\n  assert isinstance(test_dict, dict), \"invalid inputs\" # $_CONTRACT_$\n  return test_tup + (test_dict, )\n\n\nContract List:\nassert_0: assert isinstance(test_tup, tuple), \"invalid inputs\nassert_1: assert isinstance(test_dict, dict), \"invalid inputs\n\n"}], "grammar": [{"production": ["{\n  \"helper_functions\": \"(define-fun-rec IsList ((v Value)) Bool\\n  (or (is-Nil v) (and (is-Cons v) (IsList (tail v)))))\\n\\n(define-fun IsPair ((v Value)) Bool\\n  (and (is-Cons v) (is-Cons (tail v)) (is-Nil (tail (tail v)))))\\n(define-fun first ((p Value)) Value (head p))\\n(define-fun second ((p Value)) Value (head (tail p)))\\n\\n(define-fun IsKVPair ((v Value)) Bool\\n  (and (IsPair v) (is-StrVal (first v))))\\n\\n(define-fun-rec IsDict ((v Value)) Bool\\n  (or (is-Nil v) (and (is-Cons v) (IsKVPair (head v)) (IsDict (tail v)))))\",\n  \"basic_structure\": \"\",\n  \"inputs\": \"(declare-const test_tup Value)\\n(declare-const test_dict Value)\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool (IsList test_tup))\",\n    \"assert_1\": \"(define-fun C1 () Bool (IsDict test_dict))\"\n  }\n}"], "constraints": [{"assert_0": "assert isinstance(test_tup, tuple), \"invalid inputs", "assert_1": "assert isinstance(test_dict, dict), \"invalid inputs"}]}], "reasoning": ["I translate the Python type‐checks into SMT‐LIB type predicates by modeling tuples as lists (Nil/Cons) and dictionaries with a DictVal constructor, provide a recursive IsList helper, declare inputs, and define C0/C1 exactly matching the assertions. This template leaves BASIC_STRUCTURE empty (no invariants beyond contracts) and includes combination scenarios for systematic testing.</think>"]}
{"name": "Mbpp/722", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for \"only allowed characters\" patterns.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re \"(\")))) ...) is WRONG; use nested lets.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: filter_data\nProblem Description:\n\"\"\"\nThe input is given as - a dictionary with a student name as a key and a tuple of float (student_height, student_weight) as a value, - minimal height, - minimal weight. Write a function to filter students that have height and weight above the minimum.\nassert filter_data({'Cierra Vega': (6.2, 70), 'Alden Cantrell': (5.9, 65), 'Kierra Gentry': (6.0, 68), 'Pierre Cox': (5.8, 66)},6.0,70)=={'Cierra Vega': (6.2, 70)}\n\"\"\"\n\n\ndef filter_data(students,h,w):\n\n    assert isinstance(students, dict), \"invalid inputs\" # $_CONTRACT_$\n    assert all(isinstance(x, str) for x in students.keys()), \"invalid inputs\" # $_CONTRACT_$\n    assert all(isinstance(x, tuple) for x in students.values()), \"invalid inputs\" # $_CONTRACT_$\n    assert all(len(x) == 2 for x in students.values()), \"invalid inputs\" # $_CONTRACT_$\n    assert all(isinstance(height, (int, float)) and isinstance(weight, (int, float)) for height, weight in students.values()) # $_CONTRACT_$\n    assert isinstance(h, (int, float)), \"invalid inputs\" # $_CONTRACT_$\n    assert isinstance(w, (int, float)), \"invalid inputs\" # $_CONTRACT_$\n    assert h >= 0, \"invalid inputs\" # $_CONTRACT_$\n    assert w >= 0, \"invalid inputs\" # $_CONTRACT_$\n    return {k: s for k, s in students.items() if s[0] >= h and s[1] >= w}\n\n\nContract List:\nassert_0: assert isinstance(students, dict), \"invalid inputs\nassert_1: assert all(isinstance(x, str) for x in students.keys()), \"invalid inputs\nassert_2: assert all(isinstance(x, tuple) for x in students.values()), \"invalid inputs\nassert_3: assert all(len(x) == 2 for x in students.values()), \"invalid inputs\nassert_4: assert all(isinstance(height, (int, float)) and isinstance(weight, (int, float)) for height, weight in students.values())\nassert_5: assert isinstance(h, (int, float)), \"invalid inputs\nassert_6: assert isinstance(w, (int, float)), \"invalid inputs\nassert_7: assert h >= 0, \"invalid inputs\nassert_8: assert w >= 0, \"invalid inputs\n\n"}], "grammar": [{"production": ["{\n  \"helper_functions\": \"(define-fun-rec IsList ((l Value)) Bool\\n  (or (is-Nil l) (and (is-Cons l) (IsList (tail l)))))\\n\\n; pair (a,b) ≡ Cons a (Cons b Nil)\\n(define-fun IsPair ((v Value)) Bool\\n  (and (is-Cons v) (is-Cons (tail v)) (is-Nil (tail (tail v)))))\\n(define-fun first  ((p Value)) Value (head p))\\n(define-fun second ((p Value)) Value (head (tail p)))\\n\\n; dict := list of (StrVal key, Value val) pairs\\n(define-fun IsKVPair ((v Value)) Bool\\n  (and (IsPair v) (is-StrVal (first v))))\\n(define-fun-rec IsDict ((v Value)) Bool\\n  (or (is-Nil v) (and (is-Cons v) (IsKVPair (head v)) (IsDict (tail v)))))\\n\\n; all keys are strings (redundant if IsDict holds, but kept for contract mapping)\\n(define-fun-rec AllKeysStr ((d Value)) Bool\\n  (or (is-Nil d) (and (is-Cons d) (IsKVPair (head d)) (AllKeysStr (tail d)))))\\n\\n; all values are pairs (tuple-like)\\n(define-fun-rec AllValsPair ((d Value)) Bool\\n  (or (is-Nil d) (and (is-Cons d) (IsKVPair (head d)) (IsPair (second (head d))) (AllValsPair (tail d)))))\\n\\n; all values have length 2 (same as pair, kept to mirror contract)\\n(define-fun-rec AllValLen2 ((d Value)) Bool\\n  (or (is-Nil d) (and (is-Cons d) (IsKVPair (head d)) (IsPair (second (head d))) (AllValLen2 (tail d)))))\\n\\n; numeric helpers\\n(define-fun is-Number ((v Value)) Bool (or (is-IntVal v) (is-FloatVal v)))\\n(define-fun SafeReal ((v Value)) Real\\n  (ite (is-FloatVal v) (fval v) (ite (is-IntVal v) (to_real (ival v)) 0.0)))\\n\\n; all (height, weight) are numeric\\n(define-fun-rec AllValsNumericPair ((d Value)) Bool\\n  (or (is-Nil d)\\n      (and (is-Cons d) (IsKVPair (head d))\\n           (let ((v (second (head d))))\\n             (and (IsPair v) (is-Number (first v)) (is-Number (second v))))\\n           (AllValsNumericPair (tail d)))))\",\n  \"basic_structure\": \"\",\n  \"inputs\": \"(declare-const students Value)\\n(declare-const h Value)\\n(declare-const w Value)\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool (IsDict students))\",\n    \"assert_1\": \"(define-fun C1 () Bool (AllKeysStr students))\",\n    \"assert_2\": \"(define-fun C2 () Bool (AllValsPair students))\",\n    \"assert_3\": \"(define-fun C3 () Bool (AllValLen2 students))\",\n    \"assert_4\": \"(define-fun C4 () Bool (AllValsNumericPair students))\",\n    \"assert_5\": \"(define-fun C5 () Bool (is-Number h))\",\n    \"assert_6\": \"(define-fun C6 () Bool (is-Number w))\",\n    \"assert_7\": \"(define-fun C7 () Bool (and (is-Number h) (>= (SafeReal h) 0.0)))\",\n    \"assert_8\": \"(define-fun C8 () Bool (and (is-Number w) (>= (SafeReal w) 0.0)))\"\n  }\n}"], "constraints": [{"assert_0": "assert isinstance(students, dict), \"invalid inputs", "assert_1": "assert all(isinstance(x, str) for x in students.keys()), \"invalid inputs", "assert_2": "assert all(isinstance(x, tuple) for x in students.values()), \"invalid inputs", "assert_3": "assert all(len(x) == 2 for x in students.values()), \"invalid inputs", "assert_4": "assert all(isinstance(height, (int, float)) and isinstance(weight, (int, float)) for height, weight in students.values())", "assert_5": "assert isinstance(h, (int, float)), \"invalid inputs", "assert_6": "assert isinstance(w, (int, float)), \"invalid inputs", "assert_7": "assert h >= 0, \"invalid inputs", "assert_8": "assert w >= 0, \"invalid inputs"}]}], "reasoning": ["I encoded the Python dict as a list of key-value pairs using a Pair constructor, then defined recursive helpers to enforce list structure, key type, tuple shape, and numeric checks. Structural invariants (C0–C6) go into basic_structure for safe execution, while range assertions (C7–C8) remain as separate contracts.</think>"]}
{"name": "Mbpp/728", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for \"only allowed characters\" patterns.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re \"(\")))) ...) is WRONG; use nested lets.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: sum_list\nProblem Description:\n\"\"\"\nWrite a function takes as input two lists [a_1,...,a_n], [b_1,...,b_n] and returns [a_1+b_1,...,a_n+b_n].\nassert sum_list([10,20,30],[15,25,35])==[25,45,65]\n\"\"\"\n\n\ndef sum_list(lst1,lst2):\n\n  assert isinstance(lst1, list), \"invalid inputs\" # $_CONTRACT_$\n  assert isinstance(lst2, list), \"invalid inputs\" # $_CONTRACT_$\n  assert len(lst1) == len(lst2), \"invalid inputs\" # $_CONTRACT_$\n  return [a + b for a, b in zip(lst1, lst2)] \n\n\nContract List:\nassert_0: assert isinstance(lst1, list), \"invalid inputs\nassert_1: assert isinstance(lst2, list), \"invalid inputs\nassert_2: assert len(lst1) == len(lst2), \"invalid inputs\n\n"}], "grammar": [{"production": ["{\n  \"helper_functions\": \"(define-fun-rec IsList ((lst Value)) Bool\\n  (or (is-Nil lst)\\n      (and (is-Cons lst)\\n           (IsList (tail lst)))))\\n\\n(define-fun-rec length ((lst Value)) Int\\n  (ite (is-Nil lst) 0\\n       (ite (is-Cons lst)\\n            (+ 1 (length (tail lst)))\\n            0)))\",\n  \"basic_structure\": \"(assert (IsList lst1))\\n(assert (IsList lst2))\",\n  \"inputs\": \"(declare-const lst1 Value)\\n(declare-const lst2 Value)\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool (IsList lst1))\",\n    \"assert_1\": \"(define-fun C1 () Bool (IsList lst2))\",\n    \"assert_2\": \"(define-fun C2 () Bool (= (length lst1) (length lst2)))\"\n  }\n}"], "constraints": [{"assert_0": "assert isinstance(lst1, list), \"invalid inputs", "assert_1": "assert isinstance(lst2, list), \"invalid inputs", "assert_2": "assert len(lst1) == len(lst2), \"invalid inputs"}]}], "reasoning": ["I define recursive helpers for list structure and length, declare inputs as Value, enforce basic list-shape constraints, and translate each Python assertion into an SMT Bool predicate for exact semantic matching.</think>"]}
{"name": "Mbpp/736", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for \"only allowed characters\" patterns.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re \"(\")))) ...) is WRONG; use nested lets.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: left_insertion\nProblem Description:\n\"\"\"\nWrite a function to locate the left insertion point for a specified value in sorted order. \nassert left_insertion([1,2,4,5],6)==4\n\"\"\"\n\n\nimport bisect\ndef left_insertion(a, x):\n\n    assert isinstance(a, list), \"invalid inputs\" # $_CONTRACT_$\n    assert all(x <= y for x, y in zip(a, a[1:])), \"invalid inputs\" # $_CONTRACT_$\n    assert all(isinstance(x, (int, float)) for x in a), \"invalid inputs\" # $_CONTRACT_$\n    return bisect.bisect_left(a, x)\n\n\nContract List:\nassert_0: assert isinstance(a, list), \"invalid inputs\nassert_1: assert all(x <= y for x, y in zip(a, a[1:])), \"invalid inputs\nassert_2: assert all(isinstance(x, (int, float)) for x in a), \"invalid inputs\n\n"}], "grammar": [{"production": ["{\n  \"helper_functions\": \"(define-fun-rec IsList ((v Value)) Bool\\n  (or (is-Nil v) (and (is-Cons v) (IsList (tail v)))))\\n\\n(define-fun value_to_real ((v Value)) Real\\n  (ite (is-IntVal v) (to_real (ival v)) (ite (is-FloatVal v) (fval v) 0.0)))\\n\\n(define-fun-rec list_all_numeric ((lst Value)) Bool\\n  (or (is-Nil lst) (and (or (is-IntVal (head lst)) (is-FloatVal (head lst))) (list_all_numeric (tail lst)))))\\n\\n(define-fun-rec list_sorted ((lst Value)) Bool\\n  (or (is-Nil lst)\\n      (and (is-Cons lst)\\n           (or (is-Nil (tail lst))\\n               (and (<= (value_to_real (head lst)) (value_to_real (head (tail lst))))\\n                    (list_sorted (tail lst)))))))\",\n  \"basic_structure\": \"(assert (IsList a))\",\n  \"inputs\": \"(declare-const a Value)\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool (IsList a))\",\n    \"assert_1\": \"(define-fun C1 () Bool (list_sorted a))\",\n    \"assert_2\": \"(define-fun C2 () Bool (list_all_numeric a))\"\n  }\n}"], "constraints": [{"assert_0": "assert isinstance(a, list), \"invalid inputs", "assert_1": "assert all(x <= y for x, y in zip(a, a[1:])), \"invalid inputs", "assert_2": "assert all(isinstance(x, (int, float)) for x in a), \"invalid inputs"}]}], "reasoning": ["I translate each Python assertion into an SMT predicate over our canonical ADT, adding recursive definitions for list structure, numeric checking, and sorting. I declare the input and assert only the fundamental shape in the basic structure, leaving each contract in its own Ck definition.</think>"]}
{"name": "Mbpp/753", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for \"only allowed characters\" patterns.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re \"(\")))) ...) is WRONG; use nested lets.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: min_k\nProblem Description:\n\"\"\"\nWrite a function to find minimum k records from tuple list.  - in this case a verbatim copy of test cases\nassert min_k([('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)], 2) == [('Akash', 2), ('Akshat', 4)]\n\"\"\"\n\n\ndef min_k(test_list, K):\n\n  assert isinstance(test_list, list), \"invalid inputs\" # $_CONTRACT_$\n  assert all(isinstance(x, tuple) for x in test_list), \"invalid inputs\" # $_CONTRACT_$\n  assert all(isinstance(x[1], (int, float)) for x in test_list), \"invalid inputs\" # $_CONTRACT_$\n  assert K <= len(test_list), \"invalid inputs\" # $_CONTRACT_$\n  res = sorted(test_list, key = lambda x: x[1])[:K]\n  return (res) \n\n\nContract List:\nassert_0: assert isinstance(test_list, list), \"invalid inputs\nassert_1: assert all(isinstance(x, tuple) for x in test_list), \"invalid inputs\nassert_2: assert all(isinstance(x[1], (int, float)) for x in test_list), \"invalid inputs\nassert_3: assert K <= len(test_list), \"invalid inputs\n\n"}], "grammar": [{"production": ["{\n  \"helper_functions\": \"(define-fun-rec IsList ((l Value)) Bool\\n  (or (is-Nil l) (and (is-Cons l) (IsList (tail l)))))\\n\\n(define-fun isNumericVal ((v Value)) Bool\\n  (or (is-IntVal v) (is-FloatVal v)))\\n\\n; all elements are sequences (we'll cast to Python tuples on reconstruction)\\n(define-fun-rec AllSeq ((l Value)) Bool\\n  (or (is-Nil l) (and (is-Cons l) (IsList (head l)) (AllSeq (tail l)))))\\n\\n; check that each element has a numeric second item (index 1)\\n(define-fun-rec AllSecondNumeric ((l Value)) Bool\\n  (or (is-Nil l)\\n      (and (is-Cons l)\\n           (IsList (head l))\\n           (is-Cons (tail (head l)))\\n           (isNumericVal (head (tail (head l))))\\n           (AllSecondNumeric (tail l)))))\\n\\n(define-fun-rec length ((l Value)) Int\\n  (ite (is-Nil l) 0 (ite (is-Cons l) (+ 1 (length (tail l))) 0)))\",\n  \"basic_structure\": \"\",\n  \"inputs\": \"(declare-const test_list Value)\\n(declare-const K Value)\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool (IsList test_list))\",\n    \"assert_1\": \"(define-fun C1 () Bool (AllSeq test_list))\",\n    \"assert_2\": \"(define-fun C2 () Bool (AllSecondNumeric test_list))\",\n    \"assert_3\": \"(define-fun C3 () Bool (and (is-IntVal K) (<= (ival K) (length test_list))))\"\n  }\n}"], "constraints": [{"assert_0": "assert isinstance(test_list, list), \"invalid inputs", "assert_1": "assert all(isinstance(x, tuple) for x in test_list), \"invalid inputs", "assert_2": "assert all(isinstance(x[1], (int, float)) for x in test_list), \"invalid inputs", "assert_3": "assert K <= len(test_list), \"invalid inputs"}]}], "reasoning": ["I extend the ADT with a Tuple constructor and define recursive helpers for list structure, tuple and numeric checks, and list length. Then I declare inputs, assert base structure, and define named predicates C0–C3 mirroring the Python assertions exactly.</think>"]}
{"name": "Mbpp/780", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for \"only allowed characters\" patterns.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re \"(\")))) ...) is WRONG; use nested lets.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: find_combinations\nProblem Description:\n\"\"\"\nWrite a function to find the combinations of sums with tuples in the given tuple list. \nassert find_combinations([(2, 4), (6, 7), (5, 1), (6, 10)]) == [(8, 11), (7, 5), (8, 14), (11, 8), (12, 17), (11, 11)]\n\"\"\"\n\n\nfrom itertools import combinations \ndef find_combinations(test_list):\n\n  assert isinstance(test_list, list), \"invalid inputs\" # $_CONTRACT_$\n  assert len(test_list) > 0, \"invalid inputs\" # $_CONTRACT_$\n  assert all(isinstance(t, tuple) for t in test_list), \"invalid inputs\" # $_CONTRACT_$\n  assert all(len(t) == len(test_list[0]) for t in test_list), \"invalid inputs\" # $_CONTRACT_$))\n  assert all(isinstance(x, (int, float)) for t in test_list for x in t), \"invalid inputs\" # $_CONTRACT_$\n  return [tuple(map(sum, zip(*t))) for t in combinations(test_list, 2)]\n\n\nContract List:\nassert_0: assert isinstance(test_list, list), \"invalid inputs\nassert_1: assert len(test_list) > 0, \"invalid inputs\nassert_2: assert all(isinstance(t, tuple) for t in test_list), \"invalid inputs\nassert_3: assert all(len(t) == len(test_list[0]) for t in test_list), \"invalid inputs\" ))\nassert_4: assert all(isinstance(x, (int, float)) for t in test_list for x in t), \"invalid inputs\n\n"}], "grammar": [{"production": ["{\n  \"helper_functions\": \"(define-fun-rec IsList ((v Value)) Bool (ite (is-Nil v) true (ite (is-Cons v) (IsList (tail v)) false)))\\n(define-fun-rec list_length ((v Value)) Int (ite (is-Nil v) 0 (ite (is-Cons v) (+ 1 (list_length (tail v))) 0)))\\n(define-fun-rec AllSeq ((lst Value)) Bool (ite (is-Nil lst) true (ite (is-Cons lst) (and (IsList (head lst)) (AllSeq (tail lst))) false)))\\n(define-fun-rec all_same_length ((lst Value) (base_len Int)) Bool (ite (is-Nil lst) true (ite (is-Cons lst) (and (IsList (head lst)) (= (list_length (head lst)) base_len) (all_same_length (tail lst) base_len)) false)))\\n(define-fun-rec all_numeric ((lst Value)) Bool (ite (is-Nil lst) true (ite (is-Cons lst) (and (or (is-IntVal (head lst)) (is-FloatVal (head lst))) (all_numeric (tail lst))) false)))\\n(define-fun-rec all_numeric_tuples ((lst Value)) Bool (ite (is-Nil lst) true (ite (is-Cons lst) (and (IsList (head lst)) (all_numeric (head lst)) (all_numeric_tuples (tail lst))) false)))\",\n  \"basic_structure\": \"(assert (IsList test_list))\",\n  \"inputs\": \"(declare-const test_list Value)\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool (IsList test_list))\",\n    \"assert_1\": \"(define-fun C1 () Bool (> (list_length test_list) 0))\",\n    \"assert_2\": \"(define-fun C2 () Bool (AllSeq test_list))\",\n    \"assert_3\": \"(define-fun C3 () Bool (all_same_length test_list (ite (is-Cons test_list) (list_length (head test_list)) 0)))\",\n    \"assert_4\": \"(define-fun C4 () Bool (all_numeric_tuples test_list))\"\n  }\n}"], "constraints": [{"assert_0": "assert isinstance(test_list, list), \"invalid inputs", "assert_1": "assert len(test_list) > 0, \"invalid inputs", "assert_2": "assert all(isinstance(t, tuple) for t in test_list), \"invalid inputs", "assert_3": "assert all(len(t) == len(test_list[0]) for t in test_list), \"invalid inputs\" ))", "assert_4": "assert all(isinstance(x, (int, float)) for t in test_list for x in t), \"invalid inputs"}]}], "reasoning": ["I will translate the Python input‐validation assertions into precise SMT‐LIB predicates, define necessary recursive helpers (IsList, list_length, all_same_length, all_numeric, all_numeric_tuples) to enforce ADT shape and flatten checks, and capture each assert as C0…C4. The basic structure ensures the input is a well‐formed list before any contract.</think>"]}
{"name": "Mbpp/785", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for \"only allowed characters\" patterns.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re \"(\")))) ...) is WRONG; use nested lets.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: tuple_str_int\nProblem Description:\n\"\"\"\nWrite a function to convert tuple string to integer tuple.\nassert tuple_str_int(\"(7, 8, 9)\") == (7, 8, 9)\n\"\"\"\n\n\ndef tuple_str_int(test_str):\n\n  assert isinstance(test_str, str), \"invalid inputs\" # $_CONTRACT_$\n  assert test_str.startswith('('), \"invalid inputs\" # $_CONTRACT_$\n  assert test_str.endswith(')'), \"invalid inputs\" # $_CONTRACT_$\n  assert test_str.lstrip('(').rstrip(')').replace('...', '').replace(',', '').replace(' ', '').isdigit(), \"invalid inputs\" # $_CONTRACT_$\n  return tuple(int(num) for num in test_str.replace('(', '').replace(')', '').replace('...', '').split(', '))\n\n\nContract List:\nassert_0: assert isinstance(test_str, str), \"invalid inputs\nassert_1: assert test_str.startswith('('), \"invalid inputs\nassert_2: assert test_str.endswith(')'), \"invalid inputs\nassert_3: assert test_str.lstrip('(').rstrip(')').replace('...', '').replace(',', '').replace(' ', '').isdigit(), \"invalid inputs\n\n"}], "grammar": [{"production": ["{\n  \"helper_functions\": \"(define-fun SafeStr ((v Value)) String (ite (is-StrVal v) (sval v) \\\"\\\"))\\n\\n(define-fun-rec replace_all ((s String) (target String) (rep String)) String\\n  (ite (str.contains s target)\\n       (let ((idx (str.indexof s target 0)))\\n         (let ((pre  (str.substr s 0 idx))\\n               (post (str.substr s (+ idx (str.len target)) (- (str.len s) (+ idx (str.len target))))))\\n           (str.++ pre rep (replace_all post target rep))))\\n       s))\\n\\n(define-fun is_digit_string ((s String)) Bool (str.in.re s (re.+ (re.range \\\"0\\\" \\\"9\\\"))))\",\n  \"basic_structure\": \"\",\n  \"inputs\": \"(declare-const test_str Value)\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool (is-StrVal test_str))\",\n    \"assert_1\": \"(define-fun C1 () Bool (and (is-StrVal test_str) (str.prefixof \\\"(\\\" (SafeStr test_str))))\",\n    \"assert_2\": \"(define-fun C2 () Bool (and (is-StrVal test_str) (str.suffixof \\\")\\\" (SafeStr test_str))))\",\n    \"assert_3\": \"(define-fun C3 () Bool\\n  (let ((s0 (SafeStr test_str)))\\n    (let ((inner (ite (and (str.prefixof \\\"(\\\" s0) (str.suffixof \\\")\\\" s0))\\n                       (str.substr s0 1 (- (str.len s0) 2))\\n                       \\\"\\\")))\\n      (let ((s1 (replace_all inner \\\"...\\\" \\\"\\\")))\\n        (let ((s2 (replace_all s1 \\\",\\\" \\\"\\\")))\\n          (let ((s3 (replace_all s2 \\\" \\\" \\\"\\\")))\\n            (is_digit_string s3)))))))\"\n  }\n}"], "constraints": [{"assert_0": "assert isinstance(test_str, str), \"invalid inputs", "assert_1": "assert test_str.startswith('('), \"invalid inputs", "assert_2": "assert test_str.endswith(')'), \"invalid inputs", "assert_3": "assert test_str.lstrip('(').rstrip(')').replace('...', '').replace(',', '').replace(' ', '').isdigit(), \"invalid inputs"}]}], "reasoning": ["I will model the string‐tuple parser’s input checks as precise SMT predicates, using an ADT for Value and helper functions for safe string extraction and regex‐based digit validation, ensuring each contract can be tested in isolation or in combination.</think>"]}
{"name": "Mbpp/790", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for \"only allowed characters\" patterns.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re \"(\")))) ...) is WRONG; use nested lets.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: even_position\nProblem Description:\n\"\"\"\nWrite a python function to check whether every even index contains even numbers of a given list.\nassert even_position([3,2,1]) == False\n\"\"\"\n\n\ndef even_position(nums):\n\n\tassert isinstance(nums, list), \"invalid inputs\" # $_CONTRACT_$\n\tassert all(isinstance(i, int) for i in nums), \"invalid inputs\" # $_CONTRACT_$\n\treturn all(nums[i]%2==i%2 for i in range(len(nums)))\n\n\nContract List:\nassert_0: assert isinstance(nums, list), \"invalid inputs\nassert_1: assert all(isinstance(i, int) for i in nums), \"invalid inputs\n\n"}], "grammar": [{"production": ["{\n  \"helper_functions\": \"(define-fun isNil ((v Value)) Bool (is-Nil v))\\n(define-fun isCons ((v Value)) Bool (is-Cons v))\\n(define-fun-rec IsList ((v Value)) Bool\\n  (ite (is-Nil v)\\n       true\\n       (ite (is-Cons v)\\n            (IsList (tail v))\\n            false)))\\n(define-fun-rec ListAllInt ((v Value)) Bool\\n  (ite (is-Nil v)\\n       true\\n       (ite (is-Cons v)\\n            (and (is-IntVal (head v))\\n                 (ListAllInt (tail v)))\\n            false)))\\n(define-fun-rec ListAllEven ((v Value) (idx Int)) Bool\\n  (ite (is-Nil v)\\n       true\\n       (ite (is-Cons v)\\n            (let ((h (head v)) (t (tail v)))\\n              (ite (is-IntVal h)\\n                   (and (= (mod (ival h) 2) (mod idx 2))\\n                        (ListAllEven t (+ idx 1)))\\n                   false))\\n            false)))\",\n  \"basic_structure\": \"(assert (IsList nums))\",\n  \"inputs\": \"(declare-const nums Value)\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool (IsList nums))\",\n    \"assert_1\": \"(define-fun C1 () Bool (ListAllInt nums))\"\n  }\n}"], "constraints": [{"assert_0": "assert isinstance(nums, list), \"invalid inputs", "assert_1": "assert all(isinstance(i, int) for i in nums), \"invalid inputs"}]}], "reasoning": ["I translate the Python asserts into precise SMT predicates, define ADT and recursive helpers for list structure and integer checks, and separate basic executability (shape) from the contract predicates C0/C1.</think>"]}
{"name": "Mbpp/796", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite. NEVER use selectors directly on Value parameters - extract to String/Int/Real first.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS. NEVER use anchors (^, $) in str.to.re - use re.*(union ...) for \"only allowed characters\" patterns.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed. Example: (let ((ch (str.at s i)) (isL (str.in.re ch (str.to.re \"(\")))) ...) is WRONG; use nested lets.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: return_sum\nProblem Description:\n\"\"\"\nWrite function to find the sum of all items in the given dictionary.\nassert return_sum({'a': 100, 'b':200, 'c':300}) == 600\n\"\"\"\n\n\ndef return_sum(d):\n\n  assert isinstance(d, dict), \"invalid inputs\" # $_CONTRACT_$\n  assert all(isinstance(x, (int, float)) for x in d.values()), \"invalid inputs\" # $_CONTRACT_$\n  return sum(d.values())\n\n\nContract List:\nassert_0: assert isinstance(d, dict), \"invalid inputs\nassert_1: assert all(isinstance(x, (int, float)) for x in d.values()), \"invalid inputs\n\n"}], "grammar": [{"production": ["{\n  \"helper_functions\": \"(define-fun IsPair ((v Value)) Bool (and (is-Cons v) (is-Cons (tail v)) (is-Nil (tail (tail v)))))\\n(define-fun first  ((p Value)) Value (head p))\\n(define-fun second ((p Value)) Value (head (tail p)))\\n\\n(define-fun-rec IsDict ((v Value)) Bool\\n  (or (is-Nil v) (and (is-Cons v) (IsPair (head v)) (IsDict (tail v)))))\\n\\n(define-fun isNumeric ((v Value)) Bool (or (is-IntVal v) (is-FloatVal v)))\\n(define-fun-rec dict_all_numeric ((v Value)) Bool\\n  (or (is-Nil v) (and (is-Cons v) (IsPair (head v)) (isNumeric (second (head v))) (dict_all_numeric (tail v)))))\",\n  \"basic_structure\": \"(assert (IsDict d))\",\n  \"inputs\": \"(declare-const d Value)\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool (IsDict d))\",\n    \"assert_1\": \"(define-fun C1 () Bool (dict_all_numeric d))\"\n  }\n}"], "constraints": [{"assert_0": "assert isinstance(d, dict), \"invalid inputs", "assert_1": "assert all(isinstance(x, (int, float)) for x in d.values()), \"invalid inputs"}]}], "reasoning": ["I model Python dicts as lists of Pair entries in the Value ADT, add helpers to check well-formed dictionaries (IsDict) and numeric values (dict_all_numeric), then define C0/C1 to mirror the two asserts.</think>"]}
