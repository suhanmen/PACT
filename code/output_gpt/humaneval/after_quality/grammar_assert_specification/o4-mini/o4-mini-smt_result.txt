=== SMT Test Cases Report ===
Generated: 2025-09-12 23:49:29.351146
Model: o4-mini
Solver: z3
Solutions per case: 5
tasks failed when smt solver failed: []
tasks failed when all contracts true: []
tasks failed when all contracts true only: {'HumanEval/0': True, 'HumanEval/1': True, 'HumanEval/2': True, 'HumanEval/3': True, 'HumanEval/4': True, 'HumanEval/5': True, 'HumanEval/6': True, 'HumanEval/7': True, 'HumanEval/8': True, 'HumanEval/9': True, 'HumanEval/10': True, 'HumanEval/11': True, 'HumanEval/12': True, 'HumanEval/13': True, 'HumanEval/14': True, 'HumanEval/15': True, 'HumanEval/16': True, 'HumanEval/17': True, 'HumanEval/18': True, 'HumanEval/19': True, 'HumanEval/20': True, 'HumanEval/21': True, 'HumanEval/22': True, 'HumanEval/23': True, 'HumanEval/24': True, 'HumanEval/25': True, 'HumanEval/26': True, 'HumanEval/27': True, 'HumanEval/28': True, 'HumanEval/29': True, 'HumanEval/30': True, 'HumanEval/31': True, 'HumanEval/32': True, 'HumanEval/33': True, 'HumanEval/34': True, 'HumanEval/35': True, 'HumanEval/36': True, 'HumanEval/37': True, 'HumanEval/38': True, 'HumanEval/39': True, 'HumanEval/40': True, 'HumanEval/41': True, 'HumanEval/42': True, 'HumanEval/43': True, 'HumanEval/44': True, 'HumanEval/45': True, 'HumanEval/46': True, 'HumanEval/47': True, 'HumanEval/48': True, 'HumanEval/49': True, 'HumanEval/50': True, 'HumanEval/51': True, 'HumanEval/52': True, 'HumanEval/53': True, 'HumanEval/54': True, 'HumanEval/55': True, 'HumanEval/56': True, 'HumanEval/57': True, 'HumanEval/58': True, 'HumanEval/59': True, 'HumanEval/60': True, 'HumanEval/61': True, 'HumanEval/62': True, 'HumanEval/63': True, 'HumanEval/64': True, 'HumanEval/65': True, 'HumanEval/66': True, 'HumanEval/67': True, 'HumanEval/68': True, 'HumanEval/69': True, 'HumanEval/70': True, 'HumanEval/71': True, 'HumanEval/72': True, 'HumanEval/73': True, 'HumanEval/74': True, 'HumanEval/75': True, 'HumanEval/76': True, 'HumanEval/77': True, 'HumanEval/78': True, 'HumanEval/79': True, 'HumanEval/80': True, 'HumanEval/81': True, 'HumanEval/82': True, 'HumanEval/83': True, 'HumanEval/84': True, 'HumanEval/85': True, 'HumanEval/86': True, 'HumanEval/87': True, 'HumanEval/88': True, 'HumanEval/89': True, 'HumanEval/90': True, 'HumanEval/91': True, 'HumanEval/92': True, 'HumanEval/93': True, 'HumanEval/94': True, 'HumanEval/95': True, 'HumanEval/96': True, 'HumanEval/97': True, 'HumanEval/98': True, 'HumanEval/99': True, 'HumanEval/100': True, 'HumanEval/101': True, 'HumanEval/102': True, 'HumanEval/103': True, 'HumanEval/104': True, 'HumanEval/105': True, 'HumanEval/106': True, 'HumanEval/107': True, 'HumanEval/108': True, 'HumanEval/109': True, 'HumanEval/110': True, 'HumanEval/111': True, 'HumanEval/112': True, 'HumanEval/113': True, 'HumanEval/114': True, 'HumanEval/115': True, 'HumanEval/116': True, 'HumanEval/117': True, 'HumanEval/118': True, 'HumanEval/119': True, 'HumanEval/120': True, 'HumanEval/121': True, 'HumanEval/122': True, 'HumanEval/123': True, 'HumanEval/124': True, 'HumanEval/125': True, 'HumanEval/126': True, 'HumanEval/127': True, 'HumanEval/128': True, 'HumanEval/129': True, 'HumanEval/130': True, 'HumanEval/131': True, 'HumanEval/132': True, 'HumanEval/133': True, 'HumanEval/134': True, 'HumanEval/135': True, 'HumanEval/136': True, 'HumanEval/137': True, 'HumanEval/138': True, 'HumanEval/139': True, 'HumanEval/140': True, 'HumanEval/141': True, 'HumanEval/142': True, 'HumanEval/143': True, 'HumanEval/144': True, 'HumanEval/145': True, 'HumanEval/146': True, 'HumanEval/147': True, 'HumanEval/148': True, 'HumanEval/149': True, 'HumanEval/150': True, 'HumanEval/151': True, 'HumanEval/152': True, 'HumanEval/153': True, 'HumanEval/154': True, 'HumanEval/155': True, 'HumanEval/156': True, 'HumanEval/157': True, 'HumanEval/158': True, 'HumanEval/159': True, 'HumanEval/160': True, 'HumanEval/161': True, 'HumanEval/162': True, 'HumanEval/163': True}
==================================================

=== Task: HumanEval/0 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1;assert_2
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2'], 'total_contracts': 3}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (ite (is-Nil lst)
       true
       (ite (is-Cons lst)
            (IsList (tail lst))
            false)))

(define-fun-rec list_all_numeric ((lst Value)) Bool
  (ite (is-Nil lst)
       true
       (ite (is-Cons lst)
            (and (or (is-IntVal (head lst)) (is-FloatVal (head lst)))
                 (list_all_numeric (tail lst)))
            false)))

; === Inputs ===
(declare-const threshold Value)
(declare-const numbers Value)

; === BASIC STRUCTURE ===
(assert (is-FloatVal threshold))
(assert (IsList numbers))

; === Contract predicates ===
(define-fun C0 () Bool (and (is-FloatVal threshold) (> (fval threshold) 0)))
(define-fun C1 () Bool (IsList numbers))
(define-fun C2 () Bool (list_all_numeric numbers))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1;assert_2
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1', 'assert_2'], 'total_contracts': 3}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (ite (is-Nil lst)
       true
       (ite (is-Cons lst)
            (IsList (tail lst))
            false)))

(define-fun-rec list_all_numeric ((lst Value)) Bool
  (ite (is-Nil lst)
       true
       (ite (is-Cons lst)
            (and (or (is-IntVal (head lst)) (is-FloatVal (head lst)))
                 (list_all_numeric (tail lst)))
            false)))

; === Inputs ===
(declare-const threshold Value)
(declare-const numbers Value)

; === BASIC STRUCTURE ===
(assert (is-FloatVal threshold))
(assert (IsList numbers))

; === Contract predicates ===
(define-fun C0 () Bool (and (is-FloatVal threshold) (> (fval threshold) 0)))
(define-fun C1 () Bool (IsList numbers))
(define-fun C2 () Bool (list_all_numeric numbers))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0;assert_2
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0', 'assert_2'], 'total_contracts': 3}
  Solutions:
    Solution 1:
      test_case: {'numbers': ['!0!'], 'threshold': 0.0}
    Solution 2:
      test_case: {'numbers': ['!'], 'threshold': -7719.0}
    Solution 3:
      test_case: {'numbers': ['0'], 'threshold': -10156.0}
    Solution 4:
      test_case: {'threshold': -10156.0, 'numbers': ['0!']}
    Solution 5:
      test_case: {'numbers': [''], 'threshold': -10156.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (ite (is-Nil lst)
       true
       (ite (is-Cons lst)
            (IsList (tail lst))
            false)))

(define-fun-rec list_all_numeric ((lst Value)) Bool
  (ite (is-Nil lst)
       true
       (ite (is-Cons lst)
            (and (or (is-IntVal (head lst)) (is-FloatVal (head lst)))
                 (list_all_numeric (tail lst)))
            false)))

; === Inputs ===
(declare-const threshold Value)
(declare-const numbers Value)

; === BASIC STRUCTURE ===
(assert (is-FloatVal threshold))
(assert (IsList numbers))

; === Contract predicates ===
(define-fun C0 () Bool (and (is-FloatVal threshold) (> (fval threshold) 0)))
(define-fun C1 () Bool (IsList numbers))
(define-fun C2 () Bool (list_all_numeric numbers))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_assert_2
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': ['assert_2'], 'total_contracts': 3}
  Solutions:
    Solution 1:
      test_case: {'numbers': ['!0!'], 'threshold': 0.5}
    Solution 2:
      test_case: {'numbers': ['!'], 'threshold': 0.25}
    Solution 3:
      test_case: {'threshold': 0.125, 'numbers': ['0']}
    Solution 4:
      test_case: {'numbers': ['0!'], 'threshold': 0.0625}
    Solution 5:
      test_case: {'numbers': ['A'], 'threshold': 0.03125}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (ite (is-Nil lst)
       true
       (ite (is-Cons lst)
            (IsList (tail lst))
            false)))

(define-fun-rec list_all_numeric ((lst Value)) Bool
  (ite (is-Nil lst)
       true
       (ite (is-Cons lst)
            (and (or (is-IntVal (head lst)) (is-FloatVal (head lst)))
                 (list_all_numeric (tail lst)))
            false)))

; === Inputs ===
(declare-const threshold Value)
(declare-const numbers Value)

; === BASIC STRUCTURE ===
(assert (is-FloatVal threshold))
(assert (IsList numbers))

; === Contract predicates ===
(define-fun C0 () Bool (and (is-FloatVal threshold) (> (fval threshold) 0)))
(define-fun C1 () Bool (IsList numbers))
(define-fun C2 () Bool (list_all_numeric numbers))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))

(check-sat)
(get-model)

------------------------------
  Test Case 5: satisfied_assert_2, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_2'], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 3}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (ite (is-Nil lst)
       true
       (ite (is-Cons lst)
            (IsList (tail lst))
            false)))

(define-fun-rec list_all_numeric ((lst Value)) Bool
  (ite (is-Nil lst)
       true
       (ite (is-Cons lst)
            (and (or (is-IntVal (head lst)) (is-FloatVal (head lst)))
                 (list_all_numeric (tail lst)))
            false)))

; === Inputs ===
(declare-const threshold Value)
(declare-const numbers Value)

; === BASIC STRUCTURE ===
(assert (is-FloatVal threshold))
(assert (IsList numbers))

; === Contract predicates ===
(define-fun C0 () Bool (and (is-FloatVal threshold) (> (fval threshold) 0)))
(define-fun C1 () Bool (IsList numbers))
(define-fun C2 () Bool (list_all_numeric numbers))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)

(check-sat)
(get-model)

------------------------------
  Test Case 6: satisfied_assert_0;assert_2, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2'], 'violated_contracts': ['assert_1'], 'total_contracts': 3}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (ite (is-Nil lst)
       true
       (ite (is-Cons lst)
            (IsList (tail lst))
            false)))

(define-fun-rec list_all_numeric ((lst Value)) Bool
  (ite (is-Nil lst)
       true
       (ite (is-Cons lst)
            (and (or (is-IntVal (head lst)) (is-FloatVal (head lst)))
                 (list_all_numeric (tail lst)))
            false)))

; === Inputs ===
(declare-const threshold Value)
(declare-const numbers Value)

; === BASIC STRUCTURE ===
(assert (is-FloatVal threshold))
(assert (IsList numbers))

; === Contract predicates ===
(define-fun C0 () Bool (and (is-FloatVal threshold) (> (fval threshold) 0)))
(define-fun C1 () Bool (IsList numbers))
(define-fun C2 () Bool (list_all_numeric numbers))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)

(check-sat)
(get-model)

------------------------------
  Test Case 7: satisfied_assert_1;assert_2, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2'], 'violated_contracts': ['assert_0'], 'total_contracts': 3}
  Solutions:
    Solution 1:
      test_case: {'numbers': [], 'threshold': 0.0}
    Solution 2:
      test_case: {'numbers': [], 'threshold': -7719.0}
    Solution 3:
      test_case: {'numbers': [], 'threshold': -10156.0}
    Solution 4:
      test_case: {'numbers': [], 'threshold': -21953.0}
    Solution 5:
      test_case: {'threshold': -54238.0, 'numbers': []}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (ite (is-Nil lst)
       true
       (ite (is-Cons lst)
            (IsList (tail lst))
            false)))

(define-fun-rec list_all_numeric ((lst Value)) Bool
  (ite (is-Nil lst)
       true
       (ite (is-Cons lst)
            (and (or (is-IntVal (head lst)) (is-FloatVal (head lst)))
                 (list_all_numeric (tail lst)))
            false)))

; === Inputs ===
(declare-const threshold Value)
(declare-const numbers Value)

; === BASIC STRUCTURE ===
(assert (is-FloatVal threshold))
(assert (IsList numbers))

; === Contract predicates ===
(define-fun C0 () Bool (and (is-FloatVal threshold) (> (fval threshold) 0)))
(define-fun C1 () Bool (IsList numbers))
(define-fun C2 () Bool (list_all_numeric numbers))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)

(check-sat)
(get-model)

------------------------------
  Test Case 8: satisfied_assert_0;assert_1;assert_2, violated_
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2'], 'violated_contracts': [], 'total_contracts': 3}
  Solutions:
    Solution 1:
      test_case: {'numbers': [], 'threshold': 0.5}
    Solution 2:
      test_case: {'numbers': [], 'threshold': 0.25}
    Solution 3:
      test_case: {'numbers': [], 'threshold': 0.125}
    Solution 4:
      test_case: {'numbers': [], 'threshold': 0.0625}
    Solution 5:
      test_case: {'numbers': [], 'threshold': 0.03125}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (ite (is-Nil lst)
       true
       (ite (is-Cons lst)
            (IsList (tail lst))
            false)))

(define-fun-rec list_all_numeric ((lst Value)) Bool
  (ite (is-Nil lst)
       true
       (ite (is-Cons lst)
            (and (or (is-IntVal (head lst)) (is-FloatVal (head lst)))
                 (list_all_numeric (tail lst)))
            false)))

; === Inputs ===
(declare-const threshold Value)
(declare-const numbers Value)

; === BASIC STRUCTURE ===
(assert (is-FloatVal threshold))
(assert (IsList numbers))

; === Contract predicates ===
(define-fun C0 () Bool (and (is-FloatVal threshold) (> (fval threshold) 0)))
(define-fun C1 () Bool (IsList numbers))
(define-fun C2 () Bool (list_all_numeric numbers))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/1 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1;assert_2;assert_3
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False, 'assert_3': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_3'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun safe-sval ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

(define-fun-rec all_valid_chars ((v Value) (idx Int)) Bool
  (ite (< idx (str.len (safe-sval v)))
       (let ((ch (str.substr (safe-sval v) idx 1)))
         (and (or (= ch "(") (= ch ")") (= ch " "))
              (all_valid_chars v (+ idx 1))))
       true))

(define-fun-rec prefix_balanced ((v Value) (idx Int) (cnt Int)) Bool
  (ite (< idx (str.len (safe-sval v)))
       (let ((ch (str.substr (safe-sval v) idx 1)))
         (let ((new_cnt (ite (= ch "(") (+ cnt 1)
                              (ite (= ch ")") (- cnt 1) cnt))))
           (and (>= new_cnt 0)
                (prefix_balanced v (+ idx 1) new_cnt))))
       true))

(define-fun-rec final_count ((v Value) (idx Int) (cnt Int)) Int
  (ite (< idx (str.len (safe-sval v)))
       (let ((ch (str.substr (safe-sval v) idx 1)))
         (final_count v (+ idx 1)
                      (ite (= ch "(") (+ cnt 1)
                           (ite (= ch ")") (- cnt 1) cnt))))
       cnt))

; === Inputs ===
(declare-const paren_string Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal paren_string))
(define-fun C1 () Bool (all_valid_chars paren_string 0))
(define-fun C2 () Bool (prefix_balanced paren_string 0 0))
(define-fun C3 () Bool (= (final_count paren_string 0 0) 0))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1;assert_2;assert_3
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False, 'assert_3': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1', 'assert_2', 'assert_3'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'paren_string': 'A)'}
    Solution 2:
      test_case: {'paren_string': ')B'}
    Solution 3:
      test_case: {'paren_string': ')C'}
    Solution 4:
      test_case: {'paren_string': ')D'}
    Solution 5:
      test_case: {'paren_string': ')E'}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun safe-sval ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

(define-fun-rec all_valid_chars ((v Value) (idx Int)) Bool
  (ite (< idx (str.len (safe-sval v)))
       (let ((ch (str.substr (safe-sval v) idx 1)))
         (and (or (= ch "(") (= ch ")") (= ch " "))
              (all_valid_chars v (+ idx 1))))
       true))

(define-fun-rec prefix_balanced ((v Value) (idx Int) (cnt Int)) Bool
  (ite (< idx (str.len (safe-sval v)))
       (let ((ch (str.substr (safe-sval v) idx 1)))
         (let ((new_cnt (ite (= ch "(") (+ cnt 1)
                              (ite (= ch ")") (- cnt 1) cnt))))
           (and (>= new_cnt 0)
                (prefix_balanced v (+ idx 1) new_cnt))))
       true))

(define-fun-rec final_count ((v Value) (idx Int) (cnt Int)) Int
  (ite (< idx (str.len (safe-sval v)))
       (let ((ch (str.substr (safe-sval v) idx 1)))
         (final_count v (+ idx 1)
                      (ite (= ch "(") (+ cnt 1)
                           (ite (= ch ")") (- cnt 1) cnt))))
       cnt))

; === Inputs ===
(declare-const paren_string Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal paren_string))
(define-fun C1 () Bool (all_valid_chars paren_string 0))
(define-fun C2 () Bool (prefix_balanced paren_string 0 0))
(define-fun C3 () Bool (= (final_count paren_string 0 0) 0))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0;assert_2;assert_3
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False, 'assert_3': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0', 'assert_2', 'assert_3'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun safe-sval ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

(define-fun-rec all_valid_chars ((v Value) (idx Int)) Bool
  (ite (< idx (str.len (safe-sval v)))
       (let ((ch (str.substr (safe-sval v) idx 1)))
         (and (or (= ch "(") (= ch ")") (= ch " "))
              (all_valid_chars v (+ idx 1))))
       true))

(define-fun-rec prefix_balanced ((v Value) (idx Int) (cnt Int)) Bool
  (ite (< idx (str.len (safe-sval v)))
       (let ((ch (str.substr (safe-sval v) idx 1)))
         (let ((new_cnt (ite (= ch "(") (+ cnt 1)
                              (ite (= ch ")") (- cnt 1) cnt))))
           (and (>= new_cnt 0)
                (prefix_balanced v (+ idx 1) new_cnt))))
       true))

(define-fun-rec final_count ((v Value) (idx Int) (cnt Int)) Int
  (ite (< idx (str.len (safe-sval v)))
       (let ((ch (str.substr (safe-sval v) idx 1)))
         (final_count v (+ idx 1)
                      (ite (= ch "(") (+ cnt 1)
                           (ite (= ch ")") (- cnt 1) cnt))))
       cnt))

; === Inputs ===
(declare-const paren_string Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal paren_string))
(define-fun C1 () Bool (all_valid_chars paren_string 0))
(define-fun C2 () Bool (prefix_balanced paren_string 0 0))
(define-fun C3 () Bool (= (final_count paren_string 0 0) 0))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_assert_2;assert_3
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False, 'assert_3': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': ['assert_2', 'assert_3'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'paren_string': ')'}
    Solution 2:
      test_case: {'paren_string': ' )'}
    Solution 3:
      test_case: {'paren_string': ') '}
    Solution 4:
      test_case: {'paren_string': '))'}
    Solution 5:
      test_case: {'paren_string': ' ) '}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun safe-sval ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

(define-fun-rec all_valid_chars ((v Value) (idx Int)) Bool
  (ite (< idx (str.len (safe-sval v)))
       (let ((ch (str.substr (safe-sval v) idx 1)))
         (and (or (= ch "(") (= ch ")") (= ch " "))
              (all_valid_chars v (+ idx 1))))
       true))

(define-fun-rec prefix_balanced ((v Value) (idx Int) (cnt Int)) Bool
  (ite (< idx (str.len (safe-sval v)))
       (let ((ch (str.substr (safe-sval v) idx 1)))
         (let ((new_cnt (ite (= ch "(") (+ cnt 1)
                              (ite (= ch ")") (- cnt 1) cnt))))
           (and (>= new_cnt 0)
                (prefix_balanced v (+ idx 1) new_cnt))))
       true))

(define-fun-rec final_count ((v Value) (idx Int) (cnt Int)) Int
  (ite (< idx (str.len (safe-sval v)))
       (let ((ch (str.substr (safe-sval v) idx 1)))
         (final_count v (+ idx 1)
                      (ite (= ch "(") (+ cnt 1)
                           (ite (= ch ")") (- cnt 1) cnt))))
       cnt))

; === Inputs ===
(declare-const paren_string Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal paren_string))
(define-fun C1 () Bool (all_valid_chars paren_string 0))
(define-fun C2 () Bool (prefix_balanced paren_string 0 0))
(define-fun C3 () Bool (= (final_count paren_string 0 0) 0))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 5: satisfied_assert_2, violated_assert_0;assert_1;assert_3
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True, 'assert_3': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_2'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_3'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun safe-sval ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

(define-fun-rec all_valid_chars ((v Value) (idx Int)) Bool
  (ite (< idx (str.len (safe-sval v)))
       (let ((ch (str.substr (safe-sval v) idx 1)))
         (and (or (= ch "(") (= ch ")") (= ch " "))
              (all_valid_chars v (+ idx 1))))
       true))

(define-fun-rec prefix_balanced ((v Value) (idx Int) (cnt Int)) Bool
  (ite (< idx (str.len (safe-sval v)))
       (let ((ch (str.substr (safe-sval v) idx 1)))
         (let ((new_cnt (ite (= ch "(") (+ cnt 1)
                              (ite (= ch ")") (- cnt 1) cnt))))
           (and (>= new_cnt 0)
                (prefix_balanced v (+ idx 1) new_cnt))))
       true))

(define-fun-rec final_count ((v Value) (idx Int) (cnt Int)) Int
  (ite (< idx (str.len (safe-sval v)))
       (let ((ch (str.substr (safe-sval v) idx 1)))
         (final_count v (+ idx 1)
                      (ite (= ch "(") (+ cnt 1)
                           (ite (= ch ")") (- cnt 1) cnt))))
       cnt))

; === Inputs ===
(declare-const paren_string Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal paren_string))
(define-fun C1 () Bool (all_valid_chars paren_string 0))
(define-fun C2 () Bool (prefix_balanced paren_string 0 0))
(define-fun C3 () Bool (= (final_count paren_string 0 0) 0))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 6: satisfied_assert_0;assert_2, violated_assert_1;assert_3
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True, 'assert_3': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2'], 'violated_contracts': ['assert_1', 'assert_3'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'paren_string': '(A'}
    Solution 2:
      test_case: {'paren_string': '(B'}
    Solution 3:
      test_case: {'paren_string': '(C'}
    Solution 4:
      test_case: {'paren_string': '(D'}
    Solution 5:
      test_case: {'paren_string': '(E'}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun safe-sval ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

(define-fun-rec all_valid_chars ((v Value) (idx Int)) Bool
  (ite (< idx (str.len (safe-sval v)))
       (let ((ch (str.substr (safe-sval v) idx 1)))
         (and (or (= ch "(") (= ch ")") (= ch " "))
              (all_valid_chars v (+ idx 1))))
       true))

(define-fun-rec prefix_balanced ((v Value) (idx Int) (cnt Int)) Bool
  (ite (< idx (str.len (safe-sval v)))
       (let ((ch (str.substr (safe-sval v) idx 1)))
         (let ((new_cnt (ite (= ch "(") (+ cnt 1)
                              (ite (= ch ")") (- cnt 1) cnt))))
           (and (>= new_cnt 0)
                (prefix_balanced v (+ idx 1) new_cnt))))
       true))

(define-fun-rec final_count ((v Value) (idx Int) (cnt Int)) Int
  (ite (< idx (str.len (safe-sval v)))
       (let ((ch (str.substr (safe-sval v) idx 1)))
         (final_count v (+ idx 1)
                      (ite (= ch "(") (+ cnt 1)
                           (ite (= ch ")") (- cnt 1) cnt))))
       cnt))

; === Inputs ===
(declare-const paren_string Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal paren_string))
(define-fun C1 () Bool (all_valid_chars paren_string 0))
(define-fun C2 () Bool (prefix_balanced paren_string 0 0))
(define-fun C3 () Bool (= (final_count paren_string 0 0) 0))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 7: satisfied_assert_1;assert_2, violated_assert_0;assert_3
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True, 'assert_3': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2'], 'violated_contracts': ['assert_0', 'assert_3'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun safe-sval ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

(define-fun-rec all_valid_chars ((v Value) (idx Int)) Bool
  (ite (< idx (str.len (safe-sval v)))
       (let ((ch (str.substr (safe-sval v) idx 1)))
         (and (or (= ch "(") (= ch ")") (= ch " "))
              (all_valid_chars v (+ idx 1))))
       true))

(define-fun-rec prefix_balanced ((v Value) (idx Int) (cnt Int)) Bool
  (ite (< idx (str.len (safe-sval v)))
       (let ((ch (str.substr (safe-sval v) idx 1)))
         (let ((new_cnt (ite (= ch "(") (+ cnt 1)
                              (ite (= ch ")") (- cnt 1) cnt))))
           (and (>= new_cnt 0)
                (prefix_balanced v (+ idx 1) new_cnt))))
       true))

(define-fun-rec final_count ((v Value) (idx Int) (cnt Int)) Int
  (ite (< idx (str.len (safe-sval v)))
       (let ((ch (str.substr (safe-sval v) idx 1)))
         (final_count v (+ idx 1)
                      (ite (= ch "(") (+ cnt 1)
                           (ite (= ch ")") (- cnt 1) cnt))))
       cnt))

; === Inputs ===
(declare-const paren_string Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal paren_string))
(define-fun C1 () Bool (all_valid_chars paren_string 0))
(define-fun C2 () Bool (prefix_balanced paren_string 0 0))
(define-fun C3 () Bool (= (final_count paren_string 0 0) 0))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 8: satisfied_assert_0;assert_1;assert_2, violated_assert_3
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True, 'assert_3': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2'], 'violated_contracts': ['assert_3'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'paren_string': '('}
    Solution 2:
      test_case: {'paren_string': ' ('}
    Solution 3:
      test_case: {'paren_string': '(('}
    Solution 4:
      test_case: {'paren_string': '( '}
    Solution 5:
      test_case: {'paren_string': '  ('}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun safe-sval ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

(define-fun-rec all_valid_chars ((v Value) (idx Int)) Bool
  (ite (< idx (str.len (safe-sval v)))
       (let ((ch (str.substr (safe-sval v) idx 1)))
         (and (or (= ch "(") (= ch ")") (= ch " "))
              (all_valid_chars v (+ idx 1))))
       true))

(define-fun-rec prefix_balanced ((v Value) (idx Int) (cnt Int)) Bool
  (ite (< idx (str.len (safe-sval v)))
       (let ((ch (str.substr (safe-sval v) idx 1)))
         (let ((new_cnt (ite (= ch "(") (+ cnt 1)
                              (ite (= ch ")") (- cnt 1) cnt))))
           (and (>= new_cnt 0)
                (prefix_balanced v (+ idx 1) new_cnt))))
       true))

(define-fun-rec final_count ((v Value) (idx Int) (cnt Int)) Int
  (ite (< idx (str.len (safe-sval v)))
       (let ((ch (str.substr (safe-sval v) idx 1)))
         (final_count v (+ idx 1)
                      (ite (= ch "(") (+ cnt 1)
                           (ite (= ch ")") (- cnt 1) cnt))))
       cnt))

; === Inputs ===
(declare-const paren_string Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal paren_string))
(define-fun C1 () Bool (all_valid_chars paren_string 0))
(define-fun C2 () Bool (prefix_balanced paren_string 0 0))
(define-fun C3 () Bool (= (final_count paren_string 0 0) 0))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 9: satisfied_assert_3, violated_assert_0;assert_1;assert_2
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False, 'assert_3': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_3'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun safe-sval ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

(define-fun-rec all_valid_chars ((v Value) (idx Int)) Bool
  (ite (< idx (str.len (safe-sval v)))
       (let ((ch (str.substr (safe-sval v) idx 1)))
         (and (or (= ch "(") (= ch ")") (= ch " "))
              (all_valid_chars v (+ idx 1))))
       true))

(define-fun-rec prefix_balanced ((v Value) (idx Int) (cnt Int)) Bool
  (ite (< idx (str.len (safe-sval v)))
       (let ((ch (str.substr (safe-sval v) idx 1)))
         (let ((new_cnt (ite (= ch "(") (+ cnt 1)
                              (ite (= ch ")") (- cnt 1) cnt))))
           (and (>= new_cnt 0)
                (prefix_balanced v (+ idx 1) new_cnt))))
       true))

(define-fun-rec final_count ((v Value) (idx Int) (cnt Int)) Int
  (ite (< idx (str.len (safe-sval v)))
       (let ((ch (str.substr (safe-sval v) idx 1)))
         (final_count v (+ idx 1)
                      (ite (= ch "(") (+ cnt 1)
                           (ite (= ch ")") (- cnt 1) cnt))))
       cnt))

; === Inputs ===
(declare-const paren_string Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal paren_string))
(define-fun C1 () Bool (all_valid_chars paren_string 0))
(define-fun C2 () Bool (prefix_balanced paren_string 0 0))
(define-fun C3 () Bool (= (final_count paren_string 0 0) 0))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 10: satisfied_assert_0;assert_3, violated_assert_1;assert_2
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False, 'assert_3': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_3'], 'violated_contracts': ['assert_1', 'assert_2'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'paren_string': ')A('}
    Solution 2:
      test_case: {'paren_string': 'B)('}
    Solution 3:
      test_case: {'paren_string': 'C)('}
    Solution 4:
      test_case: {'paren_string': 'D)('}
    Solution 5:
      test_case: {'paren_string': 'E)('}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun safe-sval ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

(define-fun-rec all_valid_chars ((v Value) (idx Int)) Bool
  (ite (< idx (str.len (safe-sval v)))
       (let ((ch (str.substr (safe-sval v) idx 1)))
         (and (or (= ch "(") (= ch ")") (= ch " "))
              (all_valid_chars v (+ idx 1))))
       true))

(define-fun-rec prefix_balanced ((v Value) (idx Int) (cnt Int)) Bool
  (ite (< idx (str.len (safe-sval v)))
       (let ((ch (str.substr (safe-sval v) idx 1)))
         (let ((new_cnt (ite (= ch "(") (+ cnt 1)
                              (ite (= ch ")") (- cnt 1) cnt))))
           (and (>= new_cnt 0)
                (prefix_balanced v (+ idx 1) new_cnt))))
       true))

(define-fun-rec final_count ((v Value) (idx Int) (cnt Int)) Int
  (ite (< idx (str.len (safe-sval v)))
       (let ((ch (str.substr (safe-sval v) idx 1)))
         (final_count v (+ idx 1)
                      (ite (= ch "(") (+ cnt 1)
                           (ite (= ch ")") (- cnt 1) cnt))))
       cnt))

; === Inputs ===
(declare-const paren_string Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal paren_string))
(define-fun C1 () Bool (all_valid_chars paren_string 0))
(define-fun C2 () Bool (prefix_balanced paren_string 0 0))
(define-fun C3 () Bool (= (final_count paren_string 0 0) 0))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 11: satisfied_assert_1;assert_3, violated_assert_0;assert_2
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False, 'assert_3': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_3'], 'violated_contracts': ['assert_0', 'assert_2'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun safe-sval ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

(define-fun-rec all_valid_chars ((v Value) (idx Int)) Bool
  (ite (< idx (str.len (safe-sval v)))
       (let ((ch (str.substr (safe-sval v) idx 1)))
         (and (or (= ch "(") (= ch ")") (= ch " "))
              (all_valid_chars v (+ idx 1))))
       true))

(define-fun-rec prefix_balanced ((v Value) (idx Int) (cnt Int)) Bool
  (ite (< idx (str.len (safe-sval v)))
       (let ((ch (str.substr (safe-sval v) idx 1)))
         (let ((new_cnt (ite (= ch "(") (+ cnt 1)
                              (ite (= ch ")") (- cnt 1) cnt))))
           (and (>= new_cnt 0)
                (prefix_balanced v (+ idx 1) new_cnt))))
       true))

(define-fun-rec final_count ((v Value) (idx Int) (cnt Int)) Int
  (ite (< idx (str.len (safe-sval v)))
       (let ((ch (str.substr (safe-sval v) idx 1)))
         (final_count v (+ idx 1)
                      (ite (= ch "(") (+ cnt 1)
                           (ite (= ch ")") (- cnt 1) cnt))))
       cnt))

; === Inputs ===
(declare-const paren_string Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal paren_string))
(define-fun C1 () Bool (all_valid_chars paren_string 0))
(define-fun C2 () Bool (prefix_balanced paren_string 0 0))
(define-fun C3 () Bool (= (final_count paren_string 0 0) 0))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 12: satisfied_assert_0;assert_1;assert_3, violated_assert_2
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False, 'assert_3': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_3'], 'violated_contracts': ['assert_2'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'paren_string': ')('}
    Solution 2:
      test_case: {'paren_string': ' )('}
    Solution 3:
      test_case: {'paren_string': ')( '}
    Solution 4:
      test_case: {'paren_string': ') ('}
    Solution 5:
      test_case: {'paren_string': ' ) ('}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun safe-sval ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

(define-fun-rec all_valid_chars ((v Value) (idx Int)) Bool
  (ite (< idx (str.len (safe-sval v)))
       (let ((ch (str.substr (safe-sval v) idx 1)))
         (and (or (= ch "(") (= ch ")") (= ch " "))
              (all_valid_chars v (+ idx 1))))
       true))

(define-fun-rec prefix_balanced ((v Value) (idx Int) (cnt Int)) Bool
  (ite (< idx (str.len (safe-sval v)))
       (let ((ch (str.substr (safe-sval v) idx 1)))
         (let ((new_cnt (ite (= ch "(") (+ cnt 1)
                              (ite (= ch ")") (- cnt 1) cnt))))
           (and (>= new_cnt 0)
                (prefix_balanced v (+ idx 1) new_cnt))))
       true))

(define-fun-rec final_count ((v Value) (idx Int) (cnt Int)) Int
  (ite (< idx (str.len (safe-sval v)))
       (let ((ch (str.substr (safe-sval v) idx 1)))
         (final_count v (+ idx 1)
                      (ite (= ch "(") (+ cnt 1)
                           (ite (= ch ")") (- cnt 1) cnt))))
       cnt))

; === Inputs ===
(declare-const paren_string Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal paren_string))
(define-fun C1 () Bool (all_valid_chars paren_string 0))
(define-fun C2 () Bool (prefix_balanced paren_string 0 0))
(define-fun C3 () Bool (= (final_count paren_string 0 0) 0))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 13: satisfied_assert_2;assert_3, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True, 'assert_3': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_2', 'assert_3'], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun safe-sval ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

(define-fun-rec all_valid_chars ((v Value) (idx Int)) Bool
  (ite (< idx (str.len (safe-sval v)))
       (let ((ch (str.substr (safe-sval v) idx 1)))
         (and (or (= ch "(") (= ch ")") (= ch " "))
              (all_valid_chars v (+ idx 1))))
       true))

(define-fun-rec prefix_balanced ((v Value) (idx Int) (cnt Int)) Bool
  (ite (< idx (str.len (safe-sval v)))
       (let ((ch (str.substr (safe-sval v) idx 1)))
         (let ((new_cnt (ite (= ch "(") (+ cnt 1)
                              (ite (= ch ")") (- cnt 1) cnt))))
           (and (>= new_cnt 0)
                (prefix_balanced v (+ idx 1) new_cnt))))
       true))

(define-fun-rec final_count ((v Value) (idx Int) (cnt Int)) Int
  (ite (< idx (str.len (safe-sval v)))
       (let ((ch (str.substr (safe-sval v) idx 1)))
         (final_count v (+ idx 1)
                      (ite (= ch "(") (+ cnt 1)
                           (ite (= ch ")") (- cnt 1) cnt))))
       cnt))

; === Inputs ===
(declare-const paren_string Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal paren_string))
(define-fun C1 () Bool (all_valid_chars paren_string 0))
(define-fun C2 () Bool (prefix_balanced paren_string 0 0))
(define-fun C3 () Bool (= (final_count paren_string 0 0) 0))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 14: satisfied_assert_0;assert_2;assert_3, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True, 'assert_3': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2', 'assert_3'], 'violated_contracts': ['assert_1'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'paren_string': 'A'}
    Solution 2:
      test_case: {'paren_string': 'B'}
    Solution 3:
      test_case: {'paren_string': 'C'}
    Solution 4:
      test_case: {'paren_string': 'D'}
    Solution 5:
      test_case: {'paren_string': 'E'}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun safe-sval ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

(define-fun-rec all_valid_chars ((v Value) (idx Int)) Bool
  (ite (< idx (str.len (safe-sval v)))
       (let ((ch (str.substr (safe-sval v) idx 1)))
         (and (or (= ch "(") (= ch ")") (= ch " "))
              (all_valid_chars v (+ idx 1))))
       true))

(define-fun-rec prefix_balanced ((v Value) (idx Int) (cnt Int)) Bool
  (ite (< idx (str.len (safe-sval v)))
       (let ((ch (str.substr (safe-sval v) idx 1)))
         (let ((new_cnt (ite (= ch "(") (+ cnt 1)
                              (ite (= ch ")") (- cnt 1) cnt))))
           (and (>= new_cnt 0)
                (prefix_balanced v (+ idx 1) new_cnt))))
       true))

(define-fun-rec final_count ((v Value) (idx Int) (cnt Int)) Int
  (ite (< idx (str.len (safe-sval v)))
       (let ((ch (str.substr (safe-sval v) idx 1)))
         (final_count v (+ idx 1)
                      (ite (= ch "(") (+ cnt 1)
                           (ite (= ch ")") (- cnt 1) cnt))))
       cnt))

; === Inputs ===
(declare-const paren_string Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal paren_string))
(define-fun C1 () Bool (all_valid_chars paren_string 0))
(define-fun C2 () Bool (prefix_balanced paren_string 0 0))
(define-fun C3 () Bool (= (final_count paren_string 0 0) 0))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 15: satisfied_assert_1;assert_2;assert_3, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True, 'assert_3': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2', 'assert_3'], 'violated_contracts': ['assert_0'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'paren_string': 2.0}
    Solution 2:
      test_case: {'paren_string': 3.0}
    Solution 3:
      test_case: {'paren_string': 4.0}
    Solution 4:
      test_case: {'paren_string': 5.0}
    Solution 5:
      test_case: {'paren_string': 6.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun safe-sval ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

(define-fun-rec all_valid_chars ((v Value) (idx Int)) Bool
  (ite (< idx (str.len (safe-sval v)))
       (let ((ch (str.substr (safe-sval v) idx 1)))
         (and (or (= ch "(") (= ch ")") (= ch " "))
              (all_valid_chars v (+ idx 1))))
       true))

(define-fun-rec prefix_balanced ((v Value) (idx Int) (cnt Int)) Bool
  (ite (< idx (str.len (safe-sval v)))
       (let ((ch (str.substr (safe-sval v) idx 1)))
         (let ((new_cnt (ite (= ch "(") (+ cnt 1)
                              (ite (= ch ")") (- cnt 1) cnt))))
           (and (>= new_cnt 0)
                (prefix_balanced v (+ idx 1) new_cnt))))
       true))

(define-fun-rec final_count ((v Value) (idx Int) (cnt Int)) Int
  (ite (< idx (str.len (safe-sval v)))
       (let ((ch (str.substr (safe-sval v) idx 1)))
         (final_count v (+ idx 1)
                      (ite (= ch "(") (+ cnt 1)
                           (ite (= ch ")") (- cnt 1) cnt))))
       cnt))

; === Inputs ===
(declare-const paren_string Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal paren_string))
(define-fun C1 () Bool (all_valid_chars paren_string 0))
(define-fun C2 () Bool (prefix_balanced paren_string 0 0))
(define-fun C3 () Bool (= (final_count paren_string 0 0) 0))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 16: satisfied_assert_0;assert_1;assert_2;assert_3, violated_
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True, 'assert_3': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_3'], 'violated_contracts': [], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'paren_string': ''}
    Solution 2:
      test_case: {'paren_string': ' '}
    Solution 3:
      test_case: {'paren_string': '  '}
    Solution 4:
      test_case: {'paren_string': '()'}
    Solution 5:
      test_case: {'paren_string': ' ()'}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun safe-sval ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

(define-fun-rec all_valid_chars ((v Value) (idx Int)) Bool
  (ite (< idx (str.len (safe-sval v)))
       (let ((ch (str.substr (safe-sval v) idx 1)))
         (and (or (= ch "(") (= ch ")") (= ch " "))
              (all_valid_chars v (+ idx 1))))
       true))

(define-fun-rec prefix_balanced ((v Value) (idx Int) (cnt Int)) Bool
  (ite (< idx (str.len (safe-sval v)))
       (let ((ch (str.substr (safe-sval v) idx 1)))
         (let ((new_cnt (ite (= ch "(") (+ cnt 1)
                              (ite (= ch ")") (- cnt 1) cnt))))
           (and (>= new_cnt 0)
                (prefix_balanced v (+ idx 1) new_cnt))))
       true))

(define-fun-rec final_count ((v Value) (idx Int) (cnt Int)) Int
  (ite (< idx (str.len (safe-sval v)))
       (let ((ch (str.substr (safe-sval v) idx 1)))
         (final_count v (+ idx 1)
                      (ite (= ch "(") (+ cnt 1)
                           (ite (= ch ")") (- cnt 1) cnt))))
       cnt))

; === Inputs ===
(declare-const paren_string Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal paren_string))
(define-fun C1 () Bool (all_valid_chars paren_string 0))
(define-fun C2 () Bool (prefix_balanced paren_string 0 0))
(define-fun C3 () Bool (= (final_count paren_string 0 0) 0))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)
(assert C3)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/2 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1;assert_2
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2'], 'total_contracts': 3}
  Solutions:
    Solution 1:
      test_case: {'number': 2}
    Solution 2:
      test_case: {'number': 3}
    Solution 3:
      test_case: {'number': 4}
    Solution 4:
      test_case: {'number': 5}
    Solution 5:
      test_case: {'number': 6}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun safe_fval ((v Value)) Real
 (ite (is-FloatVal v) (fval v) 0.0))
(declare-const INF Real)

; === Inputs ===
(declare-const number Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (> (safe_fval number) 0.0))
(define-fun C1 () Bool (is-FloatVal number))
(define-fun C2 () Bool (and (is-FloatVal number) (not (= (fval number) INF))))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1;assert_2
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1', 'assert_2'], 'total_contracts': 3}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun safe_fval ((v Value)) Real
 (ite (is-FloatVal v) (fval v) 0.0))
(declare-const INF Real)

; === Inputs ===
(declare-const number Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (> (safe_fval number) 0.0))
(define-fun C1 () Bool (is-FloatVal number))
(define-fun C2 () Bool (and (is-FloatVal number) (not (= (fval number) INF))))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0;assert_2
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0', 'assert_2'], 'total_contracts': 3}
  Solutions:
    Solution 1:
      test_case: {'number': 0.0, 'INF': 0.0}
    Solution 2:
      test_case: {'INF': -1.0, 'number': -1.0}
    Solution 3:
      test_case: {'INF': -2.0, 'number': -2.0}
    Solution 4:
      test_case: {'INF': -3.0, 'number': -3.0}
    Solution 5:
      test_case: {'INF': -4.0, 'number': -4.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun safe_fval ((v Value)) Real
 (ite (is-FloatVal v) (fval v) 0.0))
(declare-const INF Real)

; === Inputs ===
(declare-const number Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (> (safe_fval number) 0.0))
(define-fun C1 () Bool (is-FloatVal number))
(define-fun C2 () Bool (and (is-FloatVal number) (not (= (fval number) INF))))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_assert_2
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': ['assert_2'], 'total_contracts': 3}
  Solutions:
    Solution 1:
      test_case: {'number': 0.5, 'INF': 0.5}
    Solution 2:
      test_case: {'INF': 0.25, 'number': 0.25}
    Solution 3:
      test_case: {'INF': 0.125, 'number': 0.125}
    Solution 4:
      test_case: {'INF': 0.0625, 'number': 0.0625}
    Solution 5:
      test_case: {'INF': 0.03125, 'number': 0.03125}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun safe_fval ((v Value)) Real
 (ite (is-FloatVal v) (fval v) 0.0))
(declare-const INF Real)

; === Inputs ===
(declare-const number Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (> (safe_fval number) 0.0))
(define-fun C1 () Bool (is-FloatVal number))
(define-fun C2 () Bool (and (is-FloatVal number) (not (= (fval number) INF))))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))

(check-sat)
(get-model)

------------------------------
  Test Case 5: satisfied_assert_2, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_2'], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 3}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun safe_fval ((v Value)) Real
 (ite (is-FloatVal v) (fval v) 0.0))
(declare-const INF Real)

; === Inputs ===
(declare-const number Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (> (safe_fval number) 0.0))
(define-fun C1 () Bool (is-FloatVal number))
(define-fun C2 () Bool (and (is-FloatVal number) (not (= (fval number) INF))))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)

(check-sat)
(get-model)

------------------------------
  Test Case 6: satisfied_assert_0;assert_2, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2'], 'violated_contracts': ['assert_1'], 'total_contracts': 3}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun safe_fval ((v Value)) Real
 (ite (is-FloatVal v) (fval v) 0.0))
(declare-const INF Real)

; === Inputs ===
(declare-const number Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (> (safe_fval number) 0.0))
(define-fun C1 () Bool (is-FloatVal number))
(define-fun C2 () Bool (and (is-FloatVal number) (not (= (fval number) INF))))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)

(check-sat)
(get-model)

------------------------------
  Test Case 7: satisfied_assert_1;assert_2, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2'], 'violated_contracts': ['assert_0'], 'total_contracts': 3}
  Solutions:
    Solution 1:
      test_case: {'INF': 2.0, 'number': 0.0}
    Solution 2:
      test_case: {'INF': 3.0, 'number': -7719.0}
    Solution 3:
      test_case: {'INF': 4.0, 'number': -10156.0}
    Solution 4:
      test_case: {'INF': 5.0, 'number': -21953.0}
    Solution 5:
      test_case: {'INF': 6.0, 'number': -54238.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun safe_fval ((v Value)) Real
 (ite (is-FloatVal v) (fval v) 0.0))
(declare-const INF Real)

; === Inputs ===
(declare-const number Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (> (safe_fval number) 0.0))
(define-fun C1 () Bool (is-FloatVal number))
(define-fun C2 () Bool (and (is-FloatVal number) (not (= (fval number) INF))))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)

(check-sat)
(get-model)

------------------------------
  Test Case 8: satisfied_assert_0;assert_1;assert_2, violated_
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2'], 'violated_contracts': [], 'total_contracts': 3}
  Solutions:
    Solution 1:
      test_case: {'INF': 2.0, 'number': 0.5}
    Solution 2:
      test_case: {'INF': 3.0, 'number': 0.25}
    Solution 3:
      test_case: {'INF': 4.0, 'number': 0.125}
    Solution 4:
      test_case: {'INF': 5.0, 'number': 0.0625}
    Solution 5:
      test_case: {'INF': 6.0, 'number': 0.03125}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun safe_fval ((v Value)) Real
 (ite (is-FloatVal v) (fval v) 0.0))
(declare-const INF Real)

; === Inputs ===
(declare-const number Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (> (safe_fval number) 0.0))
(define-fun C1 () Bool (is-FloatVal number))
(define-fun C2 () Bool (and (is-FloatVal number) (not (= (fval number) INF))))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/3 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (IsList (tail v)))))

(define-fun safe_ival ((v Value)) Int
  (ite (is-IntVal v)
       (ival v)
       0))

(define-fun-rec list_all_int ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (is-IntVal (head v))
           (list_all_int (tail v)))))

; === Inputs ===
(declare-const operations Value)

; === BASIC STRUCTURE ===
(assert (IsList operations))

; === Contract predicates ===
(define-fun C0 () Bool (IsList operations))
(define-fun C1 () Bool (list_all_int operations))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'operations': [2.0]}
    Solution 2:
      test_case: {'operations': [3.0]}
    Solution 3:
      test_case: {'operations': [4.0]}
    Solution 4:
      test_case: {'operations': [5.0]}
    Solution 5:
      test_case: {'operations': [6.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (IsList (tail v)))))

(define-fun safe_ival ((v Value)) Int
  (ite (is-IntVal v)
       (ival v)
       0))

(define-fun-rec list_all_int ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (is-IntVal (head v))
           (list_all_int (tail v)))))

; === Inputs ===
(declare-const operations Value)

; === BASIC STRUCTURE ===
(assert (IsList operations))

; === Contract predicates ===
(define-fun C0 () Bool (IsList operations))
(define-fun C1 () Bool (list_all_int operations))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (IsList (tail v)))))

(define-fun safe_ival ((v Value)) Int
  (ite (is-IntVal v)
       (ival v)
       0))

(define-fun-rec list_all_int ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (is-IntVal (head v))
           (list_all_int (tail v)))))

; === Inputs ===
(declare-const operations Value)

; === BASIC STRUCTURE ===
(assert (IsList operations))

; === Contract predicates ===
(define-fun C0 () Bool (IsList operations))
(define-fun C1 () Bool (list_all_int operations))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'operations': []}
    Solution 2:
      test_case: {'operations': [2, 3]}
    Solution 3:
      test_case: {'operations': [4]}
    Solution 4:
      test_case: {'operations': [5]}
    Solution 5:
      test_case: {'operations': [6]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (IsList (tail v)))))

(define-fun safe_ival ((v Value)) Int
  (ite (is-IntVal v)
       (ival v)
       0))

(define-fun-rec list_all_int ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (is-IntVal (head v))
           (list_all_int (tail v)))))

; === Inputs ===
(declare-const operations Value)

; === BASIC STRUCTURE ===
(assert (IsList operations))

; === Contract predicates ===
(define-fun C0 () Bool (IsList operations))
(define-fun C1 () Bool (list_all_int operations))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/4 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (ite (is-Nil lst)
       true
       (ite (is-Cons lst)
            (IsList (tail lst))
            false)))

(define-fun-rec list_all_float ((lst Value)) Bool
  (ite (is-Nil lst)
       true
       (ite (is-Cons lst)
            (and (is-FloatVal (head lst)) (list_all_float (tail lst)))
            false)))

; === Inputs ===
(declare-const numbers Value)

; === BASIC STRUCTURE ===
(assert (IsList numbers))

; === Contract predicates ===
(define-fun C0 () Bool
  (list_all_float numbers))
(define-fun C1 () Bool
  (is-Cons numbers))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 1
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'numbers': []}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (ite (is-Nil lst)
       true
       (ite (is-Cons lst)
            (IsList (tail lst))
            false)))

(define-fun-rec list_all_float ((lst Value)) Bool
  (ite (is-Nil lst)
       true
       (ite (is-Cons lst)
            (and (is-FloatVal (head lst)) (list_all_float (tail lst)))
            false)))

; === Inputs ===
(declare-const numbers Value)

; === BASIC STRUCTURE ===
(assert (IsList numbers))

; === Contract predicates ===
(define-fun C0 () Bool
  (list_all_float numbers))
(define-fun C1 () Bool
  (is-Cons numbers))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'numbers': [2]}
    Solution 2:
      test_case: {'numbers': [3]}
    Solution 3:
      test_case: {'numbers': [4]}
    Solution 4:
      test_case: {'numbers': [5]}
    Solution 5:
      test_case: {'numbers': [6]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (ite (is-Nil lst)
       true
       (ite (is-Cons lst)
            (IsList (tail lst))
            false)))

(define-fun-rec list_all_float ((lst Value)) Bool
  (ite (is-Nil lst)
       true
       (ite (is-Cons lst)
            (and (is-FloatVal (head lst)) (list_all_float (tail lst)))
            false)))

; === Inputs ===
(declare-const numbers Value)

; === BASIC STRUCTURE ===
(assert (IsList numbers))

; === Contract predicates ===
(define-fun C0 () Bool
  (list_all_float numbers))
(define-fun C1 () Bool
  (is-Cons numbers))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'numbers': [2.0]}
    Solution 2:
      test_case: {'numbers': [3.0]}
    Solution 3:
      test_case: {'numbers': [4.0]}
    Solution 4:
      test_case: {'numbers': [5.0]}
    Solution 5:
      test_case: {'numbers': [6.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (ite (is-Nil lst)
       true
       (ite (is-Cons lst)
            (IsList (tail lst))
            false)))

(define-fun-rec list_all_float ((lst Value)) Bool
  (ite (is-Nil lst)
       true
       (ite (is-Cons lst)
            (and (is-FloatVal (head lst)) (list_all_float (tail lst)))
            false)))

; === Inputs ===
(declare-const numbers Value)

; === BASIC STRUCTURE ===
(assert (IsList numbers))

; === Contract predicates ===
(define-fun C0 () Bool
  (list_all_float numbers))
(define-fun C1 () Bool
  (is-Cons numbers))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/5 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'numbers': [3.0], 'delimeter': 2.0}
    Solution 2:
      test_case: {'numbers': [5.0], 'delimeter': 4.0}
    Solution 3:
      test_case: {'numbers': [7.0], 'delimeter': 6.0}
    Solution 4:
      test_case: {'numbers': [8.0], 'delimeter': 9.0}
    Solution 5:
      test_case: {'numbers': [10.0], 'delimeter': 11.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (let ((h (head v))
                  (t (tail v)))
              (IsList t))
            false)))

(define-fun-rec list_all_ints ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (let ((h (head v))
                  (t (tail v)))
              (and (is-IntVal h)
                   (list_all_ints t)))
            false)))

; === Inputs ===
(declare-const numbers Value)
(declare-const delimeter Value)

; === BASIC STRUCTURE ===
(assert (IsList numbers))

; === Contract predicates ===
(define-fun C0 () Bool
  (list_all_ints numbers))
(define-fun C1 () Bool
  (is-IntVal delimeter))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'numbers': [], 'delimeter': 2.0}
    Solution 2:
      test_case: {'numbers': [], 'delimeter': 3.0}
    Solution 3:
      test_case: {'numbers': [], 'delimeter': 4.0}
    Solution 4:
      test_case: {'numbers': [], 'delimeter': 5.0}
    Solution 5:
      test_case: {'numbers': [], 'delimeter': 6.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (let ((h (head v))
                  (t (tail v)))
              (IsList t))
            false)))

(define-fun-rec list_all_ints ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (let ((h (head v))
                  (t (tail v)))
              (and (is-IntVal h)
                   (list_all_ints t)))
            false)))

; === Inputs ===
(declare-const numbers Value)
(declare-const delimeter Value)

; === BASIC STRUCTURE ===
(assert (IsList numbers))

; === Contract predicates ===
(define-fun C0 () Bool
  (list_all_ints numbers))
(define-fun C1 () Bool
  (is-IntVal delimeter))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'numbers': [2.0], 'delimeter': 2}
    Solution 2:
      test_case: {'numbers': [3.0], 'delimeter': 3}
    Solution 3:
      test_case: {'numbers': [4.0], 'delimeter': 4}
    Solution 4:
      test_case: {'numbers': [5.0], 'delimeter': 5}
    Solution 5:
      test_case: {'numbers': [6.0], 'delimeter': 6}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (let ((h (head v))
                  (t (tail v)))
              (IsList t))
            false)))

(define-fun-rec list_all_ints ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (let ((h (head v))
                  (t (tail v)))
              (and (is-IntVal h)
                   (list_all_ints t)))
            false)))

; === Inputs ===
(declare-const numbers Value)
(declare-const delimeter Value)

; === BASIC STRUCTURE ===
(assert (IsList numbers))

; === Contract predicates ===
(define-fun C0 () Bool
  (list_all_ints numbers))
(define-fun C1 () Bool
  (is-IntVal delimeter))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'numbers': [], 'delimeter': 2}
    Solution 2:
      test_case: {'numbers': [], 'delimeter': 3}
    Solution 3:
      test_case: {'numbers': [], 'delimeter': 4}
    Solution 4:
      test_case: {'numbers': [], 'delimeter': 5}
    Solution 5:
      test_case: {'numbers': [], 'delimeter': 6}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (let ((h (head v))
                  (t (tail v)))
              (IsList t))
            false)))

(define-fun-rec list_all_ints ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (let ((h (head v))
                  (t (tail v)))
              (and (is-IntVal h)
                   (list_all_ints t)))
            false)))

; === Inputs ===
(declare-const numbers Value)
(declare-const delimeter Value)

; === BASIC STRUCTURE ===
(assert (IsList numbers))

; === Contract predicates ===
(define-fun C0 () Bool
  (list_all_ints numbers))
(define-fun C1 () Bool
  (is-IntVal delimeter))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/6 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1;assert_2;assert_3
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False, 'assert_3': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_3'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'paren_string': 2.0}
    Solution 2:
      test_case: {'paren_string': 3.0}
    Solution 3:
      test_case: {'paren_string': 4.0}
    Solution 4:
      test_case: {'paren_string': 5.0}
    Solution 5:
      test_case: {'paren_string': 6.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun ValidParenChars ((s String)) Bool
  (str.in.re s (re.* (re.union (str.to.re "(") (re.union (str.to.re ")") (str.to.re " "))))))

(define-fun-rec prefix_ok ((s String) (i Int) (cnt Int)) Bool
  (ite (>= i (str.len s))
       true
       (let ((ch (str.at s i)))
         (let ((isL (str.in.re ch (str.to.re "(")))
               (isR (str.in.re ch (str.to.re ")"))))
           (let ((newCnt (ite isL (+ cnt 1) (ite isR (- cnt 1) cnt))))
             (and (>= newCnt 0)
                  (prefix_ok s (+ i 1) newCnt)))))))

(define-fun-rec sum_balance ((s String) (i Int)) Int
  (ite (>= i (str.len s))
       0
       (let ((ch (str.at s i)))
         (let ((isL (str.in.re ch (str.to.re "(")))
               (isR (str.in.re ch (str.to.re ")"))))
           (let ((cur (ite isL 1 (ite isR (- 1) 0))))
             (+ cur (sum_balance s (+ i 1))))))))

; === Inputs ===
(declare-const paren_string Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal paren_string))
(define-fun C1 () Bool (and (is-StrVal paren_string) (ValidParenChars (sval paren_string))))
(define-fun C2 () Bool (and (is-StrVal paren_string) (prefix_ok (sval paren_string) 0 0)))
(define-fun C3 () Bool (and (is-StrVal paren_string) (= (sum_balance (sval paren_string) 0) 0)))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1;assert_2;assert_3
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False, 'assert_3': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1', 'assert_2', 'assert_3'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'paren_string': ')A'}
    Solution 2:
      test_case: {'paren_string': 'B)'}
    Solution 3:
      test_case: {'paren_string': 'C)'}
    Solution 4:
      test_case: {'paren_string': 'D)'}
    Solution 5:
      test_case: {'paren_string': 'E)'}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun ValidParenChars ((s String)) Bool
  (str.in.re s (re.* (re.union (str.to.re "(") (re.union (str.to.re ")") (str.to.re " "))))))

(define-fun-rec prefix_ok ((s String) (i Int) (cnt Int)) Bool
  (ite (>= i (str.len s))
       true
       (let ((ch (str.at s i)))
         (let ((isL (str.in.re ch (str.to.re "(")))
               (isR (str.in.re ch (str.to.re ")"))))
           (let ((newCnt (ite isL (+ cnt 1) (ite isR (- cnt 1) cnt))))
             (and (>= newCnt 0)
                  (prefix_ok s (+ i 1) newCnt)))))))

(define-fun-rec sum_balance ((s String) (i Int)) Int
  (ite (>= i (str.len s))
       0
       (let ((ch (str.at s i)))
         (let ((isL (str.in.re ch (str.to.re "(")))
               (isR (str.in.re ch (str.to.re ")"))))
           (let ((cur (ite isL 1 (ite isR (- 1) 0))))
             (+ cur (sum_balance s (+ i 1))))))))

; === Inputs ===
(declare-const paren_string Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal paren_string))
(define-fun C1 () Bool (and (is-StrVal paren_string) (ValidParenChars (sval paren_string))))
(define-fun C2 () Bool (and (is-StrVal paren_string) (prefix_ok (sval paren_string) 0 0)))
(define-fun C3 () Bool (and (is-StrVal paren_string) (= (sum_balance (sval paren_string) 0) 0)))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0;assert_2;assert_3
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False, 'assert_3': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0', 'assert_2', 'assert_3'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun ValidParenChars ((s String)) Bool
  (str.in.re s (re.* (re.union (str.to.re "(") (re.union (str.to.re ")") (str.to.re " "))))))

(define-fun-rec prefix_ok ((s String) (i Int) (cnt Int)) Bool
  (ite (>= i (str.len s))
       true
       (let ((ch (str.at s i)))
         (let ((isL (str.in.re ch (str.to.re "(")))
               (isR (str.in.re ch (str.to.re ")"))))
           (let ((newCnt (ite isL (+ cnt 1) (ite isR (- cnt 1) cnt))))
             (and (>= newCnt 0)
                  (prefix_ok s (+ i 1) newCnt)))))))

(define-fun-rec sum_balance ((s String) (i Int)) Int
  (ite (>= i (str.len s))
       0
       (let ((ch (str.at s i)))
         (let ((isL (str.in.re ch (str.to.re "(")))
               (isR (str.in.re ch (str.to.re ")"))))
           (let ((cur (ite isL 1 (ite isR (- 1) 0))))
             (+ cur (sum_balance s (+ i 1))))))))

; === Inputs ===
(declare-const paren_string Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal paren_string))
(define-fun C1 () Bool (and (is-StrVal paren_string) (ValidParenChars (sval paren_string))))
(define-fun C2 () Bool (and (is-StrVal paren_string) (prefix_ok (sval paren_string) 0 0)))
(define-fun C3 () Bool (and (is-StrVal paren_string) (= (sum_balance (sval paren_string) 0) 0)))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_assert_2;assert_3
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False, 'assert_3': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': ['assert_2', 'assert_3'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'paren_string': ')'}
    Solution 2:
      test_case: {'paren_string': ' )'}
    Solution 3:
      test_case: {'paren_string': '))'}
    Solution 4:
      test_case: {'paren_string': ') '}
    Solution 5:
      test_case: {'paren_string': '  )'}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun ValidParenChars ((s String)) Bool
  (str.in.re s (re.* (re.union (str.to.re "(") (re.union (str.to.re ")") (str.to.re " "))))))

(define-fun-rec prefix_ok ((s String) (i Int) (cnt Int)) Bool
  (ite (>= i (str.len s))
       true
       (let ((ch (str.at s i)))
         (let ((isL (str.in.re ch (str.to.re "(")))
               (isR (str.in.re ch (str.to.re ")"))))
           (let ((newCnt (ite isL (+ cnt 1) (ite isR (- cnt 1) cnt))))
             (and (>= newCnt 0)
                  (prefix_ok s (+ i 1) newCnt)))))))

(define-fun-rec sum_balance ((s String) (i Int)) Int
  (ite (>= i (str.len s))
       0
       (let ((ch (str.at s i)))
         (let ((isL (str.in.re ch (str.to.re "(")))
               (isR (str.in.re ch (str.to.re ")"))))
           (let ((cur (ite isL 1 (ite isR (- 1) 0))))
             (+ cur (sum_balance s (+ i 1))))))))

; === Inputs ===
(declare-const paren_string Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal paren_string))
(define-fun C1 () Bool (and (is-StrVal paren_string) (ValidParenChars (sval paren_string))))
(define-fun C2 () Bool (and (is-StrVal paren_string) (prefix_ok (sval paren_string) 0 0)))
(define-fun C3 () Bool (and (is-StrVal paren_string) (= (sum_balance (sval paren_string) 0) 0)))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 5: satisfied_assert_2, violated_assert_0;assert_1;assert_3
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True, 'assert_3': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_2'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_3'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun ValidParenChars ((s String)) Bool
  (str.in.re s (re.* (re.union (str.to.re "(") (re.union (str.to.re ")") (str.to.re " "))))))

(define-fun-rec prefix_ok ((s String) (i Int) (cnt Int)) Bool
  (ite (>= i (str.len s))
       true
       (let ((ch (str.at s i)))
         (let ((isL (str.in.re ch (str.to.re "(")))
               (isR (str.in.re ch (str.to.re ")"))))
           (let ((newCnt (ite isL (+ cnt 1) (ite isR (- cnt 1) cnt))))
             (and (>= newCnt 0)
                  (prefix_ok s (+ i 1) newCnt)))))))

(define-fun-rec sum_balance ((s String) (i Int)) Int
  (ite (>= i (str.len s))
       0
       (let ((ch (str.at s i)))
         (let ((isL (str.in.re ch (str.to.re "(")))
               (isR (str.in.re ch (str.to.re ")"))))
           (let ((cur (ite isL 1 (ite isR (- 1) 0))))
             (+ cur (sum_balance s (+ i 1))))))))

; === Inputs ===
(declare-const paren_string Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal paren_string))
(define-fun C1 () Bool (and (is-StrVal paren_string) (ValidParenChars (sval paren_string))))
(define-fun C2 () Bool (and (is-StrVal paren_string) (prefix_ok (sval paren_string) 0 0)))
(define-fun C3 () Bool (and (is-StrVal paren_string) (= (sum_balance (sval paren_string) 0) 0)))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 6: satisfied_assert_0;assert_2, violated_assert_1;assert_3
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True, 'assert_3': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2'], 'violated_contracts': ['assert_1', 'assert_3'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'paren_string': 'A('}
    Solution 2:
      test_case: {'paren_string': 'B('}
    Solution 3:
      test_case: {'paren_string': 'C('}
    Solution 4:
      test_case: {'paren_string': 'D('}
    Solution 5:
      test_case: {'paren_string': 'E('}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun ValidParenChars ((s String)) Bool
  (str.in.re s (re.* (re.union (str.to.re "(") (re.union (str.to.re ")") (str.to.re " "))))))

(define-fun-rec prefix_ok ((s String) (i Int) (cnt Int)) Bool
  (ite (>= i (str.len s))
       true
       (let ((ch (str.at s i)))
         (let ((isL (str.in.re ch (str.to.re "(")))
               (isR (str.in.re ch (str.to.re ")"))))
           (let ((newCnt (ite isL (+ cnt 1) (ite isR (- cnt 1) cnt))))
             (and (>= newCnt 0)
                  (prefix_ok s (+ i 1) newCnt)))))))

(define-fun-rec sum_balance ((s String) (i Int)) Int
  (ite (>= i (str.len s))
       0
       (let ((ch (str.at s i)))
         (let ((isL (str.in.re ch (str.to.re "(")))
               (isR (str.in.re ch (str.to.re ")"))))
           (let ((cur (ite isL 1 (ite isR (- 1) 0))))
             (+ cur (sum_balance s (+ i 1))))))))

; === Inputs ===
(declare-const paren_string Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal paren_string))
(define-fun C1 () Bool (and (is-StrVal paren_string) (ValidParenChars (sval paren_string))))
(define-fun C2 () Bool (and (is-StrVal paren_string) (prefix_ok (sval paren_string) 0 0)))
(define-fun C3 () Bool (and (is-StrVal paren_string) (= (sum_balance (sval paren_string) 0) 0)))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 7: satisfied_assert_1;assert_2, violated_assert_0;assert_3
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True, 'assert_3': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2'], 'violated_contracts': ['assert_0', 'assert_3'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun ValidParenChars ((s String)) Bool
  (str.in.re s (re.* (re.union (str.to.re "(") (re.union (str.to.re ")") (str.to.re " "))))))

(define-fun-rec prefix_ok ((s String) (i Int) (cnt Int)) Bool
  (ite (>= i (str.len s))
       true
       (let ((ch (str.at s i)))
         (let ((isL (str.in.re ch (str.to.re "(")))
               (isR (str.in.re ch (str.to.re ")"))))
           (let ((newCnt (ite isL (+ cnt 1) (ite isR (- cnt 1) cnt))))
             (and (>= newCnt 0)
                  (prefix_ok s (+ i 1) newCnt)))))))

(define-fun-rec sum_balance ((s String) (i Int)) Int
  (ite (>= i (str.len s))
       0
       (let ((ch (str.at s i)))
         (let ((isL (str.in.re ch (str.to.re "(")))
               (isR (str.in.re ch (str.to.re ")"))))
           (let ((cur (ite isL 1 (ite isR (- 1) 0))))
             (+ cur (sum_balance s (+ i 1))))))))

; === Inputs ===
(declare-const paren_string Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal paren_string))
(define-fun C1 () Bool (and (is-StrVal paren_string) (ValidParenChars (sval paren_string))))
(define-fun C2 () Bool (and (is-StrVal paren_string) (prefix_ok (sval paren_string) 0 0)))
(define-fun C3 () Bool (and (is-StrVal paren_string) (= (sum_balance (sval paren_string) 0) 0)))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 8: satisfied_assert_0;assert_1;assert_2, violated_assert_3
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True, 'assert_3': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2'], 'violated_contracts': ['assert_3'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'paren_string': '('}
    Solution 2:
      test_case: {'paren_string': ' ('}
    Solution 3:
      test_case: {'paren_string': '( '}
    Solution 4:
      test_case: {'paren_string': '(('}
    Solution 5:
      test_case: {'paren_string': '  ('}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun ValidParenChars ((s String)) Bool
  (str.in.re s (re.* (re.union (str.to.re "(") (re.union (str.to.re ")") (str.to.re " "))))))

(define-fun-rec prefix_ok ((s String) (i Int) (cnt Int)) Bool
  (ite (>= i (str.len s))
       true
       (let ((ch (str.at s i)))
         (let ((isL (str.in.re ch (str.to.re "(")))
               (isR (str.in.re ch (str.to.re ")"))))
           (let ((newCnt (ite isL (+ cnt 1) (ite isR (- cnt 1) cnt))))
             (and (>= newCnt 0)
                  (prefix_ok s (+ i 1) newCnt)))))))

(define-fun-rec sum_balance ((s String) (i Int)) Int
  (ite (>= i (str.len s))
       0
       (let ((ch (str.at s i)))
         (let ((isL (str.in.re ch (str.to.re "(")))
               (isR (str.in.re ch (str.to.re ")"))))
           (let ((cur (ite isL 1 (ite isR (- 1) 0))))
             (+ cur (sum_balance s (+ i 1))))))))

; === Inputs ===
(declare-const paren_string Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal paren_string))
(define-fun C1 () Bool (and (is-StrVal paren_string) (ValidParenChars (sval paren_string))))
(define-fun C2 () Bool (and (is-StrVal paren_string) (prefix_ok (sval paren_string) 0 0)))
(define-fun C3 () Bool (and (is-StrVal paren_string) (= (sum_balance (sval paren_string) 0) 0)))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 9: satisfied_assert_3, violated_assert_0;assert_1;assert_2
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False, 'assert_3': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_3'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun ValidParenChars ((s String)) Bool
  (str.in.re s (re.* (re.union (str.to.re "(") (re.union (str.to.re ")") (str.to.re " "))))))

(define-fun-rec prefix_ok ((s String) (i Int) (cnt Int)) Bool
  (ite (>= i (str.len s))
       true
       (let ((ch (str.at s i)))
         (let ((isL (str.in.re ch (str.to.re "(")))
               (isR (str.in.re ch (str.to.re ")"))))
           (let ((newCnt (ite isL (+ cnt 1) (ite isR (- cnt 1) cnt))))
             (and (>= newCnt 0)
                  (prefix_ok s (+ i 1) newCnt)))))))

(define-fun-rec sum_balance ((s String) (i Int)) Int
  (ite (>= i (str.len s))
       0
       (let ((ch (str.at s i)))
         (let ((isL (str.in.re ch (str.to.re "(")))
               (isR (str.in.re ch (str.to.re ")"))))
           (let ((cur (ite isL 1 (ite isR (- 1) 0))))
             (+ cur (sum_balance s (+ i 1))))))))

; === Inputs ===
(declare-const paren_string Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal paren_string))
(define-fun C1 () Bool (and (is-StrVal paren_string) (ValidParenChars (sval paren_string))))
(define-fun C2 () Bool (and (is-StrVal paren_string) (prefix_ok (sval paren_string) 0 0)))
(define-fun C3 () Bool (and (is-StrVal paren_string) (= (sum_balance (sval paren_string) 0) 0)))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 10: satisfied_assert_0;assert_3, violated_assert_1;assert_2
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False, 'assert_3': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_3'], 'violated_contracts': ['assert_1', 'assert_2'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'paren_string': 'A)('}
    Solution 2:
      test_case: {'paren_string': 'B)('}
    Solution 3:
      test_case: {'paren_string': 'C)('}
    Solution 4:
      test_case: {'paren_string': 'D)('}
    Solution 5:
      test_case: {'paren_string': 'E)('}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun ValidParenChars ((s String)) Bool
  (str.in.re s (re.* (re.union (str.to.re "(") (re.union (str.to.re ")") (str.to.re " "))))))

(define-fun-rec prefix_ok ((s String) (i Int) (cnt Int)) Bool
  (ite (>= i (str.len s))
       true
       (let ((ch (str.at s i)))
         (let ((isL (str.in.re ch (str.to.re "(")))
               (isR (str.in.re ch (str.to.re ")"))))
           (let ((newCnt (ite isL (+ cnt 1) (ite isR (- cnt 1) cnt))))
             (and (>= newCnt 0)
                  (prefix_ok s (+ i 1) newCnt)))))))

(define-fun-rec sum_balance ((s String) (i Int)) Int
  (ite (>= i (str.len s))
       0
       (let ((ch (str.at s i)))
         (let ((isL (str.in.re ch (str.to.re "(")))
               (isR (str.in.re ch (str.to.re ")"))))
           (let ((cur (ite isL 1 (ite isR (- 1) 0))))
             (+ cur (sum_balance s (+ i 1))))))))

; === Inputs ===
(declare-const paren_string Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal paren_string))
(define-fun C1 () Bool (and (is-StrVal paren_string) (ValidParenChars (sval paren_string))))
(define-fun C2 () Bool (and (is-StrVal paren_string) (prefix_ok (sval paren_string) 0 0)))
(define-fun C3 () Bool (and (is-StrVal paren_string) (= (sum_balance (sval paren_string) 0) 0)))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 11: satisfied_assert_1;assert_3, violated_assert_0;assert_2
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False, 'assert_3': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_3'], 'violated_contracts': ['assert_0', 'assert_2'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun ValidParenChars ((s String)) Bool
  (str.in.re s (re.* (re.union (str.to.re "(") (re.union (str.to.re ")") (str.to.re " "))))))

(define-fun-rec prefix_ok ((s String) (i Int) (cnt Int)) Bool
  (ite (>= i (str.len s))
       true
       (let ((ch (str.at s i)))
         (let ((isL (str.in.re ch (str.to.re "(")))
               (isR (str.in.re ch (str.to.re ")"))))
           (let ((newCnt (ite isL (+ cnt 1) (ite isR (- cnt 1) cnt))))
             (and (>= newCnt 0)
                  (prefix_ok s (+ i 1) newCnt)))))))

(define-fun-rec sum_balance ((s String) (i Int)) Int
  (ite (>= i (str.len s))
       0
       (let ((ch (str.at s i)))
         (let ((isL (str.in.re ch (str.to.re "(")))
               (isR (str.in.re ch (str.to.re ")"))))
           (let ((cur (ite isL 1 (ite isR (- 1) 0))))
             (+ cur (sum_balance s (+ i 1))))))))

; === Inputs ===
(declare-const paren_string Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal paren_string))
(define-fun C1 () Bool (and (is-StrVal paren_string) (ValidParenChars (sval paren_string))))
(define-fun C2 () Bool (and (is-StrVal paren_string) (prefix_ok (sval paren_string) 0 0)))
(define-fun C3 () Bool (and (is-StrVal paren_string) (= (sum_balance (sval paren_string) 0) 0)))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 12: satisfied_assert_0;assert_1;assert_3, violated_assert_2
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False, 'assert_3': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_3'], 'violated_contracts': ['assert_2'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'paren_string': ')('}
    Solution 2:
      test_case: {'paren_string': ') ('}
    Solution 3:
      test_case: {'paren_string': ')( '}
    Solution 4:
      test_case: {'paren_string': ' )('}
    Solution 5:
      test_case: {'paren_string': ' ) ('}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun ValidParenChars ((s String)) Bool
  (str.in.re s (re.* (re.union (str.to.re "(") (re.union (str.to.re ")") (str.to.re " "))))))

(define-fun-rec prefix_ok ((s String) (i Int) (cnt Int)) Bool
  (ite (>= i (str.len s))
       true
       (let ((ch (str.at s i)))
         (let ((isL (str.in.re ch (str.to.re "(")))
               (isR (str.in.re ch (str.to.re ")"))))
           (let ((newCnt (ite isL (+ cnt 1) (ite isR (- cnt 1) cnt))))
             (and (>= newCnt 0)
                  (prefix_ok s (+ i 1) newCnt)))))))

(define-fun-rec sum_balance ((s String) (i Int)) Int
  (ite (>= i (str.len s))
       0
       (let ((ch (str.at s i)))
         (let ((isL (str.in.re ch (str.to.re "(")))
               (isR (str.in.re ch (str.to.re ")"))))
           (let ((cur (ite isL 1 (ite isR (- 1) 0))))
             (+ cur (sum_balance s (+ i 1))))))))

; === Inputs ===
(declare-const paren_string Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal paren_string))
(define-fun C1 () Bool (and (is-StrVal paren_string) (ValidParenChars (sval paren_string))))
(define-fun C2 () Bool (and (is-StrVal paren_string) (prefix_ok (sval paren_string) 0 0)))
(define-fun C3 () Bool (and (is-StrVal paren_string) (= (sum_balance (sval paren_string) 0) 0)))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 13: satisfied_assert_2;assert_3, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True, 'assert_3': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_2', 'assert_3'], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun ValidParenChars ((s String)) Bool
  (str.in.re s (re.* (re.union (str.to.re "(") (re.union (str.to.re ")") (str.to.re " "))))))

(define-fun-rec prefix_ok ((s String) (i Int) (cnt Int)) Bool
  (ite (>= i (str.len s))
       true
       (let ((ch (str.at s i)))
         (let ((isL (str.in.re ch (str.to.re "(")))
               (isR (str.in.re ch (str.to.re ")"))))
           (let ((newCnt (ite isL (+ cnt 1) (ite isR (- cnt 1) cnt))))
             (and (>= newCnt 0)
                  (prefix_ok s (+ i 1) newCnt)))))))

(define-fun-rec sum_balance ((s String) (i Int)) Int
  (ite (>= i (str.len s))
       0
       (let ((ch (str.at s i)))
         (let ((isL (str.in.re ch (str.to.re "(")))
               (isR (str.in.re ch (str.to.re ")"))))
           (let ((cur (ite isL 1 (ite isR (- 1) 0))))
             (+ cur (sum_balance s (+ i 1))))))))

; === Inputs ===
(declare-const paren_string Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal paren_string))
(define-fun C1 () Bool (and (is-StrVal paren_string) (ValidParenChars (sval paren_string))))
(define-fun C2 () Bool (and (is-StrVal paren_string) (prefix_ok (sval paren_string) 0 0)))
(define-fun C3 () Bool (and (is-StrVal paren_string) (= (sum_balance (sval paren_string) 0) 0)))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 14: satisfied_assert_0;assert_2;assert_3, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True, 'assert_3': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2', 'assert_3'], 'violated_contracts': ['assert_1'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'paren_string': 'A'}
    Solution 2:
      test_case: {'paren_string': 'B'}
    Solution 3:
      test_case: {'paren_string': 'C'}
    Solution 4:
      test_case: {'paren_string': 'D'}
    Solution 5:
      test_case: {'paren_string': 'E'}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun ValidParenChars ((s String)) Bool
  (str.in.re s (re.* (re.union (str.to.re "(") (re.union (str.to.re ")") (str.to.re " "))))))

(define-fun-rec prefix_ok ((s String) (i Int) (cnt Int)) Bool
  (ite (>= i (str.len s))
       true
       (let ((ch (str.at s i)))
         (let ((isL (str.in.re ch (str.to.re "(")))
               (isR (str.in.re ch (str.to.re ")"))))
           (let ((newCnt (ite isL (+ cnt 1) (ite isR (- cnt 1) cnt))))
             (and (>= newCnt 0)
                  (prefix_ok s (+ i 1) newCnt)))))))

(define-fun-rec sum_balance ((s String) (i Int)) Int
  (ite (>= i (str.len s))
       0
       (let ((ch (str.at s i)))
         (let ((isL (str.in.re ch (str.to.re "(")))
               (isR (str.in.re ch (str.to.re ")"))))
           (let ((cur (ite isL 1 (ite isR (- 1) 0))))
             (+ cur (sum_balance s (+ i 1))))))))

; === Inputs ===
(declare-const paren_string Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal paren_string))
(define-fun C1 () Bool (and (is-StrVal paren_string) (ValidParenChars (sval paren_string))))
(define-fun C2 () Bool (and (is-StrVal paren_string) (prefix_ok (sval paren_string) 0 0)))
(define-fun C3 () Bool (and (is-StrVal paren_string) (= (sum_balance (sval paren_string) 0) 0)))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 15: satisfied_assert_1;assert_2;assert_3, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True, 'assert_3': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2', 'assert_3'], 'violated_contracts': ['assert_0'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun ValidParenChars ((s String)) Bool
  (str.in.re s (re.* (re.union (str.to.re "(") (re.union (str.to.re ")") (str.to.re " "))))))

(define-fun-rec prefix_ok ((s String) (i Int) (cnt Int)) Bool
  (ite (>= i (str.len s))
       true
       (let ((ch (str.at s i)))
         (let ((isL (str.in.re ch (str.to.re "(")))
               (isR (str.in.re ch (str.to.re ")"))))
           (let ((newCnt (ite isL (+ cnt 1) (ite isR (- cnt 1) cnt))))
             (and (>= newCnt 0)
                  (prefix_ok s (+ i 1) newCnt)))))))

(define-fun-rec sum_balance ((s String) (i Int)) Int
  (ite (>= i (str.len s))
       0
       (let ((ch (str.at s i)))
         (let ((isL (str.in.re ch (str.to.re "(")))
               (isR (str.in.re ch (str.to.re ")"))))
           (let ((cur (ite isL 1 (ite isR (- 1) 0))))
             (+ cur (sum_balance s (+ i 1))))))))

; === Inputs ===
(declare-const paren_string Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal paren_string))
(define-fun C1 () Bool (and (is-StrVal paren_string) (ValidParenChars (sval paren_string))))
(define-fun C2 () Bool (and (is-StrVal paren_string) (prefix_ok (sval paren_string) 0 0)))
(define-fun C3 () Bool (and (is-StrVal paren_string) (= (sum_balance (sval paren_string) 0) 0)))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 16: satisfied_assert_0;assert_1;assert_2;assert_3, violated_
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True, 'assert_3': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_3'], 'violated_contracts': [], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'paren_string': ''}
    Solution 2:
      test_case: {'paren_string': ' '}
    Solution 3:
      test_case: {'paren_string': '()'}
    Solution 4:
      test_case: {'paren_string': '  '}
    Solution 5:
      test_case: {'paren_string': ' ()'}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun ValidParenChars ((s String)) Bool
  (str.in.re s (re.* (re.union (str.to.re "(") (re.union (str.to.re ")") (str.to.re " "))))))

(define-fun-rec prefix_ok ((s String) (i Int) (cnt Int)) Bool
  (ite (>= i (str.len s))
       true
       (let ((ch (str.at s i)))
         (let ((isL (str.in.re ch (str.to.re "(")))
               (isR (str.in.re ch (str.to.re ")"))))
           (let ((newCnt (ite isL (+ cnt 1) (ite isR (- cnt 1) cnt))))
             (and (>= newCnt 0)
                  (prefix_ok s (+ i 1) newCnt)))))))

(define-fun-rec sum_balance ((s String) (i Int)) Int
  (ite (>= i (str.len s))
       0
       (let ((ch (str.at s i)))
         (let ((isL (str.in.re ch (str.to.re "(")))
               (isR (str.in.re ch (str.to.re ")"))))
           (let ((cur (ite isL 1 (ite isR (- 1) 0))))
             (+ cur (sum_balance s (+ i 1))))))))

; === Inputs ===
(declare-const paren_string Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal paren_string))
(define-fun C1 () Bool (and (is-StrVal paren_string) (ValidParenChars (sval paren_string))))
(define-fun C2 () Bool (and (is-StrVal paren_string) (prefix_ok (sval paren_string) 0 0)))
(define-fun C3 () Bool (and (is-StrVal paren_string) (= (sum_balance (sval paren_string) 0) 0)))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)
(assert C3)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/7 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1;assert_2
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2'], 'total_contracts': 3}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec AllStr ((lst Value)) Bool
  (ite (is-Nil lst)
       true
       (ite (is-Cons lst)
            (and (is-StrVal (head lst))
                 (AllStr (tail lst)))
            false)))

; === Inputs ===
(declare-const strings Value)
(declare-const substring Value)

; === BASIC STRUCTURE ===
(assert (IsList strings))

; === Contract predicates ===
(define-fun C0 () Bool (IsList strings))
(define-fun C1 () Bool (AllStr strings))
(define-fun C2 () Bool (is-StrVal substring))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1;assert_2
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1', 'assert_2'], 'total_contracts': 3}
  Solutions:
    Solution 1:
      test_case: {'substring': 2.0, 'strings': [3.0]}
    Solution 2:
      test_case: {'substring': 4.0, 'strings': [5.0]}
    Solution 3:
      test_case: {'substring': 6.0, 'strings': [7.0]}
    Solution 4:
      test_case: {'substring': 9.0, 'strings': [8.0]}
    Solution 5:
      test_case: {'strings': [10.0], 'substring': 11.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec AllStr ((lst Value)) Bool
  (ite (is-Nil lst)
       true
       (ite (is-Cons lst)
            (and (is-StrVal (head lst))
                 (AllStr (tail lst)))
            false)))

; === Inputs ===
(declare-const strings Value)
(declare-const substring Value)

; === BASIC STRUCTURE ===
(assert (IsList strings))

; === Contract predicates ===
(define-fun C0 () Bool (IsList strings))
(define-fun C1 () Bool (AllStr strings))
(define-fun C2 () Bool (is-StrVal substring))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0;assert_2
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0', 'assert_2'], 'total_contracts': 3}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec AllStr ((lst Value)) Bool
  (ite (is-Nil lst)
       true
       (ite (is-Cons lst)
            (and (is-StrVal (head lst))
                 (AllStr (tail lst)))
            false)))

; === Inputs ===
(declare-const strings Value)
(declare-const substring Value)

; === BASIC STRUCTURE ===
(assert (IsList strings))

; === Contract predicates ===
(define-fun C0 () Bool (IsList strings))
(define-fun C1 () Bool (AllStr strings))
(define-fun C2 () Bool (is-StrVal substring))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_assert_2
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': ['assert_2'], 'total_contracts': 3}
  Solutions:
    Solution 1:
      test_case: {'substring': 2.0, 'strings': []}
    Solution 2:
      test_case: {'substring': 3.0, 'strings': []}
    Solution 3:
      test_case: {'substring': 4.0, 'strings': []}
    Solution 4:
      test_case: {'substring': 5.0, 'strings': []}
    Solution 5:
      test_case: {'substring': 6.0, 'strings': []}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec AllStr ((lst Value)) Bool
  (ite (is-Nil lst)
       true
       (ite (is-Cons lst)
            (and (is-StrVal (head lst))
                 (AllStr (tail lst)))
            false)))

; === Inputs ===
(declare-const strings Value)
(declare-const substring Value)

; === BASIC STRUCTURE ===
(assert (IsList strings))

; === Contract predicates ===
(define-fun C0 () Bool (IsList strings))
(define-fun C1 () Bool (AllStr strings))
(define-fun C2 () Bool (is-StrVal substring))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))

(check-sat)
(get-model)

------------------------------
  Test Case 5: satisfied_assert_2, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_2'], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 3}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec AllStr ((lst Value)) Bool
  (ite (is-Nil lst)
       true
       (ite (is-Cons lst)
            (and (is-StrVal (head lst))
                 (AllStr (tail lst)))
            false)))

; === Inputs ===
(declare-const strings Value)
(declare-const substring Value)

; === BASIC STRUCTURE ===
(assert (IsList strings))

; === Contract predicates ===
(define-fun C0 () Bool (IsList strings))
(define-fun C1 () Bool (AllStr strings))
(define-fun C2 () Bool (is-StrVal substring))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)

(check-sat)
(get-model)

------------------------------
  Test Case 6: satisfied_assert_0;assert_2, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2'], 'violated_contracts': ['assert_1'], 'total_contracts': 3}
  Solutions:
    Solution 1:
      test_case: {'substring': '!0!', 'strings': [2.0]}
    Solution 2:
      test_case: {'substring': '!', 'strings': [3.0]}
    Solution 3:
      test_case: {'substring': '0', 'strings': [4.0]}
    Solution 4:
      test_case: {'substring': '0!', 'strings': [5.0]}
    Solution 5:
      test_case: {'substring': 'A', 'strings': [6.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec AllStr ((lst Value)) Bool
  (ite (is-Nil lst)
       true
       (ite (is-Cons lst)
            (and (is-StrVal (head lst))
                 (AllStr (tail lst)))
            false)))

; === Inputs ===
(declare-const strings Value)
(declare-const substring Value)

; === BASIC STRUCTURE ===
(assert (IsList strings))

; === Contract predicates ===
(define-fun C0 () Bool (IsList strings))
(define-fun C1 () Bool (AllStr strings))
(define-fun C2 () Bool (is-StrVal substring))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)

(check-sat)
(get-model)

------------------------------
  Test Case 7: satisfied_assert_1;assert_2, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2'], 'violated_contracts': ['assert_0'], 'total_contracts': 3}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec AllStr ((lst Value)) Bool
  (ite (is-Nil lst)
       true
       (ite (is-Cons lst)
            (and (is-StrVal (head lst))
                 (AllStr (tail lst)))
            false)))

; === Inputs ===
(declare-const strings Value)
(declare-const substring Value)

; === BASIC STRUCTURE ===
(assert (IsList strings))

; === Contract predicates ===
(define-fun C0 () Bool (IsList strings))
(define-fun C1 () Bool (AllStr strings))
(define-fun C2 () Bool (is-StrVal substring))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)

(check-sat)
(get-model)

------------------------------
  Test Case 8: satisfied_assert_0;assert_1;assert_2, violated_
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2'], 'violated_contracts': [], 'total_contracts': 3}
  Solutions:
    Solution 1:
      test_case: {'substring': '!0!', 'strings': []}
    Solution 2:
      test_case: {'substring': '!', 'strings': []}
    Solution 3:
      test_case: {'strings': [], 'substring': '0'}
    Solution 4:
      test_case: {'substring': '0!', 'strings': []}
    Solution 5:
      test_case: {'substring': '', 'strings': []}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec AllStr ((lst Value)) Bool
  (ite (is-Nil lst)
       true
       (ite (is-Cons lst)
            (and (is-StrVal (head lst))
                 (AllStr (tail lst)))
            false)))

; === Inputs ===
(declare-const strings Value)
(declare-const substring Value)

; === BASIC STRUCTURE ===
(assert (IsList strings))

; === Contract predicates ===
(define-fun C0 () Bool (IsList strings))
(define-fun C1 () Bool (AllStr strings))
(define-fun C2 () Bool (is-StrVal substring))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/8 ===
  Test Case 1: satisfied_, violated_assert_0
  Combination: {'assert_0': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0'], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'numbers': [2.0]}
    Solution 2:
      test_case: {'numbers': [3.0]}
    Solution 3:
      test_case: {'numbers': [4.0]}
    Solution 4:
      test_case: {'numbers': [5.0]}
    Solution 5:
      test_case: {'numbers': [6.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (IsList (tail l))
            false)))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (and (is-IntVal (head l))
                 (list_all_int (tail l)))
            false)))

; === Inputs ===
(declare-const numbers Value)

; === BASIC STRUCTURE ===
(assert (IsList numbers))

; === Contract predicates ===
(define-fun C0 () Bool (list_all_int numbers))

; === COMBINATION ===
(assert (not C0))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_
  Combination: {'assert_0': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': [], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'numbers': []}
    Solution 2:
      test_case: {'numbers': [2]}
    Solution 3:
      test_case: {'numbers': [3]}
    Solution 4:
      test_case: {'numbers': [4]}
    Solution 5:
      test_case: {'numbers': [5]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (IsList (tail l))
            false)))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (and (is-IntVal (head l))
                 (list_all_int (tail l)))
            false)))

; === Inputs ===
(declare-const numbers Value)

; === BASIC STRUCTURE ===
(assert (IsList numbers))

; === Contract predicates ===
(define-fun C0 () Bool (list_all_int numbers))

; === COMBINATION ===
(assert C0)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/9 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_int ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (is-IntVal (head v))
                 (list_all_int (tail v)))
            false)))

; === Inputs ===
(declare-const numbers Value)

; === BASIC STRUCTURE ===
(assert (IsList numbers))

; === Contract predicates ===
(define-fun C0 () Bool (IsList numbers))
(define-fun C1 () Bool (list_all_int numbers))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'numbers': [2.0]}
    Solution 2:
      test_case: {'numbers': [3.0]}
    Solution 3:
      test_case: {'numbers': [4.0]}
    Solution 4:
      test_case: {'numbers': [5.0]}
    Solution 5:
      test_case: {'numbers': [6.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_int ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (is-IntVal (head v))
                 (list_all_int (tail v)))
            false)))

; === Inputs ===
(declare-const numbers Value)

; === BASIC STRUCTURE ===
(assert (IsList numbers))

; === Contract predicates ===
(define-fun C0 () Bool (IsList numbers))
(define-fun C1 () Bool (list_all_int numbers))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_int ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (is-IntVal (head v))
                 (list_all_int (tail v)))
            false)))

; === Inputs ===
(declare-const numbers Value)

; === BASIC STRUCTURE ===
(assert (IsList numbers))

; === Contract predicates ===
(define-fun C0 () Bool (IsList numbers))
(define-fun C1 () Bool (list_all_int numbers))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'numbers': []}
    Solution 2:
      test_case: {'numbers': [2]}
    Solution 3:
      test_case: {'numbers': [3]}
    Solution 4:
      test_case: {'numbers': [4]}
    Solution 5:
      test_case: {'numbers': [5]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_int ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (is-IntVal (head v))
                 (list_all_int (tail v)))
            false)))

; === Inputs ===
(declare-const numbers Value)

; === BASIC STRUCTURE ===
(assert (IsList numbers))

; === Contract predicates ===
(define-fun C0 () Bool (IsList numbers))
(define-fun C1 () Bool (list_all_int numbers))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/10 ===
  Test Case 1: satisfied_, violated_assert_0
  Combination: {'assert_0': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0'], 'total_contracts': 1}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const string Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal string))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal string))

; === COMBINATION ===
(assert (not C0))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_
  Combination: {'assert_0': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': [], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'string': '!0!'}
    Solution 2:
      test_case: {'string': '!'}
    Solution 3:
      test_case: {'string': '0'}
    Solution 4:
      test_case: {'string': '0!'}
    Solution 5:
      test_case: {'string': ''}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const string Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal string))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal string))

; === COMBINATION ===
(assert C0)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/11 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1;assert_2
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2'], 'total_contracts': 3}
  Solutions:
    Solution 1:
      test_case: {'b': 'A', 'a': 2.0}
    Solution 2:
      test_case: {'b': 'B', 'a': 3.0}
    Solution 3:
      test_case: {'b': 'D', 'a': 4.0}
    Solution 4:
      test_case: {'b': 'C', 'a': 5.0}
    Solution 5:
      test_case: {'b': 'E', 'a': 6.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun Safe_Sval ((x Value)) String
  (ite (is-StrVal x) (sval x) ""))
(define-fun isBinaryString ((s Value)) Bool
  (and (is-StrVal s)
       (str.in.re (Safe_Sval s) (re.* (re.union (str.to.re "0") (str.to.re "1"))))))

; === Inputs ===
(declare-const a Value)
(declare-const b Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (is-StrVal a) (is-StrVal b)))
(define-fun C1 () Bool (= (str.len (Safe_Sval a)) (str.len (Safe_Sval b))))
(define-fun C2 () Bool (and (isBinaryString a) (isBinaryString b)))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1;assert_2
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1', 'assert_2'], 'total_contracts': 3}
  Solutions:
    Solution 1:
      test_case: {'b': '', 'a': 'B'}
    Solution 2:
      test_case: {'b': '', 'a': 'C'}
    Solution 3:
      test_case: {'b': '', 'a': 'D'}
    Solution 4:
      test_case: {'b': '', 'a': 'A'}
    Solution 5:
      test_case: {'b': '', 'a': 'E'}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun Safe_Sval ((x Value)) String
  (ite (is-StrVal x) (sval x) ""))
(define-fun isBinaryString ((s Value)) Bool
  (and (is-StrVal s)
       (str.in.re (Safe_Sval s) (re.* (re.union (str.to.re "0") (str.to.re "1"))))))

; === Inputs ===
(declare-const a Value)
(declare-const b Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (is-StrVal a) (is-StrVal b)))
(define-fun C1 () Bool (= (str.len (Safe_Sval a)) (str.len (Safe_Sval b))))
(define-fun C2 () Bool (and (isBinaryString a) (isBinaryString b)))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0;assert_2
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0', 'assert_2'], 'total_contracts': 3}
  Solutions:
    Solution 1:
      test_case: {'b': 3.0, 'a': 2.0}
    Solution 2:
      test_case: {'b': 4.0, 'a': 5.0}
    Solution 3:
      test_case: {'b': 7.0, 'a': 6.0}
    Solution 4:
      test_case: {'b': 8.0, 'a': 9.0}
    Solution 5:
      test_case: {'b': 10.0, 'a': 11.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun Safe_Sval ((x Value)) String
  (ite (is-StrVal x) (sval x) ""))
(define-fun isBinaryString ((s Value)) Bool
  (and (is-StrVal s)
       (str.in.re (Safe_Sval s) (re.* (re.union (str.to.re "0") (str.to.re "1"))))))

; === Inputs ===
(declare-const a Value)
(declare-const b Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (is-StrVal a) (is-StrVal b)))
(define-fun C1 () Bool (= (str.len (Safe_Sval a)) (str.len (Safe_Sval b))))
(define-fun C2 () Bool (and (isBinaryString a) (isBinaryString b)))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_assert_2
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': ['assert_2'], 'total_contracts': 3}
  Solutions:
    Solution 1:
      test_case: {'b': 'A', 'a': 'A'}
    Solution 2:
      test_case: {'b': 'B', 'a': 'B'}
    Solution 3:
      test_case: {'b': 'C', 'a': 'C'}
    Solution 4:
      test_case: {'b': 'D', 'a': 'D'}
    Solution 5:
      test_case: {'b': 'E', 'a': 'E'}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun Safe_Sval ((x Value)) String
  (ite (is-StrVal x) (sval x) ""))
(define-fun isBinaryString ((s Value)) Bool
  (and (is-StrVal s)
       (str.in.re (Safe_Sval s) (re.* (re.union (str.to.re "0") (str.to.re "1"))))))

; === Inputs ===
(declare-const a Value)
(declare-const b Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (is-StrVal a) (is-StrVal b)))
(define-fun C1 () Bool (= (str.len (Safe_Sval a)) (str.len (Safe_Sval b))))
(define-fun C2 () Bool (and (isBinaryString a) (isBinaryString b)))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))

(check-sat)
(get-model)

------------------------------
  Test Case 5: satisfied_assert_2, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_2'], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 3}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun Safe_Sval ((x Value)) String
  (ite (is-StrVal x) (sval x) ""))
(define-fun isBinaryString ((s Value)) Bool
  (and (is-StrVal s)
       (str.in.re (Safe_Sval s) (re.* (re.union (str.to.re "0") (str.to.re "1"))))))

; === Inputs ===
(declare-const a Value)
(declare-const b Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (is-StrVal a) (is-StrVal b)))
(define-fun C1 () Bool (= (str.len (Safe_Sval a)) (str.len (Safe_Sval b))))
(define-fun C2 () Bool (and (isBinaryString a) (isBinaryString b)))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)

(check-sat)
(get-model)

------------------------------
  Test Case 6: satisfied_assert_0;assert_2, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2'], 'violated_contracts': ['assert_1'], 'total_contracts': 3}
  Solutions:
    Solution 1:
      test_case: {'b': '', 'a': '0'}
    Solution 2:
      test_case: {'b': '', 'a': '1'}
    Solution 3:
      test_case: {'b': '0', 'a': ''}
    Solution 4:
      test_case: {'b': '1', 'a': ''}
    Solution 5:
      test_case: {'b': '1', 'a': '10'}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun Safe_Sval ((x Value)) String
  (ite (is-StrVal x) (sval x) ""))
(define-fun isBinaryString ((s Value)) Bool
  (and (is-StrVal s)
       (str.in.re (Safe_Sval s) (re.* (re.union (str.to.re "0") (str.to.re "1"))))))

; === Inputs ===
(declare-const a Value)
(declare-const b Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (is-StrVal a) (is-StrVal b)))
(define-fun C1 () Bool (= (str.len (Safe_Sval a)) (str.len (Safe_Sval b))))
(define-fun C2 () Bool (and (isBinaryString a) (isBinaryString b)))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)

(check-sat)
(get-model)

------------------------------
  Test Case 7: satisfied_assert_1;assert_2, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2'], 'violated_contracts': ['assert_0'], 'total_contracts': 3}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun Safe_Sval ((x Value)) String
  (ite (is-StrVal x) (sval x) ""))
(define-fun isBinaryString ((s Value)) Bool
  (and (is-StrVal s)
       (str.in.re (Safe_Sval s) (re.* (re.union (str.to.re "0") (str.to.re "1"))))))

; === Inputs ===
(declare-const a Value)
(declare-const b Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (is-StrVal a) (is-StrVal b)))
(define-fun C1 () Bool (= (str.len (Safe_Sval a)) (str.len (Safe_Sval b))))
(define-fun C2 () Bool (and (isBinaryString a) (isBinaryString b)))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)

(check-sat)
(get-model)

------------------------------
  Test Case 8: satisfied_assert_0;assert_1;assert_2, violated_
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2'], 'violated_contracts': [], 'total_contracts': 3}
  Solutions:
    Solution 1:
      test_case: {'b': '', 'a': ''}
    Solution 2:
      test_case: {'b': '1', 'a': '1'}
    Solution 3:
      test_case: {'b': '0', 'a': '1'}
    Solution 4:
      test_case: {'b': '0', 'a': '0'}
    Solution 5:
      test_case: {'b': '1', 'a': '0'}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun Safe_Sval ((x Value)) String
  (ite (is-StrVal x) (sval x) ""))
(define-fun isBinaryString ((s Value)) Bool
  (and (is-StrVal s)
       (str.in.re (Safe_Sval s) (re.* (re.union (str.to.re "0") (str.to.re "1"))))))

; === Inputs ===
(declare-const a Value)
(declare-const b Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (is-StrVal a) (is-StrVal b)))
(define-fun C1 () Bool (= (str.len (Safe_Sval a)) (str.len (Safe_Sval b))))
(define-fun C2 () Bool (and (isBinaryString a) (isBinaryString b)))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/12 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (IsList (tail v))
      false)))

(define-fun-rec AllStr ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (and (is-StrVal (head v)) (AllStr (tail v)))
      false)))

; === Inputs ===
(declare-const strings Value)

; === BASIC STRUCTURE ===
(assert (IsList strings))

; === Contract predicates ===
(define-fun C0 () Bool (IsList strings))
(define-fun C1 () Bool (AllStr strings))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'strings': [2.0]}
    Solution 2:
      test_case: {'strings': [3.0]}
    Solution 3:
      test_case: {'strings': [4.0]}
    Solution 4:
      test_case: {'strings': [5.0]}
    Solution 5:
      test_case: {'strings': [6.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (IsList (tail v))
      false)))

(define-fun-rec AllStr ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (and (is-StrVal (head v)) (AllStr (tail v)))
      false)))

; === Inputs ===
(declare-const strings Value)

; === BASIC STRUCTURE ===
(assert (IsList strings))

; === Contract predicates ===
(define-fun C0 () Bool (IsList strings))
(define-fun C1 () Bool (AllStr strings))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (IsList (tail v))
      false)))

(define-fun-rec AllStr ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (and (is-StrVal (head v)) (AllStr (tail v)))
      false)))

; === Inputs ===
(declare-const strings Value)

; === BASIC STRUCTURE ===
(assert (IsList strings))

; === Contract predicates ===
(define-fun C0 () Bool (IsList strings))
(define-fun C1 () Bool (AllStr strings))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'strings': []}
    Solution 2:
      test_case: {'strings': ['!0!']}
    Solution 3:
      test_case: {'strings': ['!']}
    Solution 4:
      test_case: {'strings': ['0']}
    Solution 5:
      test_case: {'strings': ['0!']}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (IsList (tail v))
      false)))

(define-fun-rec AllStr ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (and (is-StrVal (head v)) (AllStr (tail v)))
      false)))

; === Inputs ===
(declare-const strings Value)

; === BASIC STRUCTURE ===
(assert (IsList strings))

; === Contract predicates ===
(define-fun C0 () Bool (IsList strings))
(define-fun C1 () Bool (AllStr strings))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/13 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'b': 3.0, 'a': 2.0}
    Solution 2:
      test_case: {'b': 5.0, 'a': 4.0}
    Solution 3:
      test_case: {'b': 7.0, 'a': 6.0}
    Solution 4:
      test_case: {'b': 9.0, 'a': 8.0}
    Solution 5:
      test_case: {'b': 10.0, 'a': 11.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun IsInt ((v Value)) Bool (is-IntVal v))
(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))
(define-fun-rec query_gcd ((x Int) (y Int)) Int
  (ite (= y 0)
       x
       (query_gcd y (mod x y))))

; === Inputs ===
(declare-const a Value)
(declare-const b Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (is-IntVal a) (is-IntVal b)))
(define-fun C1 () Bool (and (> (SafeI a) 0) (> (SafeI b) 0)))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'b': 21238, 'a': 0}
    Solution 2:
      test_case: {'b': 2437, 'a': -21238}
    Solution 3:
      test_case: {'b': 10802, 'a': -21238}
    Solution 4:
      test_case: {'b': 41414, 'a': -21238}
    Solution 5:
      test_case: {'b': 42556, 'a': -21238}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun IsInt ((v Value)) Bool (is-IntVal v))
(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))
(define-fun-rec query_gcd ((x Int) (y Int)) Int
  (ite (= y 0)
       x
       (query_gcd y (mod x y))))

; === Inputs ===
(declare-const a Value)
(declare-const b Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (is-IntVal a) (is-IntVal b)))
(define-fun C1 () Bool (and (> (SafeI a) 0) (> (SafeI b) 0)))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun IsInt ((v Value)) Bool (is-IntVal v))
(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))
(define-fun-rec query_gcd ((x Int) (y Int)) Int
  (ite (= y 0)
       x
       (query_gcd y (mod x y))))

; === Inputs ===
(declare-const a Value)
(declare-const b Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (is-IntVal a) (is-IntVal b)))
(define-fun C1 () Bool (and (> (SafeI a) 0) (> (SafeI b) 0)))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'b': 7720, 'a': 1}
    Solution 2:
      test_case: {'b': 7721, 'a': 1}
    Solution 3:
      test_case: {'b': 7719, 'a': 1}
    Solution 4:
      test_case: {'b': 2732, 'a': 1}
    Solution 5:
      test_case: {'b': 1143, 'a': 28101}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun IsInt ((v Value)) Bool (is-IntVal v))
(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))
(define-fun-rec query_gcd ((x Int) (y Int)) Int
  (ite (= y 0)
       x
       (query_gcd y (mod x y))))

; === Inputs ===
(declare-const a Value)
(declare-const b Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (is-IntVal a) (is-IntVal b)))
(define-fun C1 () Bool (and (> (SafeI a) 0) (> (SafeI b) 0)))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/14 ===
  Test Case 1: satisfied_, violated_assert_0
  Combination: {'assert_0': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0'], 'total_contracts': 1}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const string Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal string))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal string))

; === COMBINATION ===
(assert (not C0))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_
  Combination: {'assert_0': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': [], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'string': '!0!'}
    Solution 2:
      test_case: {'string': '!'}
    Solution 3:
      test_case: {'string': '0'}
    Solution 4:
      test_case: {'string': '0!'}
    Solution 5:
      test_case: {'string': ''}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const string Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal string))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal string))

; === COMBINATION ===
(assert C0)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/15 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))
(define-fun C1 () Bool (implies (is-IntVal n) (>= (ival n) 0)))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'n': -1}
    Solution 2:
      test_case: {'n': -7720}
    Solution 3:
      test_case: {'n': -10157}
    Solution 4:
      test_case: {'n': -21954}
    Solution 5:
      test_case: {'n': -54239}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))
(define-fun C1 () Bool (implies (is-IntVal n) (>= (ival n) 0)))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'n': 2.0}
    Solution 2:
      test_case: {'n': 3.0}
    Solution 3:
      test_case: {'n': 4.0}
    Solution 4:
      test_case: {'n': 5.0}
    Solution 5:
      test_case: {'n': 6.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))
(define-fun C1 () Bool (implies (is-IntVal n) (>= (ival n) 0)))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'n': 0}
    Solution 2:
      test_case: {'n': 7719}
    Solution 3:
      test_case: {'n': 10156}
    Solution 4:
      test_case: {'n': 21953}
    Solution 5:
      test_case: {'n': 54238}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))
(define-fun C1 () Bool (implies (is-IntVal n) (>= (ival n) 0)))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/16 ===
  Test Case 1: satisfied_, violated_assert_0
  Combination: {'assert_0': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0'], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'string': 2.0}
    Solution 2:
      test_case: {'string': 3.0}
    Solution 3:
      test_case: {'string': 4.0}
    Solution 4:
      test_case: {'string': 5.0}
    Solution 5:
      test_case: {'string': 6.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const string Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal string))

; === COMBINATION ===
(assert (not C0))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_
  Combination: {'assert_0': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': [], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'string': '!0!'}
    Solution 2:
      test_case: {'string': '!'}
    Solution 3:
      test_case: {'string': '0'}
    Solution 4:
      test_case: {'string': '0!'}
    Solution 5:
      test_case: {'string': ''}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const string Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal string))

; === COMBINATION ===
(assert C0)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/17 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeS ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

; === Inputs ===
(declare-const music_string Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal music_string))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal music_string))
(define-fun C1 () Bool (or (= (SafeS music_string) "") (str.in.re (SafeS music_string) (re.union (str.to.re "") (re.++ (re.union (str.to.re "o") (str.to.re "o|") (str.to.re ".|")) (re.* (re.++ (str.to.re " ") (re.union (str.to.re "o") (str.to.re "o|") (str.to.re ".|")))))))))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'music_string': 'A'}
    Solution 2:
      test_case: {'music_string': 'B'}
    Solution 3:
      test_case: {'music_string': 'C'}
    Solution 4:
      test_case: {'music_string': 'D'}
    Solution 5:
      test_case: {'music_string': 'E'}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeS ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

; === Inputs ===
(declare-const music_string Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal music_string))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal music_string))
(define-fun C1 () Bool (or (= (SafeS music_string) "") (str.in.re (SafeS music_string) (re.union (str.to.re "") (re.++ (re.union (str.to.re "o") (str.to.re "o|") (str.to.re ".|")) (re.* (re.++ (str.to.re " ") (re.union (str.to.re "o") (str.to.re "o|") (str.to.re ".|")))))))))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeS ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

; === Inputs ===
(declare-const music_string Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal music_string))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal music_string))
(define-fun C1 () Bool (or (= (SafeS music_string) "") (str.in.re (SafeS music_string) (re.union (str.to.re "") (re.++ (re.union (str.to.re "o") (str.to.re "o|") (str.to.re ".|")) (re.* (re.++ (str.to.re " ") (re.union (str.to.re "o") (str.to.re "o|") (str.to.re ".|")))))))))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'music_string': ''}
    Solution 2:
      test_case: {'music_string': 'o'}
    Solution 3:
      test_case: {'music_string': '.|'}
    Solution 4:
      test_case: {'music_string': 'o|'}
    Solution 5:
      test_case: {'music_string': 'o o'}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeS ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

; === Inputs ===
(declare-const music_string Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal music_string))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal music_string))
(define-fun C1 () Bool (or (= (SafeS music_string) "") (str.in.re (SafeS music_string) (re.union (str.to.re "") (re.++ (re.union (str.to.re "o") (str.to.re "o|") (str.to.re ".|")) (re.* (re.++ (str.to.re " ") (re.union (str.to.re "o") (str.to.re "o|") (str.to.re ".|")))))))))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/18 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const string Value)
(declare-const substring Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal string))
(assert (is-StrVal substring))

; === Contract predicates ===
(define-fun C0 () Bool (and (is-StrVal string) (is-StrVal substring)))
(define-fun C1 () Bool (ite (is-StrVal substring) (not (= (sval substring) "")) true))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'substring': '', 'string': ''}
    Solution 2:
      test_case: {'substring': '', 'string': 'A'}
    Solution 3:
      test_case: {'substring': '', 'string': 'B'}
    Solution 4:
      test_case: {'substring': '', 'string': 'C'}
    Solution 5:
      test_case: {'substring': '', 'string': 'D'}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const string Value)
(declare-const substring Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal string))
(assert (is-StrVal substring))

; === Contract predicates ===
(define-fun C0 () Bool (and (is-StrVal string) (is-StrVal substring)))
(define-fun C1 () Bool (ite (is-StrVal substring) (not (= (sval substring) "")) true))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const string Value)
(declare-const substring Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal string))
(assert (is-StrVal substring))

; === Contract predicates ===
(define-fun C0 () Bool (and (is-StrVal string) (is-StrVal substring)))
(define-fun C1 () Bool (ite (is-StrVal substring) (not (= (sval substring) "")) true))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'substring': 'A', 'string': ''}
    Solution 2:
      test_case: {'substring': 'B', 'string': 'A'}
    Solution 3:
      test_case: {'substring': 'C', 'string': 'B'}
    Solution 4:
      test_case: {'substring': 'D', 'string': 'C'}
    Solution 5:
      test_case: {'substring': 'E', 'string': 'D'}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const string Value)
(declare-const substring Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal string))
(assert (is-StrVal substring))

; === Contract predicates ===
(define-fun C0 () Bool (and (is-StrVal string) (is-StrVal substring)))
(define-fun C1 () Bool (ite (is-StrVal substring) (not (= (sval substring) "")) true))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/19 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeStr ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

; === Inputs ===
(declare-const numbers Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool
  (is-StrVal numbers))
(define-fun C1 () Bool
  (let ((s (SafeStr numbers))
        (pattern
          (let ((digit (re.union (str.to.re "zero") (str.to.re "one") (str.to.re "two") (str.to.re "three") (str.to.re "four") (str.to.re "five") (str.to.re "six") (str.to.re "seven") (str.to.re "eight") (str.to.re "nine")))
                (sep (str.to.re " ")))
            (re.++ digit (re.* (re.++ sep digit))))))
    (or (= s "") (str.in.re s pattern))))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'numbers': 'e'}
    Solution 2:
      test_case: {'numbers': 'f'}
    Solution 3:
      test_case: {'numbers': 'o'}
    Solution 4:
      test_case: {'numbers': 't'}
    Solution 5:
      test_case: {'numbers': 'n'}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeStr ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

; === Inputs ===
(declare-const numbers Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool
  (is-StrVal numbers))
(define-fun C1 () Bool
  (let ((s (SafeStr numbers))
        (pattern
          (let ((digit (re.union (str.to.re "zero") (str.to.re "one") (str.to.re "two") (str.to.re "three") (str.to.re "four") (str.to.re "five") (str.to.re "six") (str.to.re "seven") (str.to.re "eight") (str.to.re "nine")))
                (sep (str.to.re " ")))
            (re.++ digit (re.* (re.++ sep digit))))))
    (or (= s "") (str.in.re s pattern))))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'numbers': 2.0}
    Solution 2:
      test_case: {'numbers': 3.0}
    Solution 3:
      test_case: {'numbers': 4.0}
    Solution 4:
      test_case: {'numbers': 5.0}
    Solution 5:
      test_case: {'numbers': 6.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeStr ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

; === Inputs ===
(declare-const numbers Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool
  (is-StrVal numbers))
(define-fun C1 () Bool
  (let ((s (SafeStr numbers))
        (pattern
          (let ((digit (re.union (str.to.re "zero") (str.to.re "one") (str.to.re "two") (str.to.re "three") (str.to.re "four") (str.to.re "five") (str.to.re "six") (str.to.re "seven") (str.to.re "eight") (str.to.re "nine")))
                (sep (str.to.re " ")))
            (re.++ digit (re.* (re.++ sep digit))))))
    (or (= s "") (str.in.re s pattern))))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'numbers': ''}
    Solution 2:
      test_case: {'numbers': 'one'}
    Solution 3:
      test_case: {'numbers': 'two'}
    Solution 4:
      test_case: {'numbers': 'six'}
    Solution 5:
      test_case: {'numbers': 'four'}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeStr ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

; === Inputs ===
(declare-const numbers Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool
  (is-StrVal numbers))
(define-fun C1 () Bool
  (let ((s (SafeStr numbers))
        (pattern
          (let ((digit (re.union (str.to.re "zero") (str.to.re "one") (str.to.re "two") (str.to.re "three") (str.to.re "four") (str.to.re "five") (str.to.re "six") (str.to.re "seven") (str.to.re "eight") (str.to.re "nine")))
                (sep (str.to.re " ")))
            (re.++ digit (re.* (re.++ sep digit))))))
    (or (= s "") (str.in.re s pattern))))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/20 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'numbers': ['!0!']}
    Solution 2:
      test_case: {'numbers': ['!']}
    Solution 3:
      test_case: {'numbers': ['0']}
    Solution 4:
      test_case: {'numbers': ['0!']}
    Solution 5:
      test_case: {'numbers': ['']}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (IsList (tail v)))))
(define-fun-rec list_all_numeric ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (let ((head (head v)) (tailv (tail v)))
             (and (or (is-IntVal head) (is-FloatVal head))
                  (list_all_numeric tailv))))))
(define-fun-rec list_length ((v Value)) Int
  (ite (is-Cons v)
       (+ 1 (list_length (tail v)))
       0))

; === Inputs ===
(declare-const numbers Value)

; === BASIC STRUCTURE ===
(assert (IsList numbers))

; === Contract predicates ===
(define-fun C0 () Bool
  (list_all_numeric numbers))
(define-fun C1 () Bool
  (>= (list_length numbers) 2))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'numbers': []}
    Solution 2:
      test_case: {'numbers': [2.0]}
    Solution 3:
      test_case: {'numbers': [3.0]}
    Solution 4:
      test_case: {'numbers': [4.0]}
    Solution 5:
      test_case: {'numbers': [5.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (IsList (tail v)))))
(define-fun-rec list_all_numeric ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (let ((head (head v)) (tailv (tail v)))
             (and (or (is-IntVal head) (is-FloatVal head))
                  (list_all_numeric tailv))))))
(define-fun-rec list_length ((v Value)) Int
  (ite (is-Cons v)
       (+ 1 (list_length (tail v)))
       0))

; === Inputs ===
(declare-const numbers Value)

; === BASIC STRUCTURE ===
(assert (IsList numbers))

; === Contract predicates ===
(define-fun C0 () Bool
  (list_all_numeric numbers))
(define-fun C1 () Bool
  (>= (list_length numbers) 2))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'numbers': ['!0!', '!0!', 2.0]}
    Solution 2:
      test_case: {'numbers': ['0', '!', 3.0]}
    Solution 3:
      test_case: {'numbers': ['!0!', '0!', 4.0]}
    Solution 4:
      test_case: {'numbers': ['!0!', 6.0, 5.0]}
    Solution 5:
      test_case: {'numbers': ['!0!', 8.0, 7.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (IsList (tail v)))))
(define-fun-rec list_all_numeric ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (let ((head (head v)) (tailv (tail v)))
             (and (or (is-IntVal head) (is-FloatVal head))
                  (list_all_numeric tailv))))))
(define-fun-rec list_length ((v Value)) Int
  (ite (is-Cons v)
       (+ 1 (list_length (tail v)))
       0))

; === Inputs ===
(declare-const numbers Value)

; === BASIC STRUCTURE ===
(assert (IsList numbers))

; === Contract predicates ===
(define-fun C0 () Bool
  (list_all_numeric numbers))
(define-fun C1 () Bool
  (>= (list_length numbers) 2))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'numbers': [8, 2.0, 9]}
    Solution 2:
      test_case: {'numbers': [10, 11, 3.0]}
    Solution 3:
      test_case: {'numbers': [12, 4.0, 13]}
    Solution 4:
      test_case: {'numbers': [14, 5.0, 15]}
    Solution 5:
      test_case: {'numbers': [16, 17, 6.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (IsList (tail v)))))
(define-fun-rec list_all_numeric ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (let ((head (head v)) (tailv (tail v)))
             (and (or (is-IntVal head) (is-FloatVal head))
                  (list_all_numeric tailv))))))
(define-fun-rec list_length ((v Value)) Int
  (ite (is-Cons v)
       (+ 1 (list_length (tail v)))
       0))

; === Inputs ===
(declare-const numbers Value)

; === BASIC STRUCTURE ===
(assert (IsList numbers))

; === Contract predicates ===
(define-fun C0 () Bool
  (list_all_numeric numbers))
(define-fun C1 () Bool
  (>= (list_length numbers) 2))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/21 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1;assert_2
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2'], 'total_contracts': 3}
  Solutions:
    Solution 1:
      test_case: {'numbers': ['!0!']}
    Solution 2:
      test_case: {'numbers': ['!']}
    Solution 3:
      test_case: {'numbers': ['0']}
    Solution 4:
      test_case: {'numbers': ['0!']}
    Solution 5:
      test_case: {'numbers': ['A']}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (or (is-Nil l) (and (is-Cons l) (IsList (tail l)))))

(define-fun-rec list_all_numeric ((l Value)) Bool
  (or (is-Nil l) (and (is-Cons l) (or (is-IntVal (head l)) (is-FloatVal (head l))) (list_all_numeric (tail l)))))

(define-fun safe_num ((v Value)) Real
  (ite (is-IntVal v) (to_real (ival v)) (ite (is-FloatVal v) (fval v) 0.0)))

(define-fun LenGE2 ((l Value)) Bool
  (and (is-Cons l) (is-Cons (tail l))))

(define-fun-rec exists_gt_tail ((x Value) (l Value)) Bool
  (ite (is-Cons l) (or (> (safe_num x) (safe_num (head l))) (exists_gt_tail x (tail l))) false))

(define-fun-rec exists_pair_gt ((l Value)) Bool
  (ite (is-Cons l) (or (exists_gt_tail (head l) (tail l)) (exists_pair_gt (tail l))) false))

; === Inputs ===
(declare-const numbers Value)

; === BASIC STRUCTURE ===
(assert (IsList numbers))

; === Contract predicates ===
(define-fun C0 () Bool (list_all_numeric numbers))
(define-fun C1 () Bool (LenGE2 numbers))
(define-fun C2 () Bool (and (LenGE2 numbers) (exists_pair_gt numbers)))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1;assert_2
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1', 'assert_2'], 'total_contracts': 3}
  Solutions:
    Solution 1:
      test_case: {'numbers': []}
    Solution 2:
      test_case: {'numbers': [2.0]}
    Solution 3:
      test_case: {'numbers': [3.0]}
    Solution 4:
      test_case: {'numbers': [4.0]}
    Solution 5:
      test_case: {'numbers': [5.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (or (is-Nil l) (and (is-Cons l) (IsList (tail l)))))

(define-fun-rec list_all_numeric ((l Value)) Bool
  (or (is-Nil l) (and (is-Cons l) (or (is-IntVal (head l)) (is-FloatVal (head l))) (list_all_numeric (tail l)))))

(define-fun safe_num ((v Value)) Real
  (ite (is-IntVal v) (to_real (ival v)) (ite (is-FloatVal v) (fval v) 0.0)))

(define-fun LenGE2 ((l Value)) Bool
  (and (is-Cons l) (is-Cons (tail l))))

(define-fun-rec exists_gt_tail ((x Value) (l Value)) Bool
  (ite (is-Cons l) (or (> (safe_num x) (safe_num (head l))) (exists_gt_tail x (tail l))) false))

(define-fun-rec exists_pair_gt ((l Value)) Bool
  (ite (is-Cons l) (or (exists_gt_tail (head l) (tail l)) (exists_pair_gt (tail l))) false))

; === Inputs ===
(declare-const numbers Value)

; === BASIC STRUCTURE ===
(assert (IsList numbers))

; === Contract predicates ===
(define-fun C0 () Bool (list_all_numeric numbers))
(define-fun C1 () Bool (LenGE2 numbers))
(define-fun C2 () Bool (and (LenGE2 numbers) (exists_pair_gt numbers)))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0;assert_2
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0', 'assert_2'], 'total_contracts': 3}
  Solutions:
    Solution 1:
      test_case: {'numbers': [0, '!0!']}
    Solution 2:
      test_case: {'numbers': [0, '!']}
    Solution 3:
      test_case: {'numbers': [-30612, '0']}
    Solution 4:
      test_case: {'numbers': [-30893, '0!']}
    Solution 5:
      test_case: {'numbers': [-30893, '!0!']}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (or (is-Nil l) (and (is-Cons l) (IsList (tail l)))))

(define-fun-rec list_all_numeric ((l Value)) Bool
  (or (is-Nil l) (and (is-Cons l) (or (is-IntVal (head l)) (is-FloatVal (head l))) (list_all_numeric (tail l)))))

(define-fun safe_num ((v Value)) Real
  (ite (is-IntVal v) (to_real (ival v)) (ite (is-FloatVal v) (fval v) 0.0)))

(define-fun LenGE2 ((l Value)) Bool
  (and (is-Cons l) (is-Cons (tail l))))

(define-fun-rec exists_gt_tail ((x Value) (l Value)) Bool
  (ite (is-Cons l) (or (> (safe_num x) (safe_num (head l))) (exists_gt_tail x (tail l))) false))

(define-fun-rec exists_pair_gt ((l Value)) Bool
  (ite (is-Cons l) (or (exists_gt_tail (head l) (tail l)) (exists_pair_gt (tail l))) false))

; === Inputs ===
(declare-const numbers Value)

; === BASIC STRUCTURE ===
(assert (IsList numbers))

; === Contract predicates ===
(define-fun C0 () Bool (list_all_numeric numbers))
(define-fun C1 () Bool (LenGE2 numbers))
(define-fun C2 () Bool (and (LenGE2 numbers) (exists_pair_gt numbers)))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_assert_2
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': ['assert_2'], 'total_contracts': 3}
  Solutions:
    Solution 1:
      test_case: {'numbers': [0.5, 1]}
    Solution 2:
      test_case: {'numbers': [0, 0]}
    Solution 3:
      test_case: {'numbers': [0.0, 0]}
    Solution 4:
      test_case: {'numbers': [-15921.0, 0]}
    Solution 5:
      test_case: {'numbers': [-47812.0, 0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (or (is-Nil l) (and (is-Cons l) (IsList (tail l)))))

(define-fun-rec list_all_numeric ((l Value)) Bool
  (or (is-Nil l) (and (is-Cons l) (or (is-IntVal (head l)) (is-FloatVal (head l))) (list_all_numeric (tail l)))))

(define-fun safe_num ((v Value)) Real
  (ite (is-IntVal v) (to_real (ival v)) (ite (is-FloatVal v) (fval v) 0.0)))

(define-fun LenGE2 ((l Value)) Bool
  (and (is-Cons l) (is-Cons (tail l))))

(define-fun-rec exists_gt_tail ((x Value) (l Value)) Bool
  (ite (is-Cons l) (or (> (safe_num x) (safe_num (head l))) (exists_gt_tail x (tail l))) false))

(define-fun-rec exists_pair_gt ((l Value)) Bool
  (ite (is-Cons l) (or (exists_gt_tail (head l) (tail l)) (exists_pair_gt (tail l))) false))

; === Inputs ===
(declare-const numbers Value)

; === BASIC STRUCTURE ===
(assert (IsList numbers))

; === Contract predicates ===
(define-fun C0 () Bool (list_all_numeric numbers))
(define-fun C1 () Bool (LenGE2 numbers))
(define-fun C2 () Bool (and (LenGE2 numbers) (exists_pair_gt numbers)))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))

(check-sat)
(get-model)

------------------------------
  Test Case 5: satisfied_assert_2, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_2'], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 3}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (or (is-Nil l) (and (is-Cons l) (IsList (tail l)))))

(define-fun-rec list_all_numeric ((l Value)) Bool
  (or (is-Nil l) (and (is-Cons l) (or (is-IntVal (head l)) (is-FloatVal (head l))) (list_all_numeric (tail l)))))

(define-fun safe_num ((v Value)) Real
  (ite (is-IntVal v) (to_real (ival v)) (ite (is-FloatVal v) (fval v) 0.0)))

(define-fun LenGE2 ((l Value)) Bool
  (and (is-Cons l) (is-Cons (tail l))))

(define-fun-rec exists_gt_tail ((x Value) (l Value)) Bool
  (ite (is-Cons l) (or (> (safe_num x) (safe_num (head l))) (exists_gt_tail x (tail l))) false))

(define-fun-rec exists_pair_gt ((l Value)) Bool
  (ite (is-Cons l) (or (exists_gt_tail (head l) (tail l)) (exists_pair_gt (tail l))) false))

; === Inputs ===
(declare-const numbers Value)

; === BASIC STRUCTURE ===
(assert (IsList numbers))

; === Contract predicates ===
(define-fun C0 () Bool (list_all_numeric numbers))
(define-fun C1 () Bool (LenGE2 numbers))
(define-fun C2 () Bool (and (LenGE2 numbers) (exists_pair_gt numbers)))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)

(check-sat)
(get-model)

------------------------------
  Test Case 6: satisfied_assert_0;assert_2, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2'], 'violated_contracts': ['assert_1'], 'total_contracts': 3}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (or (is-Nil l) (and (is-Cons l) (IsList (tail l)))))

(define-fun-rec list_all_numeric ((l Value)) Bool
  (or (is-Nil l) (and (is-Cons l) (or (is-IntVal (head l)) (is-FloatVal (head l))) (list_all_numeric (tail l)))))

(define-fun safe_num ((v Value)) Real
  (ite (is-IntVal v) (to_real (ival v)) (ite (is-FloatVal v) (fval v) 0.0)))

(define-fun LenGE2 ((l Value)) Bool
  (and (is-Cons l) (is-Cons (tail l))))

(define-fun-rec exists_gt_tail ((x Value) (l Value)) Bool
  (ite (is-Cons l) (or (> (safe_num x) (safe_num (head l))) (exists_gt_tail x (tail l))) false))

(define-fun-rec exists_pair_gt ((l Value)) Bool
  (ite (is-Cons l) (or (exists_gt_tail (head l) (tail l)) (exists_pair_gt (tail l))) false))

; === Inputs ===
(declare-const numbers Value)

; === BASIC STRUCTURE ===
(assert (IsList numbers))

; === Contract predicates ===
(define-fun C0 () Bool (list_all_numeric numbers))
(define-fun C1 () Bool (LenGE2 numbers))
(define-fun C2 () Bool (and (LenGE2 numbers) (exists_pair_gt numbers)))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)

(check-sat)
(get-model)

------------------------------
  Test Case 7: satisfied_assert_1;assert_2, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2'], 'violated_contracts': ['assert_0'], 'total_contracts': 3}
  Solutions:
    Solution 1:
      test_case: {'numbers': [1, '!0!']}
    Solution 2:
      test_case: {'numbers': ['!', -1]}
    Solution 3:
      test_case: {'numbers': ['0', -1]}
    Solution 4:
      test_case: {'numbers': ['0!', -20977]}
    Solution 5:
      test_case: {'numbers': ['!0!', -20977]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (or (is-Nil l) (and (is-Cons l) (IsList (tail l)))))

(define-fun-rec list_all_numeric ((l Value)) Bool
  (or (is-Nil l) (and (is-Cons l) (or (is-IntVal (head l)) (is-FloatVal (head l))) (list_all_numeric (tail l)))))

(define-fun safe_num ((v Value)) Real
  (ite (is-IntVal v) (to_real (ival v)) (ite (is-FloatVal v) (fval v) 0.0)))

(define-fun LenGE2 ((l Value)) Bool
  (and (is-Cons l) (is-Cons (tail l))))

(define-fun-rec exists_gt_tail ((x Value) (l Value)) Bool
  (ite (is-Cons l) (or (> (safe_num x) (safe_num (head l))) (exists_gt_tail x (tail l))) false))

(define-fun-rec exists_pair_gt ((l Value)) Bool
  (ite (is-Cons l) (or (exists_gt_tail (head l) (tail l)) (exists_pair_gt (tail l))) false))

; === Inputs ===
(declare-const numbers Value)

; === BASIC STRUCTURE ===
(assert (IsList numbers))

; === Contract predicates ===
(define-fun C0 () Bool (list_all_numeric numbers))
(define-fun C1 () Bool (LenGE2 numbers))
(define-fun C2 () Bool (and (LenGE2 numbers) (exists_pair_gt numbers)))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)

(check-sat)
(get-model)

------------------------------
  Test Case 8: satisfied_assert_0;assert_1;assert_2, violated_
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2'], 'violated_contracts': [], 'total_contracts': 3}
  Solutions:
    Solution 1:
      test_case: {'numbers': [-1, -2]}
    Solution 2:
      test_case: {'numbers': [-0.25, -0.5]}
    Solution 3:
      test_case: {'numbers': [-0.0625, -0.125]}
    Solution 4:
      test_case: {'numbers': [0.5, 0.25]}
    Solution 5:
      test_case: {'numbers': [0.125, 0.0625]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (or (is-Nil l) (and (is-Cons l) (IsList (tail l)))))

(define-fun-rec list_all_numeric ((l Value)) Bool
  (or (is-Nil l) (and (is-Cons l) (or (is-IntVal (head l)) (is-FloatVal (head l))) (list_all_numeric (tail l)))))

(define-fun safe_num ((v Value)) Real
  (ite (is-IntVal v) (to_real (ival v)) (ite (is-FloatVal v) (fval v) 0.0)))

(define-fun LenGE2 ((l Value)) Bool
  (and (is-Cons l) (is-Cons (tail l))))

(define-fun-rec exists_gt_tail ((x Value) (l Value)) Bool
  (ite (is-Cons l) (or (> (safe_num x) (safe_num (head l))) (exists_gt_tail x (tail l))) false))

(define-fun-rec exists_pair_gt ((l Value)) Bool
  (ite (is-Cons l) (or (exists_gt_tail (head l) (tail l)) (exists_pair_gt (tail l))) false))

; === Inputs ===
(declare-const numbers Value)

; === BASIC STRUCTURE ===
(assert (IsList numbers))

; === Contract predicates ===
(define-fun C0 () Bool (list_all_numeric numbers))
(define-fun C1 () Bool (LenGE2 numbers))
(define-fun C2 () Bool (and (LenGE2 numbers) (exists_pair_gt numbers)))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/22 ===
  Test Case 1: satisfied_, violated_assert_0
  Combination: {'assert_0': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0'], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'values': 2.0}
    Solution 2:
      test_case: {'values': 3.0}
    Solution 3:
      test_case: {'values': 4.0}
    Solution 4:
      test_case: {'values': 5.0}
    Solution 5:
      test_case: {'values': 6.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

; === Inputs ===
(declare-const values Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (IsList values))

; === COMBINATION ===
(assert (not C0))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_
  Combination: {'assert_0': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': [], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'values': []}
    Solution 2:
      test_case: {'values': [2.0]}
    Solution 3:
      test_case: {'values': [3.0]}
    Solution 4:
      test_case: {'values': [4.0]}
    Solution 5:
      test_case: {'values': [5.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

; === Inputs ===
(declare-const values Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (IsList values))

; === COMBINATION ===
(assert C0)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/23 ===
  Test Case 1: satisfied_, violated_assert_0
  Combination: {'assert_0': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0'], 'total_contracts': 1}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const string Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal string))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal string))

; === COMBINATION ===
(assert (not C0))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_
  Combination: {'assert_0': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': [], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'string': '!0!'}
    Solution 2:
      test_case: {'string': '!'}
    Solution 3:
      test_case: {'string': '0'}
    Solution 4:
      test_case: {'string': '0!'}
    Solution 5:
      test_case: {'string': ''}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const string Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal string))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal string))

; === COMBINATION ===
(assert C0)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/24 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun safe-int ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===
(assert (is-IntVal n))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))
(define-fun C1 () Bool (> (safe-int n) 1))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'n': 0}
    Solution 2:
      test_case: {'n': -7719}
    Solution 3:
      test_case: {'n': -10156}
    Solution 4:
      test_case: {'n': -21953}
    Solution 5:
      test_case: {'n': -54238}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun safe-int ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===
(assert (is-IntVal n))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))
(define-fun C1 () Bool (> (safe-int n) 1))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun safe-int ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===
(assert (is-IntVal n))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))
(define-fun C1 () Bool (> (safe-int n) 1))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'n': 2}
    Solution 2:
      test_case: {'n': 7721}
    Solution 3:
      test_case: {'n': 10158}
    Solution 4:
      test_case: {'n': 21955}
    Solution 5:
      test_case: {'n': 54240}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun safe-int ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===
(assert (is-IntVal n))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))
(define-fun C1 () Bool (> (safe-int n) 1))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/25 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'n': 2.0}
    Solution 2:
      test_case: {'n': 3.0}
    Solution 3:
      test_case: {'n': 4.0}
    Solution 4:
      test_case: {'n': 5.0}
    Solution 5:
      test_case: {'n': 6.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))
(define-fun C1 () Bool (and (is-IntVal n) (>= (SafeI n) 2)))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'n': 0}
    Solution 2:
      test_case: {'n': -7719}
    Solution 3:
      test_case: {'n': -10156}
    Solution 4:
      test_case: {'n': -21953}
    Solution 5:
      test_case: {'n': -54238}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))
(define-fun C1 () Bool (and (is-IntVal n) (>= (SafeI n) 2)))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))
(define-fun C1 () Bool (and (is-IntVal n) (>= (SafeI n) 2)))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'n': 2}
    Solution 2:
      test_case: {'n': 7721}
    Solution 3:
      test_case: {'n': 10158}
    Solution 4:
      test_case: {'n': 21955}
    Solution 5:
      test_case: {'n': 54240}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))
(define-fun C1 () Bool (and (is-IntVal n) (>= (SafeI n) 2)))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/26 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_ints ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (is-IntVal (head v))
                 (list_all_ints (tail v)))
            false)))

; === Inputs ===
(declare-const numbers Value)

; === BASIC STRUCTURE ===
(assert (IsList numbers))

; === Contract predicates ===
(define-fun C0 () Bool (IsList numbers))
(define-fun C1 () Bool (list_all_ints numbers))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'numbers': [2.0]}
    Solution 2:
      test_case: {'numbers': [3.0]}
    Solution 3:
      test_case: {'numbers': [4.0]}
    Solution 4:
      test_case: {'numbers': [5.0]}
    Solution 5:
      test_case: {'numbers': [6.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_ints ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (is-IntVal (head v))
                 (list_all_ints (tail v)))
            false)))

; === Inputs ===
(declare-const numbers Value)

; === BASIC STRUCTURE ===
(assert (IsList numbers))

; === Contract predicates ===
(define-fun C0 () Bool (IsList numbers))
(define-fun C1 () Bool (list_all_ints numbers))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_ints ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (is-IntVal (head v))
                 (list_all_ints (tail v)))
            false)))

; === Inputs ===
(declare-const numbers Value)

; === BASIC STRUCTURE ===
(assert (IsList numbers))

; === Contract predicates ===
(define-fun C0 () Bool (IsList numbers))
(define-fun C1 () Bool (list_all_ints numbers))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'numbers': []}
    Solution 2:
      test_case: {'numbers': [2]}
    Solution 3:
      test_case: {'numbers': [3]}
    Solution 4:
      test_case: {'numbers': [4]}
    Solution 5:
      test_case: {'numbers': [5]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_ints ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (is-IntVal (head v))
                 (list_all_ints (tail v)))
            false)))

; === Inputs ===
(declare-const numbers Value)

; === BASIC STRUCTURE ===
(assert (IsList numbers))

; === Contract predicates ===
(define-fun C0 () Bool (IsList numbers))
(define-fun C1 () Bool (list_all_ints numbers))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/27 ===
  Test Case 1: satisfied_, violated_assert_0
  Combination: {'assert_0': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0'], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'string': 2.0}
    Solution 2:
      test_case: {'string': 3.0}
    Solution 3:
      test_case: {'string': 4.0}
    Solution 4:
      test_case: {'string': 5.0}
    Solution 5:
      test_case: {'string': 6.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeS ((v Value)) String (ite (is-StrVal v) (sval v) ""))

; === Inputs ===
(declare-const string Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal string))

; === COMBINATION ===
(assert (not C0))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_
  Combination: {'assert_0': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': [], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'string': '!0!'}
    Solution 2:
      test_case: {'string': '!'}
    Solution 3:
      test_case: {'string': '0'}
    Solution 4:
      test_case: {'string': '0!'}
    Solution 5:
      test_case: {'string': ''}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeS ((v Value)) String (ite (is-StrVal v) (sval v) ""))

; === Inputs ===
(declare-const string Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal string))

; === COMBINATION ===
(assert C0)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/28 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'strings': 2.0}
    Solution 2:
      test_case: {'strings': 3.0}
    Solution 3:
      test_case: {'strings': 4.0}
    Solution 4:
      test_case: {'strings': 5.0}
    Solution 5:
      test_case: {'strings': 6.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (or
    (is-Nil v)
    (and (is-Cons v) (IsList (tail v)))
  )
)

(define-fun-rec list_all_str ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (is-StrVal (head v)) (list_all_str (tail v)))
            false
       )
  )
)

; === Inputs ===
(declare-const strings Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (list_all_str strings))
(define-fun C1 () Bool (IsList strings))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (or
    (is-Nil v)
    (and (is-Cons v) (IsList (tail v)))
  )
)

(define-fun-rec list_all_str ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (is-StrVal (head v)) (list_all_str (tail v)))
            false
       )
  )
)

; === Inputs ===
(declare-const strings Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (list_all_str strings))
(define-fun C1 () Bool (IsList strings))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'strings': [2.0]}
    Solution 2:
      test_case: {'strings': [3.0]}
    Solution 3:
      test_case: {'strings': [4.0]}
    Solution 4:
      test_case: {'strings': [5.0]}
    Solution 5:
      test_case: {'strings': [6.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (or
    (is-Nil v)
    (and (is-Cons v) (IsList (tail v)))
  )
)

(define-fun-rec list_all_str ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (is-StrVal (head v)) (list_all_str (tail v)))
            false
       )
  )
)

; === Inputs ===
(declare-const strings Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (list_all_str strings))
(define-fun C1 () Bool (IsList strings))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'strings': []}
    Solution 2:
      test_case: {'strings': ['!0!']}
    Solution 3:
      test_case: {'strings': ['!']}
    Solution 4:
      test_case: {'strings': ['0']}
    Solution 5:
      test_case: {'strings': ['0!']}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (or
    (is-Nil v)
    (and (is-Cons v) (IsList (tail v)))
  )
)

(define-fun-rec list_all_str ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (is-StrVal (head v)) (list_all_str (tail v)))
            false
       )
  )
)

; === Inputs ===
(declare-const strings Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (list_all_str strings))
(define-fun C1 () Bool (IsList strings))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/29 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'strings': [3.0], 'prefix': 2.0}
    Solution 2:
      test_case: {'strings': [5.0], 'prefix': 4.0}
    Solution 3:
      test_case: {'strings': [7.0], 'prefix': 6.0}
    Solution 4:
      test_case: {'strings': [8.0], 'prefix': 9.0}
    Solution 5:
      test_case: {'strings': [10.0], 'prefix': 11.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_str ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (is-StrVal (head v))
                 (list_all_str (tail v)))
            false)))

; === Inputs ===
(declare-const strings Value)
(declare-const prefix Value)

; === BASIC STRUCTURE ===
(assert (IsList strings))

; === Contract predicates ===
(define-fun C0 () Bool
  (list_all_str strings))
(define-fun C1 () Bool
  (is-StrVal prefix))
(define-fun COMBINATION () Bool
  (or
    (and C0 C1)
    (and (not C0) C1)
    (and C0 (not C1))
    (and (not C0) (not C1))))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'strings': [], 'prefix': 2.0}
    Solution 2:
      test_case: {'strings': [], 'prefix': 3.0}
    Solution 3:
      test_case: {'strings': [], 'prefix': 4.0}
    Solution 4:
      test_case: {'prefix': 5.0, 'strings': []}
    Solution 5:
      test_case: {'strings': [], 'prefix': 6.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_str ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (is-StrVal (head v))
                 (list_all_str (tail v)))
            false)))

; === Inputs ===
(declare-const strings Value)
(declare-const prefix Value)

; === BASIC STRUCTURE ===
(assert (IsList strings))

; === Contract predicates ===
(define-fun C0 () Bool
  (list_all_str strings))
(define-fun C1 () Bool
  (is-StrVal prefix))
(define-fun COMBINATION () Bool
  (or
    (and C0 C1)
    (and (not C0) C1)
    (and C0 (not C1))
    (and (not C0) (not C1))))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'strings': [2.0], 'prefix': '!0!'}
    Solution 2:
      test_case: {'strings': [3.0], 'prefix': '!'}
    Solution 3:
      test_case: {'strings': [4.0], 'prefix': '0'}
    Solution 4:
      test_case: {'strings': [5.0], 'prefix': '0!'}
    Solution 5:
      test_case: {'strings': [6.0], 'prefix': 'A'}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_str ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (is-StrVal (head v))
                 (list_all_str (tail v)))
            false)))

; === Inputs ===
(declare-const strings Value)
(declare-const prefix Value)

; === BASIC STRUCTURE ===
(assert (IsList strings))

; === Contract predicates ===
(define-fun C0 () Bool
  (list_all_str strings))
(define-fun C1 () Bool
  (is-StrVal prefix))
(define-fun COMBINATION () Bool
  (or
    (and C0 C1)
    (and (not C0) C1)
    (and C0 (not C1))
    (and (not C0) (not C1))))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'strings': [], 'prefix': '!0!'}
    Solution 2:
      test_case: {'strings': [], 'prefix': '!'}
    Solution 3:
      test_case: {'strings': [], 'prefix': '0'}
    Solution 4:
      test_case: {'prefix': '0!', 'strings': []}
    Solution 5:
      test_case: {'strings': [], 'prefix': ''}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_str ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (is-StrVal (head v))
                 (list_all_str (tail v)))
            false)))

; === Inputs ===
(declare-const strings Value)
(declare-const prefix Value)

; === BASIC STRUCTURE ===
(assert (IsList strings))

; === Contract predicates ===
(define-fun C0 () Bool
  (list_all_str strings))
(define-fun C1 () Bool
  (is-StrVal prefix))
(define-fun COMBINATION () Bool
  (or
    (and C0 C1)
    (and (not C0) C1)
    (and C0 (not C1))
    (and (not C0) (not C1))))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/30 ===
  Test Case 1: satisfied_, violated_assert_0
  Combination: {'assert_0': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0'], 'total_contracts': 1}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (IsList (tail v))
         false)))

(define-fun-rec list_all_numeric ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (let ((hd (head v)) (tl (tail v)))
           (and (or (is-IntVal hd) (is-FloatVal hd))
                (list_all_numeric tl)))
         false)))

; === Inputs ===
(declare-const l Value)

; === BASIC STRUCTURE ===
(assert (IsList l))
(assert (list_all_numeric l))

; === Contract predicates ===
(define-fun C0 () Bool (IsList l))

; === COMBINATION ===
(assert (not C0))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_
  Combination: {'assert_0': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': [], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'l': []}
    Solution 2:
      test_case: {'l': [2.0]}
    Solution 3:
      test_case: {'l': [2]}
    Solution 4:
      test_case: {'l': [3]}
    Solution 5:
      test_case: {'l': [3.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (IsList (tail v))
         false)))

(define-fun-rec list_all_numeric ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (let ((hd (head v)) (tl (tail v)))
           (and (or (is-IntVal hd) (is-FloatVal hd))
                (list_all_numeric tl)))
         false)))

; === Inputs ===
(declare-const l Value)

; === BASIC STRUCTURE ===
(assert (IsList l))
(assert (list_all_numeric l))

; === Contract predicates ===
(define-fun C0 () Bool (IsList l))

; === COMBINATION ===
(assert C0)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/31 ===
  Test Case 1: satisfied_, violated_assert_0
  Combination: {'assert_0': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0'], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'n': 2.0}
    Solution 2:
      test_case: {'n': 3.0}
    Solution 3:
      test_case: {'n': 4.0}
    Solution 4:
      test_case: {'n': 5.0}
    Solution 5:
      test_case: {'n': 6.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))

; === COMBINATION ===
(assert (not C0))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_
  Combination: {'assert_0': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': [], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'n': 2}
    Solution 2:
      test_case: {'n': 3}
    Solution 3:
      test_case: {'n': 4}
    Solution 4:
      test_case: {'n': 5}
    Solution 5:
      test_case: {'n': 6}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))

; === COMBINATION ===
(assert C0)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/32 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1;assert_2;assert_3
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False, 'assert_3': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_3'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'xs': [-1, 7.0, 0]}
    Solution 2:
      test_case: {'xs': [-1, 10.0, 0]}
    Solution 3:
      test_case: {'xs': [-1, 12.0, 0]}
    Solution 4:
      test_case: {'xs': [-1, 13.0, 0]}
    Solution 5:
      test_case: {'xs': [-1, 14.0, 0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (isList (tail l))
            false)))
(define-fun-rec length ((l Value)) Int
  (ite (is-Nil l)
       0
       (ite (is-Cons l)
            (+ 1 (length (tail l)))
            0)))
(define-fun-rec lastElem ((l Value)) Value
  (ite (and (is-Cons l) (is-Nil (tail l)))
       (head l)
       (ite (is-Cons l)
            (lastElem (tail l))
            l)))
(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (and (is-Cons l) (is-IntVal (head l)) (list_all_int (tail l)))
            true
            false)))
(define-fun-rec pow ((x Real) (n Int)) Real
  (ite (= n 0)
       1
       (* x (pow x (- n 1)))))
(define-fun-rec poly_help ((l Value) (idx Int) (x Real)) Real
  (ite (is-Nil l)
       0
       (let ((h (head l)) (t (tail l)))
         (ite (is-IntVal h)
              (+ (* (to_real (ival h)) (pow x idx))
                 (poly_help t (+ idx 1) x))
              (poly_help t (+ idx 1) x)))))
(define-fun poly ((l Value) (x Real)) Real
  (poly_help l 0 x))
(define-fun abs ((r Real)) Real
  (ite (< r 0) (- r) r))
(declare-fun find_zero ((Value)) Real)

; === Inputs ===
(declare-const xs Value)


; === BASIC STRUCTURE ===
(assert (isList xs))
(assert (> (length xs) 0))

; === Contract predicates ===
(define-fun C0 () Bool
  (and (isList xs)
       (> (length xs) 0)
       (= (mod (length xs) 2) 0)))
(define-fun C1 () Bool
  (not (= (lastElem xs) (IntVal 0))))
(define-fun C2 () Bool
  (list_all_int xs))
(define-fun C3 () Bool
  (< (abs (poly xs (find_zero xs))) (/ 1 100000)))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1;assert_2;assert_3
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False, 'assert_3': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1', 'assert_2', 'assert_3'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'xs': [11.0, 10.0, 1, 0]}
    Solution 2:
      test_case: {'xs': [12.0, -1, 13.0, 0]}
    Solution 3:
      test_case: {'xs': [14.0, -1, 15.0, 0]}
    Solution 4:
      test_case: {'xs': [16.0, -1, 17.0, 0]}
    Solution 5:
      test_case: {'xs': [18.0, -1, 19.0, 0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (isList (tail l))
            false)))
(define-fun-rec length ((l Value)) Int
  (ite (is-Nil l)
       0
       (ite (is-Cons l)
            (+ 1 (length (tail l)))
            0)))
(define-fun-rec lastElem ((l Value)) Value
  (ite (and (is-Cons l) (is-Nil (tail l)))
       (head l)
       (ite (is-Cons l)
            (lastElem (tail l))
            l)))
(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (and (is-Cons l) (is-IntVal (head l)) (list_all_int (tail l)))
            true
            false)))
(define-fun-rec pow ((x Real) (n Int)) Real
  (ite (= n 0)
       1
       (* x (pow x (- n 1)))))
(define-fun-rec poly_help ((l Value) (idx Int) (x Real)) Real
  (ite (is-Nil l)
       0
       (let ((h (head l)) (t (tail l)))
         (ite (is-IntVal h)
              (+ (* (to_real (ival h)) (pow x idx))
                 (poly_help t (+ idx 1) x))
              (poly_help t (+ idx 1) x)))))
(define-fun poly ((l Value) (x Real)) Real
  (poly_help l 0 x))
(define-fun abs ((r Real)) Real
  (ite (< r 0) (- r) r))
(declare-fun find_zero ((Value)) Real)

; === Inputs ===
(declare-const xs Value)


; === BASIC STRUCTURE ===
(assert (isList xs))
(assert (> (length xs) 0))

; === Contract predicates ===
(define-fun C0 () Bool
  (and (isList xs)
       (> (length xs) 0)
       (= (mod (length xs) 2) 0)))
(define-fun C1 () Bool
  (not (= (lastElem xs) (IntVal 0))))
(define-fun C2 () Bool
  (list_all_int xs))
(define-fun C3 () Bool
  (< (abs (poly xs (find_zero xs))) (/ 1 100000)))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0;assert_2;assert_3
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False, 'assert_3': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0', 'assert_2', 'assert_3'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'xs': [9.0, 2, -1]}
    Solution 2:
      test_case: {'xs': [8.0, 0, -4]}
    Solution 3:
      test_case: {'xs': [10.0, -2, 1]}
    Solution 4:
      test_case: {'xs': [11.0, 1, -200000]}
    Solution 5:
      test_case: {'xs': [12.0, 1, -200000]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (isList (tail l))
            false)))
(define-fun-rec length ((l Value)) Int
  (ite (is-Nil l)
       0
       (ite (is-Cons l)
            (+ 1 (length (tail l)))
            0)))
(define-fun-rec lastElem ((l Value)) Value
  (ite (and (is-Cons l) (is-Nil (tail l)))
       (head l)
       (ite (is-Cons l)
            (lastElem (tail l))
            l)))
(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (and (is-Cons l) (is-IntVal (head l)) (list_all_int (tail l)))
            true
            false)))
(define-fun-rec pow ((x Real) (n Int)) Real
  (ite (= n 0)
       1
       (* x (pow x (- n 1)))))
(define-fun-rec poly_help ((l Value) (idx Int) (x Real)) Real
  (ite (is-Nil l)
       0
       (let ((h (head l)) (t (tail l)))
         (ite (is-IntVal h)
              (+ (* (to_real (ival h)) (pow x idx))
                 (poly_help t (+ idx 1) x))
              (poly_help t (+ idx 1) x)))))
(define-fun poly ((l Value) (x Real)) Real
  (poly_help l 0 x))
(define-fun abs ((r Real)) Real
  (ite (< r 0) (- r) r))
(declare-fun find_zero ((Value)) Real)

; === Inputs ===
(declare-const xs Value)


; === BASIC STRUCTURE ===
(assert (isList xs))
(assert (> (length xs) 0))

; === Contract predicates ===
(define-fun C0 () Bool
  (and (isList xs)
       (> (length xs) 0)
       (= (mod (length xs) 2) 0)))
(define-fun C1 () Bool
  (not (= (lastElem xs) (IntVal 0))))
(define-fun C2 () Bool
  (list_all_int xs))
(define-fun C3 () Bool
  (< (abs (poly xs (find_zero xs))) (/ 1 100000)))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_assert_2;assert_3
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False, 'assert_3': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': ['assert_2', 'assert_3'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'xs': [6.0, -1]}
    Solution 2:
      test_case: {'xs': [1, 7.0]}
    Solution 3:
      test_case: {'xs': [-1, 8.0]}
    Solution 4:
      test_case: {'xs': [-1, 9.0]}
    Solution 5:
      test_case: {'xs': [-1, 10.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (isList (tail l))
            false)))
(define-fun-rec length ((l Value)) Int
  (ite (is-Nil l)
       0
       (ite (is-Cons l)
            (+ 1 (length (tail l)))
            0)))
(define-fun-rec lastElem ((l Value)) Value
  (ite (and (is-Cons l) (is-Nil (tail l)))
       (head l)
       (ite (is-Cons l)
            (lastElem (tail l))
            l)))
(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (and (is-Cons l) (is-IntVal (head l)) (list_all_int (tail l)))
            true
            false)))
(define-fun-rec pow ((x Real) (n Int)) Real
  (ite (= n 0)
       1
       (* x (pow x (- n 1)))))
(define-fun-rec poly_help ((l Value) (idx Int) (x Real)) Real
  (ite (is-Nil l)
       0
       (let ((h (head l)) (t (tail l)))
         (ite (is-IntVal h)
              (+ (* (to_real (ival h)) (pow x idx))
                 (poly_help t (+ idx 1) x))
              (poly_help t (+ idx 1) x)))))
(define-fun poly ((l Value) (x Real)) Real
  (poly_help l 0 x))
(define-fun abs ((r Real)) Real
  (ite (< r 0) (- r) r))
(declare-fun find_zero ((Value)) Real)

; === Inputs ===
(declare-const xs Value)


; === BASIC STRUCTURE ===
(assert (isList xs))
(assert (> (length xs) 0))

; === Contract predicates ===
(define-fun C0 () Bool
  (and (isList xs)
       (> (length xs) 0)
       (= (mod (length xs) 2) 0)))
(define-fun C1 () Bool
  (not (= (lastElem xs) (IntVal 0))))
(define-fun C2 () Bool
  (list_all_int xs))
(define-fun C3 () Bool
  (< (abs (poly xs (find_zero xs))) (/ 1 100000)))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 5: satisfied_assert_2, violated_assert_0;assert_1;assert_3
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True, 'assert_3': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_2'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_3'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'xs': [1, -1, 0]}
    Solution 2:
      test_case: {'xs': [2, 1, 0]}
    Solution 3:
      test_case: {'xs': [3, 2, 0]}
    Solution 4:
      test_case: {'xs': [4, 2, 0]}
    Solution 5:
      test_case: {'xs': [4, 1, 0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (isList (tail l))
            false)))
(define-fun-rec length ((l Value)) Int
  (ite (is-Nil l)
       0
       (ite (is-Cons l)
            (+ 1 (length (tail l)))
            0)))
(define-fun-rec lastElem ((l Value)) Value
  (ite (and (is-Cons l) (is-Nil (tail l)))
       (head l)
       (ite (is-Cons l)
            (lastElem (tail l))
            l)))
(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (and (is-Cons l) (is-IntVal (head l)) (list_all_int (tail l)))
            true
            false)))
(define-fun-rec pow ((x Real) (n Int)) Real
  (ite (= n 0)
       1
       (* x (pow x (- n 1)))))
(define-fun-rec poly_help ((l Value) (idx Int) (x Real)) Real
  (ite (is-Nil l)
       0
       (let ((h (head l)) (t (tail l)))
         (ite (is-IntVal h)
              (+ (* (to_real (ival h)) (pow x idx))
                 (poly_help t (+ idx 1) x))
              (poly_help t (+ idx 1) x)))))
(define-fun poly ((l Value) (x Real)) Real
  (poly_help l 0 x))
(define-fun abs ((r Real)) Real
  (ite (< r 0) (- r) r))
(declare-fun find_zero ((Value)) Real)

; === Inputs ===
(declare-const xs Value)


; === BASIC STRUCTURE ===
(assert (isList xs))
(assert (> (length xs) 0))

; === Contract predicates ===
(define-fun C0 () Bool
  (and (isList xs)
       (> (length xs) 0)
       (= (mod (length xs) 2) 0)))
(define-fun C1 () Bool
  (not (= (lastElem xs) (IntVal 0))))
(define-fun C2 () Bool
  (list_all_int xs))
(define-fun C3 () Bool
  (< (abs (poly xs (find_zero xs))) (/ 1 100000)))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 6: satisfied_assert_0;assert_2, violated_assert_1;assert_3
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True, 'assert_3': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2'], 'violated_contracts': ['assert_1', 'assert_3'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'xs': [1, 0]}
    Solution 2:
      test_case: {'xs': [2, 0]}
    Solution 3:
      test_case: {'xs': [3, 0]}
    Solution 4:
      test_case: {'xs': [4, 0]}
    Solution 5:
      test_case: {'xs': [5, 0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (isList (tail l))
            false)))
(define-fun-rec length ((l Value)) Int
  (ite (is-Nil l)
       0
       (ite (is-Cons l)
            (+ 1 (length (tail l)))
            0)))
(define-fun-rec lastElem ((l Value)) Value
  (ite (and (is-Cons l) (is-Nil (tail l)))
       (head l)
       (ite (is-Cons l)
            (lastElem (tail l))
            l)))
(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (and (is-Cons l) (is-IntVal (head l)) (list_all_int (tail l)))
            true
            false)))
(define-fun-rec pow ((x Real) (n Int)) Real
  (ite (= n 0)
       1
       (* x (pow x (- n 1)))))
(define-fun-rec poly_help ((l Value) (idx Int) (x Real)) Real
  (ite (is-Nil l)
       0
       (let ((h (head l)) (t (tail l)))
         (ite (is-IntVal h)
              (+ (* (to_real (ival h)) (pow x idx))
                 (poly_help t (+ idx 1) x))
              (poly_help t (+ idx 1) x)))))
(define-fun poly ((l Value) (x Real)) Real
  (poly_help l 0 x))
(define-fun abs ((r Real)) Real
  (ite (< r 0) (- r) r))
(declare-fun find_zero ((Value)) Real)

; === Inputs ===
(declare-const xs Value)


; === BASIC STRUCTURE ===
(assert (isList xs))
(assert (> (length xs) 0))

; === Contract predicates ===
(define-fun C0 () Bool
  (and (isList xs)
       (> (length xs) 0)
       (= (mod (length xs) 2) 0)))
(define-fun C1 () Bool
  (not (= (lastElem xs) (IntVal 0))))
(define-fun C2 () Bool
  (list_all_int xs))
(define-fun C3 () Bool
  (< (abs (poly xs (find_zero xs))) (/ 1 100000)))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 7: satisfied_assert_1;assert_2, violated_assert_0;assert_3
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True, 'assert_3': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2'], 'violated_contracts': ['assert_0', 'assert_3'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'xs': [1]}
    Solution 2:
      test_case: {'xs': [2]}
    Solution 3:
      test_case: {'xs': [-1]}
    Solution 4:
      test_case: {'xs': [-2]}
    Solution 5:
      test_case: {'xs': [-3]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (isList (tail l))
            false)))
(define-fun-rec length ((l Value)) Int
  (ite (is-Nil l)
       0
       (ite (is-Cons l)
            (+ 1 (length (tail l)))
            0)))
(define-fun-rec lastElem ((l Value)) Value
  (ite (and (is-Cons l) (is-Nil (tail l)))
       (head l)
       (ite (is-Cons l)
            (lastElem (tail l))
            l)))
(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (and (is-Cons l) (is-IntVal (head l)) (list_all_int (tail l)))
            true
            false)))
(define-fun-rec pow ((x Real) (n Int)) Real
  (ite (= n 0)
       1
       (* x (pow x (- n 1)))))
(define-fun-rec poly_help ((l Value) (idx Int) (x Real)) Real
  (ite (is-Nil l)
       0
       (let ((h (head l)) (t (tail l)))
         (ite (is-IntVal h)
              (+ (* (to_real (ival h)) (pow x idx))
                 (poly_help t (+ idx 1) x))
              (poly_help t (+ idx 1) x)))))
(define-fun poly ((l Value) (x Real)) Real
  (poly_help l 0 x))
(define-fun abs ((r Real)) Real
  (ite (< r 0) (- r) r))
(declare-fun find_zero ((Value)) Real)

; === Inputs ===
(declare-const xs Value)


; === BASIC STRUCTURE ===
(assert (isList xs))
(assert (> (length xs) 0))

; === Contract predicates ===
(define-fun C0 () Bool
  (and (isList xs)
       (> (length xs) 0)
       (= (mod (length xs) 2) 0)))
(define-fun C1 () Bool
  (not (= (lastElem xs) (IntVal 0))))
(define-fun C2 () Bool
  (list_all_int xs))
(define-fun C3 () Bool
  (< (abs (poly xs (find_zero xs))) (/ 1 100000)))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 8: satisfied_assert_0;assert_1;assert_2, violated_assert_3
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True, 'assert_3': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2'], 'violated_contracts': ['assert_3'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'xs': [1, 1]}
    Solution 2:
      test_case: {'xs': [2, 2]}
    Solution 3:
      test_case: {'xs': [3, 3]}
    Solution 4:
      test_case: {'xs': [5, 5]}
    Solution 5:
      test_case: {'xs': [7, 7]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (isList (tail l))
            false)))
(define-fun-rec length ((l Value)) Int
  (ite (is-Nil l)
       0
       (ite (is-Cons l)
            (+ 1 (length (tail l)))
            0)))
(define-fun-rec lastElem ((l Value)) Value
  (ite (and (is-Cons l) (is-Nil (tail l)))
       (head l)
       (ite (is-Cons l)
            (lastElem (tail l))
            l)))
(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (and (is-Cons l) (is-IntVal (head l)) (list_all_int (tail l)))
            true
            false)))
(define-fun-rec pow ((x Real) (n Int)) Real
  (ite (= n 0)
       1
       (* x (pow x (- n 1)))))
(define-fun-rec poly_help ((l Value) (idx Int) (x Real)) Real
  (ite (is-Nil l)
       0
       (let ((h (head l)) (t (tail l)))
         (ite (is-IntVal h)
              (+ (* (to_real (ival h)) (pow x idx))
                 (poly_help t (+ idx 1) x))
              (poly_help t (+ idx 1) x)))))
(define-fun poly ((l Value) (x Real)) Real
  (poly_help l 0 x))
(define-fun abs ((r Real)) Real
  (ite (< r 0) (- r) r))
(declare-fun find_zero ((Value)) Real)

; === Inputs ===
(declare-const xs Value)


; === BASIC STRUCTURE ===
(assert (isList xs))
(assert (> (length xs) 0))

; === Contract predicates ===
(define-fun C0 () Bool
  (and (isList xs)
       (> (length xs) 0)
       (= (mod (length xs) 2) 0)))
(define-fun C1 () Bool
  (not (= (lastElem xs) (IntVal 0))))
(define-fun C2 () Bool
  (list_all_int xs))
(define-fun C3 () Bool
  (< (abs (poly xs (find_zero xs))) (/ 1 100000)))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 9: satisfied_assert_3, violated_assert_0;assert_1;assert_2
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False, 'assert_3': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_3'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'xs': [7.0, 6.0, 0]}
    Solution 2:
      test_case: {'xs': [12.0, 2, 0]}
    Solution 3:
      test_case: {'xs': [10.0, -1, 0]}
    Solution 4:
      test_case: {'xs': [11.0, -1, 0]}
    Solution 5:
      test_case: {'xs': [13.0, -1, 0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (isList (tail l))
            false)))
(define-fun-rec length ((l Value)) Int
  (ite (is-Nil l)
       0
       (ite (is-Cons l)
            (+ 1 (length (tail l)))
            0)))
(define-fun-rec lastElem ((l Value)) Value
  (ite (and (is-Cons l) (is-Nil (tail l)))
       (head l)
       (ite (is-Cons l)
            (lastElem (tail l))
            l)))
(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (and (is-Cons l) (is-IntVal (head l)) (list_all_int (tail l)))
            true
            false)))
(define-fun-rec pow ((x Real) (n Int)) Real
  (ite (= n 0)
       1
       (* x (pow x (- n 1)))))
(define-fun-rec poly_help ((l Value) (idx Int) (x Real)) Real
  (ite (is-Nil l)
       0
       (let ((h (head l)) (t (tail l)))
         (ite (is-IntVal h)
              (+ (* (to_real (ival h)) (pow x idx))
                 (poly_help t (+ idx 1) x))
              (poly_help t (+ idx 1) x)))))
(define-fun poly ((l Value) (x Real)) Real
  (poly_help l 0 x))
(define-fun abs ((r Real)) Real
  (ite (< r 0) (- r) r))
(declare-fun find_zero ((Value)) Real)

; === Inputs ===
(declare-const xs Value)


; === BASIC STRUCTURE ===
(assert (isList xs))
(assert (> (length xs) 0))

; === Contract predicates ===
(define-fun C0 () Bool
  (and (isList xs)
       (> (length xs) 0)
       (= (mod (length xs) 2) 0)))
(define-fun C1 () Bool
  (not (= (lastElem xs) (IntVal 0))))
(define-fun C2 () Bool
  (list_all_int xs))
(define-fun C3 () Bool
  (< (abs (poly xs (find_zero xs))) (/ 1 100000)))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 10: satisfied_assert_0;assert_3, violated_assert_1;assert_2
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False, 'assert_3': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_3'], 'violated_contracts': ['assert_1', 'assert_2'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'xs': [6.0, 0]}
    Solution 2:
      test_case: {'xs': [7.0, 0]}
    Solution 3:
      test_case: {'xs': [8.0, 0]}
    Solution 4:
      test_case: {'xs': [9.0, 0]}
    Solution 5:
      test_case: {'xs': [10.0, 0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (isList (tail l))
            false)))
(define-fun-rec length ((l Value)) Int
  (ite (is-Nil l)
       0
       (ite (is-Cons l)
            (+ 1 (length (tail l)))
            0)))
(define-fun-rec lastElem ((l Value)) Value
  (ite (and (is-Cons l) (is-Nil (tail l)))
       (head l)
       (ite (is-Cons l)
            (lastElem (tail l))
            l)))
(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (and (is-Cons l) (is-IntVal (head l)) (list_all_int (tail l)))
            true
            false)))
(define-fun-rec pow ((x Real) (n Int)) Real
  (ite (= n 0)
       1
       (* x (pow x (- n 1)))))
(define-fun-rec poly_help ((l Value) (idx Int) (x Real)) Real
  (ite (is-Nil l)
       0
       (let ((h (head l)) (t (tail l)))
         (ite (is-IntVal h)
              (+ (* (to_real (ival h)) (pow x idx))
                 (poly_help t (+ idx 1) x))
              (poly_help t (+ idx 1) x)))))
(define-fun poly ((l Value) (x Real)) Real
  (poly_help l 0 x))
(define-fun abs ((r Real)) Real
  (ite (< r 0) (- r) r))
(declare-fun find_zero ((Value)) Real)

; === Inputs ===
(declare-const xs Value)


; === BASIC STRUCTURE ===
(assert (isList xs))
(assert (> (length xs) 0))

; === Contract predicates ===
(define-fun C0 () Bool
  (and (isList xs)
       (> (length xs) 0)
       (= (mod (length xs) 2) 0)))
(define-fun C1 () Bool
  (not (= (lastElem xs) (IntVal 0))))
(define-fun C2 () Bool
  (list_all_int xs))
(define-fun C3 () Bool
  (< (abs (poly xs (find_zero xs))) (/ 1 100000)))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 11: satisfied_assert_1;assert_3, violated_assert_0;assert_2
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False, 'assert_3': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_3'], 'violated_contracts': ['assert_0', 'assert_2'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'xs': [5.0]}
    Solution 2:
      test_case: {'xs': [6.0]}
    Solution 3:
      test_case: {'xs': [7.0]}
    Solution 4:
      test_case: {'xs': [8.0]}
    Solution 5:
      test_case: {'xs': [9.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (isList (tail l))
            false)))
(define-fun-rec length ((l Value)) Int
  (ite (is-Nil l)
       0
       (ite (is-Cons l)
            (+ 1 (length (tail l)))
            0)))
(define-fun-rec lastElem ((l Value)) Value
  (ite (and (is-Cons l) (is-Nil (tail l)))
       (head l)
       (ite (is-Cons l)
            (lastElem (tail l))
            l)))
(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (and (is-Cons l) (is-IntVal (head l)) (list_all_int (tail l)))
            true
            false)))
(define-fun-rec pow ((x Real) (n Int)) Real
  (ite (= n 0)
       1
       (* x (pow x (- n 1)))))
(define-fun-rec poly_help ((l Value) (idx Int) (x Real)) Real
  (ite (is-Nil l)
       0
       (let ((h (head l)) (t (tail l)))
         (ite (is-IntVal h)
              (+ (* (to_real (ival h)) (pow x idx))
                 (poly_help t (+ idx 1) x))
              (poly_help t (+ idx 1) x)))))
(define-fun poly ((l Value) (x Real)) Real
  (poly_help l 0 x))
(define-fun abs ((r Real)) Real
  (ite (< r 0) (- r) r))
(declare-fun find_zero ((Value)) Real)

; === Inputs ===
(declare-const xs Value)


; === BASIC STRUCTURE ===
(assert (isList xs))
(assert (> (length xs) 0))

; === Contract predicates ===
(define-fun C0 () Bool
  (and (isList xs)
       (> (length xs) 0)
       (= (mod (length xs) 2) 0)))
(define-fun C1 () Bool
  (not (= (lastElem xs) (IntVal 0))))
(define-fun C2 () Bool
  (list_all_int xs))
(define-fun C3 () Bool
  (< (abs (poly xs (find_zero xs))) (/ 1 100000)))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 12: satisfied_assert_0;assert_1;assert_3, violated_assert_2
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False, 'assert_3': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_3'], 'violated_contracts': ['assert_2'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'xs': [6.0, -1]}
    Solution 2:
      test_case: {'xs': [5.0, 5.0]}
    Solution 3:
      test_case: {'xs': [7.0, 7.0]}
    Solution 4:
      test_case: {'xs': [8.0, 8.0]}
    Solution 5:
      test_case: {'xs': [9.0, 9.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (isList (tail l))
            false)))
(define-fun-rec length ((l Value)) Int
  (ite (is-Nil l)
       0
       (ite (is-Cons l)
            (+ 1 (length (tail l)))
            0)))
(define-fun-rec lastElem ((l Value)) Value
  (ite (and (is-Cons l) (is-Nil (tail l)))
       (head l)
       (ite (is-Cons l)
            (lastElem (tail l))
            l)))
(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (and (is-Cons l) (is-IntVal (head l)) (list_all_int (tail l)))
            true
            false)))
(define-fun-rec pow ((x Real) (n Int)) Real
  (ite (= n 0)
       1
       (* x (pow x (- n 1)))))
(define-fun-rec poly_help ((l Value) (idx Int) (x Real)) Real
  (ite (is-Nil l)
       0
       (let ((h (head l)) (t (tail l)))
         (ite (is-IntVal h)
              (+ (* (to_real (ival h)) (pow x idx))
                 (poly_help t (+ idx 1) x))
              (poly_help t (+ idx 1) x)))))
(define-fun poly ((l Value) (x Real)) Real
  (poly_help l 0 x))
(define-fun abs ((r Real)) Real
  (ite (< r 0) (- r) r))
(declare-fun find_zero ((Value)) Real)

; === Inputs ===
(declare-const xs Value)


; === BASIC STRUCTURE ===
(assert (isList xs))
(assert (> (length xs) 0))

; === Contract predicates ===
(define-fun C0 () Bool
  (and (isList xs)
       (> (length xs) 0)
       (= (mod (length xs) 2) 0)))
(define-fun C1 () Bool
  (not (= (lastElem xs) (IntVal 0))))
(define-fun C2 () Bool
  (list_all_int xs))
(define-fun C3 () Bool
  (< (abs (poly xs (find_zero xs))) (/ 1 100000)))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 13: satisfied_assert_2;assert_3, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True, 'assert_3': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_2', 'assert_3'], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'xs': [0]}
    Solution 2:
      test_case: {'xs': [1, -200001, 0]}
    Solution 3:
      test_case: {'xs': [1, 200001, 0]}
    Solution 4:
      test_case: {'xs': [1, 1, 0]}
    Solution 5:
      test_case: {'xs': [2, 2, 0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (isList (tail l))
            false)))
(define-fun-rec length ((l Value)) Int
  (ite (is-Nil l)
       0
       (ite (is-Cons l)
            (+ 1 (length (tail l)))
            0)))
(define-fun-rec lastElem ((l Value)) Value
  (ite (and (is-Cons l) (is-Nil (tail l)))
       (head l)
       (ite (is-Cons l)
            (lastElem (tail l))
            l)))
(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (and (is-Cons l) (is-IntVal (head l)) (list_all_int (tail l)))
            true
            false)))
(define-fun-rec pow ((x Real) (n Int)) Real
  (ite (= n 0)
       1
       (* x (pow x (- n 1)))))
(define-fun-rec poly_help ((l Value) (idx Int) (x Real)) Real
  (ite (is-Nil l)
       0
       (let ((h (head l)) (t (tail l)))
         (ite (is-IntVal h)
              (+ (* (to_real (ival h)) (pow x idx))
                 (poly_help t (+ idx 1) x))
              (poly_help t (+ idx 1) x)))))
(define-fun poly ((l Value) (x Real)) Real
  (poly_help l 0 x))
(define-fun abs ((r Real)) Real
  (ite (< r 0) (- r) r))
(declare-fun find_zero ((Value)) Real)

; === Inputs ===
(declare-const xs Value)


; === BASIC STRUCTURE ===
(assert (isList xs))
(assert (> (length xs) 0))

; === Contract predicates ===
(define-fun C0 () Bool
  (and (isList xs)
       (> (length xs) 0)
       (= (mod (length xs) 2) 0)))
(define-fun C1 () Bool
  (not (= (lastElem xs) (IntVal 0))))
(define-fun C2 () Bool
  (list_all_int xs))
(define-fun C3 () Bool
  (< (abs (poly xs (find_zero xs))) (/ 1 100000)))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 14: satisfied_assert_0;assert_2;assert_3, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True, 'assert_3': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2', 'assert_3'], 'violated_contracts': ['assert_1'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'xs': [0, 0]}
    Solution 2:
      test_case: {'xs': [0, -2, -2, 0]}
    Solution 3:
      test_case: {'xs': [0, -2, -1, 0]}
    Solution 4:
      test_case: {'xs': [0, -3, -1, 0]}
    Solution 5:
      test_case: {'xs': [0, -4, -16, 0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (isList (tail l))
            false)))
(define-fun-rec length ((l Value)) Int
  (ite (is-Nil l)
       0
       (ite (is-Cons l)
            (+ 1 (length (tail l)))
            0)))
(define-fun-rec lastElem ((l Value)) Value
  (ite (and (is-Cons l) (is-Nil (tail l)))
       (head l)
       (ite (is-Cons l)
            (lastElem (tail l))
            l)))
(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (and (is-Cons l) (is-IntVal (head l)) (list_all_int (tail l)))
            true
            false)))
(define-fun-rec pow ((x Real) (n Int)) Real
  (ite (= n 0)
       1
       (* x (pow x (- n 1)))))
(define-fun-rec poly_help ((l Value) (idx Int) (x Real)) Real
  (ite (is-Nil l)
       0
       (let ((h (head l)) (t (tail l)))
         (ite (is-IntVal h)
              (+ (* (to_real (ival h)) (pow x idx))
                 (poly_help t (+ idx 1) x))
              (poly_help t (+ idx 1) x)))))
(define-fun poly ((l Value) (x Real)) Real
  (poly_help l 0 x))
(define-fun abs ((r Real)) Real
  (ite (< r 0) (- r) r))
(declare-fun find_zero ((Value)) Real)

; === Inputs ===
(declare-const xs Value)


; === BASIC STRUCTURE ===
(assert (isList xs))
(assert (> (length xs) 0))

; === Contract predicates ===
(define-fun C0 () Bool
  (and (isList xs)
       (> (length xs) 0)
       (= (mod (length xs) 2) 0)))
(define-fun C1 () Bool
  (not (= (lastElem xs) (IntVal 0))))
(define-fun C2 () Bool
  (list_all_int xs))
(define-fun C3 () Bool
  (< (abs (poly xs (find_zero xs))) (/ 1 100000)))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 15: satisfied_assert_1;assert_2;assert_3, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True, 'assert_3': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2', 'assert_3'], 'violated_contracts': ['assert_0'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'xs': [1, -100001, 100000]}
    Solution 2:
      test_case: {'xs': [0, 2, 1]}
    Solution 3:
      test_case: {'xs': [1, 40000400000, 40000000000]}
    Solution 4:
      test_case: {'xs': [2, 40000400001, 39999999999]}
    Solution 5:
      test_case: {'xs': [0, 40000400001, 22184]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (isList (tail l))
            false)))
(define-fun-rec length ((l Value)) Int
  (ite (is-Nil l)
       0
       (ite (is-Cons l)
            (+ 1 (length (tail l)))
            0)))
(define-fun-rec lastElem ((l Value)) Value
  (ite (and (is-Cons l) (is-Nil (tail l)))
       (head l)
       (ite (is-Cons l)
            (lastElem (tail l))
            l)))
(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (and (is-Cons l) (is-IntVal (head l)) (list_all_int (tail l)))
            true
            false)))
(define-fun-rec pow ((x Real) (n Int)) Real
  (ite (= n 0)
       1
       (* x (pow x (- n 1)))))
(define-fun-rec poly_help ((l Value) (idx Int) (x Real)) Real
  (ite (is-Nil l)
       0
       (let ((h (head l)) (t (tail l)))
         (ite (is-IntVal h)
              (+ (* (to_real (ival h)) (pow x idx))
                 (poly_help t (+ idx 1) x))
              (poly_help t (+ idx 1) x)))))
(define-fun poly ((l Value) (x Real)) Real
  (poly_help l 0 x))
(define-fun abs ((r Real)) Real
  (ite (< r 0) (- r) r))
(declare-fun find_zero ((Value)) Real)

; === Inputs ===
(declare-const xs Value)


; === BASIC STRUCTURE ===
(assert (isList xs))
(assert (> (length xs) 0))

; === Contract predicates ===
(define-fun C0 () Bool
  (and (isList xs)
       (> (length xs) 0)
       (= (mod (length xs) 2) 0)))
(define-fun C1 () Bool
  (not (= (lastElem xs) (IntVal 0))))
(define-fun C2 () Bool
  (list_all_int xs))
(define-fun C3 () Bool
  (< (abs (poly xs (find_zero xs))) (/ 1 100000)))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 16: satisfied_assert_0;assert_1;assert_2;assert_3, violated_
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True, 'assert_3': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_3'], 'violated_contracts': [], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'xs': [0, -1]}
    Solution 2:
      test_case: {'xs': [0, 1]}
    Solution 3:
      test_case: {'xs': [-3, -2]}
    Solution 4:
      test_case: {'xs': [-4, -2]}
    Solution 5:
      test_case: {'xs': [-2, -1]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (isList (tail l))
            false)))
(define-fun-rec length ((l Value)) Int
  (ite (is-Nil l)
       0
       (ite (is-Cons l)
            (+ 1 (length (tail l)))
            0)))
(define-fun-rec lastElem ((l Value)) Value
  (ite (and (is-Cons l) (is-Nil (tail l)))
       (head l)
       (ite (is-Cons l)
            (lastElem (tail l))
            l)))
(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (and (is-Cons l) (is-IntVal (head l)) (list_all_int (tail l)))
            true
            false)))
(define-fun-rec pow ((x Real) (n Int)) Real
  (ite (= n 0)
       1
       (* x (pow x (- n 1)))))
(define-fun-rec poly_help ((l Value) (idx Int) (x Real)) Real
  (ite (is-Nil l)
       0
       (let ((h (head l)) (t (tail l)))
         (ite (is-IntVal h)
              (+ (* (to_real (ival h)) (pow x idx))
                 (poly_help t (+ idx 1) x))
              (poly_help t (+ idx 1) x)))))
(define-fun poly ((l Value) (x Real)) Real
  (poly_help l 0 x))
(define-fun abs ((r Real)) Real
  (ite (< r 0) (- r) r))
(declare-fun find_zero ((Value)) Real)

; === Inputs ===
(declare-const xs Value)


; === BASIC STRUCTURE ===
(assert (isList xs))
(assert (> (length xs) 0))

; === Contract predicates ===
(define-fun C0 () Bool
  (and (isList xs)
       (> (length xs) 0)
       (= (mod (length xs) 2) 0)))
(define-fun C1 () Bool
  (not (= (lastElem xs) (IntVal 0))))
(define-fun C2 () Bool
  (list_all_int xs))
(define-fun C3 () Bool
  (< (abs (poly xs (find_zero xs))) (/ 1 100000)))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)
(assert C3)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/33 ===
  Test Case 1: satisfied_, violated_assert_0
  Combination: {'assert_0': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0'], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'l': 2.0}
    Solution 2:
      test_case: {'l': 3.0}
    Solution 3:
      test_case: {'l': 4.0}
    Solution 4:
      test_case: {'l': 5.0}
    Solution 5:
      test_case: {'l': 6.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool (ite (is-Nil v) true (ite (is-Cons v) (IsList (tail v)) false)))

; === Inputs ===
(declare-const l Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (IsList l))

; === COMBINATION ===
(assert (not C0))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_
  Combination: {'assert_0': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': [], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'l': []}
    Solution 2:
      test_case: {'l': [2.0]}
    Solution 3:
      test_case: {'l': [3.0]}
    Solution 4:
      test_case: {'l': [4.0]}
    Solution 5:
      test_case: {'l': [5.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool (ite (is-Nil v) true (ite (is-Cons v) (IsList (tail v)) false)))

; === Inputs ===
(declare-const l Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (IsList l))

; === COMBINATION ===
(assert C0)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/34 ===
  Test Case 1: satisfied_, violated_assert_0
  Combination: {'assert_0': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0'], 'total_contracts': 1}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((x Value)) Bool
  (ite (is-Nil x) true
       (ite (is-Cons x)
            (IsList (tail x))
            false)))

; === Inputs ===
(declare-const l Value)

; === BASIC STRUCTURE ===
(assert (IsList l))

; === Contract predicates ===
(define-fun C0 () Bool (or (is-Nil l) (is-Cons l)))

; === COMBINATION ===
(assert (not C0))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_
  Combination: {'assert_0': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': [], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'l': []}
    Solution 2:
      test_case: {'l': [2.0]}
    Solution 3:
      test_case: {'l': [3.0]}
    Solution 4:
      test_case: {'l': [4.0]}
    Solution 5:
      test_case: {'l': [5.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((x Value)) Bool
  (ite (is-Nil x) true
       (ite (is-Cons x)
            (IsList (tail x))
            false)))

; === Inputs ===
(declare-const l Value)

; === BASIC STRUCTURE ===
(assert (IsList l))

; === Contract predicates ===
(define-fun C0 () Bool (or (is-Nil l) (is-Cons l)))

; === COMBINATION ===
(assert C0)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/35 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1;assert_2
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2'], 'total_contracts': 3}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v)
       0
       (ite (is-Cons v)
            (+ 1 (length (tail v)))
            0)))

(define-fun-rec list_all_numeric ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (let ((h (head v)) (t (tail v)))
              (and (or (is-IntVal h) (is-FloatVal h))
                   (list_all_numeric t)))
            false)))

; === Inputs ===
(declare-const l Value)

; === BASIC STRUCTURE ===
(assert (IsList l))

; === Contract predicates ===
(define-fun C0 () Bool (IsList l))
(define-fun C1 () Bool (not (= (length l) 0)))
(define-fun C2 () Bool (list_all_numeric l))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1;assert_2
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1', 'assert_2'], 'total_contracts': 3}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v)
       0
       (ite (is-Cons v)
            (+ 1 (length (tail v)))
            0)))

(define-fun-rec list_all_numeric ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (let ((h (head v)) (t (tail v)))
              (and (or (is-IntVal h) (is-FloatVal h))
                   (list_all_numeric t)))
            false)))

; === Inputs ===
(declare-const l Value)

; === BASIC STRUCTURE ===
(assert (IsList l))

; === Contract predicates ===
(define-fun C0 () Bool (IsList l))
(define-fun C1 () Bool (not (= (length l) 0)))
(define-fun C2 () Bool (list_all_numeric l))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0;assert_2
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0', 'assert_2'], 'total_contracts': 3}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v)
       0
       (ite (is-Cons v)
            (+ 1 (length (tail v)))
            0)))

(define-fun-rec list_all_numeric ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (let ((h (head v)) (t (tail v)))
              (and (or (is-IntVal h) (is-FloatVal h))
                   (list_all_numeric t)))
            false)))

; === Inputs ===
(declare-const l Value)

; === BASIC STRUCTURE ===
(assert (IsList l))

; === Contract predicates ===
(define-fun C0 () Bool (IsList l))
(define-fun C1 () Bool (not (= (length l) 0)))
(define-fun C2 () Bool (list_all_numeric l))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_assert_2
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': ['assert_2'], 'total_contracts': 3}
  Solutions:
    Solution 1:
      test_case: {'l': ['!0!']}
    Solution 2:
      test_case: {'l': ['!']}
    Solution 3:
      test_case: {'l': ['0']}
    Solution 4:
      test_case: {'l': ['0!']}
    Solution 5:
      test_case: {'l': ['']}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v)
       0
       (ite (is-Cons v)
            (+ 1 (length (tail v)))
            0)))

(define-fun-rec list_all_numeric ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (let ((h (head v)) (t (tail v)))
              (and (or (is-IntVal h) (is-FloatVal h))
                   (list_all_numeric t)))
            false)))

; === Inputs ===
(declare-const l Value)

; === BASIC STRUCTURE ===
(assert (IsList l))

; === Contract predicates ===
(define-fun C0 () Bool (IsList l))
(define-fun C1 () Bool (not (= (length l) 0)))
(define-fun C2 () Bool (list_all_numeric l))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))

(check-sat)
(get-model)

------------------------------
  Test Case 5: satisfied_assert_2, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_2'], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 3}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v)
       0
       (ite (is-Cons v)
            (+ 1 (length (tail v)))
            0)))

(define-fun-rec list_all_numeric ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (let ((h (head v)) (t (tail v)))
              (and (or (is-IntVal h) (is-FloatVal h))
                   (list_all_numeric t)))
            false)))

; === Inputs ===
(declare-const l Value)

; === BASIC STRUCTURE ===
(assert (IsList l))

; === Contract predicates ===
(define-fun C0 () Bool (IsList l))
(define-fun C1 () Bool (not (= (length l) 0)))
(define-fun C2 () Bool (list_all_numeric l))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)

(check-sat)
(get-model)

------------------------------
  Test Case 6: satisfied_assert_0;assert_2, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True}
  Satisfiable: True
  Solution Count: 1
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2'], 'violated_contracts': ['assert_1'], 'total_contracts': 3}
  Solutions:
    Solution 1:
      test_case: {'l': []}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v)
       0
       (ite (is-Cons v)
            (+ 1 (length (tail v)))
            0)))

(define-fun-rec list_all_numeric ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (let ((h (head v)) (t (tail v)))
              (and (or (is-IntVal h) (is-FloatVal h))
                   (list_all_numeric t)))
            false)))

; === Inputs ===
(declare-const l Value)

; === BASIC STRUCTURE ===
(assert (IsList l))

; === Contract predicates ===
(define-fun C0 () Bool (IsList l))
(define-fun C1 () Bool (not (= (length l) 0)))
(define-fun C2 () Bool (list_all_numeric l))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)

(check-sat)
(get-model)

------------------------------
  Test Case 7: satisfied_assert_1;assert_2, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2'], 'violated_contracts': ['assert_0'], 'total_contracts': 3}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v)
       0
       (ite (is-Cons v)
            (+ 1 (length (tail v)))
            0)))

(define-fun-rec list_all_numeric ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (let ((h (head v)) (t (tail v)))
              (and (or (is-IntVal h) (is-FloatVal h))
                   (list_all_numeric t)))
            false)))

; === Inputs ===
(declare-const l Value)

; === BASIC STRUCTURE ===
(assert (IsList l))

; === Contract predicates ===
(define-fun C0 () Bool (IsList l))
(define-fun C1 () Bool (not (= (length l) 0)))
(define-fun C2 () Bool (list_all_numeric l))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)

(check-sat)
(get-model)

------------------------------
  Test Case 8: satisfied_assert_0;assert_1;assert_2, violated_
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2'], 'violated_contracts': [], 'total_contracts': 3}
  Solutions:
    Solution 1:
      test_case: {'l': [2.0]}
    Solution 2:
      test_case: {'l': [2]}
    Solution 3:
      test_case: {'l': [3]}
    Solution 4:
      test_case: {'l': [4]}
    Solution 5:
      test_case: {'l': [5]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v)
       0
       (ite (is-Cons v)
            (+ 1 (length (tail v)))
            0)))

(define-fun-rec list_all_numeric ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (let ((h (head v)) (t (tail v)))
              (and (or (is-IntVal h) (is-FloatVal h))
                   (list_all_numeric t)))
            false)))

; === Inputs ===
(declare-const l Value)

; === BASIC STRUCTURE ===
(assert (IsList l))

; === Contract predicates ===
(define-fun C0 () Bool (IsList l))
(define-fun C1 () Bool (not (= (length l) 0)))
(define-fun C2 () Bool (list_all_numeric l))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/36 ===
  Test Case 1: satisfied_, violated_assert_0
  Combination: {'assert_0': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0'], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'n': 2.0}
    Solution 2:
      test_case: {'n': 3.0}
    Solution 3:
      test_case: {'n': 4.0}
    Solution 4:
      test_case: {'n': 5.0}
    Solution 5:
      test_case: {'n': 6.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (is-IntVal n) (> (ival n) 0)))

; === COMBINATION ===
(assert (not C0))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_
  Combination: {'assert_0': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': [], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'n': 1}
    Solution 2:
      test_case: {'n': 7720}
    Solution 3:
      test_case: {'n': 10157}
    Solution 4:
      test_case: {'n': 21954}
    Solution 5:
      test_case: {'n': 54239}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (is-IntVal n) (> (ival n) 0)))

; === COMBINATION ===
(assert C0)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/37 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_numeric ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (or (is-IntVal (head v)) (is-FloatVal (head v)))
                 (list_all_numeric (tail v)))
            false)))

; === Inputs ===
(declare-const l Value)

; === BASIC STRUCTURE ===
(assert (IsList l))

; === Contract predicates ===
(define-fun C0 () Bool
  (IsList l))
(define-fun C1 () Bool
  (list_all_numeric l))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'l': ['!0!']}
    Solution 2:
      test_case: {'l': ['!']}
    Solution 3:
      test_case: {'l': ['0']}
    Solution 4:
      test_case: {'l': ['0!']}
    Solution 5:
      test_case: {'l': ['']}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_numeric ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (or (is-IntVal (head v)) (is-FloatVal (head v)))
                 (list_all_numeric (tail v)))
            false)))

; === Inputs ===
(declare-const l Value)

; === BASIC STRUCTURE ===
(assert (IsList l))

; === Contract predicates ===
(define-fun C0 () Bool
  (IsList l))
(define-fun C1 () Bool
  (list_all_numeric l))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_numeric ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (or (is-IntVal (head v)) (is-FloatVal (head v)))
                 (list_all_numeric (tail v)))
            false)))

; === Inputs ===
(declare-const l Value)

; === BASIC STRUCTURE ===
(assert (IsList l))

; === Contract predicates ===
(define-fun C0 () Bool
  (IsList l))
(define-fun C1 () Bool
  (list_all_numeric l))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'l': []}
    Solution 2:
      test_case: {'l': [2]}
    Solution 3:
      test_case: {'l': [2.0]}
    Solution 4:
      test_case: {'l': [3.0]}
    Solution 5:
      test_case: {'l': [3]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_numeric ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (or (is-IntVal (head v)) (is-FloatVal (head v)))
                 (list_all_numeric (tail v)))
            false)))

; === Inputs ===
(declare-const l Value)

; === BASIC STRUCTURE ===
(assert (IsList l))

; === Contract predicates ===
(define-fun C0 () Bool
  (IsList l))
(define-fun C1 () Bool
  (list_all_numeric l))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/38 ===
  Test Case 1: satisfied_, violated_assert_0
  Combination: {'assert_0': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0'], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'s': 2.0}
    Solution 2:
      test_case: {'s': 3.0}
    Solution 3:
      test_case: {'s': 4.0}
    Solution 4:
      test_case: {'s': 5.0}
    Solution 5:
      test_case: {'s': 6.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeS ((v Value)) String (ite (is-StrVal v) (sval v) ""))

; === Inputs ===
(declare-const s Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal s))

; === COMBINATION ===
(assert (not C0))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_
  Combination: {'assert_0': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': [], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'s': '!0!'}
    Solution 2:
      test_case: {'s': '!'}
    Solution 3:
      test_case: {'s': '0'}
    Solution 4:
      test_case: {'s': '0!'}
    Solution 5:
      test_case: {'s': ''}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeS ((v Value)) String (ite (is-StrVal v) (sval v) ""))

; === Inputs ===
(declare-const s Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal s))

; === COMBINATION ===
(assert C0)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/39 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'n': 2.0}
    Solution 2:
      test_case: {'n': 3.0}
    Solution 3:
      test_case: {'n': 4.0}
    Solution 4:
      test_case: {'n': 5.0}
    Solution 5:
      test_case: {'n': 6.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun safe-ival ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))
(define-fun C1 () Bool (and (<= 1 (safe-ival n)) (<= (safe-ival n) 12)))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'n': 13}
    Solution 2:
      test_case: {'n': 21251}
    Solution 3:
      test_case: {'n': 33048}
    Solution 4:
      test_case: {'n': 43498}
    Solution 5:
      test_case: {'n': 71598}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun safe-ival ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))
(define-fun C1 () Bool (and (<= 1 (safe-ival n)) (<= (safe-ival n) 12)))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun safe-ival ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))
(define-fun C1 () Bool (and (<= 1 (safe-ival n)) (<= (safe-ival n) 12)))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'n': 1}
    Solution 2:
      test_case: {'n': 4}
    Solution 3:
      test_case: {'n': 2}
    Solution 4:
      test_case: {'n': 3}
    Solution 5:
      test_case: {'n': 10}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun safe-ival ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))
(define-fun C1 () Bool (and (<= 1 (safe-ival n)) (<= (safe-ival n) 12)))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/40 ===
  Test Case 1: satisfied_, violated_assert_0
  Combination: {'assert_0': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0'], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'l': 2.0}
    Solution 2:
      test_case: {'l': 3.0}
    Solution 3:
      test_case: {'l': 4.0}
    Solution 4:
      test_case: {'l': 5.0}
    Solution 5:
      test_case: {'l': 6.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_int ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (is-IntVal (head v))
                 (list_all_int (tail v)))
            false)))

; === Inputs ===
(declare-const l Value)

; === BASIC STRUCTURE ===
(and (IsList l) (list_all_int l))

; === Contract predicates ===
(define-fun C0 () Bool (IsList l))

; === COMBINATION ===
(assert (not C0))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_
  Combination: {'assert_0': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': [], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'l': []}
    Solution 2:
      test_case: {'l': [2.0]}
    Solution 3:
      test_case: {'l': [3.0]}
    Solution 4:
      test_case: {'l': [4.0]}
    Solution 5:
      test_case: {'l': [5.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_int ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (is-IntVal (head v))
                 (list_all_int (tail v)))
            false)))

; === Inputs ===
(declare-const l Value)

; === BASIC STRUCTURE ===
(and (IsList l) (list_all_int l))

; === Contract predicates ===
(define-fun C0 () Bool (IsList l))

; === COMBINATION ===
(assert C0)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/41 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'n': 2.0}
    Solution 2:
      test_case: {'n': 3.0}
    Solution 3:
      test_case: {'n': 4.0}
    Solution 4:
      test_case: {'n': 5.0}
    Solution 5:
      test_case: {'n': 6.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))
(define-fun C1 () Bool (>= (SafeI n) 1))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'n': 0}
    Solution 2:
      test_case: {'n': -7719}
    Solution 3:
      test_case: {'n': -10156}
    Solution 4:
      test_case: {'n': -21953}
    Solution 5:
      test_case: {'n': -54238}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))
(define-fun C1 () Bool (>= (SafeI n) 1))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))
(define-fun C1 () Bool (>= (SafeI n) 1))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'n': 1}
    Solution 2:
      test_case: {'n': 7720}
    Solution 3:
      test_case: {'n': 10157}
    Solution 4:
      test_case: {'n': 21954}
    Solution 5:
      test_case: {'n': 54239}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))
(define-fun C1 () Bool (>= (SafeI n) 1))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/42 ===
  Test Case 1: satisfied_, violated_assert_0
  Combination: {'assert_0': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0'], 'total_contracts': 1}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_numeric ((xs Value)) Bool
  (ite (is-Nil xs)
       true
       (ite (is-Cons xs)
            (and (or (is-IntVal (head xs))
                     (is-FloatVal (head xs)))
                 (list_all_numeric (tail xs)))
            false)))

; === Inputs ===
(declare-const l Value)

; === BASIC STRUCTURE ===
(assert (IsList l))
(assert (list_all_numeric l))

; === Contract predicates ===
(define-fun C0 () Bool (IsList l))

; === COMBINATION ===
(assert (not C0))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_
  Combination: {'assert_0': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': [], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'l': []}
    Solution 2:
      test_case: {'l': [2.0]}
    Solution 3:
      test_case: {'l': [2]}
    Solution 4:
      test_case: {'l': [3]}
    Solution 5:
      test_case: {'l': [3.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_numeric ((xs Value)) Bool
  (ite (is-Nil xs)
       true
       (ite (is-Cons xs)
            (and (or (is-IntVal (head xs))
                     (is-FloatVal (head xs)))
                 (list_all_numeric (tail xs)))
            false)))

; === Inputs ===
(declare-const l Value)

; === BASIC STRUCTURE ===
(assert (IsList l))
(assert (list_all_numeric l))

; === Contract predicates ===
(define-fun C0 () Bool (IsList l))

; === COMBINATION ===
(assert C0)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/43 ===
  Test Case 1: satisfied_, violated_assert_0
  Combination: {'assert_0': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0'], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'l': [2.0]}
    Solution 2:
      test_case: {'l': [3.0]}
    Solution 3:
      test_case: {'l': [4.0]}
    Solution 4:
      test_case: {'l': [5.0]}
    Solution 5:
      test_case: {'l': [6.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_int ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (let ((h (head v)) (t (tail v)))
              (ite (is-IntVal h)
                   (list_all_int t)
                   false))
            false)))

; === Inputs ===
(declare-const l Value)

; === BASIC STRUCTURE ===
(assert (IsList l))

; === Contract predicates ===
(define-fun C0 () Bool
  (list_all_int l))

; === COMBINATION ===
(assert (not C0))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_
  Combination: {'assert_0': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': [], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'l': []}
    Solution 2:
      test_case: {'l': [2]}
    Solution 3:
      test_case: {'l': [3]}
    Solution 4:
      test_case: {'l': [4]}
    Solution 5:
      test_case: {'l': [5]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_int ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (let ((h (head v)) (t (tail v)))
              (ite (is-IntVal h)
                   (list_all_int t)
                   false))
            false)))

; === Inputs ===
(declare-const l Value)

; === BASIC STRUCTURE ===
(assert (IsList l))

; === Contract predicates ===
(define-fun C0 () Bool
  (list_all_int l))

; === COMBINATION ===
(assert C0)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/44 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1;assert_2
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2'], 'total_contracts': 3}
  Solutions:
    Solution 1:
      test_case: {'x': 2.0, 'base': 3.0}
    Solution 2:
      test_case: {'x': 5.0, 'base': 4.0}
    Solution 3:
      test_case: {'x': 7.0, 'base': 6.0}
    Solution 4:
      test_case: {'x': 9.0, 'base': 8.0}
    Solution 5:
      test_case: {'x': 10.0, 'base': 11.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const x Value)
(declare-const base Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (is-IntVal x) (is-IntVal base)))
(define-fun C1 () Bool (and (is-IntVal x) (>= (ival x) 0)))
(define-fun C2 () Bool (and (is-IntVal base) (<= 2 (ival base) 9)))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1;assert_2
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1', 'assert_2'], 'total_contracts': 3}
  Solutions:
    Solution 1:
      test_case: {'x': -1, 'base': 10}
    Solution 2:
      test_case: {'x': -1, 'base': 0}
    Solution 3:
      test_case: {'x': -1, 'base': -2437}
    Solution 4:
      test_case: {'x': -8366, 'base': -2437}
    Solution 5:
      test_case: {'x': -38978, 'base': -2437}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const x Value)
(declare-const base Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (is-IntVal x) (is-IntVal base)))
(define-fun C1 () Bool (and (is-IntVal x) (>= (ival x) 0)))
(define-fun C2 () Bool (and (is-IntVal base) (<= 2 (ival base) 9)))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0;assert_2
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0', 'assert_2'], 'total_contracts': 3}
  Solutions:
    Solution 1:
      test_case: {'x': 0, 'base': 2.0}
    Solution 2:
      test_case: {'x': 7719, 'base': 3.0}
    Solution 3:
      test_case: {'x': 10156, 'base': 4.0}
    Solution 4:
      test_case: {'x': 10156, 'base': 5.0}
    Solution 5:
      test_case: {'x': 18521, 'base': 6.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const x Value)
(declare-const base Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (is-IntVal x) (is-IntVal base)))
(define-fun C1 () Bool (and (is-IntVal x) (>= (ival x) 0)))
(define-fun C2 () Bool (and (is-IntVal base) (<= 2 (ival base) 9)))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_assert_2
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': ['assert_2'], 'total_contracts': 3}
  Solutions:
    Solution 1:
      test_case: {'x': 0, 'base': -21238}
    Solution 2:
      test_case: {'x': 21238, 'base': -2437}
    Solution 3:
      test_case: {'x': 29603, 'base': -2437}
    Solution 4:
      test_case: {'x': 60215, 'base': -2437}
    Solution 5:
      test_case: {'x': 61357, 'base': -2437}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const x Value)
(declare-const base Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (is-IntVal x) (is-IntVal base)))
(define-fun C1 () Bool (and (is-IntVal x) (>= (ival x) 0)))
(define-fun C2 () Bool (and (is-IntVal base) (<= 2 (ival base) 9)))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))

(check-sat)
(get-model)

------------------------------
  Test Case 5: satisfied_assert_2, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_2'], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 3}
  Solutions:
    Solution 1:
      test_case: {'x': 2.0, 'base': 2}
    Solution 2:
      test_case: {'x': 3.0, 'base': 9}
    Solution 3:
      test_case: {'x': 4.0, 'base': 7}
    Solution 4:
      test_case: {'x': 5.0, 'base': 7}
    Solution 5:
      test_case: {'x': 6.0, 'base': 7}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const x Value)
(declare-const base Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (is-IntVal x) (is-IntVal base)))
(define-fun C1 () Bool (and (is-IntVal x) (>= (ival x) 0)))
(define-fun C2 () Bool (and (is-IntVal base) (<= 2 (ival base) 9)))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)

(check-sat)
(get-model)

------------------------------
  Test Case 6: satisfied_assert_0;assert_2, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2'], 'violated_contracts': ['assert_1'], 'total_contracts': 3}
  Solutions:
    Solution 1:
      test_case: {'x': -1, 'base': 2}
    Solution 2:
      test_case: {'x': -21239, 'base': 9}
    Solution 3:
      test_case: {'x': -21239, 'base': 8}
    Solution 4:
      test_case: {'x': -21239, 'base': 7}
    Solution 5:
      test_case: {'x': -21239, 'base': 6}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const x Value)
(declare-const base Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (is-IntVal x) (is-IntVal base)))
(define-fun C1 () Bool (and (is-IntVal x) (>= (ival x) 0)))
(define-fun C2 () Bool (and (is-IntVal base) (<= 2 (ival base) 9)))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)

(check-sat)
(get-model)

------------------------------
  Test Case 7: satisfied_assert_1;assert_2, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2'], 'violated_contracts': ['assert_0'], 'total_contracts': 3}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const x Value)
(declare-const base Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (is-IntVal x) (is-IntVal base)))
(define-fun C1 () Bool (and (is-IntVal x) (>= (ival x) 0)))
(define-fun C2 () Bool (and (is-IntVal base) (<= 2 (ival base) 9)))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)

(check-sat)
(get-model)

------------------------------
  Test Case 8: satisfied_assert_0;assert_1;assert_2, violated_
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2'], 'violated_contracts': [], 'total_contracts': 3}
  Solutions:
    Solution 1:
      test_case: {'x': 0, 'base': 2}
    Solution 2:
      test_case: {'x': 7719, 'base': 8}
    Solution 3:
      test_case: {'x': 16574, 'base': 8}
    Solution 4:
      test_case: {'x': 24939, 'base': 8}
    Solution 5:
      test_case: {'x': 24939, 'base': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const x Value)
(declare-const base Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (is-IntVal x) (is-IntVal base)))
(define-fun C1 () Bool (and (is-IntVal x) (>= (ival x) 0)))
(define-fun C2 () Bool (and (is-IntVal base) (<= 2 (ival base) 9)))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/45 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeToReal ((v Value)) Real
  (ite (is-IntVal v)
       (to_real (ival v))
       (ite (is-FloatVal v)
            (fval v)
            0.0)))

; === Inputs ===
(declare-const a Value)
(declare-const h Value)

; === BASIC STRUCTURE ===
(assert (or (is-IntVal a) (is-FloatVal a)))
(assert (or (is-IntVal h) (is-FloatVal h)))

; === Contract predicates ===
(define-fun C0 () Bool
  (and (or (is-IntVal a) (is-FloatVal a))
       (or (is-IntVal h) (is-FloatVal h))))
(define-fun C1 () Bool
  (and (> (SafeToReal a) 0)
       (> (SafeToReal h) 0)))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'h': 1, 'a': 0}
    Solution 2:
      test_case: {'h': -1, 'a': 30612}
    Solution 3:
      test_case: {'h': -1.5, 'a': -2}
    Solution 4:
      test_case: {'h': -1.25, 'a': -2}
    Solution 5:
      test_case: {'h': -31892.5, 'a': -31893}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeToReal ((v Value)) Real
  (ite (is-IntVal v)
       (to_real (ival v))
       (ite (is-FloatVal v)
            (fval v)
            0.0)))

; === Inputs ===
(declare-const a Value)
(declare-const h Value)

; === BASIC STRUCTURE ===
(assert (or (is-IntVal a) (is-FloatVal a)))
(assert (or (is-IntVal h) (is-FloatVal h)))

; === Contract predicates ===
(define-fun C0 () Bool
  (and (or (is-IntVal a) (is-FloatVal a))
       (or (is-IntVal h) (is-FloatVal h))))
(define-fun C1 () Bool
  (and (> (SafeToReal a) 0)
       (> (SafeToReal h) 0)))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeToReal ((v Value)) Real
  (ite (is-IntVal v)
       (to_real (ival v))
       (ite (is-FloatVal v)
            (fval v)
            0.0)))

; === Inputs ===
(declare-const a Value)
(declare-const h Value)

; === BASIC STRUCTURE ===
(assert (or (is-IntVal a) (is-FloatVal a)))
(assert (or (is-IntVal h) (is-FloatVal h)))

; === Contract predicates ===
(define-fun C0 () Bool
  (and (or (is-IntVal a) (is-FloatVal a))
       (or (is-IntVal h) (is-FloatVal h))))
(define-fun C1 () Bool
  (and (> (SafeToReal a) 0)
       (> (SafeToReal h) 0)))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'h': 282, 'a': 1}
    Solution 2:
      test_case: {'h': 20538, 'a': 282}
    Solution 3:
      test_case: {'h': 52429, 'a': 282.5}
    Solution 4:
      test_case: {'h': 52429, 'a': 282.25}
    Solution 5:
      test_case: {'h': 52429, 'a': 282.125}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeToReal ((v Value)) Real
  (ite (is-IntVal v)
       (to_real (ival v))
       (ite (is-FloatVal v)
            (fval v)
            0.0)))

; === Inputs ===
(declare-const a Value)
(declare-const h Value)

; === BASIC STRUCTURE ===
(assert (or (is-IntVal a) (is-FloatVal a)))
(assert (or (is-IntVal h) (is-FloatVal h)))

; === Contract predicates ===
(define-fun C0 () Bool
  (and (or (is-IntVal a) (is-FloatVal a))
       (or (is-IntVal h) (is-FloatVal h))))
(define-fun C1 () Bool
  (and (> (SafeToReal a) 0)
       (> (SafeToReal h) 0)))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/46 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===
(assert (is-IntVal n))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))
(define-fun C1 () Bool (>= (SafeI n) 0))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'n': -1}
    Solution 2:
      test_case: {'n': -7720}
    Solution 3:
      test_case: {'n': -10157}
    Solution 4:
      test_case: {'n': -21954}
    Solution 5:
      test_case: {'n': -54239}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===
(assert (is-IntVal n))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))
(define-fun C1 () Bool (>= (SafeI n) 0))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===
(assert (is-IntVal n))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))
(define-fun C1 () Bool (>= (SafeI n) 0))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'n': 0}
    Solution 2:
      test_case: {'n': 7719}
    Solution 3:
      test_case: {'n': 10156}
    Solution 4:
      test_case: {'n': 21953}
    Solution 5:
      test_case: {'n': 54238}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===
(assert (is-IntVal n))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))
(define-fun C1 () Bool (>= (SafeI n) 0))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/47 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v) (isList (tail v)) false)))

(define-fun-rec length ((l Value)) Int
  (ite (is-Nil l) 0
    (ite (is-Cons l) (+ 1 (length (tail l))) 0)))

(define-fun-rec all_numeric ((l Value)) Bool
  (ite (is-Nil l) true
    (ite (is-Cons l)
      (and (or (is-IntVal (head l)) (is-FloatVal (head l)))
           (all_numeric (tail l)))
      false)))

; === Inputs ===
(declare-const l Value)

; === BASIC STRUCTURE ===
(assert (isList l))

; === Contract predicates ===
(define-fun C0 () Bool (> (length l) 0))
(define-fun C1 () Bool (all_numeric l))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'l': ['!0!']}
    Solution 2:
      test_case: {'l': ['!']}
    Solution 3:
      test_case: {'l': ['0']}
    Solution 4:
      test_case: {'l': ['0!']}
    Solution 5:
      test_case: {'l': ['']}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v) (isList (tail v)) false)))

(define-fun-rec length ((l Value)) Int
  (ite (is-Nil l) 0
    (ite (is-Cons l) (+ 1 (length (tail l))) 0)))

(define-fun-rec all_numeric ((l Value)) Bool
  (ite (is-Nil l) true
    (ite (is-Cons l)
      (and (or (is-IntVal (head l)) (is-FloatVal (head l)))
           (all_numeric (tail l)))
      false)))

; === Inputs ===
(declare-const l Value)

; === BASIC STRUCTURE ===
(assert (isList l))

; === Contract predicates ===
(define-fun C0 () Bool (> (length l) 0))
(define-fun C1 () Bool (all_numeric l))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: True
  Solution Count: 1
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'l': []}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v) (isList (tail v)) false)))

(define-fun-rec length ((l Value)) Int
  (ite (is-Nil l) 0
    (ite (is-Cons l) (+ 1 (length (tail l))) 0)))

(define-fun-rec all_numeric ((l Value)) Bool
  (ite (is-Nil l) true
    (ite (is-Cons l)
      (and (or (is-IntVal (head l)) (is-FloatVal (head l)))
           (all_numeric (tail l)))
      false)))

; === Inputs ===
(declare-const l Value)

; === BASIC STRUCTURE ===
(assert (isList l))

; === Contract predicates ===
(define-fun C0 () Bool (> (length l) 0))
(define-fun C1 () Bool (all_numeric l))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'l': [4]}
    Solution 2:
      test_case: {'l': [5]}
    Solution 3:
      test_case: {'l': [6]}
    Solution 4:
      test_case: {'l': [7]}
    Solution 5:
      test_case: {'l': [8]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v) (isList (tail v)) false)))

(define-fun-rec length ((l Value)) Int
  (ite (is-Nil l) 0
    (ite (is-Cons l) (+ 1 (length (tail l))) 0)))

(define-fun-rec all_numeric ((l Value)) Bool
  (ite (is-Nil l) true
    (ite (is-Cons l)
      (and (or (is-IntVal (head l)) (is-FloatVal (head l)))
           (all_numeric (tail l)))
      false)))

; === Inputs ===
(declare-const l Value)

; === BASIC STRUCTURE ===
(assert (isList l))

; === Contract predicates ===
(define-fun C0 () Bool (> (length l) 0))
(define-fun C1 () Bool (all_numeric l))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/48 ===
  Test Case 1: satisfied_, violated_assert_0
  Combination: {'assert_0': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0'], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'text': 2.0}
    Solution 2:
      test_case: {'text': 3.0}
    Solution 3:
      test_case: {'text': 4.0}
    Solution 4:
      test_case: {'text': 5.0}
    Solution 5:
      test_case: {'text': 6.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeS ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

(define-fun-rec rev ((s String)) String
  (ite (= (str.len s) 0) ""
    (str.++ (str.substr s (- (str.len s) 1) 1)
      (rev (str.substr s 0 (- (str.len s) 1))))))

(define-fun is_palindrome_fn ((v Value)) Bool
  (= (SafeS v) (rev (SafeS v))))

; === Inputs ===
(declare-const text Value)

; === BASIC STRUCTURE ===
(assert true)

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal text))

; === COMBINATION ===
(assert (not C0))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_
  Combination: {'assert_0': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': [], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'text': '!0!'}
    Solution 2:
      test_case: {'text': '!'}
    Solution 3:
      test_case: {'text': '0'}
    Solution 4:
      test_case: {'text': '0!'}
    Solution 5:
      test_case: {'text': ''}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeS ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

(define-fun-rec rev ((s String)) String
  (ite (= (str.len s) 0) ""
    (str.++ (str.substr s (- (str.len s) 1) 1)
      (rev (str.substr s 0 (- (str.len s) 1))))))

(define-fun is_palindrome_fn ((v Value)) Bool
  (= (SafeS v) (rev (SafeS v))))

; === Inputs ===
(declare-const text Value)

; === BASIC STRUCTURE ===
(assert true)

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal text))

; === COMBINATION ===
(assert C0)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/49 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'n': -1, 'p': 2.0}
    Solution 2:
      test_case: {'n': 3.0, 'p': 4.0}
    Solution 3:
      test_case: {'n': 5.0, 'p': 6.0}
    Solution 4:
      test_case: {'n': 8.0, 'p': 7.0}
    Solution 5:
      test_case: {'n': -1, 'p': 9.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeIval ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const n Value)
(declare-const p Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (is-IntVal n) (is-IntVal p)))
(define-fun C1 () Bool (and (>= (SafeIval n) 0) (>= (SafeIval p) 1)))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'n': 0, 'p': -21238}
    Solution 2:
      test_case: {'n': 0, 'p': -21237}
    Solution 3:
      test_case: {'n': 0, 'p': -21239}
    Solution 4:
      test_case: {'n': 0, 'p': -51851}
    Solution 5:
      test_case: {'n': 0, 'p': -52993}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeIval ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const n Value)
(declare-const p Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (is-IntVal n) (is-IntVal p)))
(define-fun C1 () Bool (and (>= (SafeIval n) 0) (>= (SafeIval p) 1)))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'n': 2.0, 'p': 1}
    Solution 2:
      test_case: {'n': 3.0, 'p': 7720}
    Solution 3:
      test_case: {'n': 4.0, 'p': 10157}
    Solution 4:
      test_case: {'n': 5.0, 'p': 21954}
    Solution 5:
      test_case: {'n': 6.0, 'p': 54239}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeIval ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const n Value)
(declare-const p Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (is-IntVal n) (is-IntVal p)))
(define-fun C1 () Bool (and (>= (SafeIval n) 0) (>= (SafeIval p) 1)))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'n': 0, 'p': 1}
    Solution 2:
      test_case: {'n': 7719, 'p': 21239}
    Solution 3:
      test_case: {'n': 7719, 'p': 30094}
    Solution 4:
      test_case: {'n': 7719, 'p': 38459}
    Solution 5:
      test_case: {'n': 18169, 'p': 38459}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeIval ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const n Value)
(declare-const p Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (is-IntVal n) (is-IntVal p)))
(define-fun C1 () Bool (and (>= (SafeIval n) 0) (>= (SafeIval p) 1)))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/50 ===
  Test Case 1: satisfied_, violated_assert_0
  Combination: {'assert_0': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0'], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'s': 2.0}
    Solution 2:
      test_case: {'s': 3.0}
    Solution 3:
      test_case: {'s': 4.0}
    Solution 4:
      test_case: {'s': 5.0}
    Solution 5:
      test_case: {'s': 6.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec all_lower ((str String) (i Int)) Bool
  (ite (= i (str.len str))
       true
       (and (str.in.re (str.substr str i 1) (str.to.re "[a-z]"))
            (all_lower str (+ i 1)))))

(define-fun is_lower ((str String)) Bool
  (and (> (str.len str) 0)
       (all_lower str 0)))

; === Inputs ===
(declare-const s Value)

; === BASIC STRUCTURE ===
(is-StrVal s)

; === Contract predicates ===
(define-fun C0 () Bool
  (let ((str (sval s)))
    (or (= str "")
        (is_lower str))))

; === COMBINATION ===
(assert (not C0))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_
  Combination: {'assert_0': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': [], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'s': 2.0}
    Solution 2:
      test_case: {'s': 3.0}
    Solution 3:
      test_case: {'s': 4.0}
    Solution 4:
      test_case: {'s': 5.0}
    Solution 5:
      test_case: {'s': 6.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec all_lower ((str String) (i Int)) Bool
  (ite (= i (str.len str))
       true
       (and (str.in.re (str.substr str i 1) (str.to.re "[a-z]"))
            (all_lower str (+ i 1)))))

(define-fun is_lower ((str String)) Bool
  (and (> (str.len str) 0)
       (all_lower str 0)))

; === Inputs ===
(declare-const s Value)

; === BASIC STRUCTURE ===
(is-StrVal s)

; === Contract predicates ===
(define-fun C0 () Bool
  (let ((str (sval s)))
    (or (= str "")
        (is_lower str))))

; === COMBINATION ===
(assert C0)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/51 ===
  Test Case 1: satisfied_, violated_assert_0
  Combination: {'assert_0': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0'], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'text': 2.0}
    Solution 2:
      test_case: {'text': 3.0}
    Solution 3:
      test_case: {'text': 4.0}
    Solution 4:
      test_case: {'text': 5.0}
    Solution 5:
      test_case: {'text': 6.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const text Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal text))

; === COMBINATION ===
(assert (not C0))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_
  Combination: {'assert_0': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': [], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'text': '!0!'}
    Solution 2:
      test_case: {'text': '!'}
    Solution 3:
      test_case: {'text': '0'}
    Solution 4:
      test_case: {'text': '0!'}
    Solution 5:
      test_case: {'text': ''}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const text Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal text))

; === COMBINATION ===
(assert C0)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/52 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1;assert_2
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2'], 'total_contracts': 3}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (isList (tail v))
            false)))

(define-fun isNumeric ((v Value)) Bool
  (or (is-IntVal v)
      (is-FloatVal v)
      (is-BoolVal v)))

(define-fun-rec list_all_numeric ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (isNumeric (head v))
                 (list_all_numeric (tail v)))
            false)))

; === Inputs ===
(declare-const l Value)
(declare-const t Value)

; === BASIC STRUCTURE ===
(assert (isList l))

; === Contract predicates ===
(define-fun C0 () Bool (isList l))
(define-fun C1 () Bool (is-IntVal t))
(define-fun C2 () Bool (list_all_numeric l))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1;assert_2
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1', 'assert_2'], 'total_contracts': 3}
  Solutions:
    Solution 1:
      test_case: {'l': ['!0!'], 't': 2.0}
    Solution 2:
      test_case: {'l': ['!'], 't': 3.0}
    Solution 3:
      test_case: {'l': ['0'], 't': 4.0}
    Solution 4:
      test_case: {'l': ['0!'], 't': 5.0}
    Solution 5:
      test_case: {'l': ['A'], 't': 6.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (isList (tail v))
            false)))

(define-fun isNumeric ((v Value)) Bool
  (or (is-IntVal v)
      (is-FloatVal v)
      (is-BoolVal v)))

(define-fun-rec list_all_numeric ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (isNumeric (head v))
                 (list_all_numeric (tail v)))
            false)))

; === Inputs ===
(declare-const l Value)
(declare-const t Value)

; === BASIC STRUCTURE ===
(assert (isList l))

; === Contract predicates ===
(define-fun C0 () Bool (isList l))
(define-fun C1 () Bool (is-IntVal t))
(define-fun C2 () Bool (list_all_numeric l))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0;assert_2
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0', 'assert_2'], 'total_contracts': 3}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (isList (tail v))
            false)))

(define-fun isNumeric ((v Value)) Bool
  (or (is-IntVal v)
      (is-FloatVal v)
      (is-BoolVal v)))

(define-fun-rec list_all_numeric ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (isNumeric (head v))
                 (list_all_numeric (tail v)))
            false)))

; === Inputs ===
(declare-const l Value)
(declare-const t Value)

; === BASIC STRUCTURE ===
(assert (isList l))

; === Contract predicates ===
(define-fun C0 () Bool (isList l))
(define-fun C1 () Bool (is-IntVal t))
(define-fun C2 () Bool (list_all_numeric l))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_assert_2
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': ['assert_2'], 'total_contracts': 3}
  Solutions:
    Solution 1:
      test_case: {'l': ['!0!'], 't': 2}
    Solution 2:
      test_case: {'l': ['!'], 't': 3}
    Solution 3:
      test_case: {'l': ['0'], 't': 4}
    Solution 4:
      test_case: {'l': ['0!'], 't': 5}
    Solution 5:
      test_case: {'l': [''], 't': 6}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (isList (tail v))
            false)))

(define-fun isNumeric ((v Value)) Bool
  (or (is-IntVal v)
      (is-FloatVal v)
      (is-BoolVal v)))

(define-fun-rec list_all_numeric ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (isNumeric (head v))
                 (list_all_numeric (tail v)))
            false)))

; === Inputs ===
(declare-const l Value)
(declare-const t Value)

; === BASIC STRUCTURE ===
(assert (isList l))

; === Contract predicates ===
(define-fun C0 () Bool (isList l))
(define-fun C1 () Bool (is-IntVal t))
(define-fun C2 () Bool (list_all_numeric l))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))

(check-sat)
(get-model)

------------------------------
  Test Case 5: satisfied_assert_2, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_2'], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 3}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (isList (tail v))
            false)))

(define-fun isNumeric ((v Value)) Bool
  (or (is-IntVal v)
      (is-FloatVal v)
      (is-BoolVal v)))

(define-fun-rec list_all_numeric ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (isNumeric (head v))
                 (list_all_numeric (tail v)))
            false)))

; === Inputs ===
(declare-const l Value)
(declare-const t Value)

; === BASIC STRUCTURE ===
(assert (isList l))

; === Contract predicates ===
(define-fun C0 () Bool (isList l))
(define-fun C1 () Bool (is-IntVal t))
(define-fun C2 () Bool (list_all_numeric l))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)

(check-sat)
(get-model)

------------------------------
  Test Case 6: satisfied_assert_0;assert_2, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2'], 'violated_contracts': ['assert_1'], 'total_contracts': 3}
  Solutions:
    Solution 1:
      test_case: {'l': [], 't': 2.0}
    Solution 2:
      test_case: {'l': [], 't': 3.0}
    Solution 3:
      test_case: {'l': [], 't': 4.0}
    Solution 4:
      test_case: {'l': [], 't': 5.0}
    Solution 5:
      test_case: {'l': [], 't': 6.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (isList (tail v))
            false)))

(define-fun isNumeric ((v Value)) Bool
  (or (is-IntVal v)
      (is-FloatVal v)
      (is-BoolVal v)))

(define-fun-rec list_all_numeric ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (isNumeric (head v))
                 (list_all_numeric (tail v)))
            false)))

; === Inputs ===
(declare-const l Value)
(declare-const t Value)

; === BASIC STRUCTURE ===
(assert (isList l))

; === Contract predicates ===
(define-fun C0 () Bool (isList l))
(define-fun C1 () Bool (is-IntVal t))
(define-fun C2 () Bool (list_all_numeric l))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)

(check-sat)
(get-model)

------------------------------
  Test Case 7: satisfied_assert_1;assert_2, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2'], 'violated_contracts': ['assert_0'], 'total_contracts': 3}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (isList (tail v))
            false)))

(define-fun isNumeric ((v Value)) Bool
  (or (is-IntVal v)
      (is-FloatVal v)
      (is-BoolVal v)))

(define-fun-rec list_all_numeric ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (isNumeric (head v))
                 (list_all_numeric (tail v)))
            false)))

; === Inputs ===
(declare-const l Value)
(declare-const t Value)

; === BASIC STRUCTURE ===
(assert (isList l))

; === Contract predicates ===
(define-fun C0 () Bool (isList l))
(define-fun C1 () Bool (is-IntVal t))
(define-fun C2 () Bool (list_all_numeric l))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)

(check-sat)
(get-model)

------------------------------
  Test Case 8: satisfied_assert_0;assert_1;assert_2, violated_
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2'], 'violated_contracts': [], 'total_contracts': 3}
  Solutions:
    Solution 1:
      test_case: {'l': [], 't': 2}
    Solution 2:
      test_case: {'l': [], 't': 3}
    Solution 3:
      test_case: {'l': [], 't': 4}
    Solution 4:
      test_case: {'l': [], 't': 5}
    Solution 5:
      test_case: {'l': [], 't': 6}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (isList (tail v))
            false)))

(define-fun isNumeric ((v Value)) Bool
  (or (is-IntVal v)
      (is-FloatVal v)
      (is-BoolVal v)))

(define-fun-rec list_all_numeric ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (isNumeric (head v))
                 (list_all_numeric (tail v)))
            false)))

; === Inputs ===
(declare-const l Value)
(declare-const t Value)

; === BASIC STRUCTURE ===
(assert (isList l))

; === Contract predicates ===
(define-fun C0 () Bool (isList l))
(define-fun C1 () Bool (is-IntVal t))
(define-fun C2 () Bool (list_all_numeric l))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/53 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'x': 2.0, 'y': 3.0}
    Solution 2:
      test_case: {'x': 5.0, 'y': 4.0}
    Solution 3:
      test_case: {'x': 7.0, 'y': 6.0}
    Solution 4:
      test_case: {'x': 9.0, 'y': 8.0}
    Solution 5:
      test_case: {'x': 11.0, 'y': 10.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const x Value)
(declare-const y Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal x))
(define-fun C1 () Bool (is-IntVal y))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'x': 2, 'y': 2.0}
    Solution 2:
      test_case: {'x': 3, 'y': 3.0}
    Solution 3:
      test_case: {'x': 4, 'y': 4.0}
    Solution 4:
      test_case: {'x': 5, 'y': 5.0}
    Solution 5:
      test_case: {'x': 6, 'y': 6.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const x Value)
(declare-const y Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal x))
(define-fun C1 () Bool (is-IntVal y))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'x': 2.0, 'y': 2}
    Solution 2:
      test_case: {'x': 3.0, 'y': 3}
    Solution 3:
      test_case: {'x': 4.0, 'y': 4}
    Solution 4:
      test_case: {'x': 5.0, 'y': 5}
    Solution 5:
      test_case: {'x': 6.0, 'y': 6}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const x Value)
(declare-const y Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal x))
(define-fun C1 () Bool (is-IntVal y))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'x': 2, 'y': 3}
    Solution 2:
      test_case: {'x': 4, 'y': 5}
    Solution 3:
      test_case: {'x': 6, 'y': 7}
    Solution 4:
      test_case: {'x': 8, 'y': 9}
    Solution 5:
      test_case: {'x': 10, 'y': 11}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const x Value)
(declare-const y Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal x))
(define-fun C1 () Bool (is-IntVal y))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/54 ===
  Test Case 1: satisfied_, violated_assert_0
  Combination: {'assert_0': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0'], 'total_contracts': 1}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const s0 Value)
(declare-const s1 Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal s0))
(assert (is-StrVal s1))

; === Contract predicates ===
(define-fun C0 () Bool (and (is-StrVal s0) (is-StrVal s1)))

; === COMBINATION ===
(assert (not C0))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_
  Combination: {'assert_0': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': [], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'s1': '!0!', 's0': '!0!'}
    Solution 2:
      test_case: {'s1': '0', 's0': '!'}
    Solution 3:
      test_case: {'s1': '0!', 's0': '0!'}
    Solution 4:
      test_case: {'s1': '!', 's0': ''}
    Solution 5:
      test_case: {'s1': 'A', 's0': ''}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const s0 Value)
(declare-const s1 Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal s0))
(assert (is-StrVal s1))

; === Contract predicates ===
(define-fun C0 () Bool (and (is-StrVal s0) (is-StrVal s1)))

; === COMBINATION ===
(assert C0)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/55 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (>= (SafeI n) 0))
(define-fun C1 () Bool (is-IntVal n))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'n': 2.0}
    Solution 2:
      test_case: {'n': 3.0}
    Solution 3:
      test_case: {'n': 4.0}
    Solution 4:
      test_case: {'n': 5.0}
    Solution 5:
      test_case: {'n': 6.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (>= (SafeI n) 0))
(define-fun C1 () Bool (is-IntVal n))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'n': -1}
    Solution 2:
      test_case: {'n': -7720}
    Solution 3:
      test_case: {'n': -10157}
    Solution 4:
      test_case: {'n': -21954}
    Solution 5:
      test_case: {'n': -54239}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (>= (SafeI n) 0))
(define-fun C1 () Bool (is-IntVal n))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'n': 0}
    Solution 2:
      test_case: {'n': 7719}
    Solution 3:
      test_case: {'n': 10156}
    Solution 4:
      test_case: {'n': 21953}
    Solution 5:
      test_case: {'n': 54238}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (>= (SafeI n) 0))
(define-fun C1 () Bool (is-IntVal n))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/56 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeS ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

(define-fun-rec allAngleChars ((s String)) Bool
  (ite (= (str.len s) 0)
       true
       (let ((c (str.substr s 0 1))
             (rest (str.substr s 1 (- (str.len s) 1))))
         (and (or (= c "<") (= c ">"))
              (allAngleChars rest)))))

; === Inputs ===
(declare-const brackets Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal brackets))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal brackets))
(define-fun C1 () Bool (allAngleChars (SafeS brackets)))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'brackets': 'A'}
    Solution 2:
      test_case: {'brackets': 'B'}
    Solution 3:
      test_case: {'brackets': 'C'}
    Solution 4:
      test_case: {'brackets': 'D'}
    Solution 5:
      test_case: {'brackets': 'E'}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeS ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

(define-fun-rec allAngleChars ((s String)) Bool
  (ite (= (str.len s) 0)
       true
       (let ((c (str.substr s 0 1))
             (rest (str.substr s 1 (- (str.len s) 1))))
         (and (or (= c "<") (= c ">"))
              (allAngleChars rest)))))

; === Inputs ===
(declare-const brackets Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal brackets))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal brackets))
(define-fun C1 () Bool (allAngleChars (SafeS brackets)))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeS ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

(define-fun-rec allAngleChars ((s String)) Bool
  (ite (= (str.len s) 0)
       true
       (let ((c (str.substr s 0 1))
             (rest (str.substr s 1 (- (str.len s) 1))))
         (and (or (= c "<") (= c ">"))
              (allAngleChars rest)))))

; === Inputs ===
(declare-const brackets Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal brackets))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal brackets))
(define-fun C1 () Bool (allAngleChars (SafeS brackets)))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'brackets': ''}
    Solution 2:
      test_case: {'brackets': '<'}
    Solution 3:
      test_case: {'brackets': '>'}
    Solution 4:
      test_case: {'brackets': '><'}
    Solution 5:
      test_case: {'brackets': '>>'}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeS ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

(define-fun-rec allAngleChars ((s String)) Bool
  (ite (= (str.len s) 0)
       true
       (let ((c (str.substr s 0 1))
             (rest (str.substr s 1 (- (str.len s) 1))))
         (and (or (= c "<") (= c ">"))
              (allAngleChars rest)))))

; === Inputs ===
(declare-const brackets Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal brackets))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal brackets))
(define-fun C1 () Bool (allAngleChars (SafeS brackets)))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/57 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))
(define-fun-rec AllNum ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (let ((headv (head v)) (tailv (tail v)))
              (and (or (is-IntVal headv)
                       (is-FloatVal headv)
                       (is-BoolVal headv))
                   (AllNum tailv)))
            false)))

; === Inputs ===
(declare-const l Value)

; === BASIC STRUCTURE ===
(assert (IsList l))

; === Contract predicates ===
(define-fun C0 () Bool (IsList l))
(define-fun C1 () Bool (AllNum l))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'l': ['!0!']}
    Solution 2:
      test_case: {'l': ['!']}
    Solution 3:
      test_case: {'l': ['0']}
    Solution 4:
      test_case: {'l': ['0!']}
    Solution 5:
      test_case: {'l': ['']}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))
(define-fun-rec AllNum ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (let ((headv (head v)) (tailv (tail v)))
              (and (or (is-IntVal headv)
                       (is-FloatVal headv)
                       (is-BoolVal headv))
                   (AllNum tailv)))
            false)))

; === Inputs ===
(declare-const l Value)

; === BASIC STRUCTURE ===
(assert (IsList l))

; === Contract predicates ===
(define-fun C0 () Bool (IsList l))
(define-fun C1 () Bool (AllNum l))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))
(define-fun-rec AllNum ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (let ((headv (head v)) (tailv (tail v)))
              (and (or (is-IntVal headv)
                       (is-FloatVal headv)
                       (is-BoolVal headv))
                   (AllNum tailv)))
            false)))

; === Inputs ===
(declare-const l Value)

; === BASIC STRUCTURE ===
(assert (IsList l))

; === Contract predicates ===
(define-fun C0 () Bool (IsList l))
(define-fun C1 () Bool (AllNum l))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'l': []}
    Solution 2:
      test_case: {'l': [2]}
    Solution 3:
      test_case: {'l': [2.0]}
    Solution 4:
      test_case: {'l': [3]}
    Solution 5:
      test_case: {'l': [3.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))
(define-fun-rec AllNum ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (let ((headv (head v)) (tailv (tail v)))
              (and (or (is-IntVal headv)
                       (is-FloatVal headv)
                       (is-BoolVal headv))
                   (AllNum tailv)))
            false)))

; === Inputs ===
(declare-const l Value)

; === BASIC STRUCTURE ===
(assert (IsList l))

; === Contract predicates ===
(define-fun C0 () Bool (IsList l))
(define-fun C1 () Bool (AllNum l))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/58 ===
  Test Case 1: satisfied_, violated_assert_0
  Combination: {'assert_0': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0'], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'l2': 2.0}
    Solution 2:
      test_case: {'l2': 3.0}
    Solution 3:
      test_case: {'l1': 4.0, 'l2': 2}
    Solution 4:
      test_case: {'l1': 3, 'l2': 5.0}
    Solution 5:
      test_case: {'l1': 6.0, 'l2': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
    true
    (ite (is-Cons v)
      (IsList (tail v))
      false)))

; === Inputs ===
(declare-const l1 Value)
(declare-const l2 Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (IsList l1) (IsList l2)))

; === COMBINATION ===
(assert (not C0))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_
  Combination: {'assert_0': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': [], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'l1': [], 'l2': []}
    Solution 2:
      test_case: {'l1': [], 'l2': [2.0]}
    Solution 3:
      test_case: {'l1': [], 'l2': [3.0]}
    Solution 4:
      test_case: {'l1': [], 'l2': [4.0]}
    Solution 5:
      test_case: {'l1': [], 'l2': [5.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
    true
    (ite (is-Cons v)
      (IsList (tail v))
      false)))

; === Inputs ===
(declare-const l1 Value)
(declare-const l2 Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (IsList l1) (IsList l2)))

; === COMBINATION ===
(assert C0)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/59 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'n': 2.0}
    Solution 2:
      test_case: {'n': 3.0}
    Solution 3:
      test_case: {'n': 4.0}
    Solution 4:
      test_case: {'n': 5.0}
    Solution 5:
      test_case: {'n': 6.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun is_prime ((a Value)) Bool
  (ite (is-IntVal a)
       (let ((ai (ival a)))
         (and (>= ai 2)
              (not (exists ((x Int))
                       (and (>= x 2)
                            (<= (* x x) ai)
                            (= (mod ai x) 0))))))
       false))

; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))
(define-fun C1 () Bool
  (let ((ai (ite (is-IntVal n) (ival n) 0)))
    (and (> ai 1)
         (not (is_prime n)))))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'n': 0}
    Solution 2:
      test_case: {'n': -21238}
    Solution 3:
      test_case: {'n': -33035}
    Solution 4:
      test_case: {'n': -43485}
    Solution 5:
      test_case: {'n': -71585}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun is_prime ((a Value)) Bool
  (ite (is-IntVal a)
       (let ((ai (ival a)))
         (and (>= ai 2)
              (not (exists ((x Int))
                       (and (>= x 2)
                            (<= (* x x) ai)
                            (= (mod ai x) 0))))))
       false))

; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))
(define-fun C1 () Bool
  (let ((ai (ite (is-IntVal n) (ival n) 0)))
    (and (> ai 1)
         (not (is_prime n)))))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun is_prime ((a Value)) Bool
  (ite (is-IntVal a)
       (let ((ai (ival a)))
         (and (>= ai 2)
              (not (exists ((x Int))
                       (and (>= x 2)
                            (<= (* x x) ai)
                            (= (mod ai x) 0))))))
       false))

; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))
(define-fun C1 () Bool
  (let ((ai (ite (is-IntVal n) (ival n) 0)))
    (and (> ai 1)
         (not (is_prime n)))))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'n': 4}
    Solution 2:
      test_case: {'n': 9}
    Solution 3:
      test_case: {'n': 20}
    Solution 4:
      test_case: {'n': 21}
    Solution 5:
      test_case: {'n': 10}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun is_prime ((a Value)) Bool
  (ite (is-IntVal a)
       (let ((ai (ival a)))
         (and (>= ai 2)
              (not (exists ((x Int))
                       (and (>= x 2)
                            (<= (* x x) ai)
                            (= (mod ai x) 0))))))
       false))

; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))
(define-fun C1 () Bool
  (let ((ai (ite (is-IntVal n) (ival n) 0)))
    (and (> ai 1)
         (not (is_prime n)))))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/60 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'n': 2.0}
    Solution 2:
      test_case: {'n': 3.0}
    Solution 3:
      test_case: {'n': 4.0}
    Solution 4:
      test_case: {'n': 5.0}
    Solution 5:
      test_case: {'n': 6.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))
(define-fun C1 () Bool (>= (SafeI n) 1))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'n': 0}
    Solution 2:
      test_case: {'n': -7719}
    Solution 3:
      test_case: {'n': -10156}
    Solution 4:
      test_case: {'n': -21953}
    Solution 5:
      test_case: {'n': -54238}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))
(define-fun C1 () Bool (>= (SafeI n) 1))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))
(define-fun C1 () Bool (>= (SafeI n) 1))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'n': 1}
    Solution 2:
      test_case: {'n': 7720}
    Solution 3:
      test_case: {'n': 10157}
    Solution 4:
      test_case: {'n': 21954}
    Solution 5:
      test_case: {'n': 54239}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))
(define-fun C1 () Bool (>= (SafeI n) 1))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/61 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'brackets': 2.0}
    Solution 2:
      test_case: {'brackets': 3.0}
    Solution 3:
      test_case: {'brackets': 4.0}
    Solution 4:
      test_case: {'brackets': 5.0}
    Solution 5:
      test_case: {'brackets': 6.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeS ((v Value)) String (ite (is-StrVal v) (sval v) ""))

; === Inputs ===
(declare-const brackets Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal brackets))
(define-fun C1 () Bool (let ((s (SafeS brackets))) (str.in.re s (str.to.re "^[()]*$"))))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'brackets': '^'}
    Solution 2:
      test_case: {'brackets': '['}
    Solution 3:
      test_case: {'brackets': '('}
    Solution 4:
      test_case: {'brackets': ')'}
    Solution 5:
      test_case: {'brackets': ']'}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeS ((v Value)) String (ite (is-StrVal v) (sval v) ""))

; === Inputs ===
(declare-const brackets Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal brackets))
(define-fun C1 () Bool (let ((s (SafeS brackets))) (str.in.re s (str.to.re "^[()]*$"))))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeS ((v Value)) String (ite (is-StrVal v) (sval v) ""))

; === Inputs ===
(declare-const brackets Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal brackets))
(define-fun C1 () Bool (let ((s (SafeS brackets))) (str.in.re s (str.to.re "^[()]*$"))))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 1
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'brackets': '^[()]*$'}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeS ((v Value)) String (ite (is-StrVal v) (sval v) ""))

; === Inputs ===
(declare-const brackets Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal brackets))
(define-fun C1 () Bool (let ((s (SafeS brackets))) (str.in.re s (str.to.re "^[()]*$"))))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/62 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun is_List ((v Value)) Bool (or (is-Nil v) (is-Cons v)))
(define-fun-rec length ((l Value)) Int
  (ite (is-Nil l) 0
    (ite (is-Cons l)
      (let ((restLen (length (tail l))))
        (+ restLen 1))
      0)))
(define-fun-rec list_all_numeric ((l Value)) Bool
  (ite (is-Nil l) true
    (ite (is-Cons l)
      (let ((hd (head l)) (tl (tail l)))
        (and (or (is-IntVal hd) (is-FloatVal hd))
             (list_all_numeric tl)))
      false)))

; === Inputs ===
(declare-const xs Value)

; === BASIC STRUCTURE ===
(assert (is_List xs))

; === Contract predicates ===
(define-fun C0 () Bool (> (length xs) 0))
(define-fun C1 () Bool (list_all_numeric xs))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'xs': ['!0!']}
    Solution 2:
      test_case: {'xs': ['!']}
    Solution 3:
      test_case: {'xs': ['0']}
    Solution 4:
      test_case: {'xs': ['0!']}
    Solution 5:
      test_case: {'xs': ['']}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun is_List ((v Value)) Bool (or (is-Nil v) (is-Cons v)))
(define-fun-rec length ((l Value)) Int
  (ite (is-Nil l) 0
    (ite (is-Cons l)
      (let ((restLen (length (tail l))))
        (+ restLen 1))
      0)))
(define-fun-rec list_all_numeric ((l Value)) Bool
  (ite (is-Nil l) true
    (ite (is-Cons l)
      (let ((hd (head l)) (tl (tail l)))
        (and (or (is-IntVal hd) (is-FloatVal hd))
             (list_all_numeric tl)))
      false)))

; === Inputs ===
(declare-const xs Value)

; === BASIC STRUCTURE ===
(assert (is_List xs))

; === Contract predicates ===
(define-fun C0 () Bool (> (length xs) 0))
(define-fun C1 () Bool (list_all_numeric xs))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: True
  Solution Count: 1
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'xs': []}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun is_List ((v Value)) Bool (or (is-Nil v) (is-Cons v)))
(define-fun-rec length ((l Value)) Int
  (ite (is-Nil l) 0
    (ite (is-Cons l)
      (let ((restLen (length (tail l))))
        (+ restLen 1))
      0)))
(define-fun-rec list_all_numeric ((l Value)) Bool
  (ite (is-Nil l) true
    (ite (is-Cons l)
      (let ((hd (head l)) (tl (tail l)))
        (and (or (is-IntVal hd) (is-FloatVal hd))
             (list_all_numeric tl)))
      false)))

; === Inputs ===
(declare-const xs Value)

; === BASIC STRUCTURE ===
(assert (is_List xs))

; === Contract predicates ===
(define-fun C0 () Bool (> (length xs) 0))
(define-fun C1 () Bool (list_all_numeric xs))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'xs': [2.0]}
    Solution 2:
      test_case: {'xs': [3.0]}
    Solution 3:
      test_case: {'xs': [4.0]}
    Solution 4:
      test_case: {'xs': [5.0]}
    Solution 5:
      test_case: {'xs': [6.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun is_List ((v Value)) Bool (or (is-Nil v) (is-Cons v)))
(define-fun-rec length ((l Value)) Int
  (ite (is-Nil l) 0
    (ite (is-Cons l)
      (let ((restLen (length (tail l))))
        (+ restLen 1))
      0)))
(define-fun-rec list_all_numeric ((l Value)) Bool
  (ite (is-Nil l) true
    (ite (is-Cons l)
      (let ((hd (head l)) (tl (tail l)))
        (and (or (is-IntVal hd) (is-FloatVal hd))
             (list_all_numeric tl)))
      false)))

; === Inputs ===
(declare-const xs Value)

; === BASIC STRUCTURE ===
(assert (is_List xs))

; === Contract predicates ===
(define-fun C0 () Bool (> (length xs) 0))
(define-fun C1 () Bool (list_all_numeric xs))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/63 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===
(assert (is-IntVal n))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))
(define-fun C1 () Bool (>= (SafeI n) 0))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'n': -1}
    Solution 2:
      test_case: {'n': -7720}
    Solution 3:
      test_case: {'n': -10157}
    Solution 4:
      test_case: {'n': -21954}
    Solution 5:
      test_case: {'n': -54239}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===
(assert (is-IntVal n))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))
(define-fun C1 () Bool (>= (SafeI n) 0))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===
(assert (is-IntVal n))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))
(define-fun C1 () Bool (>= (SafeI n) 0))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'n': 0}
    Solution 2:
      test_case: {'n': 7719}
    Solution 3:
      test_case: {'n': 10156}
    Solution 4:
      test_case: {'n': 21953}
    Solution 5:
      test_case: {'n': 54238}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===
(assert (is-IntVal n))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))
(define-fun C1 () Bool (>= (SafeI n) 0))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/64 ===
  Test Case 1: satisfied_, violated_assert_0
  Combination: {'assert_0': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0'], 'total_contracts': 1}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const s Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal s))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal s))

; === COMBINATION ===
(assert (not C0))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_
  Combination: {'assert_0': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': [], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'s': '!0!'}
    Solution 2:
      test_case: {'s': '!'}
    Solution 3:
      test_case: {'s': '0'}
    Solution 4:
      test_case: {'s': '0!'}
    Solution 5:
      test_case: {'s': ''}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const s Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal s))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal s))

; === COMBINATION ===
(assert C0)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/65 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun get-ival ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const x Value)
(declare-const shift Value)

; === BASIC STRUCTURE ===
(assert (is-IntVal x))
(assert (is-IntVal shift))

; === Contract predicates ===
(define-fun C0 () Bool (and (is-IntVal x) (is-IntVal shift)))
(define-fun C1 () Bool (and (>= (get-ival x) 0) (>= (get-ival shift) 0)))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'x': -1, 'shift': 0}
    Solution 2:
      test_case: {'x': -2438, 'shift': 21238}
    Solution 3:
      test_case: {'x': -2438, 'shift': -8366}
    Solution 4:
      test_case: {'x': -2438, 'shift': 22246}
    Solution 5:
      test_case: {'x': -2438, 'shift': 23388}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun get-ival ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const x Value)
(declare-const shift Value)

; === BASIC STRUCTURE ===
(assert (is-IntVal x))
(assert (is-IntVal shift))

; === Contract predicates ===
(define-fun C0 () Bool (and (is-IntVal x) (is-IntVal shift)))
(define-fun C1 () Bool (and (>= (get-ival x) 0) (>= (get-ival shift) 0)))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun get-ival ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const x Value)
(declare-const shift Value)

; === BASIC STRUCTURE ===
(assert (is-IntVal x))
(assert (is-IntVal shift))

; === Contract predicates ===
(define-fun C0 () Bool (and (is-IntVal x) (is-IntVal shift)))
(define-fun C1 () Bool (and (>= (get-ival x) 0) (>= (get-ival shift) 0)))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'x': 0, 'shift': 7719}
    Solution 2:
      test_case: {'x': 7719, 'shift': 21238}
    Solution 3:
      test_case: {'x': 16084, 'shift': 21238}
    Solution 4:
      test_case: {'x': 26534, 'shift': 21238}
    Solution 5:
      test_case: {'x': 26534, 'shift': 27091}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun get-ival ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const x Value)
(declare-const shift Value)

; === BASIC STRUCTURE ===
(assert (is-IntVal x))
(assert (is-IntVal shift))

; === Contract predicates ===
(define-fun C0 () Bool (and (is-IntVal x) (is-IntVal shift)))
(define-fun C1 () Bool (and (>= (get-ival x) 0) (>= (get-ival shift) 0)))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/66 ===
  Test Case 1: satisfied_, violated_assert_0
  Combination: {'assert_0': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0'], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'s': 2.0}
    Solution 2:
      test_case: {'s': 3.0}
    Solution 3:
      test_case: {'s': 4.0}
    Solution 4:
      test_case: {'s': 5.0}
    Solution 5:
      test_case: {'s': 6.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const s Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal s))

; === COMBINATION ===
(assert (not C0))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_
  Combination: {'assert_0': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': [], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'s': '!0!'}
    Solution 2:
      test_case: {'s': '!'}
    Solution 3:
      test_case: {'s': '0'}
    Solution 4:
      test_case: {'s': '0!'}
    Solution 5:
      test_case: {'s': ''}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const s Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal s))

; === COMBINATION ===
(assert C0)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/67 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1;assert_2;assert_3
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False, 'assert_3': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_3'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'s': 2.0, 'n': 3.0}
    Solution 2:
      test_case: {'n': 4.0, 's': 5.0}
    Solution 3:
      test_case: {'n': 6.0, 's': 7.0}
    Solution 4:
      test_case: {'n': 8.0, 's': 9.0}
    Solution 5:
      test_case: {'n': 11.0, 's': 10.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun DIGIT () (RegEx String) (re.range "0" "9"))
(define-fun LETTER () (RegEx String) (re.union (re.range "A" "Z") (re.range "a" "z")))
(define-fun ALNUM () (RegEx String) (re.union LETTER DIGIT))
(define-fun WORD () (RegEx String) (re.++ LETTER (re.* ALNUM)))
(define-fun NUM () (RegEx String) (re.++ DIGIT (re.* DIGIT)))
(define-fun TOKEN () (RegEx String) (re.union WORD NUM))
(define-fun SP () (RegEx String) (str.to.re " "))
(define-const R5 (RegEx String) (re.++ TOKEN SP TOKEN SP TOKEN SP TOKEN SP TOKEN))
(define-const RW (RegEx String) (re.++ TOKEN (str.to.re " apples and ") TOKEN (str.to.re " oranges")))
(define-const RN (RegEx String) (re.++ NUM (str.to.re " apples and ") NUM (str.to.re " oranges")))

; === Inputs ===
(declare-const s Value)
(declare-const n Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (is-StrVal s) (is-IntVal n)))
(define-fun C1 () Bool (and (is-StrVal s) (str.in.re (sval s) R5)))
(define-fun C2 () Bool (and (is-StrVal s) (str.in.re (sval s) RW)))
(define-fun C3 () Bool (and (is-StrVal s) (str.in.re (sval s) RN)))
(define-fun C4 () Bool (and (is-StrVal s) (is-IntVal n) (let ((sep1 " apples and ") (sep2 " oranges") (S (sval s))) (let ((i1 (str.indexof S sep1 0))) (and (>= i1 0) (let ((x (str.substr S 0 i1)) (start2 (+ i1 (str.len sep1)))) (let ((i2 (str.indexof S sep2 start2))) (and (>= i2 0) (let ((y (str.substr S start2 (- i2 start2)))) (and (str.in.re x NUM) (str.in.re y NUM) (>= (ival n) (+ (str.to.int x) (str.to.int y)))))))))))))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1;assert_2;assert_3
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False, 'assert_3': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1', 'assert_2', 'assert_3'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'s': '', 'n': 2}
    Solution 2:
      test_case: {'n': 3, 's': ''}
    Solution 3:
      test_case: {'n': 4, 's': ''}
    Solution 4:
      test_case: {'n': 5, 's': ''}
    Solution 5:
      test_case: {'n': 6, 's': ''}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun DIGIT () (RegEx String) (re.range "0" "9"))
(define-fun LETTER () (RegEx String) (re.union (re.range "A" "Z") (re.range "a" "z")))
(define-fun ALNUM () (RegEx String) (re.union LETTER DIGIT))
(define-fun WORD () (RegEx String) (re.++ LETTER (re.* ALNUM)))
(define-fun NUM () (RegEx String) (re.++ DIGIT (re.* DIGIT)))
(define-fun TOKEN () (RegEx String) (re.union WORD NUM))
(define-fun SP () (RegEx String) (str.to.re " "))
(define-const R5 (RegEx String) (re.++ TOKEN SP TOKEN SP TOKEN SP TOKEN SP TOKEN))
(define-const RW (RegEx String) (re.++ TOKEN (str.to.re " apples and ") TOKEN (str.to.re " oranges")))
(define-const RN (RegEx String) (re.++ NUM (str.to.re " apples and ") NUM (str.to.re " oranges")))

; === Inputs ===
(declare-const s Value)
(declare-const n Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (is-StrVal s) (is-IntVal n)))
(define-fun C1 () Bool (and (is-StrVal s) (str.in.re (sval s) R5)))
(define-fun C2 () Bool (and (is-StrVal s) (str.in.re (sval s) RW)))
(define-fun C3 () Bool (and (is-StrVal s) (str.in.re (sval s) RN)))
(define-fun C4 () Bool (and (is-StrVal s) (is-IntVal n) (let ((sep1 " apples and ") (sep2 " oranges") (S (sval s))) (let ((i1 (str.indexof S sep1 0))) (and (>= i1 0) (let ((x (str.substr S 0 i1)) (start2 (+ i1 (str.len sep1)))) (let ((i2 (str.indexof S sep2 start2))) (and (>= i2 0) (let ((y (str.substr S start2 (- i2 start2)))) (and (str.in.re x NUM) (str.in.re y NUM) (>= (ival n) (+ (str.to.int x) (str.to.int y)))))))))))))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0;assert_2;assert_3
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False, 'assert_3': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0', 'assert_2', 'assert_3'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'s': '3 0 p 3 h', 'n': 2.0}
    Solution 2:
      test_case: {'n': 3.0, 's': '4 0 K K C'}
    Solution 3:
      test_case: {'n': 4.0, 's': '4 0 K K 1'}
    Solution 4:
      test_case: {'n': 5.0, 's': '4 0 K K 1'}
    Solution 5:
      test_case: {'n': 6.0, 's': '4 0 K K 1'}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun DIGIT () (RegEx String) (re.range "0" "9"))
(define-fun LETTER () (RegEx String) (re.union (re.range "A" "Z") (re.range "a" "z")))
(define-fun ALNUM () (RegEx String) (re.union LETTER DIGIT))
(define-fun WORD () (RegEx String) (re.++ LETTER (re.* ALNUM)))
(define-fun NUM () (RegEx String) (re.++ DIGIT (re.* DIGIT)))
(define-fun TOKEN () (RegEx String) (re.union WORD NUM))
(define-fun SP () (RegEx String) (str.to.re " "))
(define-const R5 (RegEx String) (re.++ TOKEN SP TOKEN SP TOKEN SP TOKEN SP TOKEN))
(define-const RW (RegEx String) (re.++ TOKEN (str.to.re " apples and ") TOKEN (str.to.re " oranges")))
(define-const RN (RegEx String) (re.++ NUM (str.to.re " apples and ") NUM (str.to.re " oranges")))

; === Inputs ===
(declare-const s Value)
(declare-const n Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (is-StrVal s) (is-IntVal n)))
(define-fun C1 () Bool (and (is-StrVal s) (str.in.re (sval s) R5)))
(define-fun C2 () Bool (and (is-StrVal s) (str.in.re (sval s) RW)))
(define-fun C3 () Bool (and (is-StrVal s) (str.in.re (sval s) RN)))
(define-fun C4 () Bool (and (is-StrVal s) (is-IntVal n) (let ((sep1 " apples and ") (sep2 " oranges") (S (sval s))) (let ((i1 (str.indexof S sep1 0))) (and (>= i1 0) (let ((x (str.substr S 0 i1)) (start2 (+ i1 (str.len sep1)))) (let ((i2 (str.indexof S sep2 start2))) (and (>= i2 0) (let ((y (str.substr S start2 (- i2 start2)))) (and (str.in.re x NUM) (str.in.re y NUM) (>= (ival n) (+ (str.to.int x) (str.to.int y)))))))))))))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_assert_2;assert_3
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False, 'assert_3': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': ['assert_2', 'assert_3'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'s': '3 0 0 0 2', 'n': 12}
    Solution 2:
      test_case: {'n': 13, 's': 'k 0 0 z A'}
    Solution 3:
      test_case: {'n': 15, 's': 'k 0 0 z z'}
    Solution 4:
      test_case: {'n': 16, 's': 'k 0 0 z z'}
    Solution 5:
      test_case: {'n': 17, 's': 'k 0 0 z z'}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun DIGIT () (RegEx String) (re.range "0" "9"))
(define-fun LETTER () (RegEx String) (re.union (re.range "A" "Z") (re.range "a" "z")))
(define-fun ALNUM () (RegEx String) (re.union LETTER DIGIT))
(define-fun WORD () (RegEx String) (re.++ LETTER (re.* ALNUM)))
(define-fun NUM () (RegEx String) (re.++ DIGIT (re.* DIGIT)))
(define-fun TOKEN () (RegEx String) (re.union WORD NUM))
(define-fun SP () (RegEx String) (str.to.re " "))
(define-const R5 (RegEx String) (re.++ TOKEN SP TOKEN SP TOKEN SP TOKEN SP TOKEN))
(define-const RW (RegEx String) (re.++ TOKEN (str.to.re " apples and ") TOKEN (str.to.re " oranges")))
(define-const RN (RegEx String) (re.++ NUM (str.to.re " apples and ") NUM (str.to.re " oranges")))

; === Inputs ===
(declare-const s Value)
(declare-const n Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (is-StrVal s) (is-IntVal n)))
(define-fun C1 () Bool (and (is-StrVal s) (str.in.re (sval s) R5)))
(define-fun C2 () Bool (and (is-StrVal s) (str.in.re (sval s) RW)))
(define-fun C3 () Bool (and (is-StrVal s) (str.in.re (sval s) RN)))
(define-fun C4 () Bool (and (is-StrVal s) (is-IntVal n) (let ((sep1 " apples and ") (sep2 " oranges") (S (sval s))) (let ((i1 (str.indexof S sep1 0))) (and (>= i1 0) (let ((x (str.substr S 0 i1)) (start2 (+ i1 (str.len sep1)))) (let ((i2 (str.indexof S sep2 start2))) (and (>= i2 0) (let ((y (str.substr S start2 (- i2 start2)))) (and (str.in.re x NUM) (str.in.re y NUM) (>= (ival n) (+ (str.to.int x) (str.to.int y)))))))))))))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 5: satisfied_assert_2, violated_assert_0;assert_1;assert_3
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True, 'assert_3': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_2'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_3'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun DIGIT () (RegEx String) (re.range "0" "9"))
(define-fun LETTER () (RegEx String) (re.union (re.range "A" "Z") (re.range "a" "z")))
(define-fun ALNUM () (RegEx String) (re.union LETTER DIGIT))
(define-fun WORD () (RegEx String) (re.++ LETTER (re.* ALNUM)))
(define-fun NUM () (RegEx String) (re.++ DIGIT (re.* DIGIT)))
(define-fun TOKEN () (RegEx String) (re.union WORD NUM))
(define-fun SP () (RegEx String) (str.to.re " "))
(define-const R5 (RegEx String) (re.++ TOKEN SP TOKEN SP TOKEN SP TOKEN SP TOKEN))
(define-const RW (RegEx String) (re.++ TOKEN (str.to.re " apples and ") TOKEN (str.to.re " oranges")))
(define-const RN (RegEx String) (re.++ NUM (str.to.re " apples and ") NUM (str.to.re " oranges")))

; === Inputs ===
(declare-const s Value)
(declare-const n Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (is-StrVal s) (is-IntVal n)))
(define-fun C1 () Bool (and (is-StrVal s) (str.in.re (sval s) R5)))
(define-fun C2 () Bool (and (is-StrVal s) (str.in.re (sval s) RW)))
(define-fun C3 () Bool (and (is-StrVal s) (str.in.re (sval s) RN)))
(define-fun C4 () Bool (and (is-StrVal s) (is-IntVal n) (let ((sep1 " apples and ") (sep2 " oranges") (S (sval s))) (let ((i1 (str.indexof S sep1 0))) (and (>= i1 0) (let ((x (str.substr S 0 i1)) (start2 (+ i1 (str.len sep1)))) (let ((i2 (str.indexof S sep2 start2))) (and (>= i2 0) (let ((y (str.substr S start2 (- i2 start2)))) (and (str.in.re x NUM) (str.in.re y NUM) (>= (ival n) (+ (str.to.int x) (str.to.int y)))))))))))))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 6: satisfied_assert_0;assert_2, violated_assert_1;assert_3
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True, 'assert_3': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2'], 'violated_contracts': ['assert_1', 'assert_3'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun DIGIT () (RegEx String) (re.range "0" "9"))
(define-fun LETTER () (RegEx String) (re.union (re.range "A" "Z") (re.range "a" "z")))
(define-fun ALNUM () (RegEx String) (re.union LETTER DIGIT))
(define-fun WORD () (RegEx String) (re.++ LETTER (re.* ALNUM)))
(define-fun NUM () (RegEx String) (re.++ DIGIT (re.* DIGIT)))
(define-fun TOKEN () (RegEx String) (re.union WORD NUM))
(define-fun SP () (RegEx String) (str.to.re " "))
(define-const R5 (RegEx String) (re.++ TOKEN SP TOKEN SP TOKEN SP TOKEN SP TOKEN))
(define-const RW (RegEx String) (re.++ TOKEN (str.to.re " apples and ") TOKEN (str.to.re " oranges")))
(define-const RN (RegEx String) (re.++ NUM (str.to.re " apples and ") NUM (str.to.re " oranges")))

; === Inputs ===
(declare-const s Value)
(declare-const n Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (is-StrVal s) (is-IntVal n)))
(define-fun C1 () Bool (and (is-StrVal s) (str.in.re (sval s) R5)))
(define-fun C2 () Bool (and (is-StrVal s) (str.in.re (sval s) RW)))
(define-fun C3 () Bool (and (is-StrVal s) (str.in.re (sval s) RN)))
(define-fun C4 () Bool (and (is-StrVal s) (is-IntVal n) (let ((sep1 " apples and ") (sep2 " oranges") (S (sval s))) (let ((i1 (str.indexof S sep1 0))) (and (>= i1 0) (let ((x (str.substr S 0 i1)) (start2 (+ i1 (str.len sep1)))) (let ((i2 (str.indexof S sep2 start2))) (and (>= i2 0) (let ((y (str.substr S start2 (- i2 start2)))) (and (str.in.re x NUM) (str.in.re y NUM) (>= (ival n) (+ (str.to.int x) (str.to.int y)))))))))))))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 7: satisfied_assert_1;assert_2, violated_assert_0;assert_3
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True, 'assert_3': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2'], 'violated_contracts': ['assert_0', 'assert_3'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun DIGIT () (RegEx String) (re.range "0" "9"))
(define-fun LETTER () (RegEx String) (re.union (re.range "A" "Z") (re.range "a" "z")))
(define-fun ALNUM () (RegEx String) (re.union LETTER DIGIT))
(define-fun WORD () (RegEx String) (re.++ LETTER (re.* ALNUM)))
(define-fun NUM () (RegEx String) (re.++ DIGIT (re.* DIGIT)))
(define-fun TOKEN () (RegEx String) (re.union WORD NUM))
(define-fun SP () (RegEx String) (str.to.re " "))
(define-const R5 (RegEx String) (re.++ TOKEN SP TOKEN SP TOKEN SP TOKEN SP TOKEN))
(define-const RW (RegEx String) (re.++ TOKEN (str.to.re " apples and ") TOKEN (str.to.re " oranges")))
(define-const RN (RegEx String) (re.++ NUM (str.to.re " apples and ") NUM (str.to.re " oranges")))

; === Inputs ===
(declare-const s Value)
(declare-const n Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (is-StrVal s) (is-IntVal n)))
(define-fun C1 () Bool (and (is-StrVal s) (str.in.re (sval s) R5)))
(define-fun C2 () Bool (and (is-StrVal s) (str.in.re (sval s) RW)))
(define-fun C3 () Bool (and (is-StrVal s) (str.in.re (sval s) RN)))
(define-fun C4 () Bool (and (is-StrVal s) (is-IntVal n) (let ((sep1 " apples and ") (sep2 " oranges") (S (sval s))) (let ((i1 (str.indexof S sep1 0))) (and (>= i1 0) (let ((x (str.substr S 0 i1)) (start2 (+ i1 (str.len sep1)))) (let ((i2 (str.indexof S sep2 start2))) (and (>= i2 0) (let ((y (str.substr S start2 (- i2 start2)))) (and (str.in.re x NUM) (str.in.re y NUM) (>= (ival n) (+ (str.to.int x) (str.to.int y)))))))))))))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 8: satisfied_assert_0;assert_1;assert_2, violated_assert_3
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True, 'assert_3': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2'], 'violated_contracts': ['assert_3'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun DIGIT () (RegEx String) (re.range "0" "9"))
(define-fun LETTER () (RegEx String) (re.union (re.range "A" "Z") (re.range "a" "z")))
(define-fun ALNUM () (RegEx String) (re.union LETTER DIGIT))
(define-fun WORD () (RegEx String) (re.++ LETTER (re.* ALNUM)))
(define-fun NUM () (RegEx String) (re.++ DIGIT (re.* DIGIT)))
(define-fun TOKEN () (RegEx String) (re.union WORD NUM))
(define-fun SP () (RegEx String) (str.to.re " "))
(define-const R5 (RegEx String) (re.++ TOKEN SP TOKEN SP TOKEN SP TOKEN SP TOKEN))
(define-const RW (RegEx String) (re.++ TOKEN (str.to.re " apples and ") TOKEN (str.to.re " oranges")))
(define-const RN (RegEx String) (re.++ NUM (str.to.re " apples and ") NUM (str.to.re " oranges")))

; === Inputs ===
(declare-const s Value)
(declare-const n Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (is-StrVal s) (is-IntVal n)))
(define-fun C1 () Bool (and (is-StrVal s) (str.in.re (sval s) R5)))
(define-fun C2 () Bool (and (is-StrVal s) (str.in.re (sval s) RW)))
(define-fun C3 () Bool (and (is-StrVal s) (str.in.re (sval s) RN)))
(define-fun C4 () Bool (and (is-StrVal s) (is-IntVal n) (let ((sep1 " apples and ") (sep2 " oranges") (S (sval s))) (let ((i1 (str.indexof S sep1 0))) (and (>= i1 0) (let ((x (str.substr S 0 i1)) (start2 (+ i1 (str.len sep1)))) (let ((i2 (str.indexof S sep2 start2))) (and (>= i2 0) (let ((y (str.substr S start2 (- i2 start2)))) (and (str.in.re x NUM) (str.in.re y NUM) (>= (ival n) (+ (str.to.int x) (str.to.int y)))))))))))))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 9: satisfied_assert_3, violated_assert_0;assert_1;assert_2
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False, 'assert_3': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_3'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun DIGIT () (RegEx String) (re.range "0" "9"))
(define-fun LETTER () (RegEx String) (re.union (re.range "A" "Z") (re.range "a" "z")))
(define-fun ALNUM () (RegEx String) (re.union LETTER DIGIT))
(define-fun WORD () (RegEx String) (re.++ LETTER (re.* ALNUM)))
(define-fun NUM () (RegEx String) (re.++ DIGIT (re.* DIGIT)))
(define-fun TOKEN () (RegEx String) (re.union WORD NUM))
(define-fun SP () (RegEx String) (str.to.re " "))
(define-const R5 (RegEx String) (re.++ TOKEN SP TOKEN SP TOKEN SP TOKEN SP TOKEN))
(define-const RW (RegEx String) (re.++ TOKEN (str.to.re " apples and ") TOKEN (str.to.re " oranges")))
(define-const RN (RegEx String) (re.++ NUM (str.to.re " apples and ") NUM (str.to.re " oranges")))

; === Inputs ===
(declare-const s Value)
(declare-const n Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (is-StrVal s) (is-IntVal n)))
(define-fun C1 () Bool (and (is-StrVal s) (str.in.re (sval s) R5)))
(define-fun C2 () Bool (and (is-StrVal s) (str.in.re (sval s) RW)))
(define-fun C3 () Bool (and (is-StrVal s) (str.in.re (sval s) RN)))
(define-fun C4 () Bool (and (is-StrVal s) (is-IntVal n) (let ((sep1 " apples and ") (sep2 " oranges") (S (sval s))) (let ((i1 (str.indexof S sep1 0))) (and (>= i1 0) (let ((x (str.substr S 0 i1)) (start2 (+ i1 (str.len sep1)))) (let ((i2 (str.indexof S sep2 start2))) (and (>= i2 0) (let ((y (str.substr S start2 (- i2 start2)))) (and (str.in.re x NUM) (str.in.re y NUM) (>= (ival n) (+ (str.to.int x) (str.to.int y)))))))))))))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 10: satisfied_assert_0;assert_3, violated_assert_1;assert_2
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False, 'assert_3': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_3'], 'violated_contracts': ['assert_1', 'assert_2'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun DIGIT () (RegEx String) (re.range "0" "9"))
(define-fun LETTER () (RegEx String) (re.union (re.range "A" "Z") (re.range "a" "z")))
(define-fun ALNUM () (RegEx String) (re.union LETTER DIGIT))
(define-fun WORD () (RegEx String) (re.++ LETTER (re.* ALNUM)))
(define-fun NUM () (RegEx String) (re.++ DIGIT (re.* DIGIT)))
(define-fun TOKEN () (RegEx String) (re.union WORD NUM))
(define-fun SP () (RegEx String) (str.to.re " "))
(define-const R5 (RegEx String) (re.++ TOKEN SP TOKEN SP TOKEN SP TOKEN SP TOKEN))
(define-const RW (RegEx String) (re.++ TOKEN (str.to.re " apples and ") TOKEN (str.to.re " oranges")))
(define-const RN (RegEx String) (re.++ NUM (str.to.re " apples and ") NUM (str.to.re " oranges")))

; === Inputs ===
(declare-const s Value)
(declare-const n Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (is-StrVal s) (is-IntVal n)))
(define-fun C1 () Bool (and (is-StrVal s) (str.in.re (sval s) R5)))
(define-fun C2 () Bool (and (is-StrVal s) (str.in.re (sval s) RW)))
(define-fun C3 () Bool (and (is-StrVal s) (str.in.re (sval s) RN)))
(define-fun C4 () Bool (and (is-StrVal s) (is-IntVal n) (let ((sep1 " apples and ") (sep2 " oranges") (S (sval s))) (let ((i1 (str.indexof S sep1 0))) (and (>= i1 0) (let ((x (str.substr S 0 i1)) (start2 (+ i1 (str.len sep1)))) (let ((i2 (str.indexof S sep2 start2))) (and (>= i2 0) (let ((y (str.substr S start2 (- i2 start2)))) (and (str.in.re x NUM) (str.in.re y NUM) (>= (ival n) (+ (str.to.int x) (str.to.int y)))))))))))))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 11: satisfied_assert_1;assert_3, violated_assert_0;assert_2
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False, 'assert_3': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_3'], 'violated_contracts': ['assert_0', 'assert_2'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun DIGIT () (RegEx String) (re.range "0" "9"))
(define-fun LETTER () (RegEx String) (re.union (re.range "A" "Z") (re.range "a" "z")))
(define-fun ALNUM () (RegEx String) (re.union LETTER DIGIT))
(define-fun WORD () (RegEx String) (re.++ LETTER (re.* ALNUM)))
(define-fun NUM () (RegEx String) (re.++ DIGIT (re.* DIGIT)))
(define-fun TOKEN () (RegEx String) (re.union WORD NUM))
(define-fun SP () (RegEx String) (str.to.re " "))
(define-const R5 (RegEx String) (re.++ TOKEN SP TOKEN SP TOKEN SP TOKEN SP TOKEN))
(define-const RW (RegEx String) (re.++ TOKEN (str.to.re " apples and ") TOKEN (str.to.re " oranges")))
(define-const RN (RegEx String) (re.++ NUM (str.to.re " apples and ") NUM (str.to.re " oranges")))

; === Inputs ===
(declare-const s Value)
(declare-const n Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (is-StrVal s) (is-IntVal n)))
(define-fun C1 () Bool (and (is-StrVal s) (str.in.re (sval s) R5)))
(define-fun C2 () Bool (and (is-StrVal s) (str.in.re (sval s) RW)))
(define-fun C3 () Bool (and (is-StrVal s) (str.in.re (sval s) RN)))
(define-fun C4 () Bool (and (is-StrVal s) (is-IntVal n) (let ((sep1 " apples and ") (sep2 " oranges") (S (sval s))) (let ((i1 (str.indexof S sep1 0))) (and (>= i1 0) (let ((x (str.substr S 0 i1)) (start2 (+ i1 (str.len sep1)))) (let ((i2 (str.indexof S sep2 start2))) (and (>= i2 0) (let ((y (str.substr S start2 (- i2 start2)))) (and (str.in.re x NUM) (str.in.re y NUM) (>= (ival n) (+ (str.to.int x) (str.to.int y)))))))))))))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 12: satisfied_assert_0;assert_1;assert_3, violated_assert_2
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False, 'assert_3': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_3'], 'violated_contracts': ['assert_2'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun DIGIT () (RegEx String) (re.range "0" "9"))
(define-fun LETTER () (RegEx String) (re.union (re.range "A" "Z") (re.range "a" "z")))
(define-fun ALNUM () (RegEx String) (re.union LETTER DIGIT))
(define-fun WORD () (RegEx String) (re.++ LETTER (re.* ALNUM)))
(define-fun NUM () (RegEx String) (re.++ DIGIT (re.* DIGIT)))
(define-fun TOKEN () (RegEx String) (re.union WORD NUM))
(define-fun SP () (RegEx String) (str.to.re " "))
(define-const R5 (RegEx String) (re.++ TOKEN SP TOKEN SP TOKEN SP TOKEN SP TOKEN))
(define-const RW (RegEx String) (re.++ TOKEN (str.to.re " apples and ") TOKEN (str.to.re " oranges")))
(define-const RN (RegEx String) (re.++ NUM (str.to.re " apples and ") NUM (str.to.re " oranges")))

; === Inputs ===
(declare-const s Value)
(declare-const n Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (is-StrVal s) (is-IntVal n)))
(define-fun C1 () Bool (and (is-StrVal s) (str.in.re (sval s) R5)))
(define-fun C2 () Bool (and (is-StrVal s) (str.in.re (sval s) RW)))
(define-fun C3 () Bool (and (is-StrVal s) (str.in.re (sval s) RN)))
(define-fun C4 () Bool (and (is-StrVal s) (is-IntVal n) (let ((sep1 " apples and ") (sep2 " oranges") (S (sval s))) (let ((i1 (str.indexof S sep1 0))) (and (>= i1 0) (let ((x (str.substr S 0 i1)) (start2 (+ i1 (str.len sep1)))) (let ((i2 (str.indexof S sep2 start2))) (and (>= i2 0) (let ((y (str.substr S start2 (- i2 start2)))) (and (str.in.re x NUM) (str.in.re y NUM) (>= (ival n) (+ (str.to.int x) (str.to.int y)))))))))))))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 13: satisfied_assert_2;assert_3, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True, 'assert_3': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_2', 'assert_3'], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun DIGIT () (RegEx String) (re.range "0" "9"))
(define-fun LETTER () (RegEx String) (re.union (re.range "A" "Z") (re.range "a" "z")))
(define-fun ALNUM () (RegEx String) (re.union LETTER DIGIT))
(define-fun WORD () (RegEx String) (re.++ LETTER (re.* ALNUM)))
(define-fun NUM () (RegEx String) (re.++ DIGIT (re.* DIGIT)))
(define-fun TOKEN () (RegEx String) (re.union WORD NUM))
(define-fun SP () (RegEx String) (str.to.re " "))
(define-const R5 (RegEx String) (re.++ TOKEN SP TOKEN SP TOKEN SP TOKEN SP TOKEN))
(define-const RW (RegEx String) (re.++ TOKEN (str.to.re " apples and ") TOKEN (str.to.re " oranges")))
(define-const RN (RegEx String) (re.++ NUM (str.to.re " apples and ") NUM (str.to.re " oranges")))

; === Inputs ===
(declare-const s Value)
(declare-const n Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (is-StrVal s) (is-IntVal n)))
(define-fun C1 () Bool (and (is-StrVal s) (str.in.re (sval s) R5)))
(define-fun C2 () Bool (and (is-StrVal s) (str.in.re (sval s) RW)))
(define-fun C3 () Bool (and (is-StrVal s) (str.in.re (sval s) RN)))
(define-fun C4 () Bool (and (is-StrVal s) (is-IntVal n) (let ((sep1 " apples and ") (sep2 " oranges") (S (sval s))) (let ((i1 (str.indexof S sep1 0))) (and (>= i1 0) (let ((x (str.substr S 0 i1)) (start2 (+ i1 (str.len sep1)))) (let ((i2 (str.indexof S sep2 start2))) (and (>= i2 0) (let ((y (str.substr S start2 (- i2 start2)))) (and (str.in.re x NUM) (str.in.re y NUM) (>= (ival n) (+ (str.to.int x) (str.to.int y)))))))))))))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 14: satisfied_assert_0;assert_2;assert_3, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True, 'assert_3': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2', 'assert_3'], 'violated_contracts': ['assert_1'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun DIGIT () (RegEx String) (re.range "0" "9"))
(define-fun LETTER () (RegEx String) (re.union (re.range "A" "Z") (re.range "a" "z")))
(define-fun ALNUM () (RegEx String) (re.union LETTER DIGIT))
(define-fun WORD () (RegEx String) (re.++ LETTER (re.* ALNUM)))
(define-fun NUM () (RegEx String) (re.++ DIGIT (re.* DIGIT)))
(define-fun TOKEN () (RegEx String) (re.union WORD NUM))
(define-fun SP () (RegEx String) (str.to.re " "))
(define-const R5 (RegEx String) (re.++ TOKEN SP TOKEN SP TOKEN SP TOKEN SP TOKEN))
(define-const RW (RegEx String) (re.++ TOKEN (str.to.re " apples and ") TOKEN (str.to.re " oranges")))
(define-const RN (RegEx String) (re.++ NUM (str.to.re " apples and ") NUM (str.to.re " oranges")))

; === Inputs ===
(declare-const s Value)
(declare-const n Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (is-StrVal s) (is-IntVal n)))
(define-fun C1 () Bool (and (is-StrVal s) (str.in.re (sval s) R5)))
(define-fun C2 () Bool (and (is-StrVal s) (str.in.re (sval s) RW)))
(define-fun C3 () Bool (and (is-StrVal s) (str.in.re (sval s) RN)))
(define-fun C4 () Bool (and (is-StrVal s) (is-IntVal n) (let ((sep1 " apples and ") (sep2 " oranges") (S (sval s))) (let ((i1 (str.indexof S sep1 0))) (and (>= i1 0) (let ((x (str.substr S 0 i1)) (start2 (+ i1 (str.len sep1)))) (let ((i2 (str.indexof S sep2 start2))) (and (>= i2 0) (let ((y (str.substr S start2 (- i2 start2)))) (and (str.in.re x NUM) (str.in.re y NUM) (>= (ival n) (+ (str.to.int x) (str.to.int y)))))))))))))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 15: satisfied_assert_1;assert_2;assert_3, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True, 'assert_3': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2', 'assert_3'], 'violated_contracts': ['assert_0'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun DIGIT () (RegEx String) (re.range "0" "9"))
(define-fun LETTER () (RegEx String) (re.union (re.range "A" "Z") (re.range "a" "z")))
(define-fun ALNUM () (RegEx String) (re.union LETTER DIGIT))
(define-fun WORD () (RegEx String) (re.++ LETTER (re.* ALNUM)))
(define-fun NUM () (RegEx String) (re.++ DIGIT (re.* DIGIT)))
(define-fun TOKEN () (RegEx String) (re.union WORD NUM))
(define-fun SP () (RegEx String) (str.to.re " "))
(define-const R5 (RegEx String) (re.++ TOKEN SP TOKEN SP TOKEN SP TOKEN SP TOKEN))
(define-const RW (RegEx String) (re.++ TOKEN (str.to.re " apples and ") TOKEN (str.to.re " oranges")))
(define-const RN (RegEx String) (re.++ NUM (str.to.re " apples and ") NUM (str.to.re " oranges")))

; === Inputs ===
(declare-const s Value)
(declare-const n Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (is-StrVal s) (is-IntVal n)))
(define-fun C1 () Bool (and (is-StrVal s) (str.in.re (sval s) R5)))
(define-fun C2 () Bool (and (is-StrVal s) (str.in.re (sval s) RW)))
(define-fun C3 () Bool (and (is-StrVal s) (str.in.re (sval s) RN)))
(define-fun C4 () Bool (and (is-StrVal s) (is-IntVal n) (let ((sep1 " apples and ") (sep2 " oranges") (S (sval s))) (let ((i1 (str.indexof S sep1 0))) (and (>= i1 0) (let ((x (str.substr S 0 i1)) (start2 (+ i1 (str.len sep1)))) (let ((i2 (str.indexof S sep2 start2))) (and (>= i2 0) (let ((y (str.substr S start2 (- i2 start2)))) (and (str.in.re x NUM) (str.in.re y NUM) (>= (ival n) (+ (str.to.int x) (str.to.int y)))))))))))))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 16: satisfied_assert_0;assert_1;assert_2;assert_3, violated_
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True, 'assert_3': True}
  Satisfiable: True
  Solution Count: 1
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_3'], 'violated_contracts': [], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'s': '0 apples and 0 oranges', 'n': 28}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun DIGIT () (RegEx String) (re.range "0" "9"))
(define-fun LETTER () (RegEx String) (re.union (re.range "A" "Z") (re.range "a" "z")))
(define-fun ALNUM () (RegEx String) (re.union LETTER DIGIT))
(define-fun WORD () (RegEx String) (re.++ LETTER (re.* ALNUM)))
(define-fun NUM () (RegEx String) (re.++ DIGIT (re.* DIGIT)))
(define-fun TOKEN () (RegEx String) (re.union WORD NUM))
(define-fun SP () (RegEx String) (str.to.re " "))
(define-const R5 (RegEx String) (re.++ TOKEN SP TOKEN SP TOKEN SP TOKEN SP TOKEN))
(define-const RW (RegEx String) (re.++ TOKEN (str.to.re " apples and ") TOKEN (str.to.re " oranges")))
(define-const RN (RegEx String) (re.++ NUM (str.to.re " apples and ") NUM (str.to.re " oranges")))

; === Inputs ===
(declare-const s Value)
(declare-const n Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (is-StrVal s) (is-IntVal n)))
(define-fun C1 () Bool (and (is-StrVal s) (str.in.re (sval s) R5)))
(define-fun C2 () Bool (and (is-StrVal s) (str.in.re (sval s) RW)))
(define-fun C3 () Bool (and (is-StrVal s) (str.in.re (sval s) RN)))
(define-fun C4 () Bool (and (is-StrVal s) (is-IntVal n) (let ((sep1 " apples and ") (sep2 " oranges") (S (sval s))) (let ((i1 (str.indexof S sep1 0))) (and (>= i1 0) (let ((x (str.substr S 0 i1)) (start2 (+ i1 (str.len sep1)))) (let ((i2 (str.indexof S sep2 start2))) (and (>= i2 0) (let ((y (str.substr S start2 (- i2 start2)))) (and (str.in.re x NUM) (str.in.re y NUM) (>= (ival n) (+ (str.to.int x) (str.to.int y)))))))))))))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)
(assert C3)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/68 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))
(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v)
       0
       (ite (is-Cons v)
            (+ 1 (length (tail v)))
            0)))
(define-fun-rec list_all_numeric ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (let ((hd (head v)))
              (and (is-IntVal hd)
                   (let ((iv (ival hd)))
                     (and (>= iv 0)
                          (list_all_numeric (tail v))))))
            false)))

; === Inputs ===
(declare-const arr Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))

; === Contract predicates ===
(define-fun C0 () Bool (<= (length arr) 10000))
(define-fun C1 () Bool (list_all_numeric arr))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'arr': [2.0]}
    Solution 2:
      test_case: {'arr': [3.0]}
    Solution 3:
      test_case: {'arr': [4.0]}
    Solution 4:
      test_case: {'arr': [5.0]}
    Solution 5:
      test_case: {'arr': [6.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))
(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v)
       0
       (ite (is-Cons v)
            (+ 1 (length (tail v)))
            0)))
(define-fun-rec list_all_numeric ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (let ((hd (head v)))
              (and (is-IntVal hd)
                   (let ((iv (ival hd)))
                     (and (>= iv 0)
                          (list_all_numeric (tail v))))))
            false)))

; === Inputs ===
(declare-const arr Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))

; === Contract predicates ===
(define-fun C0 () Bool (<= (length arr) 10000))
(define-fun C1 () Bool (list_all_numeric arr))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))
(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v)
       0
       (ite (is-Cons v)
            (+ 1 (length (tail v)))
            0)))
(define-fun-rec list_all_numeric ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (let ((hd (head v)))
              (and (is-IntVal hd)
                   (let ((iv (ival hd)))
                     (and (>= iv 0)
                          (list_all_numeric (tail v))))))
            false)))

; === Inputs ===
(declare-const arr Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))

; === Contract predicates ===
(define-fun C0 () Bool (<= (length arr) 10000))
(define-fun C1 () Bool (list_all_numeric arr))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'arr': []}
    Solution 2:
      test_case: {'arr': [0]}
    Solution 3:
      test_case: {'arr': [10450]}
    Solution 4:
      test_case: {'arr': [281]}
    Solution 5:
      test_case: {'arr': [2997]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))
(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v)
       0
       (ite (is-Cons v)
            (+ 1 (length (tail v)))
            0)))
(define-fun-rec list_all_numeric ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (let ((hd (head v)))
              (and (is-IntVal hd)
                   (let ((iv (ival hd)))
                     (and (>= iv 0)
                          (list_all_numeric (tail v))))))
            false)))

; === Inputs ===
(declare-const arr Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))

; === Contract predicates ===
(define-fun C0 () Bool (<= (length arr) 10000))
(define-fun C1 () Bool (list_all_numeric arr))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/69 ===
  Test Case 1: satisfied_, violated_assert_0
  Combination: {'assert_0': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0'], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'lst': [2.0]}
    Solution 2:
      test_case: {'lst': [3.0]}
    Solution 3:
      test_case: {'lst': [4.0]}
    Solution 4:
      test_case: {'lst': [5.0]}
    Solution 5:
      test_case: {'lst': [6.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (ite (is-Nil lst)
       true
       (ite (is-Cons lst)
            (IsList (tail lst))
            false)))

(define-fun-rec list_all_int ((lst Value)) Bool
  (ite (is-Nil lst)
       true
       (ite (is-Cons lst)
            (let ((hd (head lst)) (tl (tail lst)))
              (and (is-IntVal hd)
                   (list_all_int tl)))
            false)))

(define-fun-rec list_all_positive ((lst Value)) Bool
  (ite (is-Nil lst)
       true
       (ite (is-Cons lst)
            (let ((hd (head lst)) (tl (tail lst)))
              (and (is-IntVal hd)
                   (>= (ival hd) 1)
                   (list_all_positive tl)))
            false)))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (IsList lst))

; === Contract predicates ===
(define-fun C0 () Bool (and (list_all_int lst) (list_all_positive lst)))

; === COMBINATION ===
(assert (not C0))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_
  Combination: {'assert_0': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': [], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'lst': []}
    Solution 2:
      test_case: {'lst': [1]}
    Solution 3:
      test_case: {'lst': [2438]}
    Solution 4:
      test_case: {'lst': [8366]}
    Solution 5:
      test_case: {'lst': [30613]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (ite (is-Nil lst)
       true
       (ite (is-Cons lst)
            (IsList (tail lst))
            false)))

(define-fun-rec list_all_int ((lst Value)) Bool
  (ite (is-Nil lst)
       true
       (ite (is-Cons lst)
            (let ((hd (head lst)) (tl (tail lst)))
              (and (is-IntVal hd)
                   (list_all_int tl)))
            false)))

(define-fun-rec list_all_positive ((lst Value)) Bool
  (ite (is-Nil lst)
       true
       (ite (is-Cons lst)
            (let ((hd (head lst)) (tl (tail lst)))
              (and (is-IntVal hd)
                   (>= (ival hd) 1)
                   (list_all_positive tl)))
            false)))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (IsList lst))

; === Contract predicates ===
(define-fun C0 () Bool (and (list_all_int lst) (list_all_positive lst)))

; === COMBINATION ===
(assert C0)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/70 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l) true
    (ite (is-Cons l) (IsList (tail l)) false)))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l) true
    (ite (is-Cons l)
      (and (is-IntVal (head l)) (list_all_int (tail l)))
      false)))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (IsList lst))

; === Contract predicates ===
(define-fun C0 () Bool (IsList lst))
(define-fun C1 () Bool (list_all_int lst))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'lst': [2.0]}
    Solution 2:
      test_case: {'lst': [3.0]}
    Solution 3:
      test_case: {'lst': [4.0]}
    Solution 4:
      test_case: {'lst': [5.0]}
    Solution 5:
      test_case: {'lst': [6.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l) true
    (ite (is-Cons l) (IsList (tail l)) false)))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l) true
    (ite (is-Cons l)
      (and (is-IntVal (head l)) (list_all_int (tail l)))
      false)))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (IsList lst))

; === Contract predicates ===
(define-fun C0 () Bool (IsList lst))
(define-fun C1 () Bool (list_all_int lst))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l) true
    (ite (is-Cons l) (IsList (tail l)) false)))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l) true
    (ite (is-Cons l)
      (and (is-IntVal (head l)) (list_all_int (tail l)))
      false)))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (IsList lst))

; === Contract predicates ===
(define-fun C0 () Bool (IsList lst))
(define-fun C1 () Bool (list_all_int lst))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'lst': []}
    Solution 2:
      test_case: {'lst': [2]}
    Solution 3:
      test_case: {'lst': [3]}
    Solution 4:
      test_case: {'lst': [4]}
    Solution 5:
      test_case: {'lst': [5]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l) true
    (ite (is-Cons l) (IsList (tail l)) false)))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l) true
    (ite (is-Cons l)
      (and (is-IntVal (head l)) (list_all_int (tail l)))
      false)))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (IsList lst))

; === Contract predicates ===
(define-fun C0 () Bool (IsList lst))
(define-fun C1 () Bool (list_all_int lst))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/71 ===
  Test Case 1: satisfied_, violated_assert_0
  Combination: {'assert_0': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0'], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'b': 2.0, 'c': 0, 'a': 0}
    Solution 2:
      test_case: {'c': -28102, 'b': -28101, 'a': -1}
    Solution 3:
      test_case: {'c': -19157, 'b': 3.0, 'a': -1}
    Solution 4:
      test_case: {'c': -19157, 'b': 4.0, 'a': -2}
    Solution 5:
      test_case: {'c': -28102, 'b': -0.5, 'a': 1}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun is-Numeric ((v Value)) Bool (or (is-IntVal v) (is-FloatVal v)))
(define-fun toReal ((v Value)) Real
  (ite (is-IntVal v) (to_real (ival v))
       (ite (is-FloatVal v) (fval v)
            0)))
(define-fun isPositive ((v Value)) Bool
  (and (is-Numeric v) (> (toReal v) 0)))

; === Inputs ===
(declare-const a Value)
(declare-const b Value)
(declare-const c Value)

; === BASIC STRUCTURE ===
(assert (is-Numeric a))
(assert (is-Numeric b))
(assert (is-Numeric c))

; === Contract predicates ===
(define-fun C0 () Bool (and (isPositive a) (isPositive b) (isPositive c)))

; === COMBINATION ===
(assert (not C0))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_
  Combination: {'assert_0': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': [], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'b': 0.5, 'c': 282, 'a': 1}
    Solution 2:
      test_case: {'c': 31892, 'b': 20977, 'a': 1}
    Solution 3:
      test_case: {'c': 31892.0, 'b': 20977, 'a': 1.25}
    Solution 4:
      test_case: {'c': 31892.0, 'b': 20977.0, 'a': 1.125}
    Solution 5:
      test_case: {'c': 32482.0, 'b': 20977.0, 'a': 1.0625}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun is-Numeric ((v Value)) Bool (or (is-IntVal v) (is-FloatVal v)))
(define-fun toReal ((v Value)) Real
  (ite (is-IntVal v) (to_real (ival v))
       (ite (is-FloatVal v) (fval v)
            0)))
(define-fun isPositive ((v Value)) Bool
  (and (is-Numeric v) (> (toReal v) 0)))

; === Inputs ===
(declare-const a Value)
(declare-const b Value)
(declare-const c Value)

; === BASIC STRUCTURE ===
(assert (is-Numeric a))
(assert (is-Numeric b))
(assert (is-Numeric c))

; === Contract predicates ===
(define-fun C0 () Bool (and (isPositive a) (isPositive b) (isPositive c)))

; === COMBINATION ===
(assert C0)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/72 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'q': ['!0!'], 'w': '!0!'}
    Solution 2:
      test_case: {'w': '!', 'q': ['0']}
    Solution 3:
      test_case: {'w': '0', 'q': ['0!']}
    Solution 4:
      test_case: {'w': False, 'q': ['!']}
    Solution 5:
      test_case: {'q': [False], 'w': True}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (IsList (tail l))
            false)))

(define-fun IsNumeric ((v Value)) Bool
  (or (is-IntVal v)
      (is-FloatVal v)))

(define-fun-rec list_all_numeric ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (and (IsNumeric (head l))
                 (list_all_numeric (tail l)))
            false)))

; === Inputs ===
(declare-const q Value)
(declare-const w Value)

; === BASIC STRUCTURE ===
(assert (IsList q))

; === Contract predicates ===
(define-fun C0 () Bool
  (and (IsList q)
       (list_all_numeric q)))
(define-fun C1 () Bool
  (IsNumeric w))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'q': [], 'w': '!0!'}
    Solution 2:
      test_case: {'w': '!', 'q': []}
    Solution 3:
      test_case: {'w': '0', 'q': []}
    Solution 4:
      test_case: {'w': '0!', 'q': []}
    Solution 5:
      test_case: {'w': '', 'q': []}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (IsList (tail l))
            false)))

(define-fun IsNumeric ((v Value)) Bool
  (or (is-IntVal v)
      (is-FloatVal v)))

(define-fun-rec list_all_numeric ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (and (IsNumeric (head l))
                 (list_all_numeric (tail l)))
            false)))

; === Inputs ===
(declare-const q Value)
(declare-const w Value)

; === BASIC STRUCTURE ===
(assert (IsList q))

; === Contract predicates ===
(define-fun C0 () Bool
  (and (IsList q)
       (list_all_numeric q)))
(define-fun C1 () Bool
  (IsNumeric w))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'q': ['!0!'], 'w': 2}
    Solution 2:
      test_case: {'w': 3, 'q': ['!']}
    Solution 3:
      test_case: {'w': 4, 'q': ['0']}
    Solution 4:
      test_case: {'w': 5, 'q': ['0!']}
    Solution 5:
      test_case: {'w': 6, 'q': ['']}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (IsList (tail l))
            false)))

(define-fun IsNumeric ((v Value)) Bool
  (or (is-IntVal v)
      (is-FloatVal v)))

(define-fun-rec list_all_numeric ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (and (IsNumeric (head l))
                 (list_all_numeric (tail l)))
            false)))

; === Inputs ===
(declare-const q Value)
(declare-const w Value)

; === BASIC STRUCTURE ===
(assert (IsList q))

; === Contract predicates ===
(define-fun C0 () Bool
  (and (IsList q)
       (list_all_numeric q)))
(define-fun C1 () Bool
  (IsNumeric w))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'q': [], 'w': 2}
    Solution 2:
      test_case: {'w': 3, 'q': []}
    Solution 3:
      test_case: {'q': [], 'w': 4}
    Solution 4:
      test_case: {'w': 5, 'q': []}
    Solution 5:
      test_case: {'w': 6, 'q': []}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (IsList (tail l))
            false)))

(define-fun IsNumeric ((v Value)) Bool
  (or (is-IntVal v)
      (is-FloatVal v)))

(define-fun-rec list_all_numeric ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (and (IsNumeric (head l))
                 (list_all_numeric (tail l)))
            false)))

; === Inputs ===
(declare-const q Value)
(declare-const w Value)

; === BASIC STRUCTURE ===
(assert (IsList q))

; === Contract predicates ===
(define-fun C0 () Bool
  (and (IsList q)
       (list_all_numeric q)))
(define-fun C1 () Bool
  (IsNumeric w))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/73 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'arr': 2.0}
    Solution 2:
      test_case: {'arr': 3.0}
    Solution 3:
      test_case: {'arr': 4.0}
    Solution 4:
      test_case: {'arr': 5.0}
    Solution 5:
      test_case: {'arr': 6.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_ints ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (is-IntVal (head v))
                 (list_all_ints (tail v)))
            false)))

; === Inputs ===
(declare-const arr Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool
  (IsList arr))
(define-fun C1 () Bool
  (list_all_ints arr))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'arr': [2.0]}
    Solution 2:
      test_case: {'arr': [3.0]}
    Solution 3:
      test_case: {'arr': [4.0]}
    Solution 4:
      test_case: {'arr': [5.0]}
    Solution 5:
      test_case: {'arr': [6.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_ints ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (is-IntVal (head v))
                 (list_all_ints (tail v)))
            false)))

; === Inputs ===
(declare-const arr Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool
  (IsList arr))
(define-fun C1 () Bool
  (list_all_ints arr))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_ints ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (is-IntVal (head v))
                 (list_all_ints (tail v)))
            false)))

; === Inputs ===
(declare-const arr Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool
  (IsList arr))
(define-fun C1 () Bool
  (list_all_ints arr))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'arr': []}
    Solution 2:
      test_case: {'arr': [2]}
    Solution 3:
      test_case: {'arr': [3]}
    Solution 4:
      test_case: {'arr': [4]}
    Solution 5:
      test_case: {'arr': [5]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_ints ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (is-IntVal (head v))
                 (list_all_ints (tail v)))
            false)))

; === Inputs ===
(declare-const arr Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool
  (IsList arr))
(define-fun C1 () Bool
  (list_all_ints arr))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/74 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1;assert_2
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2'], 'total_contracts': 3}
  Solutions:
    Solution 1:
      test_case: {'lst1': 2.0, 'lst2': 3.0}
    Solution 2:
      test_case: {'lst2': 4.0, 'lst1': 5.0}
    Solution 3:
      test_case: {'lst1': 7.0, 'lst2': 6.0}
    Solution 4:
      test_case: {'lst2': 9.0, 'lst1': 8.0}
    Solution 5:
      test_case: {'lst1': 11.0, 'lst2': 10.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l) true
       (ite (is-Cons l)
            (IsList (tail l))
            false)))

(define-fun-rec ListAllStr ((l Value)) Bool
  (ite (is-Nil l) true
       (ite (is-Cons l)
            (and (let ((h (head l))) (is-StrVal h))
                 (ListAllStr (tail l)))
            false)))

; === Inputs ===
(declare-const lst1 Value)
(declare-const lst2 Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (IsList lst1) (IsList lst2)))
(define-fun C1 () Bool (ListAllStr lst1))
(define-fun C2 () Bool (ListAllStr lst2))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1;assert_2
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1', 'assert_2'], 'total_contracts': 3}
  Solutions:
    Solution 1:
      test_case: {'lst1': [3.0], 'lst2': [2.0]}
    Solution 2:
      test_case: {'lst1': [4.0], 'lst2': [5.0]}
    Solution 3:
      test_case: {'lst2': [6.0], 'lst1': [7.0]}
    Solution 4:
      test_case: {'lst2': [9.0], 'lst1': [8.0]}
    Solution 5:
      test_case: {'lst1': [10.0], 'lst2': [11.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l) true
       (ite (is-Cons l)
            (IsList (tail l))
            false)))

(define-fun-rec ListAllStr ((l Value)) Bool
  (ite (is-Nil l) true
       (ite (is-Cons l)
            (and (let ((h (head l))) (is-StrVal h))
                 (ListAllStr (tail l)))
            false)))

; === Inputs ===
(declare-const lst1 Value)
(declare-const lst2 Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (IsList lst1) (IsList lst2)))
(define-fun C1 () Bool (ListAllStr lst1))
(define-fun C2 () Bool (ListAllStr lst2))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0;assert_2
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0', 'assert_2'], 'total_contracts': 3}
  Solutions:
    Solution 1:
      test_case: {'lst1': [], 'lst2': 2.0}
    Solution 2:
      test_case: {'lst2': 3.0, 'lst1': []}
    Solution 3:
      test_case: {'lst2': 4.0, 'lst1': []}
    Solution 4:
      test_case: {'lst1': [], 'lst2': 5.0}
    Solution 5:
      test_case: {'lst2': 6.0, 'lst1': []}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l) true
       (ite (is-Cons l)
            (IsList (tail l))
            false)))

(define-fun-rec ListAllStr ((l Value)) Bool
  (ite (is-Nil l) true
       (ite (is-Cons l)
            (and (let ((h (head l))) (is-StrVal h))
                 (ListAllStr (tail l)))
            false)))

; === Inputs ===
(declare-const lst1 Value)
(declare-const lst2 Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (IsList lst1) (IsList lst2)))
(define-fun C1 () Bool (ListAllStr lst1))
(define-fun C2 () Bool (ListAllStr lst2))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_assert_2
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': ['assert_2'], 'total_contracts': 3}
  Solutions:
    Solution 1:
      test_case: {'lst1': [], 'lst2': [2.0]}
    Solution 2:
      test_case: {'lst2': [3.0], 'lst1': []}
    Solution 3:
      test_case: {'lst1': [], 'lst2': [4.0]}
    Solution 4:
      test_case: {'lst2': [5.0], 'lst1': []}
    Solution 5:
      test_case: {'lst1': [], 'lst2': [6.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l) true
       (ite (is-Cons l)
            (IsList (tail l))
            false)))

(define-fun-rec ListAllStr ((l Value)) Bool
  (ite (is-Nil l) true
       (ite (is-Cons l)
            (and (let ((h (head l))) (is-StrVal h))
                 (ListAllStr (tail l)))
            false)))

; === Inputs ===
(declare-const lst1 Value)
(declare-const lst2 Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (IsList lst1) (IsList lst2)))
(define-fun C1 () Bool (ListAllStr lst1))
(define-fun C2 () Bool (ListAllStr lst2))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))

(check-sat)
(get-model)

------------------------------
  Test Case 5: satisfied_assert_2, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_2'], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 3}
  Solutions:
    Solution 1:
      test_case: {'lst1': 2.0, 'lst2': []}
    Solution 2:
      test_case: {'lst2': [], 'lst1': 3.0}
    Solution 3:
      test_case: {'lst2': [], 'lst1': 4.0}
    Solution 4:
      test_case: {'lst1': 5.0, 'lst2': []}
    Solution 5:
      test_case: {'lst2': [], 'lst1': 6.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l) true
       (ite (is-Cons l)
            (IsList (tail l))
            false)))

(define-fun-rec ListAllStr ((l Value)) Bool
  (ite (is-Nil l) true
       (ite (is-Cons l)
            (and (let ((h (head l))) (is-StrVal h))
                 (ListAllStr (tail l)))
            false)))

; === Inputs ===
(declare-const lst1 Value)
(declare-const lst2 Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (IsList lst1) (IsList lst2)))
(define-fun C1 () Bool (ListAllStr lst1))
(define-fun C2 () Bool (ListAllStr lst2))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)

(check-sat)
(get-model)

------------------------------
  Test Case 6: satisfied_assert_0;assert_2, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2'], 'violated_contracts': ['assert_1'], 'total_contracts': 3}
  Solutions:
    Solution 1:
      test_case: {'lst1': [2.0], 'lst2': []}
    Solution 2:
      test_case: {'lst2': [], 'lst1': [3.0]}
    Solution 3:
      test_case: {'lst1': [4.0], 'lst2': []}
    Solution 4:
      test_case: {'lst2': [], 'lst1': [5.0]}
    Solution 5:
      test_case: {'lst2': [], 'lst1': [6.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l) true
       (ite (is-Cons l)
            (IsList (tail l))
            false)))

(define-fun-rec ListAllStr ((l Value)) Bool
  (ite (is-Nil l) true
       (ite (is-Cons l)
            (and (let ((h (head l))) (is-StrVal h))
                 (ListAllStr (tail l)))
            false)))

; === Inputs ===
(declare-const lst1 Value)
(declare-const lst2 Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (IsList lst1) (IsList lst2)))
(define-fun C1 () Bool (ListAllStr lst1))
(define-fun C2 () Bool (ListAllStr lst2))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)

(check-sat)
(get-model)

------------------------------
  Test Case 7: satisfied_assert_1;assert_2, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2'], 'violated_contracts': ['assert_0'], 'total_contracts': 3}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l) true
       (ite (is-Cons l)
            (IsList (tail l))
            false)))

(define-fun-rec ListAllStr ((l Value)) Bool
  (ite (is-Nil l) true
       (ite (is-Cons l)
            (and (let ((h (head l))) (is-StrVal h))
                 (ListAllStr (tail l)))
            false)))

; === Inputs ===
(declare-const lst1 Value)
(declare-const lst2 Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (IsList lst1) (IsList lst2)))
(define-fun C1 () Bool (ListAllStr lst1))
(define-fun C2 () Bool (ListAllStr lst2))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)

(check-sat)
(get-model)

------------------------------
  Test Case 8: satisfied_assert_0;assert_1;assert_2, violated_
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2'], 'violated_contracts': [], 'total_contracts': 3}
  Solutions:
    Solution 1:
      test_case: {'lst1': [], 'lst2': []}
    Solution 2:
      test_case: {'lst2': ['!0!'], 'lst1': []}
    Solution 3:
      test_case: {'lst2': ['!'], 'lst1': []}
    Solution 4:
      test_case: {'lst2': ['0'], 'lst1': []}
    Solution 5:
      test_case: {'lst1': [], 'lst2': ['0!']}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l) true
       (ite (is-Cons l)
            (IsList (tail l))
            false)))

(define-fun-rec ListAllStr ((l Value)) Bool
  (ite (is-Nil l) true
       (ite (is-Cons l)
            (and (let ((h (head l))) (is-StrVal h))
                 (ListAllStr (tail l)))
            false)))

; === Inputs ===
(declare-const lst1 Value)
(declare-const lst2 Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (IsList lst1) (IsList lst2)))
(define-fun C1 () Bool (ListAllStr lst1))
(define-fun C2 () Bool (ListAllStr lst2))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/75 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'a': 2.0}
    Solution 2:
      test_case: {'a': 3.0}
    Solution 3:
      test_case: {'a': 4.0}
    Solution 4:
      test_case: {'a': 5.0}
    Solution 5:
      test_case: {'a': 6.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const a Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal a))
(define-fun C1 () Bool (and (is-IntVal a) (< (SafeI a) 100)))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'a': 100}
    Solution 2:
      test_case: {'a': 7819}
    Solution 3:
      test_case: {'a': 10256}
    Solution 4:
      test_case: {'a': 22053}
    Solution 5:
      test_case: {'a': 54338}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const a Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal a))
(define-fun C1 () Bool (and (is-IntVal a) (< (SafeI a) 100)))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const a Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal a))
(define-fun C1 () Bool (and (is-IntVal a) (< (SafeI a) 100)))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'a': 0}
    Solution 2:
      test_case: {'a': -7719}
    Solution 3:
      test_case: {'a': -10156}
    Solution 4:
      test_case: {'a': -21953}
    Solution 5:
      test_case: {'a': -54238}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const a Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal a))
(define-fun C1 () Bool (and (is-IntVal a) (< (SafeI a) 100)))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/76 ===
  Test Case 1: satisfied_, violated_assert_0
  Combination: {'assert_0': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0'], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'x': 2.0, 'n': 3.0}
    Solution 2:
      test_case: {'n': 4.0, 'x': 5.0}
    Solution 3:
      test_case: {'n': 6.0, 'x': 7.0}
    Solution 4:
      test_case: {'n': 9.0, 'x': 8.0}
    Solution 5:
      test_case: {'n': 11.0, 'x': 10.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const x Value)
(declare-const n Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (is-IntVal x) (is-IntVal n)))

; === COMBINATION ===
(assert (not C0))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_
  Combination: {'assert_0': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': [], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'x': 2, 'n': 3}
    Solution 2:
      test_case: {'x': 4, 'n': 5}
    Solution 3:
      test_case: {'x': 6, 'n': 7}
    Solution 4:
      test_case: {'x': 8, 'n': 9}
    Solution 5:
      test_case: {'x': 10, 'n': 11}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const x Value)
(declare-const n Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (is-IntVal x) (is-IntVal n)))

; === COMBINATION ===
(assert C0)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/77 ===
  Test Case 1: satisfied_, violated_assert_0
  Combination: {'assert_0': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0'], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'a': 2.0}
    Solution 2:
      test_case: {'a': 3.0}
    Solution 3:
      test_case: {'a': 4.0}
    Solution 4:
      test_case: {'a': 5.0}
    Solution 5:
      test_case: {'a': 6.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeIVal ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const a Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal a))

; === COMBINATION ===
(assert (not C0))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_
  Combination: {'assert_0': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': [], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'a': 2}
    Solution 2:
      test_case: {'a': 3}
    Solution 3:
      test_case: {'a': 4}
    Solution 4:
      test_case: {'a': 5}
    Solution 5:
      test_case: {'a': 6}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeIVal ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const a Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal a))

; === COMBINATION ===
(assert C0)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/78 ===
  Test Case 1: satisfied_, violated_assert_0
  Combination: {'assert_0': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0'], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'num': '@'}
    Solution 2:
      test_case: {'num': ' '}
    Solution 3:
      test_case: {'num': '\\u{8020}'}
    Solution 4:
      test_case: {'num': '\\u{8420}'}
    Solution 5:
      test_case: {'num': '\\u{8428}'}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun hex_char_re () (RegEx String)
  (re.union (re.range "0" "9") (re.range "A" "F")))

; === Inputs ===
(declare-const num Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal num))

; === Contract predicates ===
(define-fun C0 () Bool (and (is-StrVal num) (str.in.re (sval num) (re.* hex_char_re))))

; === COMBINATION ===
(assert (not C0))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_
  Combination: {'assert_0': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': [], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'num': ''}
    Solution 2:
      test_case: {'num': '0'}
    Solution 3:
      test_case: {'num': '8'}
    Solution 4:
      test_case: {'num': '9'}
    Solution 5:
      test_case: {'num': '1'}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun hex_char_re () (RegEx String)
  (re.union (re.range "0" "9") (re.range "A" "F")))

; === Inputs ===
(declare-const num Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal num))

; === Contract predicates ===
(define-fun C0 () Bool (and (is-StrVal num) (str.in.re (sval num) (re.* hex_char_re))))

; === COMBINATION ===
(assert C0)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/79 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'decimal': 2.0}
    Solution 2:
      test_case: {'decimal': 3.0}
    Solution 3:
      test_case: {'decimal': 4.0}
    Solution 4:
      test_case: {'decimal': 5.0}
    Solution 5:
      test_case: {'decimal': 6.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const decimal Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal decimal))
(define-fun C1 () Bool (and (is-IntVal decimal) (>= (ival decimal) 0)))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'decimal': -1}
    Solution 2:
      test_case: {'decimal': -7720}
    Solution 3:
      test_case: {'decimal': -10157}
    Solution 4:
      test_case: {'decimal': -21954}
    Solution 5:
      test_case: {'decimal': -54239}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const decimal Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal decimal))
(define-fun C1 () Bool (and (is-IntVal decimal) (>= (ival decimal) 0)))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const decimal Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal decimal))
(define-fun C1 () Bool (and (is-IntVal decimal) (>= (ival decimal) 0)))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'decimal': 0}
    Solution 2:
      test_case: {'decimal': 7719}
    Solution 3:
      test_case: {'decimal': 10156}
    Solution 4:
      test_case: {'decimal': 21953}
    Solution 5:
      test_case: {'decimal': 54238}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const decimal Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal decimal))
(define-fun C1 () Bool (and (is-IntVal decimal) (>= (ival decimal) 0)))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/80 ===
  Test Case 1: satisfied_, violated_assert_0
  Combination: {'assert_0': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0'], 'total_contracts': 1}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeStrLen ((v Value)) Int
  (ite (is-StrVal v)
       (str.len (sval v))
       0))
(define-fun SafeCharAt ((v Value) (i Int)) Value
  (ite (and (is-StrVal v)
            (<= 0 i)
            (< i (str.len (sval v))))
       (StrVal (str.substr (sval v) i 1))
       Nil))

; === Inputs ===
(declare-const s Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal s))

; === Contract predicates ===
(define-fun C0 () Bool
  (is-StrVal s))

; === COMBINATION ===
(assert (not C0))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_
  Combination: {'assert_0': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': [], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'s': '!0!'}
    Solution 2:
      test_case: {'s': '!'}
    Solution 3:
      test_case: {'s': '0'}
    Solution 4:
      test_case: {'s': '0!'}
    Solution 5:
      test_case: {'s': ''}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeStrLen ((v Value)) Int
  (ite (is-StrVal v)
       (str.len (sval v))
       0))
(define-fun SafeCharAt ((v Value) (i Int)) Value
  (ite (and (is-StrVal v)
            (<= 0 i)
            (< i (str.len (sval v))))
       (StrVal (str.substr (sval v) i 1))
       Nil))

; === Inputs ===
(declare-const s Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal s))

; === Contract predicates ===
(define-fun C0 () Bool
  (is-StrVal s))

; === COMBINATION ===
(assert C0)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/81 ===
  Test Case 1: satisfied_, violated_assert_0
  Combination: {'assert_0': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0'], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'grades': [-1]}
    Solution 2:
      test_case: {'grades': [5]}
    Solution 3:
      test_case: {'grades': [-0.5]}
    Solution 4:
      test_case: {'grades': [-0.25]}
    Solution 5:
      test_case: {'grades': [-0.125]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (IsList (tail l))
            false)))

(define-fun-rec list_all_numeric ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (and (or (is-IntVal (head l)) (is-FloatVal (head l)))
                 (list_all_numeric (tail l)))
            false)))

(define-fun get_real ((v Value)) Real
  (ite (is-IntVal v)
       (to_real (ival v))
       (ite (is-FloatVal v)
            (fval v)
            0)))

(define-fun-rec list_all_in_range ((l Value) (lo Real) (hi Real)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (let ((headVal (get_real (head l))))
              (and (<= lo headVal)
                   (<= headVal hi)
                   (list_all_in_range (tail l) lo hi)))
            false)))

; === Inputs ===
(declare-const grades Value)

; === BASIC STRUCTURE ===
(assert (IsList grades))

; === Contract predicates ===
(define-fun C0 () Bool (and (list_all_numeric grades) (list_all_in_range grades 0.0 4.0)))

; === COMBINATION ===
(assert (not C0))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_
  Combination: {'assert_0': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': [], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'grades': []}
    Solution 2:
      test_case: {'grades': [0.5]}
    Solution 3:
      test_case: {'grades': [0.0]}
    Solution 4:
      test_case: {'grades': [1]}
    Solution 5:
      test_case: {'grades': [0.25]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (IsList (tail l))
            false)))

(define-fun-rec list_all_numeric ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (and (or (is-IntVal (head l)) (is-FloatVal (head l)))
                 (list_all_numeric (tail l)))
            false)))

(define-fun get_real ((v Value)) Real
  (ite (is-IntVal v)
       (to_real (ival v))
       (ite (is-FloatVal v)
            (fval v)
            0)))

(define-fun-rec list_all_in_range ((l Value) (lo Real) (hi Real)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (let ((headVal (get_real (head l))))
              (and (<= lo headVal)
                   (<= headVal hi)
                   (list_all_in_range (tail l) lo hi)))
            false)))

; === Inputs ===
(declare-const grades Value)

; === BASIC STRUCTURE ===
(assert (IsList grades))

; === Contract predicates ===
(define-fun C0 () Bool (and (list_all_numeric grades) (list_all_in_range grades 0.0 4.0)))

; === COMBINATION ===
(assert C0)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/82 ===
  Test Case 1: satisfied_, violated_assert_0
  Combination: {'assert_0': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0'], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'string': 2.0}
    Solution 2:
      test_case: {'string': 3.0}
    Solution 3:
      test_case: {'string': 4.0}
    Solution 4:
      test_case: {'string': 5.0}
    Solution 5:
      test_case: {'string': 6.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeS ((v Value)) String (ite (is-StrVal v) (sval v) ""))
(define-fun length ((s Value)) Int (str.len (SafeS s)))
(define-fun is_prime ((n Int)) Bool
  (and (>= n 2)
       (forall ((x Int))
         (or (< x 2)
             (> (* x x) n)
             (not (= (mod n x) 0))))))

; === Inputs ===
(declare-const string Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal string))

; === COMBINATION ===
(assert (not C0))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_
  Combination: {'assert_0': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': [], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'string': '!0!'}
    Solution 2:
      test_case: {'string': '!'}
    Solution 3:
      test_case: {'string': '0'}
    Solution 4:
      test_case: {'string': '0!'}
    Solution 5:
      test_case: {'string': ''}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeS ((v Value)) String (ite (is-StrVal v) (sval v) ""))
(define-fun length ((s Value)) Int (str.len (SafeS s)))
(define-fun is_prime ((n Int)) Bool
  (and (>= n 2)
       (forall ((x Int))
         (or (< x 2)
             (> (* x x) n)
             (not (= (mod n x) 0))))))

; === Inputs ===
(declare-const string Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal string))

; === COMBINATION ===
(assert C0)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/83 ===
  Test Case 1: satisfied_, violated_assert_0
  Combination: {'assert_0': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0'], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'n': 2.0}
    Solution 2:
      test_case: {'n': 3.0}
    Solution 3:
      test_case: {'n': 4.0}
    Solution 4:
      test_case: {'n': 5.0}
    Solution 5:
      test_case: {'n': 6.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (is-IntVal n) (> (ival n) 0)))

; === COMBINATION ===
(assert (not C0))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_
  Combination: {'assert_0': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': [], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'n': 1}
    Solution 2:
      test_case: {'n': 7720}
    Solution 3:
      test_case: {'n': 10157}
    Solution 4:
      test_case: {'n': 21954}
    Solution 5:
      test_case: {'n': 54239}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (is-IntVal n) (> (ival n) 0)))

; === COMBINATION ===
(assert C0)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/84 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'N': 2.0}
    Solution 2:
      test_case: {'N': 3.0}
    Solution 3:
      test_case: {'N': 4.0}
    Solution 4:
      test_case: {'N': 5.0}
    Solution 5:
      test_case: {'N': 6.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const N Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal N))
(define-fun C1 () Bool (and (> (SafeI N) 0) (<= (SafeI N) 10000)))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'N': 10001}
    Solution 2:
      test_case: {'N': 31239}
    Solution 3:
      test_case: {'N': 43036}
    Solution 4:
      test_case: {'N': 53486}
    Solution 5:
      test_case: {'N': 81586}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const N Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal N))
(define-fun C1 () Bool (and (> (SafeI N) 0) (<= (SafeI N) 10000)))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const N Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal N))
(define-fun C1 () Bool (and (> (SafeI N) 0) (<= (SafeI N) 10000)))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'N': 1}
    Solution 2:
      test_case: {'N': 7720}
    Solution 3:
      test_case: {'N': 2438}
    Solution 4:
      test_case: {'N': 1798}
    Solution 5:
      test_case: {'N': 2286}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const N Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal N))
(define-fun C1 () Bool (and (> (SafeI N) 0) (<= (SafeI N) 10000)))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/85 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec length ((l Value)) Int
  (ite (is-Nil l)
       0
       (ite (is-Cons l)
            (+ 1 (length (tail l)))
            0)))

(define-fun-rec isList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (isList (tail l))
            false)))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (and (is-IntVal (head l)) (list_all_int (tail l)))
            false)))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (isList lst))

; === Contract predicates ===
(define-fun C0 () Bool (> (length lst) 0))
(define-fun C1 () Bool (list_all_int lst))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'lst': [2.0]}
    Solution 2:
      test_case: {'lst': [3.0]}
    Solution 3:
      test_case: {'lst': [4.0]}
    Solution 4:
      test_case: {'lst': [5.0]}
    Solution 5:
      test_case: {'lst': [6.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec length ((l Value)) Int
  (ite (is-Nil l)
       0
       (ite (is-Cons l)
            (+ 1 (length (tail l)))
            0)))

(define-fun-rec isList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (isList (tail l))
            false)))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (and (is-IntVal (head l)) (list_all_int (tail l)))
            false)))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (isList lst))

; === Contract predicates ===
(define-fun C0 () Bool (> (length lst) 0))
(define-fun C1 () Bool (list_all_int lst))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: True
  Solution Count: 1
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'lst': []}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec length ((l Value)) Int
  (ite (is-Nil l)
       0
       (ite (is-Cons l)
            (+ 1 (length (tail l)))
            0)))

(define-fun-rec isList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (isList (tail l))
            false)))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (and (is-IntVal (head l)) (list_all_int (tail l)))
            false)))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (isList lst))

; === Contract predicates ===
(define-fun C0 () Bool (> (length lst) 0))
(define-fun C1 () Bool (list_all_int lst))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'lst': [4]}
    Solution 2:
      test_case: {'lst': [5]}
    Solution 3:
      test_case: {'lst': [6]}
    Solution 4:
      test_case: {'lst': [7]}
    Solution 5:
      test_case: {'lst': [8]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec length ((l Value)) Int
  (ite (is-Nil l)
       0
       (ite (is-Cons l)
            (+ 1 (length (tail l)))
            0)))

(define-fun-rec isList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (isList (tail l))
            false)))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (and (is-IntVal (head l)) (list_all_int (tail l)))
            false)))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (isList lst))

; === Contract predicates ===
(define-fun C0 () Bool (> (length lst) 0))
(define-fun C1 () Bool (list_all_int lst))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/86 ===
  Test Case 1: satisfied_, violated_assert_0
  Combination: {'assert_0': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0'], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'s': 2.0}
    Solution 2:
      test_case: {'s': 3.0}
    Solution 3:
      test_case: {'s': 4.0}
    Solution 4:
      test_case: {'s': 5.0}
    Solution 5:
      test_case: {'s': 6.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeS ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

; === Inputs ===
(declare-const s Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal s))

; === COMBINATION ===
(assert (not C0))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_
  Combination: {'assert_0': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': [], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'s': '!0!'}
    Solution 2:
      test_case: {'s': '!'}
    Solution 3:
      test_case: {'s': '0'}
    Solution 4:
      test_case: {'s': '0!'}
    Solution 5:
      test_case: {'s': ''}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeS ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

; === Inputs ===
(declare-const s Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal s))

; === COMBINATION ===
(assert C0)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/87 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1;assert_2
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2'], 'total_contracts': 3}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec AllRowsAreList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (and (IsList (head l))
                 (AllRowsAreList (tail l)))
            false)))

; === Inputs ===
(declare-const lst Value)
(declare-const x Value)

; === BASIC STRUCTURE ===
(assert (IsList lst))
(assert (AllRowsAreList lst))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal x))
(define-fun C1 () Bool (IsList lst))
(define-fun C2 () Bool (AllRowsAreList lst))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1;assert_2
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1', 'assert_2'], 'total_contracts': 3}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec AllRowsAreList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (and (IsList (head l))
                 (AllRowsAreList (tail l)))
            false)))

; === Inputs ===
(declare-const lst Value)
(declare-const x Value)

; === BASIC STRUCTURE ===
(assert (IsList lst))
(assert (AllRowsAreList lst))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal x))
(define-fun C1 () Bool (IsList lst))
(define-fun C2 () Bool (AllRowsAreList lst))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0;assert_2
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0', 'assert_2'], 'total_contracts': 3}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec AllRowsAreList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (and (IsList (head l))
                 (AllRowsAreList (tail l)))
            false)))

; === Inputs ===
(declare-const lst Value)
(declare-const x Value)

; === BASIC STRUCTURE ===
(assert (IsList lst))
(assert (AllRowsAreList lst))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal x))
(define-fun C1 () Bool (IsList lst))
(define-fun C2 () Bool (AllRowsAreList lst))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_assert_2
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': ['assert_2'], 'total_contracts': 3}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec AllRowsAreList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (and (IsList (head l))
                 (AllRowsAreList (tail l)))
            false)))

; === Inputs ===
(declare-const lst Value)
(declare-const x Value)

; === BASIC STRUCTURE ===
(assert (IsList lst))
(assert (AllRowsAreList lst))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal x))
(define-fun C1 () Bool (IsList lst))
(define-fun C2 () Bool (AllRowsAreList lst))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))

(check-sat)
(get-model)

------------------------------
  Test Case 5: satisfied_assert_2, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_2'], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 3}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec AllRowsAreList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (and (IsList (head l))
                 (AllRowsAreList (tail l)))
            false)))

; === Inputs ===
(declare-const lst Value)
(declare-const x Value)

; === BASIC STRUCTURE ===
(assert (IsList lst))
(assert (AllRowsAreList lst))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal x))
(define-fun C1 () Bool (IsList lst))
(define-fun C2 () Bool (AllRowsAreList lst))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)

(check-sat)
(get-model)

------------------------------
  Test Case 6: satisfied_assert_0;assert_2, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2'], 'violated_contracts': ['assert_1'], 'total_contracts': 3}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec AllRowsAreList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (and (IsList (head l))
                 (AllRowsAreList (tail l)))
            false)))

; === Inputs ===
(declare-const lst Value)
(declare-const x Value)

; === BASIC STRUCTURE ===
(assert (IsList lst))
(assert (AllRowsAreList lst))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal x))
(define-fun C1 () Bool (IsList lst))
(define-fun C2 () Bool (AllRowsAreList lst))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)

(check-sat)
(get-model)

------------------------------
  Test Case 7: satisfied_assert_1;assert_2, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2'], 'violated_contracts': ['assert_0'], 'total_contracts': 3}
  Solutions:
    Solution 1:
      test_case: {'lst': [], 'x': 2.0}
    Solution 2:
      test_case: {'x': 3.0, 'lst': []}
    Solution 3:
      test_case: {'lst': [], 'x': 4.0}
    Solution 4:
      test_case: {'x': 5.0, 'lst': []}
    Solution 5:
      test_case: {'x': 6.0, 'lst': []}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec AllRowsAreList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (and (IsList (head l))
                 (AllRowsAreList (tail l)))
            false)))

; === Inputs ===
(declare-const lst Value)
(declare-const x Value)

; === BASIC STRUCTURE ===
(assert (IsList lst))
(assert (AllRowsAreList lst))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal x))
(define-fun C1 () Bool (IsList lst))
(define-fun C2 () Bool (AllRowsAreList lst))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)

(check-sat)
(get-model)

------------------------------
  Test Case 8: satisfied_assert_0;assert_1;assert_2, violated_
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2'], 'violated_contracts': [], 'total_contracts': 3}
  Solutions:
    Solution 1:
      test_case: {'lst': [], 'x': 2}
    Solution 2:
      test_case: {'x': 3, 'lst': []}
    Solution 3:
      test_case: {'x': 4, 'lst': []}
    Solution 4:
      test_case: {'lst': [], 'x': 5}
    Solution 5:
      test_case: {'x': 6, 'lst': []}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec AllRowsAreList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (and (IsList (head l))
                 (AllRowsAreList (tail l)))
            false)))

; === Inputs ===
(declare-const lst Value)
(declare-const x Value)

; === BASIC STRUCTURE ===
(assert (IsList lst))
(assert (AllRowsAreList lst))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal x))
(define-fun C1 () Bool (IsList lst))
(define-fun C2 () Bool (AllRowsAreList lst))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/88 ===
  Test Case 1: satisfied_, violated_assert_0
  Combination: {'assert_0': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0'], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'array': [2.0]}
    Solution 2:
      test_case: {'array': [3.0]}
    Solution 3:
      test_case: {'array': [4.0]}
    Solution 4:
      test_case: {'array': [5.0]}
    Solution 5:
      test_case: {'array': [6.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (or (is-Nil l)
      (and (is-Cons l)
           (let ((h (head l)) (t (tail l)))
             (IsList t)))))

(define-fun-rec list_all_nonneg_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (and (is-Cons l)
            (let ((h (head l)) (t (tail l)))
              (and (is-IntVal h)
                   (>= (ival h) 0)
                   (list_all_nonneg_int t))))))

; === Inputs ===
(declare-const array Value)

; === BASIC STRUCTURE ===
(assert (IsList array))

; === Contract predicates ===
(define-fun C0 () Bool
  (list_all_nonneg_int array))

; === COMBINATION ===
(assert (not C0))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_
  Combination: {'assert_0': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': [], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'array': []}
    Solution 2:
      test_case: {'array': [0]}
    Solution 3:
      test_case: {'array': [2437]}
    Solution 4:
      test_case: {'array': [8365]}
    Solution 5:
      test_case: {'array': [30612]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (or (is-Nil l)
      (and (is-Cons l)
           (let ((h (head l)) (t (tail l)))
             (IsList t)))))

(define-fun-rec list_all_nonneg_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (and (is-Cons l)
            (let ((h (head l)) (t (tail l)))
              (and (is-IntVal h)
                   (>= (ival h) 0)
                   (list_all_nonneg_int t))))))

; === Inputs ===
(declare-const array Value)

; === BASIC STRUCTURE ===
(assert (IsList array))

; === Contract predicates ===
(define-fun C0 () Bool
  (list_all_nonneg_int array))

; === COMBINATION ===
(assert C0)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/89 ===
  Test Case 1: satisfied_, violated_assert_0
  Combination: {'assert_0': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0'], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'s': '['}
    Solution 2:
      test_case: {'s': 'a'}
    Solution 3:
      test_case: {'s': '-'}
    Solution 4:
      test_case: {'s': 'z'}
    Solution 5:
      test_case: {'s': ']'}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const s Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal s))

; === Contract predicates ===
(define-fun C0 () Bool
  (or (= (sval s) "")
      (str.in.re (sval s) (str.to.re "[a-z]*"))))

; === COMBINATION ===
(assert (not C0))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_
  Combination: {'assert_0': True}
  Satisfiable: True
  Solution Count: 2
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': [], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'s': ''}
    Solution 2:
      test_case: {'s': '[a-z]*'}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const s Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal s))

; === Contract predicates ===
(define-fun C0 () Bool
  (or (= (sval s) "")
      (str.in.re (sval s) (str.to.re "[a-z]*"))))

; === COMBINATION ===
(assert C0)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/90 ===
  Test Case 1: satisfied_, violated_assert_0
  Combination: {'assert_0': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0'], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'lst': [2.0]}
    Solution 2:
      test_case: {'lst': [3.0]}
    Solution 3:
      test_case: {'lst': [4.0]}
    Solution 4:
      test_case: {'lst': [5.0]}
    Solution 5:
      test_case: {'lst': [6.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v) (IsList (tail v)))))

(define-fun-rec ListAllInt ((v Value)) Bool
  (ite (is-Nil v) true
       (ite (is-Cons v)
            (and (is-IntVal (head v)) (ListAllInt (tail v)))
            false)))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (IsList lst))

; === Contract predicates ===
(define-fun C0 () Bool (ListAllInt lst))

; === COMBINATION ===
(assert (not C0))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_
  Combination: {'assert_0': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': [], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'lst': []}
    Solution 2:
      test_case: {'lst': [2]}
    Solution 3:
      test_case: {'lst': [3]}
    Solution 4:
      test_case: {'lst': [4]}
    Solution 5:
      test_case: {'lst': [5]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v) (IsList (tail v)))))

(define-fun-rec ListAllInt ((v Value)) Bool
  (ite (is-Nil v) true
       (ite (is-Cons v)
            (and (is-IntVal (head v)) (ListAllInt (tail v)))
            false)))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (IsList lst))

; === Contract predicates ===
(define-fun C0 () Bool (ListAllInt lst))

; === COMBINATION ===
(assert C0)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/91 ===
  Test Case 1: satisfied_, violated_assert_0
  Combination: {'assert_0': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0'], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'S': 2.0}
    Solution 2:
      test_case: {'S': 3.0}
    Solution 3:
      test_case: {'S': 4.0}
    Solution 4:
      test_case: {'S': 5.0}
    Solution 5:
      test_case: {'S': 6.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const S Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal S))

; === COMBINATION ===
(assert (not C0))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_
  Combination: {'assert_0': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': [], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'S': '!0!'}
    Solution 2:
      test_case: {'S': '!'}
    Solution 3:
      test_case: {'S': '0'}
    Solution 4:
      test_case: {'S': '0!'}
    Solution 5:
      test_case: {'S': ''}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const S Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal S))

; === COMBINATION ===
(assert C0)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/92 ===
  Test Case 1: satisfied_, violated_assert_0
  Combination: {'assert_0': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0'], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'y': '!0!', 'z': '!0!', 'x': '!0!'}
    Solution 2:
      test_case: {'x': '0!', 'z': '0', 'y': '!'}
    Solution 3:
      test_case: {'x': '0', 'z': '0!', 'y': '0!'}
    Solution 4:
      test_case: {'x': [2.0, 3.0], 'z': [], 'y': []}
    Solution 5:
      test_case: {'x': [5.0, 4.0], 'z': [7.0, 6.0], 'y': [9.0, 8.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const x Value)
(declare-const y Value)
(declare-const z Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (or (is-IntVal x) (is-FloatVal x) (is-BoolVal x)) (or (is-IntVal y) (is-FloatVal y) (is-BoolVal y)) (or (is-IntVal z) (is-FloatVal z) (is-BoolVal z))))

; === COMBINATION ===
(assert (not C0))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_
  Combination: {'assert_0': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': [], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'y': False, 'z': 2, 'x': 3}
    Solution 2:
      test_case: {'x': 4, 'z': False, 'y': True}
    Solution 3:
      test_case: {'x': 5, 'z': True, 'y': True}
    Solution 4:
      test_case: {'x': 6, 'z': True, 'y': True}
    Solution 5:
      test_case: {'x': 7, 'z': True, 'y': True}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const x Value)
(declare-const y Value)
(declare-const z Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (or (is-IntVal x) (is-FloatVal x) (is-BoolVal x)) (or (is-IntVal y) (is-FloatVal y) (is-BoolVal y)) (or (is-IntVal z) (is-FloatVal z) (is-BoolVal z))))

; === COMBINATION ===
(assert C0)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/93 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const message Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal message))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal message))
(define-fun C1 () Bool (let ((s (ite (is-StrVal message) (sval message) ""))) (forall ((i Int)) (=> (and (>= i 0) (< i (str.len s))) (or (= (str.substr s i 1) " ") (str.in.re (str.substr s i 1) (str.to.re "[A-Za-z]")))))))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'message': '['}
    Solution 2:
      test_case: {'message': 'A'}
    Solution 3:
      test_case: {'message': 'B'}
    Solution 4:
      test_case: {'message': 'C'}
    Solution 5:
      test_case: {'message': 'D'}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const message Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal message))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal message))
(define-fun C1 () Bool (let ((s (ite (is-StrVal message) (sval message) ""))) (forall ((i Int)) (=> (and (>= i 0) (< i (str.len s))) (or (= (str.substr s i 1) " ") (str.in.re (str.substr s i 1) (str.to.re "[A-Za-z]")))))))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const message Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal message))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal message))
(define-fun C1 () Bool (let ((s (ite (is-StrVal message) (sval message) ""))) (forall ((i Int)) (=> (and (>= i 0) (< i (str.len s))) (or (= (str.substr s i 1) " ") (str.in.re (str.substr s i 1) (str.to.re "[A-Za-z]")))))))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'message': ''}
    Solution 2:
      test_case: {'message': ' '}
    Solution 3:
      test_case: {'message': '  '}
    Solution 4:
      test_case: {'message': '    '}
    Solution 5:
      test_case: {'message': '   '}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const message Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal message))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal message))
(define-fun C1 () Bool (let ((s (ite (is-StrVal message) (sval message) ""))) (forall ((i Int)) (=> (and (>= i 0) (< i (str.len s))) (or (= (str.substr s i 1) " ") (str.in.re (str.substr s i 1) (str.to.re "[A-Za-z]")))))))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/94 ===
  Test Case 1: satisfied_, violated_assert_0
  Combination: {'assert_0': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0'], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'lst': []}
    Solution 2:
      test_case: {'lst': [0]}
    Solution 3:
      test_case: {'lst': [4]}
    Solution 4:
      test_case: {'lst': [-5853]}
    Solution 5:
      test_case: {'lst': [17894]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (let ((tailVal (tail v)))
             (IsList tailVal)))))
(define-fun-rec list_all_int ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (let ((headVal (head v)) (tailVal (tail v)))
             (and (is-IntVal headVal)
                  (list_all_int tailVal))))))
(define-fun-rec has_no_divisor ((n Int) (x Int)) Bool
  (ite (> (* x x) n)
       true
       (ite (= (mod n x) 0)
            false
            (has_no_divisor n (+ x 1)))))
(define-fun is_prime_val ((v Value)) Bool
  (and (is-IntVal v)
       (let ((n (ival v)))
         (and (>= n 2)
              (has_no_divisor n 2)))))
(define-fun-rec list_has_prime ((v Value)) Bool
  (ite (is-Nil v)
       false
       (and (is-Cons v)
            (let ((headVal (head v)) (tailVal (tail v)))
              (or (is_prime_val headVal)
                  (list_has_prime tailVal))))))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (IsList lst))
(assert (list_all_int lst))

; === Contract predicates ===
(define-fun C0 () Bool (list_has_prime lst))

; === COMBINATION ===
(assert (not C0))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_
  Combination: {'assert_0': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': [], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'lst': [3]}
    Solution 2:
      test_case: {'lst': [3, 7]}
    Solution 3:
      test_case: {'lst': [3, 5]}
    Solution 4:
      test_case: {'lst': [3, 6]}
    Solution 5:
      test_case: {'lst': [3, 8]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (let ((tailVal (tail v)))
             (IsList tailVal)))))
(define-fun-rec list_all_int ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (let ((headVal (head v)) (tailVal (tail v)))
             (and (is-IntVal headVal)
                  (list_all_int tailVal))))))
(define-fun-rec has_no_divisor ((n Int) (x Int)) Bool
  (ite (> (* x x) n)
       true
       (ite (= (mod n x) 0)
            false
            (has_no_divisor n (+ x 1)))))
(define-fun is_prime_val ((v Value)) Bool
  (and (is-IntVal v)
       (let ((n (ival v)))
         (and (>= n 2)
              (has_no_divisor n 2)))))
(define-fun-rec list_has_prime ((v Value)) Bool
  (ite (is-Nil v)
       false
       (and (is-Cons v)
            (let ((headVal (head v)) (tailVal (tail v)))
              (or (is_prime_val headVal)
                  (list_has_prime tailVal))))))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (IsList lst))
(assert (list_all_int lst))

; === Contract predicates ===
(define-fun C0 () Bool (list_has_prime lst))

; === COMBINATION ===
(assert C0)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/95 ===
  Test Case 1: satisfied_, violated_assert_0
  Combination: {'assert_0': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0'], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'dict': 2.0}
    Solution 2:
      test_case: {'dict': 3.0}
    Solution 3:
      test_case: {'dict': 4.0}
    Solution 4:
      test_case: {'dict': 5.0}
    Solution 5:
      test_case: {'dict': 6.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun IsKV2 ((p Value)) Bool
  (and (is-Cons p)
       (is-Cons (tail p))
       (is-Nil (tail (tail p)))
       (is-StrVal (head p))))

(define-fun-rec IsDictLike ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (IsKV2 (head v)) (IsDictLike (tail v)))
            false)))

(define-fun-rec KeysV ((v Value)) Value
  (ite (is-Nil v)
       Nil
       (Cons (head (head v)) (KeysV (tail v)))))

; === Inputs ===
(declare-const dict Value)

; === BASIC STRUCTURE ===
(assert (=> (IsDictLike dict)
                 (IsList (KeysV dict))))

; === Contract predicates ===
(define-fun C0 () Bool
  (IsDictLike dict))

; === COMBINATION ===
(assert (not C0))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_
  Combination: {'assert_0': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': [], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'dict': []}
    Solution 2:
      test_case: {'dict': [['!0!', 2.0]]}
    Solution 3:
      test_case: {'dict': [['!', 3.0]]}
    Solution 4:
      test_case: {'dict': [['0', 4.0]]}
    Solution 5:
      test_case: {'dict': [['0!', 5.0]]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun IsKV2 ((p Value)) Bool
  (and (is-Cons p)
       (is-Cons (tail p))
       (is-Nil (tail (tail p)))
       (is-StrVal (head p))))

(define-fun-rec IsDictLike ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (IsKV2 (head v)) (IsDictLike (tail v)))
            false)))

(define-fun-rec KeysV ((v Value)) Value
  (ite (is-Nil v)
       Nil
       (Cons (head (head v)) (KeysV (tail v)))))

; === Inputs ===
(declare-const dict Value)

; === BASIC STRUCTURE ===
(assert (=> (IsDictLike dict)
                 (IsList (KeysV dict))))

; === Contract predicates ===
(define-fun C0 () Bool
  (IsDictLike dict))

; === COMBINATION ===
(assert C0)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/96 ===
  Test Case 1: satisfied_, violated_assert_0
  Combination: {'assert_0': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0'], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'n': -1}
    Solution 2:
      test_case: {'n': -7720}
    Solution 3:
      test_case: {'n': -10157}
    Solution 4:
      test_case: {'n': -21954}
    Solution 5:
      test_case: {'n': -54239}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===
(assert (is-IntVal n))

; === Contract predicates ===
(define-fun C0 () Bool (and (is-IntVal n) (>= (ival n) 0)))

; === COMBINATION ===
(assert (not C0))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_
  Combination: {'assert_0': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': [], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'n': 0}
    Solution 2:
      test_case: {'n': 7719}
    Solution 3:
      test_case: {'n': 10156}
    Solution 4:
      test_case: {'n': 21953}
    Solution 5:
      test_case: {'n': 54238}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===
(assert (is-IntVal n))

; === Contract predicates ===
(define-fun C0 () Bool (and (is-IntVal n) (>= (ival n) 0)))

; === COMBINATION ===
(assert C0)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/97 ===
  Test Case 1: satisfied_, violated_assert_0
  Combination: {'assert_0': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0'], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'b': 2.0, 'a': 3.0}
    Solution 2:
      test_case: {'b': 5.0, 'a': 4.0}
    Solution 3:
      test_case: {'b': 7.0, 'a': 6.0}
    Solution 4:
      test_case: {'b': 8.0, 'a': 9.0}
    Solution 5:
      test_case: {'b': 10.0, 'a': 11.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const a Value)
(declare-const b Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (is-IntVal a) (is-IntVal b)))

; === COMBINATION ===
(assert (not C0))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_
  Combination: {'assert_0': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': [], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'b': 3, 'a': 2}
    Solution 2:
      test_case: {'b': 5, 'a': 4}
    Solution 3:
      test_case: {'b': 7, 'a': 6}
    Solution 4:
      test_case: {'b': 9, 'a': 8}
    Solution 5:
      test_case: {'b': 11, 'a': 10}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const a Value)
(declare-const b Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (is-IntVal a) (is-IntVal b)))

; === COMBINATION ===
(assert C0)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/98 ===
  Test Case 1: satisfied_, violated_assert_0
  Combination: {'assert_0': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0'], 'total_contracts': 1}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const s Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal s))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal s))

; === COMBINATION ===
(assert (not C0))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_
  Combination: {'assert_0': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': [], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'s': '!0!'}
    Solution 2:
      test_case: {'s': '!'}
    Solution 3:
      test_case: {'s': '0'}
    Solution 4:
      test_case: {'s': '0!'}
    Solution 5:
      test_case: {'s': ''}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const s Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal s))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal s))

; === COMBINATION ===
(assert C0)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/99 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'value': 2.0}
    Solution 2:
      test_case: {'value': 3.0}
    Solution 3:
      test_case: {'value': 4.0}
    Solution 4:
      test_case: {'value': 5.0}
    Solution 5:
      test_case: {'value': 6.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const value Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal value))
(define-fun C1 () Bool (ite (is-StrVal value)
                               (not (or (= (sval value) "Infinity")
                                        (= (sval value) "-Infinity")
                                        (= (sval value) "NaN")))
                               false))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 3
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'value': 'Infinity'}
    Solution 2:
      test_case: {'value': '-Infinity'}
    Solution 3:
      test_case: {'value': 'NaN'}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const value Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal value))
(define-fun C1 () Bool (ite (is-StrVal value)
                               (not (or (= (sval value) "Infinity")
                                        (= (sval value) "-Infinity")
                                        (= (sval value) "NaN")))
                               false))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const value Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal value))
(define-fun C1 () Bool (ite (is-StrVal value)
                               (not (or (= (sval value) "Infinity")
                                        (= (sval value) "-Infinity")
                                        (= (sval value) "NaN")))
                               false))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'value': '-'}
    Solution 2:
      test_case: {'value': 'N'}
    Solution 3:
      test_case: {'value': 'a'}
    Solution 4:
      test_case: {'value': 'aN'}
    Solution 5:
      test_case: {'value': 'I'}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const value Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal value))
(define-fun C1 () Bool (ite (is-StrVal value)
                               (not (or (= (sval value) "Infinity")
                                        (= (sval value) "-Infinity")
                                        (= (sval value) "NaN")))
                               false))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/100 ===
  Test Case 1: satisfied_, violated_assert_0
  Combination: {'assert_0': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0'], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'n': 2.0}
    Solution 2:
      test_case: {'n': 3.0}
    Solution 3:
      test_case: {'n': 4.0}
    Solution 4:
      test_case: {'n': 5.0}
    Solution 5:
      test_case: {'n': 6.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (is-IntVal n) (>= (SafeI n) 1)))

; === COMBINATION ===
(assert (not C0))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_
  Combination: {'assert_0': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': [], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'n': 1}
    Solution 2:
      test_case: {'n': 7720}
    Solution 3:
      test_case: {'n': 10157}
    Solution 4:
      test_case: {'n': 21954}
    Solution 5:
      test_case: {'n': 54239}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (is-IntVal n) (>= (SafeI n) 1)))

; === COMBINATION ===
(assert C0)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/101 ===
  Test Case 1: satisfied_, violated_assert_0
  Combination: {'assert_0': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0'], 'total_contracts': 1}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const s Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal s))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal s))

; === COMBINATION ===
(assert (not C0))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_
  Combination: {'assert_0': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': [], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'s': '!0!'}
    Solution 2:
      test_case: {'s': '!'}
    Solution 3:
      test_case: {'s': '0'}
    Solution 4:
      test_case: {'s': '0!'}
    Solution 5:
      test_case: {'s': ''}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const s Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal s))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal s))

; === COMBINATION ===
(assert C0)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/102 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'y': 3.0, 'x': 2.0}
    Solution 2:
      test_case: {'x': 4.0, 'y': 5.0}
    Solution 3:
      test_case: {'x': 6.0, 'y': 7.0}
    Solution 4:
      test_case: {'x': 8.0, 'y': 9.0}
    Solution 5:
      test_case: {'x': 11.0, 'y': 10.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const x Value)
(declare-const y Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool
  (and (is-IntVal x)
       (is-IntVal y)))
(define-fun C1 () Bool
  (and (> (SafeI x) 0)
       (> (SafeI y) 0)))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'y': 21238, 'x': 0}
    Solution 2:
      test_case: {'x': -21238, 'y': 2437}
    Solution 3:
      test_case: {'x': -21238, 'y': 10802}
    Solution 4:
      test_case: {'x': -21238, 'y': 41414}
    Solution 5:
      test_case: {'x': -21238, 'y': 42556}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const x Value)
(declare-const y Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool
  (and (is-IntVal x)
       (is-IntVal y)))
(define-fun C1 () Bool
  (and (> (SafeI x) 0)
       (> (SafeI y) 0)))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const x Value)
(declare-const y Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool
  (and (is-IntVal x)
       (is-IntVal y)))
(define-fun C1 () Bool
  (and (> (SafeI x) 0)
       (> (SafeI y) 0)))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'y': 7720, 'x': 1}
    Solution 2:
      test_case: {'x': 1, 'y': 7721}
    Solution 3:
      test_case: {'x': 1, 'y': 7719}
    Solution 4:
      test_case: {'x': 1, 'y': 2732}
    Solution 5:
      test_case: {'x': 28101, 'y': 1143}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const x Value)
(declare-const y Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool
  (and (is-IntVal x)
       (is-IntVal y)))
(define-fun C1 () Bool
  (and (> (SafeI x) 0)
       (> (SafeI y) 0)))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/103 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const n Value)
(declare-const m Value)

; === BASIC STRUCTURE ===
(assert (is-IntVal n))
(assert (is-IntVal m))

; === Contract predicates ===
(define-fun C0 () Bool (and (is-IntVal n) (is-IntVal m)))
(define-fun C1 () Bool (and (is-IntVal n) (> (ival n) 0) (is-IntVal m) (> (ival m) 0)))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'n': 21238, 'm': 0}
    Solution 2:
      test_case: {'n': 2437, 'm': -21238}
    Solution 3:
      test_case: {'n': 2437, 'm': -29603}
    Solution 4:
      test_case: {'n': 2437, 'm': -60215}
    Solution 5:
      test_case: {'n': 2437, 'm': -61357}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const n Value)
(declare-const m Value)

; === BASIC STRUCTURE ===
(assert (is-IntVal n))
(assert (is-IntVal m))

; === Contract predicates ===
(define-fun C0 () Bool (and (is-IntVal n) (is-IntVal m)))
(define-fun C1 () Bool (and (is-IntVal n) (> (ival n) 0) (is-IntVal m) (> (ival m) 0)))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const n Value)
(declare-const m Value)

; === BASIC STRUCTURE ===
(assert (is-IntVal n))
(assert (is-IntVal m))

; === Contract predicates ===
(define-fun C0 () Bool (and (is-IntVal n) (is-IntVal m)))
(define-fun C1 () Bool (and (is-IntVal n) (> (ival n) 0) (is-IntVal m) (> (ival m) 0)))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'n': 1, 'm': 7720}
    Solution 2:
      test_case: {'n': 7720, 'm': 21239}
    Solution 3:
      test_case: {'n': 16575, 'm': 21239}
    Solution 4:
      test_case: {'n': 24940, 'm': 21239}
    Solution 5:
      test_case: {'n': 24940, 'm': 31689}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const n Value)
(declare-const m Value)

; === BASIC STRUCTURE ===
(assert (is-IntVal n))
(assert (is-IntVal m))

; === Contract predicates ===
(define-fun C0 () Bool (and (is-IntVal n) (is-IntVal m)))
(define-fun C1 () Bool (and (is-IntVal n) (> (ival n) 0) (is-IntVal m) (> (ival m) 0)))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/104 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec AllPosIntList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (let ((h (head v))
                  (t (tail v)))
              (and (is-IntVal h)
                   (> (ival h) 0)
                   (AllPosIntList t)))
            false)))

; === Inputs ===
(declare-const x Value)

; === BASIC STRUCTURE ===
(assert (IsList x))

; === Contract predicates ===
(define-fun C0 () Bool
  (IsList x))
(define-fun C1 () Bool
  (AllPosIntList x))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'x': [2.0]}
    Solution 2:
      test_case: {'x': [3.0]}
    Solution 3:
      test_case: {'x': [4.0]}
    Solution 4:
      test_case: {'x': [5.0]}
    Solution 5:
      test_case: {'x': [6.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec AllPosIntList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (let ((h (head v))
                  (t (tail v)))
              (and (is-IntVal h)
                   (> (ival h) 0)
                   (AllPosIntList t)))
            false)))

; === Inputs ===
(declare-const x Value)

; === BASIC STRUCTURE ===
(assert (IsList x))

; === Contract predicates ===
(define-fun C0 () Bool
  (IsList x))
(define-fun C1 () Bool
  (AllPosIntList x))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec AllPosIntList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (let ((h (head v))
                  (t (tail v)))
              (and (is-IntVal h)
                   (> (ival h) 0)
                   (AllPosIntList t)))
            false)))

; === Inputs ===
(declare-const x Value)

; === BASIC STRUCTURE ===
(assert (IsList x))

; === Contract predicates ===
(define-fun C0 () Bool
  (IsList x))
(define-fun C1 () Bool
  (AllPosIntList x))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'x': []}
    Solution 2:
      test_case: {'x': [1]}
    Solution 3:
      test_case: {'x': [2438]}
    Solution 4:
      test_case: {'x': [8366]}
    Solution 5:
      test_case: {'x': [30613]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec AllPosIntList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (let ((h (head v))
                  (t (tail v)))
              (and (is-IntVal h)
                   (> (ival h) 0)
                   (AllPosIntList t)))
            false)))

; === Inputs ===
(declare-const x Value)

; === BASIC STRUCTURE ===
(assert (IsList x))

; === Contract predicates ===
(define-fun C0 () Bool
  (IsList x))
(define-fun C1 () Bool
  (AllPosIntList x))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/105 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (or
    (is-Nil v)
    (and (is-Cons v)
         (IsList (tail v))))
)

(define-fun-rec list_all_int ((v Value)) Bool
  (ite (is-Nil v)
       true
       (and (is-Cons v)
            (is-IntVal (head v))
            (list_all_int (tail v)))))

; === Inputs ===
(declare-const arr Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (list_all_int arr))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'arr': [2.0]}
    Solution 2:
      test_case: {'arr': [3.0]}
    Solution 3:
      test_case: {'arr': [4.0]}
    Solution 4:
      test_case: {'arr': [5.0]}
    Solution 5:
      test_case: {'arr': [6.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (or
    (is-Nil v)
    (and (is-Cons v)
         (IsList (tail v))))
)

(define-fun-rec list_all_int ((v Value)) Bool
  (ite (is-Nil v)
       true
       (and (is-Cons v)
            (is-IntVal (head v))
            (list_all_int (tail v)))))

; === Inputs ===
(declare-const arr Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (list_all_int arr))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (or
    (is-Nil v)
    (and (is-Cons v)
         (IsList (tail v))))
)

(define-fun-rec list_all_int ((v Value)) Bool
  (ite (is-Nil v)
       true
       (and (is-Cons v)
            (is-IntVal (head v))
            (list_all_int (tail v)))))

; === Inputs ===
(declare-const arr Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (list_all_int arr))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'arr': []}
    Solution 2:
      test_case: {'arr': [2]}
    Solution 3:
      test_case: {'arr': [3]}
    Solution 4:
      test_case: {'arr': [4]}
    Solution 5:
      test_case: {'arr': [5]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (or
    (is-Nil v)
    (and (is-Cons v)
         (IsList (tail v))))
)

(define-fun-rec list_all_int ((v Value)) Bool
  (ite (is-Nil v)
       true
       (and (is-Cons v)
            (is-IntVal (head v))
            (list_all_int (tail v)))))

; === Inputs ===
(declare-const arr Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (list_all_int arr))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/106 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))
(define-fun C1 () Bool (>= (SafeI n) 0))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'n': -1}
    Solution 2:
      test_case: {'n': -7720}
    Solution 3:
      test_case: {'n': -10157}
    Solution 4:
      test_case: {'n': -21954}
    Solution 5:
      test_case: {'n': -54239}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))
(define-fun C1 () Bool (>= (SafeI n) 0))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'n': 2.0}
    Solution 2:
      test_case: {'n': 3.0}
    Solution 3:
      test_case: {'n': 4.0}
    Solution 4:
      test_case: {'n': 5.0}
    Solution 5:
      test_case: {'n': 6.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))
(define-fun C1 () Bool (>= (SafeI n) 0))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'n': 0}
    Solution 2:
      test_case: {'n': 7719}
    Solution 3:
      test_case: {'n': 10156}
    Solution 4:
      test_case: {'n': 21953}
    Solution 5:
      test_case: {'n': 54238}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))
(define-fun C1 () Bool (>= (SafeI n) 0))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/107 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'n': 2.0}
    Solution 2:
      test_case: {'n': 3.0}
    Solution 3:
      test_case: {'n': 4.0}
    Solution 4:
      test_case: {'n': 5.0}
    Solution 5:
      test_case: {'n': 6.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))
(define-fun C1 () Bool (and (is-IntVal n) (<= 1 (SafeI n)) (<= (SafeI n) 1000)))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'n': 0}
    Solution 2:
      test_case: {'n': -21238}
    Solution 3:
      test_case: {'n': -33035}
    Solution 4:
      test_case: {'n': -43485}
    Solution 5:
      test_case: {'n': -71585}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))
(define-fun C1 () Bool (and (is-IntVal n) (<= 1 (SafeI n)) (<= (SafeI n) 1000)))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))
(define-fun C1 () Bool (and (is-IntVal n) (<= 1 (SafeI n)) (<= (SafeI n) 1000)))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'n': 1}
    Solution 2:
      test_case: {'n': 720}
    Solution 3:
      test_case: {'n': 438}
    Solution 4:
      test_case: {'n': 798}
    Solution 5:
      test_case: {'n': 286}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))
(define-fun C1 () Bool (and (is-IntVal n) (<= 1 (SafeI n)) (<= (SafeI n) 1000)))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/108 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_int ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (is-IntVal (head v))
                 (list_all_int (tail v)))
            false)))

; === Inputs ===
(declare-const arr Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))

; === Contract predicates ===
(define-fun C0 () Bool
  (IsList arr))
(define-fun C1 () Bool
  (list_all_int arr))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'arr': [2.0]}
    Solution 2:
      test_case: {'arr': [3.0]}
    Solution 3:
      test_case: {'arr': [4.0]}
    Solution 4:
      test_case: {'arr': [5.0]}
    Solution 5:
      test_case: {'arr': [6.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_int ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (is-IntVal (head v))
                 (list_all_int (tail v)))
            false)))

; === Inputs ===
(declare-const arr Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))

; === Contract predicates ===
(define-fun C0 () Bool
  (IsList arr))
(define-fun C1 () Bool
  (list_all_int arr))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_int ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (is-IntVal (head v))
                 (list_all_int (tail v)))
            false)))

; === Inputs ===
(declare-const arr Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))

; === Contract predicates ===
(define-fun C0 () Bool
  (IsList arr))
(define-fun C1 () Bool
  (list_all_int arr))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'arr': []}
    Solution 2:
      test_case: {'arr': [2]}
    Solution 3:
      test_case: {'arr': [3]}
    Solution 4:
      test_case: {'arr': [4]}
    Solution 5:
      test_case: {'arr': [5]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_int ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (is-IntVal (head v))
                 (list_all_int (tail v)))
            false)))

; === Inputs ===
(declare-const arr Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))

; === Contract predicates ===
(define-fun C0 () Bool
  (IsList arr))
(define-fun C1 () Bool
  (list_all_int arr))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/109 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1;assert_2;assert_3
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False, 'assert_3': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_3'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((l Value)) Bool
  (or (is-Nil l)
      (and (is-Cons l)
           (let ((tailVal (tail l)))
             (isList tailVal)))))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (and (is-Cons l)
            (let ((headVal (head l)) (tailVal (tail l)))
              (and (is-IntVal headVal)
                   (list_all_int tailVal))))))

(define-fun-rec list_contains ((l Value) (v Value)) Bool
  (ite (is-Nil l)
       false
       (and (is-Cons l)
            (let ((headVal (head l)) (tailVal (tail l)))
              (or (= headVal v)
                  (list_contains tailVal v))))))

(define-fun-rec list_unique ((l Value)) Bool
  (ite (is-Nil l)
       true
       (and (is-Cons l)
            (let ((headVal (head l)) (tailVal (tail l)))
              (and (not (list_contains tailVal headVal))
                   (list_unique tailVal))))))

; === Inputs ===
(declare-const arr Value)

; === BASIC STRUCTURE ===
(assert (isList arr))

; === Contract predicates ===
(define-fun C0 () Bool
  (isList arr))
(define-fun C1 () Bool
  (list_all_int arr))
(define-fun C2 () Bool
  (list_unique arr))
(define-fun C3 () Bool
  (list_all_int arr))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1;assert_2;assert_3
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False, 'assert_3': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1', 'assert_2', 'assert_3'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'arr': [2.0, 2.0]}
    Solution 2:
      test_case: {'arr': [3.0, 3.0]}
    Solution 3:
      test_case: {'arr': [4.0, 4.0]}
    Solution 4:
      test_case: {'arr': [5.0, 5.0]}
    Solution 5:
      test_case: {'arr': [6.0, 6.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((l Value)) Bool
  (or (is-Nil l)
      (and (is-Cons l)
           (let ((tailVal (tail l)))
             (isList tailVal)))))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (and (is-Cons l)
            (let ((headVal (head l)) (tailVal (tail l)))
              (and (is-IntVal headVal)
                   (list_all_int tailVal))))))

(define-fun-rec list_contains ((l Value) (v Value)) Bool
  (ite (is-Nil l)
       false
       (and (is-Cons l)
            (let ((headVal (head l)) (tailVal (tail l)))
              (or (= headVal v)
                  (list_contains tailVal v))))))

(define-fun-rec list_unique ((l Value)) Bool
  (ite (is-Nil l)
       true
       (and (is-Cons l)
            (let ((headVal (head l)) (tailVal (tail l)))
              (and (not (list_contains tailVal headVal))
                   (list_unique tailVal))))))

; === Inputs ===
(declare-const arr Value)

; === BASIC STRUCTURE ===
(assert (isList arr))

; === Contract predicates ===
(define-fun C0 () Bool
  (isList arr))
(define-fun C1 () Bool
  (list_all_int arr))
(define-fun C2 () Bool
  (list_unique arr))
(define-fun C3 () Bool
  (list_all_int arr))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0;assert_2;assert_3
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False, 'assert_3': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0', 'assert_2', 'assert_3'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((l Value)) Bool
  (or (is-Nil l)
      (and (is-Cons l)
           (let ((tailVal (tail l)))
             (isList tailVal)))))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (and (is-Cons l)
            (let ((headVal (head l)) (tailVal (tail l)))
              (and (is-IntVal headVal)
                   (list_all_int tailVal))))))

(define-fun-rec list_contains ((l Value) (v Value)) Bool
  (ite (is-Nil l)
       false
       (and (is-Cons l)
            (let ((headVal (head l)) (tailVal (tail l)))
              (or (= headVal v)
                  (list_contains tailVal v))))))

(define-fun-rec list_unique ((l Value)) Bool
  (ite (is-Nil l)
       true
       (and (is-Cons l)
            (let ((headVal (head l)) (tailVal (tail l)))
              (and (not (list_contains tailVal headVal))
                   (list_unique tailVal))))))

; === Inputs ===
(declare-const arr Value)

; === BASIC STRUCTURE ===
(assert (isList arr))

; === Contract predicates ===
(define-fun C0 () Bool
  (isList arr))
(define-fun C1 () Bool
  (list_all_int arr))
(define-fun C2 () Bool
  (list_unique arr))
(define-fun C3 () Bool
  (list_all_int arr))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_assert_2;assert_3
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False, 'assert_3': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': ['assert_2', 'assert_3'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((l Value)) Bool
  (or (is-Nil l)
      (and (is-Cons l)
           (let ((tailVal (tail l)))
             (isList tailVal)))))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (and (is-Cons l)
            (let ((headVal (head l)) (tailVal (tail l)))
              (and (is-IntVal headVal)
                   (list_all_int tailVal))))))

(define-fun-rec list_contains ((l Value) (v Value)) Bool
  (ite (is-Nil l)
       false
       (and (is-Cons l)
            (let ((headVal (head l)) (tailVal (tail l)))
              (or (= headVal v)
                  (list_contains tailVal v))))))

(define-fun-rec list_unique ((l Value)) Bool
  (ite (is-Nil l)
       true
       (and (is-Cons l)
            (let ((headVal (head l)) (tailVal (tail l)))
              (and (not (list_contains tailVal headVal))
                   (list_unique tailVal))))))

; === Inputs ===
(declare-const arr Value)

; === BASIC STRUCTURE ===
(assert (isList arr))

; === Contract predicates ===
(define-fun C0 () Bool
  (isList arr))
(define-fun C1 () Bool
  (list_all_int arr))
(define-fun C2 () Bool
  (list_unique arr))
(define-fun C3 () Bool
  (list_all_int arr))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 5: satisfied_assert_2, violated_assert_0;assert_1;assert_3
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True, 'assert_3': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_2'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_3'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((l Value)) Bool
  (or (is-Nil l)
      (and (is-Cons l)
           (let ((tailVal (tail l)))
             (isList tailVal)))))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (and (is-Cons l)
            (let ((headVal (head l)) (tailVal (tail l)))
              (and (is-IntVal headVal)
                   (list_all_int tailVal))))))

(define-fun-rec list_contains ((l Value) (v Value)) Bool
  (ite (is-Nil l)
       false
       (and (is-Cons l)
            (let ((headVal (head l)) (tailVal (tail l)))
              (or (= headVal v)
                  (list_contains tailVal v))))))

(define-fun-rec list_unique ((l Value)) Bool
  (ite (is-Nil l)
       true
       (and (is-Cons l)
            (let ((headVal (head l)) (tailVal (tail l)))
              (and (not (list_contains tailVal headVal))
                   (list_unique tailVal))))))

; === Inputs ===
(declare-const arr Value)

; === BASIC STRUCTURE ===
(assert (isList arr))

; === Contract predicates ===
(define-fun C0 () Bool
  (isList arr))
(define-fun C1 () Bool
  (list_all_int arr))
(define-fun C2 () Bool
  (list_unique arr))
(define-fun C3 () Bool
  (list_all_int arr))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 6: satisfied_assert_0;assert_2, violated_assert_1;assert_3
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True, 'assert_3': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2'], 'violated_contracts': ['assert_1', 'assert_3'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'arr': [2.0]}
    Solution 2:
      test_case: {'arr': [3.0]}
    Solution 3:
      test_case: {'arr': [4.0]}
    Solution 4:
      test_case: {'arr': [5.0]}
    Solution 5:
      test_case: {'arr': [6.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((l Value)) Bool
  (or (is-Nil l)
      (and (is-Cons l)
           (let ((tailVal (tail l)))
             (isList tailVal)))))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (and (is-Cons l)
            (let ((headVal (head l)) (tailVal (tail l)))
              (and (is-IntVal headVal)
                   (list_all_int tailVal))))))

(define-fun-rec list_contains ((l Value) (v Value)) Bool
  (ite (is-Nil l)
       false
       (and (is-Cons l)
            (let ((headVal (head l)) (tailVal (tail l)))
              (or (= headVal v)
                  (list_contains tailVal v))))))

(define-fun-rec list_unique ((l Value)) Bool
  (ite (is-Nil l)
       true
       (and (is-Cons l)
            (let ((headVal (head l)) (tailVal (tail l)))
              (and (not (list_contains tailVal headVal))
                   (list_unique tailVal))))))

; === Inputs ===
(declare-const arr Value)

; === BASIC STRUCTURE ===
(assert (isList arr))

; === Contract predicates ===
(define-fun C0 () Bool
  (isList arr))
(define-fun C1 () Bool
  (list_all_int arr))
(define-fun C2 () Bool
  (list_unique arr))
(define-fun C3 () Bool
  (list_all_int arr))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 7: satisfied_assert_1;assert_2, violated_assert_0;assert_3
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True, 'assert_3': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2'], 'violated_contracts': ['assert_0', 'assert_3'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((l Value)) Bool
  (or (is-Nil l)
      (and (is-Cons l)
           (let ((tailVal (tail l)))
             (isList tailVal)))))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (and (is-Cons l)
            (let ((headVal (head l)) (tailVal (tail l)))
              (and (is-IntVal headVal)
                   (list_all_int tailVal))))))

(define-fun-rec list_contains ((l Value) (v Value)) Bool
  (ite (is-Nil l)
       false
       (and (is-Cons l)
            (let ((headVal (head l)) (tailVal (tail l)))
              (or (= headVal v)
                  (list_contains tailVal v))))))

(define-fun-rec list_unique ((l Value)) Bool
  (ite (is-Nil l)
       true
       (and (is-Cons l)
            (let ((headVal (head l)) (tailVal (tail l)))
              (and (not (list_contains tailVal headVal))
                   (list_unique tailVal))))))

; === Inputs ===
(declare-const arr Value)

; === BASIC STRUCTURE ===
(assert (isList arr))

; === Contract predicates ===
(define-fun C0 () Bool
  (isList arr))
(define-fun C1 () Bool
  (list_all_int arr))
(define-fun C2 () Bool
  (list_unique arr))
(define-fun C3 () Bool
  (list_all_int arr))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 8: satisfied_assert_0;assert_1;assert_2, violated_assert_3
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True, 'assert_3': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2'], 'violated_contracts': ['assert_3'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((l Value)) Bool
  (or (is-Nil l)
      (and (is-Cons l)
           (let ((tailVal (tail l)))
             (isList tailVal)))))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (and (is-Cons l)
            (let ((headVal (head l)) (tailVal (tail l)))
              (and (is-IntVal headVal)
                   (list_all_int tailVal))))))

(define-fun-rec list_contains ((l Value) (v Value)) Bool
  (ite (is-Nil l)
       false
       (and (is-Cons l)
            (let ((headVal (head l)) (tailVal (tail l)))
              (or (= headVal v)
                  (list_contains tailVal v))))))

(define-fun-rec list_unique ((l Value)) Bool
  (ite (is-Nil l)
       true
       (and (is-Cons l)
            (let ((headVal (head l)) (tailVal (tail l)))
              (and (not (list_contains tailVal headVal))
                   (list_unique tailVal))))))

; === Inputs ===
(declare-const arr Value)

; === BASIC STRUCTURE ===
(assert (isList arr))

; === Contract predicates ===
(define-fun C0 () Bool
  (isList arr))
(define-fun C1 () Bool
  (list_all_int arr))
(define-fun C2 () Bool
  (list_unique arr))
(define-fun C3 () Bool
  (list_all_int arr))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 9: satisfied_assert_3, violated_assert_0;assert_1;assert_2
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False, 'assert_3': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_3'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((l Value)) Bool
  (or (is-Nil l)
      (and (is-Cons l)
           (let ((tailVal (tail l)))
             (isList tailVal)))))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (and (is-Cons l)
            (let ((headVal (head l)) (tailVal (tail l)))
              (and (is-IntVal headVal)
                   (list_all_int tailVal))))))

(define-fun-rec list_contains ((l Value) (v Value)) Bool
  (ite (is-Nil l)
       false
       (and (is-Cons l)
            (let ((headVal (head l)) (tailVal (tail l)))
              (or (= headVal v)
                  (list_contains tailVal v))))))

(define-fun-rec list_unique ((l Value)) Bool
  (ite (is-Nil l)
       true
       (and (is-Cons l)
            (let ((headVal (head l)) (tailVal (tail l)))
              (and (not (list_contains tailVal headVal))
                   (list_unique tailVal))))))

; === Inputs ===
(declare-const arr Value)

; === BASIC STRUCTURE ===
(assert (isList arr))

; === Contract predicates ===
(define-fun C0 () Bool
  (isList arr))
(define-fun C1 () Bool
  (list_all_int arr))
(define-fun C2 () Bool
  (list_unique arr))
(define-fun C3 () Bool
  (list_all_int arr))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 10: satisfied_assert_0;assert_3, violated_assert_1;assert_2
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False, 'assert_3': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_3'], 'violated_contracts': ['assert_1', 'assert_2'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((l Value)) Bool
  (or (is-Nil l)
      (and (is-Cons l)
           (let ((tailVal (tail l)))
             (isList tailVal)))))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (and (is-Cons l)
            (let ((headVal (head l)) (tailVal (tail l)))
              (and (is-IntVal headVal)
                   (list_all_int tailVal))))))

(define-fun-rec list_contains ((l Value) (v Value)) Bool
  (ite (is-Nil l)
       false
       (and (is-Cons l)
            (let ((headVal (head l)) (tailVal (tail l)))
              (or (= headVal v)
                  (list_contains tailVal v))))))

(define-fun-rec list_unique ((l Value)) Bool
  (ite (is-Nil l)
       true
       (and (is-Cons l)
            (let ((headVal (head l)) (tailVal (tail l)))
              (and (not (list_contains tailVal headVal))
                   (list_unique tailVal))))))

; === Inputs ===
(declare-const arr Value)

; === BASIC STRUCTURE ===
(assert (isList arr))

; === Contract predicates ===
(define-fun C0 () Bool
  (isList arr))
(define-fun C1 () Bool
  (list_all_int arr))
(define-fun C2 () Bool
  (list_unique arr))
(define-fun C3 () Bool
  (list_all_int arr))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 11: satisfied_assert_1;assert_3, violated_assert_0;assert_2
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False, 'assert_3': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_3'], 'violated_contracts': ['assert_0', 'assert_2'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((l Value)) Bool
  (or (is-Nil l)
      (and (is-Cons l)
           (let ((tailVal (tail l)))
             (isList tailVal)))))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (and (is-Cons l)
            (let ((headVal (head l)) (tailVal (tail l)))
              (and (is-IntVal headVal)
                   (list_all_int tailVal))))))

(define-fun-rec list_contains ((l Value) (v Value)) Bool
  (ite (is-Nil l)
       false
       (and (is-Cons l)
            (let ((headVal (head l)) (tailVal (tail l)))
              (or (= headVal v)
                  (list_contains tailVal v))))))

(define-fun-rec list_unique ((l Value)) Bool
  (ite (is-Nil l)
       true
       (and (is-Cons l)
            (let ((headVal (head l)) (tailVal (tail l)))
              (and (not (list_contains tailVal headVal))
                   (list_unique tailVal))))))

; === Inputs ===
(declare-const arr Value)

; === BASIC STRUCTURE ===
(assert (isList arr))

; === Contract predicates ===
(define-fun C0 () Bool
  (isList arr))
(define-fun C1 () Bool
  (list_all_int arr))
(define-fun C2 () Bool
  (list_unique arr))
(define-fun C3 () Bool
  (list_all_int arr))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 12: satisfied_assert_0;assert_1;assert_3, violated_assert_2
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False, 'assert_3': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_3'], 'violated_contracts': ['assert_2'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'arr': [2, 2]}
    Solution 2:
      test_case: {'arr': [3, 3]}
    Solution 3:
      test_case: {'arr': [4, 4]}
    Solution 4:
      test_case: {'arr': [5, 5]}
    Solution 5:
      test_case: {'arr': [6, 6]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((l Value)) Bool
  (or (is-Nil l)
      (and (is-Cons l)
           (let ((tailVal (tail l)))
             (isList tailVal)))))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (and (is-Cons l)
            (let ((headVal (head l)) (tailVal (tail l)))
              (and (is-IntVal headVal)
                   (list_all_int tailVal))))))

(define-fun-rec list_contains ((l Value) (v Value)) Bool
  (ite (is-Nil l)
       false
       (and (is-Cons l)
            (let ((headVal (head l)) (tailVal (tail l)))
              (or (= headVal v)
                  (list_contains tailVal v))))))

(define-fun-rec list_unique ((l Value)) Bool
  (ite (is-Nil l)
       true
       (and (is-Cons l)
            (let ((headVal (head l)) (tailVal (tail l)))
              (and (not (list_contains tailVal headVal))
                   (list_unique tailVal))))))

; === Inputs ===
(declare-const arr Value)

; === BASIC STRUCTURE ===
(assert (isList arr))

; === Contract predicates ===
(define-fun C0 () Bool
  (isList arr))
(define-fun C1 () Bool
  (list_all_int arr))
(define-fun C2 () Bool
  (list_unique arr))
(define-fun C3 () Bool
  (list_all_int arr))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 13: satisfied_assert_2;assert_3, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True, 'assert_3': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_2', 'assert_3'], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((l Value)) Bool
  (or (is-Nil l)
      (and (is-Cons l)
           (let ((tailVal (tail l)))
             (isList tailVal)))))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (and (is-Cons l)
            (let ((headVal (head l)) (tailVal (tail l)))
              (and (is-IntVal headVal)
                   (list_all_int tailVal))))))

(define-fun-rec list_contains ((l Value) (v Value)) Bool
  (ite (is-Nil l)
       false
       (and (is-Cons l)
            (let ((headVal (head l)) (tailVal (tail l)))
              (or (= headVal v)
                  (list_contains tailVal v))))))

(define-fun-rec list_unique ((l Value)) Bool
  (ite (is-Nil l)
       true
       (and (is-Cons l)
            (let ((headVal (head l)) (tailVal (tail l)))
              (and (not (list_contains tailVal headVal))
                   (list_unique tailVal))))))

; === Inputs ===
(declare-const arr Value)

; === BASIC STRUCTURE ===
(assert (isList arr))

; === Contract predicates ===
(define-fun C0 () Bool
  (isList arr))
(define-fun C1 () Bool
  (list_all_int arr))
(define-fun C2 () Bool
  (list_unique arr))
(define-fun C3 () Bool
  (list_all_int arr))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 14: satisfied_assert_0;assert_2;assert_3, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True, 'assert_3': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2', 'assert_3'], 'violated_contracts': ['assert_1'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((l Value)) Bool
  (or (is-Nil l)
      (and (is-Cons l)
           (let ((tailVal (tail l)))
             (isList tailVal)))))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (and (is-Cons l)
            (let ((headVal (head l)) (tailVal (tail l)))
              (and (is-IntVal headVal)
                   (list_all_int tailVal))))))

(define-fun-rec list_contains ((l Value) (v Value)) Bool
  (ite (is-Nil l)
       false
       (and (is-Cons l)
            (let ((headVal (head l)) (tailVal (tail l)))
              (or (= headVal v)
                  (list_contains tailVal v))))))

(define-fun-rec list_unique ((l Value)) Bool
  (ite (is-Nil l)
       true
       (and (is-Cons l)
            (let ((headVal (head l)) (tailVal (tail l)))
              (and (not (list_contains tailVal headVal))
                   (list_unique tailVal))))))

; === Inputs ===
(declare-const arr Value)

; === BASIC STRUCTURE ===
(assert (isList arr))

; === Contract predicates ===
(define-fun C0 () Bool
  (isList arr))
(define-fun C1 () Bool
  (list_all_int arr))
(define-fun C2 () Bool
  (list_unique arr))
(define-fun C3 () Bool
  (list_all_int arr))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 15: satisfied_assert_1;assert_2;assert_3, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True, 'assert_3': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2', 'assert_3'], 'violated_contracts': ['assert_0'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((l Value)) Bool
  (or (is-Nil l)
      (and (is-Cons l)
           (let ((tailVal (tail l)))
             (isList tailVal)))))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (and (is-Cons l)
            (let ((headVal (head l)) (tailVal (tail l)))
              (and (is-IntVal headVal)
                   (list_all_int tailVal))))))

(define-fun-rec list_contains ((l Value) (v Value)) Bool
  (ite (is-Nil l)
       false
       (and (is-Cons l)
            (let ((headVal (head l)) (tailVal (tail l)))
              (or (= headVal v)
                  (list_contains tailVal v))))))

(define-fun-rec list_unique ((l Value)) Bool
  (ite (is-Nil l)
       true
       (and (is-Cons l)
            (let ((headVal (head l)) (tailVal (tail l)))
              (and (not (list_contains tailVal headVal))
                   (list_unique tailVal))))))

; === Inputs ===
(declare-const arr Value)

; === BASIC STRUCTURE ===
(assert (isList arr))

; === Contract predicates ===
(define-fun C0 () Bool
  (isList arr))
(define-fun C1 () Bool
  (list_all_int arr))
(define-fun C2 () Bool
  (list_unique arr))
(define-fun C3 () Bool
  (list_all_int arr))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 16: satisfied_assert_0;assert_1;assert_2;assert_3, violated_
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True, 'assert_3': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_3'], 'violated_contracts': [], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'arr': []}
    Solution 2:
      test_case: {'arr': [2]}
    Solution 3:
      test_case: {'arr': [3]}
    Solution 4:
      test_case: {'arr': [4]}
    Solution 5:
      test_case: {'arr': [5]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((l Value)) Bool
  (or (is-Nil l)
      (and (is-Cons l)
           (let ((tailVal (tail l)))
             (isList tailVal)))))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (and (is-Cons l)
            (let ((headVal (head l)) (tailVal (tail l)))
              (and (is-IntVal headVal)
                   (list_all_int tailVal))))))

(define-fun-rec list_contains ((l Value) (v Value)) Bool
  (ite (is-Nil l)
       false
       (and (is-Cons l)
            (let ((headVal (head l)) (tailVal (tail l)))
              (or (= headVal v)
                  (list_contains tailVal v))))))

(define-fun-rec list_unique ((l Value)) Bool
  (ite (is-Nil l)
       true
       (and (is-Cons l)
            (let ((headVal (head l)) (tailVal (tail l)))
              (and (not (list_contains tailVal headVal))
                   (list_unique tailVal))))))

; === Inputs ===
(declare-const arr Value)

; === BASIC STRUCTURE ===
(assert (isList arr))

; === Contract predicates ===
(define-fun C0 () Bool
  (isList arr))
(define-fun C1 () Bool
  (list_all_int arr))
(define-fun C2 () Bool
  (list_unique arr))
(define-fun C3 () Bool
  (list_all_int arr))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)
(assert C3)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/110 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1;assert_2;assert_3
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False, 'assert_3': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_3'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (IsList (tail l))
            false)))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (and (is-IntVal (head l)) (list_all_int (tail l)))
            false)))

(define-fun-rec length ((l Value)) Int
  (ite (is-Nil l)
       0
       (ite (is-Cons l)
            (+ 1 (length (tail l)))
            0)))

; === Inputs ===
(declare-const lst1 Value)
(declare-const lst2 Value)

; === BASIC STRUCTURE ===
(assert (IsList lst1))
(assert (IsList lst2))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList lst1) (IsList lst2)))
(define-fun C1 () Bool (list_all_int lst1))
(define-fun C2 () Bool (list_all_int lst2))
(define-fun C3 () Bool (and (> (length lst1) 0) (> (length lst2) 0)))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1;assert_2;assert_3
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False, 'assert_3': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1', 'assert_2', 'assert_3'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (IsList (tail l))
            false)))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (and (is-IntVal (head l)) (list_all_int (tail l)))
            false)))

(define-fun-rec length ((l Value)) Int
  (ite (is-Nil l)
       0
       (ite (is-Cons l)
            (+ 1 (length (tail l)))
            0)))

; === Inputs ===
(declare-const lst1 Value)
(declare-const lst2 Value)

; === BASIC STRUCTURE ===
(assert (IsList lst1))
(assert (IsList lst2))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList lst1) (IsList lst2)))
(define-fun C1 () Bool (list_all_int lst1))
(define-fun C2 () Bool (list_all_int lst2))
(define-fun C3 () Bool (and (> (length lst1) 0) (> (length lst2) 0)))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0;assert_2;assert_3
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False, 'assert_3': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0', 'assert_2', 'assert_3'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (IsList (tail l))
            false)))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (and (is-IntVal (head l)) (list_all_int (tail l)))
            false)))

(define-fun-rec length ((l Value)) Int
  (ite (is-Nil l)
       0
       (ite (is-Cons l)
            (+ 1 (length (tail l)))
            0)))

; === Inputs ===
(declare-const lst1 Value)
(declare-const lst2 Value)

; === BASIC STRUCTURE ===
(assert (IsList lst1))
(assert (IsList lst2))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList lst1) (IsList lst2)))
(define-fun C1 () Bool (list_all_int lst1))
(define-fun C2 () Bool (list_all_int lst2))
(define-fun C3 () Bool (and (> (length lst1) 0) (> (length lst2) 0)))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_assert_2;assert_3
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False, 'assert_3': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': ['assert_2', 'assert_3'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'lst1': [], 'lst2': [2.0]}
    Solution 2:
      test_case: {'lst2': [3.0], 'lst1': []}
    Solution 3:
      test_case: {'lst1': [], 'lst2': [4.0]}
    Solution 4:
      test_case: {'lst2': [5.0], 'lst1': []}
    Solution 5:
      test_case: {'lst1': [], 'lst2': [6.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (IsList (tail l))
            false)))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (and (is-IntVal (head l)) (list_all_int (tail l)))
            false)))

(define-fun-rec length ((l Value)) Int
  (ite (is-Nil l)
       0
       (ite (is-Cons l)
            (+ 1 (length (tail l)))
            0)))

; === Inputs ===
(declare-const lst1 Value)
(declare-const lst2 Value)

; === BASIC STRUCTURE ===
(assert (IsList lst1))
(assert (IsList lst2))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList lst1) (IsList lst2)))
(define-fun C1 () Bool (list_all_int lst1))
(define-fun C2 () Bool (list_all_int lst2))
(define-fun C3 () Bool (and (> (length lst1) 0) (> (length lst2) 0)))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 5: satisfied_assert_2, violated_assert_0;assert_1;assert_3
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True, 'assert_3': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_2'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_3'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (IsList (tail l))
            false)))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (and (is-IntVal (head l)) (list_all_int (tail l)))
            false)))

(define-fun-rec length ((l Value)) Int
  (ite (is-Nil l)
       0
       (ite (is-Cons l)
            (+ 1 (length (tail l)))
            0)))

; === Inputs ===
(declare-const lst1 Value)
(declare-const lst2 Value)

; === BASIC STRUCTURE ===
(assert (IsList lst1))
(assert (IsList lst2))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList lst1) (IsList lst2)))
(define-fun C1 () Bool (list_all_int lst1))
(define-fun C2 () Bool (list_all_int lst2))
(define-fun C3 () Bool (and (> (length lst1) 0) (> (length lst2) 0)))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 6: satisfied_assert_0;assert_2, violated_assert_1;assert_3
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True, 'assert_3': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2'], 'violated_contracts': ['assert_1', 'assert_3'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'lst1': [2.0], 'lst2': []}
    Solution 2:
      test_case: {'lst2': [], 'lst1': [3.0]}
    Solution 3:
      test_case: {'lst1': [4.0], 'lst2': []}
    Solution 4:
      test_case: {'lst2': [], 'lst1': [5.0]}
    Solution 5:
      test_case: {'lst2': [], 'lst1': [6.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (IsList (tail l))
            false)))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (and (is-IntVal (head l)) (list_all_int (tail l)))
            false)))

(define-fun-rec length ((l Value)) Int
  (ite (is-Nil l)
       0
       (ite (is-Cons l)
            (+ 1 (length (tail l)))
            0)))

; === Inputs ===
(declare-const lst1 Value)
(declare-const lst2 Value)

; === BASIC STRUCTURE ===
(assert (IsList lst1))
(assert (IsList lst2))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList lst1) (IsList lst2)))
(define-fun C1 () Bool (list_all_int lst1))
(define-fun C2 () Bool (list_all_int lst2))
(define-fun C3 () Bool (and (> (length lst1) 0) (> (length lst2) 0)))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 7: satisfied_assert_1;assert_2, violated_assert_0;assert_3
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True, 'assert_3': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2'], 'violated_contracts': ['assert_0', 'assert_3'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (IsList (tail l))
            false)))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (and (is-IntVal (head l)) (list_all_int (tail l)))
            false)))

(define-fun-rec length ((l Value)) Int
  (ite (is-Nil l)
       0
       (ite (is-Cons l)
            (+ 1 (length (tail l)))
            0)))

; === Inputs ===
(declare-const lst1 Value)
(declare-const lst2 Value)

; === BASIC STRUCTURE ===
(assert (IsList lst1))
(assert (IsList lst2))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList lst1) (IsList lst2)))
(define-fun C1 () Bool (list_all_int lst1))
(define-fun C2 () Bool (list_all_int lst2))
(define-fun C3 () Bool (and (> (length lst1) 0) (> (length lst2) 0)))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 8: satisfied_assert_0;assert_1;assert_2, violated_assert_3
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True, 'assert_3': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2'], 'violated_contracts': ['assert_3'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'lst1': [], 'lst2': []}
    Solution 2:
      test_case: {'lst1': [], 'lst2': [2]}
    Solution 3:
      test_case: {'lst2': [3], 'lst1': []}
    Solution 4:
      test_case: {'lst1': [], 'lst2': [4]}
    Solution 5:
      test_case: {'lst2': [5], 'lst1': []}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (IsList (tail l))
            false)))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (and (is-IntVal (head l)) (list_all_int (tail l)))
            false)))

(define-fun-rec length ((l Value)) Int
  (ite (is-Nil l)
       0
       (ite (is-Cons l)
            (+ 1 (length (tail l)))
            0)))

; === Inputs ===
(declare-const lst1 Value)
(declare-const lst2 Value)

; === BASIC STRUCTURE ===
(assert (IsList lst1))
(assert (IsList lst2))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList lst1) (IsList lst2)))
(define-fun C1 () Bool (list_all_int lst1))
(define-fun C2 () Bool (list_all_int lst2))
(define-fun C3 () Bool (and (> (length lst1) 0) (> (length lst2) 0)))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 9: satisfied_assert_3, violated_assert_0;assert_1;assert_2
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False, 'assert_3': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_3'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (IsList (tail l))
            false)))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (and (is-IntVal (head l)) (list_all_int (tail l)))
            false)))

(define-fun-rec length ((l Value)) Int
  (ite (is-Nil l)
       0
       (ite (is-Cons l)
            (+ 1 (length (tail l)))
            0)))

; === Inputs ===
(declare-const lst1 Value)
(declare-const lst2 Value)

; === BASIC STRUCTURE ===
(assert (IsList lst1))
(assert (IsList lst2))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList lst1) (IsList lst2)))
(define-fun C1 () Bool (list_all_int lst1))
(define-fun C2 () Bool (list_all_int lst2))
(define-fun C3 () Bool (and (> (length lst1) 0) (> (length lst2) 0)))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 10: satisfied_assert_0;assert_3, violated_assert_1;assert_2
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False, 'assert_3': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_3'], 'violated_contracts': ['assert_1', 'assert_2'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'lst1': [3.0], 'lst2': [2.0]}
    Solution 2:
      test_case: {'lst1': [5.0], 'lst2': [4.0]}
    Solution 3:
      test_case: {'lst2': [7.0], 'lst1': [6.0]}
    Solution 4:
      test_case: {'lst2': [9.0], 'lst1': [8.0]}
    Solution 5:
      test_case: {'lst2': [11.0], 'lst1': [10.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (IsList (tail l))
            false)))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (and (is-IntVal (head l)) (list_all_int (tail l)))
            false)))

(define-fun-rec length ((l Value)) Int
  (ite (is-Nil l)
       0
       (ite (is-Cons l)
            (+ 1 (length (tail l)))
            0)))

; === Inputs ===
(declare-const lst1 Value)
(declare-const lst2 Value)

; === BASIC STRUCTURE ===
(assert (IsList lst1))
(assert (IsList lst2))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList lst1) (IsList lst2)))
(define-fun C1 () Bool (list_all_int lst1))
(define-fun C2 () Bool (list_all_int lst2))
(define-fun C3 () Bool (and (> (length lst1) 0) (> (length lst2) 0)))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 11: satisfied_assert_1;assert_3, violated_assert_0;assert_2
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False, 'assert_3': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_3'], 'violated_contracts': ['assert_0', 'assert_2'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (IsList (tail l))
            false)))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (and (is-IntVal (head l)) (list_all_int (tail l)))
            false)))

(define-fun-rec length ((l Value)) Int
  (ite (is-Nil l)
       0
       (ite (is-Cons l)
            (+ 1 (length (tail l)))
            0)))

; === Inputs ===
(declare-const lst1 Value)
(declare-const lst2 Value)

; === BASIC STRUCTURE ===
(assert (IsList lst1))
(assert (IsList lst2))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList lst1) (IsList lst2)))
(define-fun C1 () Bool (list_all_int lst1))
(define-fun C2 () Bool (list_all_int lst2))
(define-fun C3 () Bool (and (> (length lst1) 0) (> (length lst2) 0)))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 12: satisfied_assert_0;assert_1;assert_3, violated_assert_2
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False, 'assert_3': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_3'], 'violated_contracts': ['assert_2'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'lst1': [5], 'lst2': [2.0]}
    Solution 2:
      test_case: {'lst1': [6], 'lst2': [3.0]}
    Solution 3:
      test_case: {'lst2': [4.0], 'lst1': [7]}
    Solution 4:
      test_case: {'lst2': [5.0], 'lst1': [8]}
    Solution 5:
      test_case: {'lst1': [9], 'lst2': [6.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (IsList (tail l))
            false)))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (and (is-IntVal (head l)) (list_all_int (tail l)))
            false)))

(define-fun-rec length ((l Value)) Int
  (ite (is-Nil l)
       0
       (ite (is-Cons l)
            (+ 1 (length (tail l)))
            0)))

; === Inputs ===
(declare-const lst1 Value)
(declare-const lst2 Value)

; === BASIC STRUCTURE ===
(assert (IsList lst1))
(assert (IsList lst2))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList lst1) (IsList lst2)))
(define-fun C1 () Bool (list_all_int lst1))
(define-fun C2 () Bool (list_all_int lst2))
(define-fun C3 () Bool (and (> (length lst1) 0) (> (length lst2) 0)))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 13: satisfied_assert_2;assert_3, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True, 'assert_3': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_2', 'assert_3'], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (IsList (tail l))
            false)))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (and (is-IntVal (head l)) (list_all_int (tail l)))
            false)))

(define-fun-rec length ((l Value)) Int
  (ite (is-Nil l)
       0
       (ite (is-Cons l)
            (+ 1 (length (tail l)))
            0)))

; === Inputs ===
(declare-const lst1 Value)
(declare-const lst2 Value)

; === BASIC STRUCTURE ===
(assert (IsList lst1))
(assert (IsList lst2))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList lst1) (IsList lst2)))
(define-fun C1 () Bool (list_all_int lst1))
(define-fun C2 () Bool (list_all_int lst2))
(define-fun C3 () Bool (and (> (length lst1) 0) (> (length lst2) 0)))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 14: satisfied_assert_0;assert_2;assert_3, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True, 'assert_3': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2', 'assert_3'], 'violated_contracts': ['assert_1'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'lst1': [2.0], 'lst2': [5]}
    Solution 2:
      test_case: {'lst1': [3.0], 'lst2': [6]}
    Solution 3:
      test_case: {'lst2': [7], 'lst1': [4.0]}
    Solution 4:
      test_case: {'lst2': [8], 'lst1': [5.0]}
    Solution 5:
      test_case: {'lst1': [6.0], 'lst2': [9]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (IsList (tail l))
            false)))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (and (is-IntVal (head l)) (list_all_int (tail l)))
            false)))

(define-fun-rec length ((l Value)) Int
  (ite (is-Nil l)
       0
       (ite (is-Cons l)
            (+ 1 (length (tail l)))
            0)))

; === Inputs ===
(declare-const lst1 Value)
(declare-const lst2 Value)

; === BASIC STRUCTURE ===
(assert (IsList lst1))
(assert (IsList lst2))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList lst1) (IsList lst2)))
(define-fun C1 () Bool (list_all_int lst1))
(define-fun C2 () Bool (list_all_int lst2))
(define-fun C3 () Bool (and (> (length lst1) 0) (> (length lst2) 0)))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 15: satisfied_assert_1;assert_2;assert_3, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True, 'assert_3': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2', 'assert_3'], 'violated_contracts': ['assert_0'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (IsList (tail l))
            false)))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (and (is-IntVal (head l)) (list_all_int (tail l)))
            false)))

(define-fun-rec length ((l Value)) Int
  (ite (is-Nil l)
       0
       (ite (is-Cons l)
            (+ 1 (length (tail l)))
            0)))

; === Inputs ===
(declare-const lst1 Value)
(declare-const lst2 Value)

; === BASIC STRUCTURE ===
(assert (IsList lst1))
(assert (IsList lst2))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList lst1) (IsList lst2)))
(define-fun C1 () Bool (list_all_int lst1))
(define-fun C2 () Bool (list_all_int lst2))
(define-fun C3 () Bool (and (> (length lst1) 0) (> (length lst2) 0)))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 16: satisfied_assert_0;assert_1;assert_2;assert_3, violated_
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True, 'assert_3': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_3'], 'violated_contracts': [], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'lst1': [5], 'lst2': [6]}
    Solution 2:
      test_case: {'lst1': [7], 'lst2': [8]}
    Solution 3:
      test_case: {'lst2': [10], 'lst1': [9]}
    Solution 4:
      test_case: {'lst2': [12], 'lst1': [11]}
    Solution 5:
      test_case: {'lst1': [13], 'lst2': [14]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (IsList (tail l))
            false)))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (and (is-IntVal (head l)) (list_all_int (tail l)))
            false)))

(define-fun-rec length ((l Value)) Int
  (ite (is-Nil l)
       0
       (ite (is-Cons l)
            (+ 1 (length (tail l)))
            0)))

; === Inputs ===
(declare-const lst1 Value)
(declare-const lst2 Value)

; === BASIC STRUCTURE ===
(assert (IsList lst1))
(assert (IsList lst2))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList lst1) (IsList lst2)))
(define-fun C1 () Bool (list_all_int lst1))
(define-fun C2 () Bool (list_all_int lst2))
(define-fun C3 () Bool (and (> (length lst1) 0) (> (length lst2) 0)))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)
(assert C3)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/111 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeS ((v Value)) String (ite (is-StrVal v) (sval v) ""))

; === Inputs ===
(declare-const test Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal test))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal test))
(define-fun C1 () Bool (let ((s (SafeS test))) (str.in.re s (str.to.re "^(|[a-z]( [a-z])*)$"))))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'test': '^'}
    Solution 2:
      test_case: {'test': '('}
    Solution 3:
      test_case: {'test': '|'}
    Solution 4:
      test_case: {'test': '['}
    Solution 5:
      test_case: {'test': 'a'}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeS ((v Value)) String (ite (is-StrVal v) (sval v) ""))

; === Inputs ===
(declare-const test Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal test))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal test))
(define-fun C1 () Bool (let ((s (SafeS test))) (str.in.re s (str.to.re "^(|[a-z]( [a-z])*)$"))))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeS ((v Value)) String (ite (is-StrVal v) (sval v) ""))

; === Inputs ===
(declare-const test Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal test))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal test))
(define-fun C1 () Bool (let ((s (SafeS test))) (str.in.re s (str.to.re "^(|[a-z]( [a-z])*)$"))))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 1
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'test': '^(|[a-z]( [a-z])*)$'}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeS ((v Value)) String (ite (is-StrVal v) (sval v) ""))

; === Inputs ===
(declare-const test Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal test))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal test))
(define-fun C1 () Bool (let ((s (SafeS test))) (str.in.re s (str.to.re "^(|[a-z]( [a-z])*)$"))))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/112 ===
  Test Case 1: satisfied_, violated_assert_0
  Combination: {'assert_0': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0'], 'total_contracts': 1}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const s Value)
(declare-const c Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal s))
(assert (is-StrVal c))

; === Contract predicates ===
(define-fun C0 () Bool (and (is-StrVal s) (is-StrVal c)))

; === COMBINATION ===
(assert (not C0))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_
  Combination: {'assert_0': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': [], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'s': '!0!', 'c': '!0!'}
    Solution 2:
      test_case: {'s': '!', 'c': '0'}
    Solution 3:
      test_case: {'s': '0!', 'c': '0!'}
    Solution 4:
      test_case: {'s': '0', 'c': ''}
    Solution 5:
      test_case: {'s': 'A', 'c': ''}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const s Value)
(declare-const c Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal s))
(assert (is-StrVal c))

; === Contract predicates ===
(define-fun C0 () Bool (and (is-StrVal s) (is-StrVal c)))

; === COMBINATION ===
(assert C0)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/113 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1;assert_2
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2'], 'total_contracts': 3}
  Solutions:
    Solution 1:
      test_case: {'lst': 2.0}
    Solution 2:
      test_case: {'lst': 3.0}
    Solution 3:
      test_case: {'lst': 4.0}
    Solution 4:
      test_case: {'lst': 5.0}
    Solution 5:
      test_case: {'lst': 6.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (or
    (is-Nil v)
    (and (is-Cons v)
         (IsList (tail v))
    )
  )
)

(define-fun-rec list_all_str ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (is-StrVal (head v))
                 (list_all_str (tail v)))
            false
       )
  )
)

(define-fun str_all_digits ((s Value)) Bool
  (and
    (is-StrVal s)
    (str.in.re (sval s) (str.to.re "[0-9]+"))
  )
)

(define-fun-rec list_all_digit_strings ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (str_all_digits (head v))
                 (list_all_digit_strings (tail v)))
            false
       )
  )
)

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (IsList lst))
(define-fun C1 () Bool (list_all_str lst))
(define-fun C2 () Bool (list_all_digit_strings lst))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1;assert_2
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1', 'assert_2'], 'total_contracts': 3}
  Solutions:
    Solution 1:
      test_case: {'lst': [2.0]}
    Solution 2:
      test_case: {'lst': [3.0]}
    Solution 3:
      test_case: {'lst': [4.0]}
    Solution 4:
      test_case: {'lst': [5.0]}
    Solution 5:
      test_case: {'lst': [6.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (or
    (is-Nil v)
    (and (is-Cons v)
         (IsList (tail v))
    )
  )
)

(define-fun-rec list_all_str ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (is-StrVal (head v))
                 (list_all_str (tail v)))
            false
       )
  )
)

(define-fun str_all_digits ((s Value)) Bool
  (and
    (is-StrVal s)
    (str.in.re (sval s) (str.to.re "[0-9]+"))
  )
)

(define-fun-rec list_all_digit_strings ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (str_all_digits (head v))
                 (list_all_digit_strings (tail v)))
            false
       )
  )
)

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (IsList lst))
(define-fun C1 () Bool (list_all_str lst))
(define-fun C2 () Bool (list_all_digit_strings lst))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0;assert_2
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0', 'assert_2'], 'total_contracts': 3}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (or
    (is-Nil v)
    (and (is-Cons v)
         (IsList (tail v))
    )
  )
)

(define-fun-rec list_all_str ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (is-StrVal (head v))
                 (list_all_str (tail v)))
            false
       )
  )
)

(define-fun str_all_digits ((s Value)) Bool
  (and
    (is-StrVal s)
    (str.in.re (sval s) (str.to.re "[0-9]+"))
  )
)

(define-fun-rec list_all_digit_strings ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (str_all_digits (head v))
                 (list_all_digit_strings (tail v)))
            false
       )
  )
)

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (IsList lst))
(define-fun C1 () Bool (list_all_str lst))
(define-fun C2 () Bool (list_all_digit_strings lst))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_assert_2
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': ['assert_2'], 'total_contracts': 3}
  Solutions:
    Solution 1:
      test_case: {'lst': ['[']}
    Solution 2:
      test_case: {'lst': ['0']}
    Solution 3:
      test_case: {'lst': ['-']}
    Solution 4:
      test_case: {'lst': ['9']}
    Solution 5:
      test_case: {'lst': [']']}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (or
    (is-Nil v)
    (and (is-Cons v)
         (IsList (tail v))
    )
  )
)

(define-fun-rec list_all_str ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (is-StrVal (head v))
                 (list_all_str (tail v)))
            false
       )
  )
)

(define-fun str_all_digits ((s Value)) Bool
  (and
    (is-StrVal s)
    (str.in.re (sval s) (str.to.re "[0-9]+"))
  )
)

(define-fun-rec list_all_digit_strings ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (str_all_digits (head v))
                 (list_all_digit_strings (tail v)))
            false
       )
  )
)

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (IsList lst))
(define-fun C1 () Bool (list_all_str lst))
(define-fun C2 () Bool (list_all_digit_strings lst))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))

(check-sat)
(get-model)

------------------------------
  Test Case 5: satisfied_assert_2, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_2'], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 3}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (or
    (is-Nil v)
    (and (is-Cons v)
         (IsList (tail v))
    )
  )
)

(define-fun-rec list_all_str ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (is-StrVal (head v))
                 (list_all_str (tail v)))
            false
       )
  )
)

(define-fun str_all_digits ((s Value)) Bool
  (and
    (is-StrVal s)
    (str.in.re (sval s) (str.to.re "[0-9]+"))
  )
)

(define-fun-rec list_all_digit_strings ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (str_all_digits (head v))
                 (list_all_digit_strings (tail v)))
            false
       )
  )
)

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (IsList lst))
(define-fun C1 () Bool (list_all_str lst))
(define-fun C2 () Bool (list_all_digit_strings lst))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)

(check-sat)
(get-model)

------------------------------
  Test Case 6: satisfied_assert_0;assert_2, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2'], 'violated_contracts': ['assert_1'], 'total_contracts': 3}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (or
    (is-Nil v)
    (and (is-Cons v)
         (IsList (tail v))
    )
  )
)

(define-fun-rec list_all_str ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (is-StrVal (head v))
                 (list_all_str (tail v)))
            false
       )
  )
)

(define-fun str_all_digits ((s Value)) Bool
  (and
    (is-StrVal s)
    (str.in.re (sval s) (str.to.re "[0-9]+"))
  )
)

(define-fun-rec list_all_digit_strings ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (str_all_digits (head v))
                 (list_all_digit_strings (tail v)))
            false
       )
  )
)

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (IsList lst))
(define-fun C1 () Bool (list_all_str lst))
(define-fun C2 () Bool (list_all_digit_strings lst))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)

(check-sat)
(get-model)

------------------------------
  Test Case 7: satisfied_assert_1;assert_2, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2'], 'violated_contracts': ['assert_0'], 'total_contracts': 3}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (or
    (is-Nil v)
    (and (is-Cons v)
         (IsList (tail v))
    )
  )
)

(define-fun-rec list_all_str ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (is-StrVal (head v))
                 (list_all_str (tail v)))
            false
       )
  )
)

(define-fun str_all_digits ((s Value)) Bool
  (and
    (is-StrVal s)
    (str.in.re (sval s) (str.to.re "[0-9]+"))
  )
)

(define-fun-rec list_all_digit_strings ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (str_all_digits (head v))
                 (list_all_digit_strings (tail v)))
            false
       )
  )
)

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (IsList lst))
(define-fun C1 () Bool (list_all_str lst))
(define-fun C2 () Bool (list_all_digit_strings lst))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)

(check-sat)
(get-model)

------------------------------
  Test Case 8: satisfied_assert_0;assert_1;assert_2, violated_
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2'], 'violated_contracts': [], 'total_contracts': 3}
  Solutions:
    Solution 1:
      test_case: {'lst': []}
    Solution 2:
      test_case: {'lst': ['[0-9]+']}
    Solution 3:
      test_case: {'lst': ['[0-9]+', '[0-9]+']}
    Solution 4:
      test_case: {'lst': ['[0-9]+', '[0-9]+', '[0-9]+']}
    Solution 5:
      test_case: {'lst': ['[0-9]+', '[0-9]+', '[0-9]+', '[0-9]+']}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (or
    (is-Nil v)
    (and (is-Cons v)
         (IsList (tail v))
    )
  )
)

(define-fun-rec list_all_str ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (is-StrVal (head v))
                 (list_all_str (tail v)))
            false
       )
  )
)

(define-fun str_all_digits ((s Value)) Bool
  (and
    (is-StrVal s)
    (str.in.re (sval s) (str.to.re "[0-9]+"))
  )
)

(define-fun-rec list_all_digit_strings ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (str_all_digits (head v))
                 (list_all_digit_strings (tail v)))
            false
       )
  )
)

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (IsList lst))
(define-fun C1 () Bool (list_all_str lst))
(define-fun C2 () Bool (list_all_digit_strings lst))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/114 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (IsList (tail v)))))

(define-fun-rec list_all_int ((v Value)) Bool
  (ite (is-Nil v)
       true
       (and (is-Cons v)
            (is-IntVal (head v))
            (list_all_int (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v)
       0
       (ite (is-Cons v)
            (+ 1 (length (tail v)))
            0)))

; === Inputs ===
(declare-const nums Value)

; === BASIC STRUCTURE ===
(assert (IsList nums))
(assert (list_all_int nums))

; === Contract predicates ===
(define-fun C0 () Bool
  (IsList nums))
(define-fun C1 () Bool
  (> (length nums) 0))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 1
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'nums': []}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (IsList (tail v)))))

(define-fun-rec list_all_int ((v Value)) Bool
  (ite (is-Nil v)
       true
       (and (is-Cons v)
            (is-IntVal (head v))
            (list_all_int (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v)
       0
       (ite (is-Cons v)
            (+ 1 (length (tail v)))
            0)))

; === Inputs ===
(declare-const nums Value)

; === BASIC STRUCTURE ===
(assert (IsList nums))
(assert (list_all_int nums))

; === Contract predicates ===
(define-fun C0 () Bool
  (IsList nums))
(define-fun C1 () Bool
  (> (length nums) 0))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (IsList (tail v)))))

(define-fun-rec list_all_int ((v Value)) Bool
  (ite (is-Nil v)
       true
       (and (is-Cons v)
            (is-IntVal (head v))
            (list_all_int (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v)
       0
       (ite (is-Cons v)
            (+ 1 (length (tail v)))
            0)))

; === Inputs ===
(declare-const nums Value)

; === BASIC STRUCTURE ===
(assert (IsList nums))
(assert (list_all_int nums))

; === Contract predicates ===
(define-fun C0 () Bool
  (IsList nums))
(define-fun C1 () Bool
  (> (length nums) 0))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'nums': [4]}
    Solution 2:
      test_case: {'nums': [5]}
    Solution 3:
      test_case: {'nums': [6]}
    Solution 4:
      test_case: {'nums': [7]}
    Solution 5:
      test_case: {'nums': [8]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (IsList (tail v)))))

(define-fun-rec list_all_int ((v Value)) Bool
  (ite (is-Nil v)
       true
       (and (is-Cons v)
            (is-IntVal (head v))
            (list_all_int (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v)
       0
       (ite (is-Cons v)
            (+ 1 (length (tail v)))
            0)))

; === Inputs ===
(declare-const nums Value)

; === BASIC STRUCTURE ===
(assert (IsList nums))
(assert (list_all_int nums))

; === Contract predicates ===
(define-fun C0 () Bool
  (IsList nums))
(define-fun C1 () Bool
  (> (length nums) 0))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/115 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1;assert_2;assert_3
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False, 'assert_3': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_3'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v) (IsList (tail v)) false)))

(define-fun-rec AllLists ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (and (IsList (head v)) (AllLists (tail v)))
      false)))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
      (+ 1 (length (tail v)))
      0)))

(define-fun-rec maxRowLen ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
      (let ((headLen (length (head v)))
            (tailMax (maxRowLen (tail v))))
        (ite (> headLen tailMax) headLen tailMax))
      0)))

(define-fun-rec minRowLen ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
      (ite (is-Nil (tail v))
        (length (head v))
        (let ((headLen (length (head v)))
              (tailMin (minRowLen (tail v))))
          (ite (< headLen tailMin) headLen tailMin)))
      0)))

(define-fun-rec IsBinaryList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (let ((h (head v)))
        (and (is-IntVal h)
             (let ((i (ival h))) (or (= i 0) (= i 1)))
             (IsBinaryList (tail v))))
      false)))

(define-fun-rec AllBinaryMatrix ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (and (IsBinaryList (head v)) (AllBinaryMatrix (tail v)))
      false)))

; === Inputs ===
(declare-const grid Value)
(declare-const capacity Value)

; === BASIC STRUCTURE ===
(assert (IsList grid))
(assert (AllLists grid))
(assert (is-IntVal capacity))

; === Contract predicates ===
(define-fun C0 () Bool
  (and (<= 1 (length grid)) (<= (length grid) 100)))
(define-fun C1 () Bool
  (and (= (maxRowLen grid) (minRowLen grid))
       (<= 1 (maxRowLen grid)) (<= (maxRowLen grid) 100)))
(define-fun C2 () Bool
  (AllBinaryMatrix grid))
(define-fun C3 () Bool
  (let ((cap (ite (is-IntVal capacity) (ival capacity) 0)))
    (and (<= 1 cap) (<= cap 10))))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1;assert_2;assert_3
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False, 'assert_3': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1', 'assert_2', 'assert_3'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'capacity': 11, 'grid': [[2.0], []]}
    Solution 2:
      test_case: {'capacity': 0, 'grid': [[3.0], []]}
    Solution 3:
      test_case: {'capacity': -29272, 'grid': [[4.0], []]}
    Solution 4:
      test_case: {'capacity': -33095, 'grid': [[5.0], []]}
    Solution 5:
      test_case: {'capacity': -33095, 'grid': [[6.0], []]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v) (IsList (tail v)) false)))

(define-fun-rec AllLists ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (and (IsList (head v)) (AllLists (tail v)))
      false)))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
      (+ 1 (length (tail v)))
      0)))

(define-fun-rec maxRowLen ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
      (let ((headLen (length (head v)))
            (tailMax (maxRowLen (tail v))))
        (ite (> headLen tailMax) headLen tailMax))
      0)))

(define-fun-rec minRowLen ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
      (ite (is-Nil (tail v))
        (length (head v))
        (let ((headLen (length (head v)))
              (tailMin (minRowLen (tail v))))
          (ite (< headLen tailMin) headLen tailMin)))
      0)))

(define-fun-rec IsBinaryList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (let ((h (head v)))
        (and (is-IntVal h)
             (let ((i (ival h))) (or (= i 0) (= i 1)))
             (IsBinaryList (tail v))))
      false)))

(define-fun-rec AllBinaryMatrix ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (and (IsBinaryList (head v)) (AllBinaryMatrix (tail v)))
      false)))

; === Inputs ===
(declare-const grid Value)
(declare-const capacity Value)

; === BASIC STRUCTURE ===
(assert (IsList grid))
(assert (AllLists grid))
(assert (is-IntVal capacity))

; === Contract predicates ===
(define-fun C0 () Bool
  (and (<= 1 (length grid)) (<= (length grid) 100)))
(define-fun C1 () Bool
  (and (= (maxRowLen grid) (minRowLen grid))
       (<= 1 (maxRowLen grid)) (<= (maxRowLen grid) 100)))
(define-fun C2 () Bool
  (AllBinaryMatrix grid))
(define-fun C3 () Bool
  (let ((cap (ite (is-IntVal capacity) (ival capacity) 0)))
    (and (<= 1 cap) (<= cap 10))))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0;assert_2;assert_3
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False, 'assert_3': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0', 'assert_2', 'assert_3'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v) (IsList (tail v)) false)))

(define-fun-rec AllLists ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (and (IsList (head v)) (AllLists (tail v)))
      false)))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
      (+ 1 (length (tail v)))
      0)))

(define-fun-rec maxRowLen ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
      (let ((headLen (length (head v)))
            (tailMax (maxRowLen (tail v))))
        (ite (> headLen tailMax) headLen tailMax))
      0)))

(define-fun-rec minRowLen ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
      (ite (is-Nil (tail v))
        (length (head v))
        (let ((headLen (length (head v)))
              (tailMin (minRowLen (tail v))))
          (ite (< headLen tailMin) headLen tailMin)))
      0)))

(define-fun-rec IsBinaryList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (let ((h (head v)))
        (and (is-IntVal h)
             (let ((i (ival h))) (or (= i 0) (= i 1)))
             (IsBinaryList (tail v))))
      false)))

(define-fun-rec AllBinaryMatrix ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (and (IsBinaryList (head v)) (AllBinaryMatrix (tail v)))
      false)))

; === Inputs ===
(declare-const grid Value)
(declare-const capacity Value)

; === BASIC STRUCTURE ===
(assert (IsList grid))
(assert (AllLists grid))
(assert (is-IntVal capacity))

; === Contract predicates ===
(define-fun C0 () Bool
  (and (<= 1 (length grid)) (<= (length grid) 100)))
(define-fun C1 () Bool
  (and (= (maxRowLen grid) (minRowLen grid))
       (<= 1 (maxRowLen grid)) (<= (maxRowLen grid) 100)))
(define-fun C2 () Bool
  (AllBinaryMatrix grid))
(define-fun C3 () Bool
  (let ((cap (ite (is-IntVal capacity) (ival capacity) 0)))
    (and (<= 1 cap) (<= cap 10))))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_assert_2;assert_3
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False, 'assert_3': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': ['assert_2', 'assert_3'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'capacity': 0, 'grid': [[2.0]]}
    Solution 2:
      test_case: {'capacity': -12329, 'grid': [[3.0]]}
    Solution 3:
      test_case: {'capacity': -40185, 'grid': [[4.0]]}
    Solution 4:
      test_case: {'capacity': -69056, 'grid': [[5.0]]}
    Solution 5:
      test_case: {'capacity': -69056, 'grid': [[6.0]]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v) (IsList (tail v)) false)))

(define-fun-rec AllLists ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (and (IsList (head v)) (AllLists (tail v)))
      false)))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
      (+ 1 (length (tail v)))
      0)))

(define-fun-rec maxRowLen ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
      (let ((headLen (length (head v)))
            (tailMax (maxRowLen (tail v))))
        (ite (> headLen tailMax) headLen tailMax))
      0)))

(define-fun-rec minRowLen ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
      (ite (is-Nil (tail v))
        (length (head v))
        (let ((headLen (length (head v)))
              (tailMin (minRowLen (tail v))))
          (ite (< headLen tailMin) headLen tailMin)))
      0)))

(define-fun-rec IsBinaryList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (let ((h (head v)))
        (and (is-IntVal h)
             (let ((i (ival h))) (or (= i 0) (= i 1)))
             (IsBinaryList (tail v))))
      false)))

(define-fun-rec AllBinaryMatrix ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (and (IsBinaryList (head v)) (AllBinaryMatrix (tail v)))
      false)))

; === Inputs ===
(declare-const grid Value)
(declare-const capacity Value)

; === BASIC STRUCTURE ===
(assert (IsList grid))
(assert (AllLists grid))
(assert (is-IntVal capacity))

; === Contract predicates ===
(define-fun C0 () Bool
  (and (<= 1 (length grid)) (<= (length grid) 100)))
(define-fun C1 () Bool
  (and (= (maxRowLen grid) (minRowLen grid))
       (<= 1 (maxRowLen grid)) (<= (maxRowLen grid) 100)))
(define-fun C2 () Bool
  (AllBinaryMatrix grid))
(define-fun C3 () Bool
  (let ((cap (ite (is-IntVal capacity) (ival capacity) 0)))
    (and (<= 1 cap) (<= cap 10))))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 5: satisfied_assert_2, violated_assert_0;assert_1;assert_3
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True, 'assert_3': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_2'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_3'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'capacity': 0, 'grid': []}
    Solution 2:
      test_case: {'grid': [], 'capacity': 11}
    Solution 3:
      test_case: {'grid': [], 'capacity': 292}
    Solution 4:
      test_case: {'grid': [], 'capacity': 21268}
    Solution 5:
      test_case: {'grid': [], 'capacity': 23508}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v) (IsList (tail v)) false)))

(define-fun-rec AllLists ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (and (IsList (head v)) (AllLists (tail v)))
      false)))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
      (+ 1 (length (tail v)))
      0)))

(define-fun-rec maxRowLen ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
      (let ((headLen (length (head v)))
            (tailMax (maxRowLen (tail v))))
        (ite (> headLen tailMax) headLen tailMax))
      0)))

(define-fun-rec minRowLen ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
      (ite (is-Nil (tail v))
        (length (head v))
        (let ((headLen (length (head v)))
              (tailMin (minRowLen (tail v))))
          (ite (< headLen tailMin) headLen tailMin)))
      0)))

(define-fun-rec IsBinaryList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (let ((h (head v)))
        (and (is-IntVal h)
             (let ((i (ival h))) (or (= i 0) (= i 1)))
             (IsBinaryList (tail v))))
      false)))

(define-fun-rec AllBinaryMatrix ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (and (IsBinaryList (head v)) (AllBinaryMatrix (tail v)))
      false)))

; === Inputs ===
(declare-const grid Value)
(declare-const capacity Value)

; === BASIC STRUCTURE ===
(assert (IsList grid))
(assert (AllLists grid))
(assert (is-IntVal capacity))

; === Contract predicates ===
(define-fun C0 () Bool
  (and (<= 1 (length grid)) (<= (length grid) 100)))
(define-fun C1 () Bool
  (and (= (maxRowLen grid) (minRowLen grid))
       (<= 1 (maxRowLen grid)) (<= (maxRowLen grid) 100)))
(define-fun C2 () Bool
  (AllBinaryMatrix grid))
(define-fun C3 () Bool
  (let ((cap (ite (is-IntVal capacity) (ival capacity) 0)))
    (and (<= 1 cap) (<= cap 10))))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 6: satisfied_assert_0;assert_2, violated_assert_1;assert_3
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True, 'assert_3': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2'], 'violated_contracts': ['assert_1', 'assert_3'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'capacity': 11, 'grid': [[]]}
    Solution 2:
      test_case: {'grid': [[]], 'capacity': 0}
    Solution 3:
      test_case: {'capacity': -28881, 'grid': [[]]}
    Solution 4:
      test_case: {'capacity': -41337, 'grid': [[]]}
    Solution 5:
      test_case: {'capacity': -48966, 'grid': [[]]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v) (IsList (tail v)) false)))

(define-fun-rec AllLists ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (and (IsList (head v)) (AllLists (tail v)))
      false)))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
      (+ 1 (length (tail v)))
      0)))

(define-fun-rec maxRowLen ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
      (let ((headLen (length (head v)))
            (tailMax (maxRowLen (tail v))))
        (ite (> headLen tailMax) headLen tailMax))
      0)))

(define-fun-rec minRowLen ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
      (ite (is-Nil (tail v))
        (length (head v))
        (let ((headLen (length (head v)))
              (tailMin (minRowLen (tail v))))
          (ite (< headLen tailMin) headLen tailMin)))
      0)))

(define-fun-rec IsBinaryList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (let ((h (head v)))
        (and (is-IntVal h)
             (let ((i (ival h))) (or (= i 0) (= i 1)))
             (IsBinaryList (tail v))))
      false)))

(define-fun-rec AllBinaryMatrix ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (and (IsBinaryList (head v)) (AllBinaryMatrix (tail v)))
      false)))

; === Inputs ===
(declare-const grid Value)
(declare-const capacity Value)

; === BASIC STRUCTURE ===
(assert (IsList grid))
(assert (AllLists grid))
(assert (is-IntVal capacity))

; === Contract predicates ===
(define-fun C0 () Bool
  (and (<= 1 (length grid)) (<= (length grid) 100)))
(define-fun C1 () Bool
  (and (= (maxRowLen grid) (minRowLen grid))
       (<= 1 (maxRowLen grid)) (<= (maxRowLen grid) 100)))
(define-fun C2 () Bool
  (AllBinaryMatrix grid))
(define-fun C3 () Bool
  (let ((cap (ite (is-IntVal capacity) (ival capacity) 0)))
    (and (<= 1 cap) (<= cap 10))))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 7: satisfied_assert_1;assert_2, violated_assert_0;assert_3
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True, 'assert_3': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2'], 'violated_contracts': ['assert_0', 'assert_3'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v) (IsList (tail v)) false)))

(define-fun-rec AllLists ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (and (IsList (head v)) (AllLists (tail v)))
      false)))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
      (+ 1 (length (tail v)))
      0)))

(define-fun-rec maxRowLen ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
      (let ((headLen (length (head v)))
            (tailMax (maxRowLen (tail v))))
        (ite (> headLen tailMax) headLen tailMax))
      0)))

(define-fun-rec minRowLen ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
      (ite (is-Nil (tail v))
        (length (head v))
        (let ((headLen (length (head v)))
              (tailMin (minRowLen (tail v))))
          (ite (< headLen tailMin) headLen tailMin)))
      0)))

(define-fun-rec IsBinaryList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (let ((h (head v)))
        (and (is-IntVal h)
             (let ((i (ival h))) (or (= i 0) (= i 1)))
             (IsBinaryList (tail v))))
      false)))

(define-fun-rec AllBinaryMatrix ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (and (IsBinaryList (head v)) (AllBinaryMatrix (tail v)))
      false)))

; === Inputs ===
(declare-const grid Value)
(declare-const capacity Value)

; === BASIC STRUCTURE ===
(assert (IsList grid))
(assert (AllLists grid))
(assert (is-IntVal capacity))

; === Contract predicates ===
(define-fun C0 () Bool
  (and (<= 1 (length grid)) (<= (length grid) 100)))
(define-fun C1 () Bool
  (and (= (maxRowLen grid) (minRowLen grid))
       (<= 1 (maxRowLen grid)) (<= (maxRowLen grid) 100)))
(define-fun C2 () Bool
  (AllBinaryMatrix grid))
(define-fun C3 () Bool
  (let ((cap (ite (is-IntVal capacity) (ival capacity) 0)))
    (and (<= 1 cap) (<= cap 10))))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 8: satisfied_assert_0;assert_1;assert_2, violated_assert_3
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True, 'assert_3': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2'], 'violated_contracts': ['assert_3'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'capacity': 11, 'grid': [[1]]}
    Solution 2:
      test_case: {'capacity': -2446, 'grid': [[0]]}
    Solution 3:
      test_case: {'capacity': -9324, 'grid': [[0]]}
    Solution 4:
      test_case: {'capacity': -21603, 'grid': [[0]]}
    Solution 5:
      test_case: {'capacity': -22705, 'grid': [[0]]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v) (IsList (tail v)) false)))

(define-fun-rec AllLists ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (and (IsList (head v)) (AllLists (tail v)))
      false)))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
      (+ 1 (length (tail v)))
      0)))

(define-fun-rec maxRowLen ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
      (let ((headLen (length (head v)))
            (tailMax (maxRowLen (tail v))))
        (ite (> headLen tailMax) headLen tailMax))
      0)))

(define-fun-rec minRowLen ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
      (ite (is-Nil (tail v))
        (length (head v))
        (let ((headLen (length (head v)))
              (tailMin (minRowLen (tail v))))
          (ite (< headLen tailMin) headLen tailMin)))
      0)))

(define-fun-rec IsBinaryList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (let ((h (head v)))
        (and (is-IntVal h)
             (let ((i (ival h))) (or (= i 0) (= i 1)))
             (IsBinaryList (tail v))))
      false)))

(define-fun-rec AllBinaryMatrix ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (and (IsBinaryList (head v)) (AllBinaryMatrix (tail v)))
      false)))

; === Inputs ===
(declare-const grid Value)
(declare-const capacity Value)

; === BASIC STRUCTURE ===
(assert (IsList grid))
(assert (AllLists grid))
(assert (is-IntVal capacity))

; === Contract predicates ===
(define-fun C0 () Bool
  (and (<= 1 (length grid)) (<= (length grid) 100)))
(define-fun C1 () Bool
  (and (= (maxRowLen grid) (minRowLen grid))
       (<= 1 (maxRowLen grid)) (<= (maxRowLen grid) 100)))
(define-fun C2 () Bool
  (AllBinaryMatrix grid))
(define-fun C3 () Bool
  (let ((cap (ite (is-IntVal capacity) (ival capacity) 0)))
    (and (<= 1 cap) (<= cap 10))))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 9: satisfied_assert_3, violated_assert_0;assert_1;assert_2
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False, 'assert_3': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_3'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v) (IsList (tail v)) false)))

(define-fun-rec AllLists ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (and (IsList (head v)) (AllLists (tail v)))
      false)))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
      (+ 1 (length (tail v)))
      0)))

(define-fun-rec maxRowLen ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
      (let ((headLen (length (head v)))
            (tailMax (maxRowLen (tail v))))
        (ite (> headLen tailMax) headLen tailMax))
      0)))

(define-fun-rec minRowLen ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
      (ite (is-Nil (tail v))
        (length (head v))
        (let ((headLen (length (head v)))
              (tailMin (minRowLen (tail v))))
          (ite (< headLen tailMin) headLen tailMin)))
      0)))

(define-fun-rec IsBinaryList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (let ((h (head v)))
        (and (is-IntVal h)
             (let ((i (ival h))) (or (= i 0) (= i 1)))
             (IsBinaryList (tail v))))
      false)))

(define-fun-rec AllBinaryMatrix ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (and (IsBinaryList (head v)) (AllBinaryMatrix (tail v)))
      false)))

; === Inputs ===
(declare-const grid Value)
(declare-const capacity Value)

; === BASIC STRUCTURE ===
(assert (IsList grid))
(assert (AllLists grid))
(assert (is-IntVal capacity))

; === Contract predicates ===
(define-fun C0 () Bool
  (and (<= 1 (length grid)) (<= (length grid) 100)))
(define-fun C1 () Bool
  (and (= (maxRowLen grid) (minRowLen grid))
       (<= 1 (maxRowLen grid)) (<= (maxRowLen grid) 100)))
(define-fun C2 () Bool
  (AllBinaryMatrix grid))
(define-fun C3 () Bool
  (let ((cap (ite (is-IntVal capacity) (ival capacity) 0)))
    (and (<= 1 cap) (<= cap 10))))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 10: satisfied_assert_0;assert_3, violated_assert_1;assert_2
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False, 'assert_3': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_3'], 'violated_contracts': ['assert_1', 'assert_2'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'capacity': 1, 'grid': [[2.0], []]}
    Solution 2:
      test_case: {'capacity': 10, 'grid': [[3.0], []]}
    Solution 3:
      test_case: {'capacity': 5, 'grid': [[4.0], []]}
    Solution 4:
      test_case: {'capacity': 5, 'grid': [[5.0], []]}
    Solution 5:
      test_case: {'capacity': 5, 'grid': [[6.0], []]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v) (IsList (tail v)) false)))

(define-fun-rec AllLists ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (and (IsList (head v)) (AllLists (tail v)))
      false)))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
      (+ 1 (length (tail v)))
      0)))

(define-fun-rec maxRowLen ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
      (let ((headLen (length (head v)))
            (tailMax (maxRowLen (tail v))))
        (ite (> headLen tailMax) headLen tailMax))
      0)))

(define-fun-rec minRowLen ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
      (ite (is-Nil (tail v))
        (length (head v))
        (let ((headLen (length (head v)))
              (tailMin (minRowLen (tail v))))
          (ite (< headLen tailMin) headLen tailMin)))
      0)))

(define-fun-rec IsBinaryList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (let ((h (head v)))
        (and (is-IntVal h)
             (let ((i (ival h))) (or (= i 0) (= i 1)))
             (IsBinaryList (tail v))))
      false)))

(define-fun-rec AllBinaryMatrix ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (and (IsBinaryList (head v)) (AllBinaryMatrix (tail v)))
      false)))

; === Inputs ===
(declare-const grid Value)
(declare-const capacity Value)

; === BASIC STRUCTURE ===
(assert (IsList grid))
(assert (AllLists grid))
(assert (is-IntVal capacity))

; === Contract predicates ===
(define-fun C0 () Bool
  (and (<= 1 (length grid)) (<= (length grid) 100)))
(define-fun C1 () Bool
  (and (= (maxRowLen grid) (minRowLen grid))
       (<= 1 (maxRowLen grid)) (<= (maxRowLen grid) 100)))
(define-fun C2 () Bool
  (AllBinaryMatrix grid))
(define-fun C3 () Bool
  (let ((cap (ite (is-IntVal capacity) (ival capacity) 0)))
    (and (<= 1 cap) (<= cap 10))))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 11: satisfied_assert_1;assert_3, violated_assert_0;assert_2
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False, 'assert_3': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_3'], 'violated_contracts': ['assert_0', 'assert_2'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v) (IsList (tail v)) false)))

(define-fun-rec AllLists ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (and (IsList (head v)) (AllLists (tail v)))
      false)))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
      (+ 1 (length (tail v)))
      0)))

(define-fun-rec maxRowLen ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
      (let ((headLen (length (head v)))
            (tailMax (maxRowLen (tail v))))
        (ite (> headLen tailMax) headLen tailMax))
      0)))

(define-fun-rec minRowLen ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
      (ite (is-Nil (tail v))
        (length (head v))
        (let ((headLen (length (head v)))
              (tailMin (minRowLen (tail v))))
          (ite (< headLen tailMin) headLen tailMin)))
      0)))

(define-fun-rec IsBinaryList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (let ((h (head v)))
        (and (is-IntVal h)
             (let ((i (ival h))) (or (= i 0) (= i 1)))
             (IsBinaryList (tail v))))
      false)))

(define-fun-rec AllBinaryMatrix ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (and (IsBinaryList (head v)) (AllBinaryMatrix (tail v)))
      false)))

; === Inputs ===
(declare-const grid Value)
(declare-const capacity Value)

; === BASIC STRUCTURE ===
(assert (IsList grid))
(assert (AllLists grid))
(assert (is-IntVal capacity))

; === Contract predicates ===
(define-fun C0 () Bool
  (and (<= 1 (length grid)) (<= (length grid) 100)))
(define-fun C1 () Bool
  (and (= (maxRowLen grid) (minRowLen grid))
       (<= 1 (maxRowLen grid)) (<= (maxRowLen grid) 100)))
(define-fun C2 () Bool
  (AllBinaryMatrix grid))
(define-fun C3 () Bool
  (let ((cap (ite (is-IntVal capacity) (ival capacity) 0)))
    (and (<= 1 cap) (<= cap 10))))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 12: satisfied_assert_0;assert_1;assert_3, violated_assert_2
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False, 'assert_3': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_3'], 'violated_contracts': ['assert_2'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'capacity': 1, 'grid': [[2.0]]}
    Solution 2:
      test_case: {'capacity': 8, 'grid': [[4.0]]}
    Solution 3:
      test_case: {'capacity': 6, 'grid': [[3.0]]}
    Solution 4:
      test_case: {'capacity': 9, 'grid': [[5.0]]}
    Solution 5:
      test_case: {'capacity': 4, 'grid': [[7.0]]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v) (IsList (tail v)) false)))

(define-fun-rec AllLists ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (and (IsList (head v)) (AllLists (tail v)))
      false)))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
      (+ 1 (length (tail v)))
      0)))

(define-fun-rec maxRowLen ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
      (let ((headLen (length (head v)))
            (tailMax (maxRowLen (tail v))))
        (ite (> headLen tailMax) headLen tailMax))
      0)))

(define-fun-rec minRowLen ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
      (ite (is-Nil (tail v))
        (length (head v))
        (let ((headLen (length (head v)))
              (tailMin (minRowLen (tail v))))
          (ite (< headLen tailMin) headLen tailMin)))
      0)))

(define-fun-rec IsBinaryList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (let ((h (head v)))
        (and (is-IntVal h)
             (let ((i (ival h))) (or (= i 0) (= i 1)))
             (IsBinaryList (tail v))))
      false)))

(define-fun-rec AllBinaryMatrix ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (and (IsBinaryList (head v)) (AllBinaryMatrix (tail v)))
      false)))

; === Inputs ===
(declare-const grid Value)
(declare-const capacity Value)

; === BASIC STRUCTURE ===
(assert (IsList grid))
(assert (AllLists grid))
(assert (is-IntVal capacity))

; === Contract predicates ===
(define-fun C0 () Bool
  (and (<= 1 (length grid)) (<= (length grid) 100)))
(define-fun C1 () Bool
  (and (= (maxRowLen grid) (minRowLen grid))
       (<= 1 (maxRowLen grid)) (<= (maxRowLen grid) 100)))
(define-fun C2 () Bool
  (AllBinaryMatrix grid))
(define-fun C3 () Bool
  (let ((cap (ite (is-IntVal capacity) (ival capacity) 0)))
    (and (<= 1 cap) (<= cap 10))))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 13: satisfied_assert_2;assert_3, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True, 'assert_3': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_2', 'assert_3'], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'capacity': 1, 'grid': []}
    Solution 2:
      test_case: {'grid': [], 'capacity': 8}
    Solution 3:
      test_case: {'grid': [], 'capacity': 3}
    Solution 4:
      test_case: {'grid': [], 'capacity': 2}
    Solution 5:
      test_case: {'grid': [], 'capacity': 6}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v) (IsList (tail v)) false)))

(define-fun-rec AllLists ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (and (IsList (head v)) (AllLists (tail v)))
      false)))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
      (+ 1 (length (tail v)))
      0)))

(define-fun-rec maxRowLen ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
      (let ((headLen (length (head v)))
            (tailMax (maxRowLen (tail v))))
        (ite (> headLen tailMax) headLen tailMax))
      0)))

(define-fun-rec minRowLen ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
      (ite (is-Nil (tail v))
        (length (head v))
        (let ((headLen (length (head v)))
              (tailMin (minRowLen (tail v))))
          (ite (< headLen tailMin) headLen tailMin)))
      0)))

(define-fun-rec IsBinaryList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (let ((h (head v)))
        (and (is-IntVal h)
             (let ((i (ival h))) (or (= i 0) (= i 1)))
             (IsBinaryList (tail v))))
      false)))

(define-fun-rec AllBinaryMatrix ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (and (IsBinaryList (head v)) (AllBinaryMatrix (tail v)))
      false)))

; === Inputs ===
(declare-const grid Value)
(declare-const capacity Value)

; === BASIC STRUCTURE ===
(assert (IsList grid))
(assert (AllLists grid))
(assert (is-IntVal capacity))

; === Contract predicates ===
(define-fun C0 () Bool
  (and (<= 1 (length grid)) (<= (length grid) 100)))
(define-fun C1 () Bool
  (and (= (maxRowLen grid) (minRowLen grid))
       (<= 1 (maxRowLen grid)) (<= (maxRowLen grid) 100)))
(define-fun C2 () Bool
  (AllBinaryMatrix grid))
(define-fun C3 () Bool
  (let ((cap (ite (is-IntVal capacity) (ival capacity) 0)))
    (and (<= 1 cap) (<= cap 10))))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 14: satisfied_assert_0;assert_2;assert_3, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True, 'assert_3': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2', 'assert_3'], 'violated_contracts': ['assert_1'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'capacity': 1, 'grid': [[]]}
    Solution 2:
      test_case: {'grid': [[]], 'capacity': 2}
    Solution 3:
      test_case: {'grid': [[]], 'capacity': 6}
    Solution 4:
      test_case: {'capacity': 5, 'grid': [[]]}
    Solution 5:
      test_case: {'capacity': 7, 'grid': [[]]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v) (IsList (tail v)) false)))

(define-fun-rec AllLists ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (and (IsList (head v)) (AllLists (tail v)))
      false)))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
      (+ 1 (length (tail v)))
      0)))

(define-fun-rec maxRowLen ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
      (let ((headLen (length (head v)))
            (tailMax (maxRowLen (tail v))))
        (ite (> headLen tailMax) headLen tailMax))
      0)))

(define-fun-rec minRowLen ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
      (ite (is-Nil (tail v))
        (length (head v))
        (let ((headLen (length (head v)))
              (tailMin (minRowLen (tail v))))
          (ite (< headLen tailMin) headLen tailMin)))
      0)))

(define-fun-rec IsBinaryList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (let ((h (head v)))
        (and (is-IntVal h)
             (let ((i (ival h))) (or (= i 0) (= i 1)))
             (IsBinaryList (tail v))))
      false)))

(define-fun-rec AllBinaryMatrix ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (and (IsBinaryList (head v)) (AllBinaryMatrix (tail v)))
      false)))

; === Inputs ===
(declare-const grid Value)
(declare-const capacity Value)

; === BASIC STRUCTURE ===
(assert (IsList grid))
(assert (AllLists grid))
(assert (is-IntVal capacity))

; === Contract predicates ===
(define-fun C0 () Bool
  (and (<= 1 (length grid)) (<= (length grid) 100)))
(define-fun C1 () Bool
  (and (= (maxRowLen grid) (minRowLen grid))
       (<= 1 (maxRowLen grid)) (<= (maxRowLen grid) 100)))
(define-fun C2 () Bool
  (AllBinaryMatrix grid))
(define-fun C3 () Bool
  (let ((cap (ite (is-IntVal capacity) (ival capacity) 0)))
    (and (<= 1 cap) (<= cap 10))))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 15: satisfied_assert_1;assert_2;assert_3, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True, 'assert_3': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2', 'assert_3'], 'violated_contracts': ['assert_0'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v) (IsList (tail v)) false)))

(define-fun-rec AllLists ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (and (IsList (head v)) (AllLists (tail v)))
      false)))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
      (+ 1 (length (tail v)))
      0)))

(define-fun-rec maxRowLen ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
      (let ((headLen (length (head v)))
            (tailMax (maxRowLen (tail v))))
        (ite (> headLen tailMax) headLen tailMax))
      0)))

(define-fun-rec minRowLen ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
      (ite (is-Nil (tail v))
        (length (head v))
        (let ((headLen (length (head v)))
              (tailMin (minRowLen (tail v))))
          (ite (< headLen tailMin) headLen tailMin)))
      0)))

(define-fun-rec IsBinaryList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (let ((h (head v)))
        (and (is-IntVal h)
             (let ((i (ival h))) (or (= i 0) (= i 1)))
             (IsBinaryList (tail v))))
      false)))

(define-fun-rec AllBinaryMatrix ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (and (IsBinaryList (head v)) (AllBinaryMatrix (tail v)))
      false)))

; === Inputs ===
(declare-const grid Value)
(declare-const capacity Value)

; === BASIC STRUCTURE ===
(assert (IsList grid))
(assert (AllLists grid))
(assert (is-IntVal capacity))

; === Contract predicates ===
(define-fun C0 () Bool
  (and (<= 1 (length grid)) (<= (length grid) 100)))
(define-fun C1 () Bool
  (and (= (maxRowLen grid) (minRowLen grid))
       (<= 1 (maxRowLen grid)) (<= (maxRowLen grid) 100)))
(define-fun C2 () Bool
  (AllBinaryMatrix grid))
(define-fun C3 () Bool
  (let ((cap (ite (is-IntVal capacity) (ival capacity) 0)))
    (and (<= 1 cap) (<= cap 10))))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 16: satisfied_assert_0;assert_1;assert_2;assert_3, violated_
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True, 'assert_3': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_3'], 'violated_contracts': [], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'capacity': 4, 'grid': [[1]]}
    Solution 2:
      test_case: {'capacity': 1, 'grid': [[0]]}
    Solution 3:
      test_case: {'capacity': 8, 'grid': [[0]]}
    Solution 4:
      test_case: {'capacity': 5, 'grid': [[0]]}
    Solution 5:
      test_case: {'capacity': 6, 'grid': [[0]]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v) (IsList (tail v)) false)))

(define-fun-rec AllLists ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (and (IsList (head v)) (AllLists (tail v)))
      false)))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
      (+ 1 (length (tail v)))
      0)))

(define-fun-rec maxRowLen ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
      (let ((headLen (length (head v)))
            (tailMax (maxRowLen (tail v))))
        (ite (> headLen tailMax) headLen tailMax))
      0)))

(define-fun-rec minRowLen ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
      (ite (is-Nil (tail v))
        (length (head v))
        (let ((headLen (length (head v)))
              (tailMin (minRowLen (tail v))))
          (ite (< headLen tailMin) headLen tailMin)))
      0)))

(define-fun-rec IsBinaryList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (let ((h (head v)))
        (and (is-IntVal h)
             (let ((i (ival h))) (or (= i 0) (= i 1)))
             (IsBinaryList (tail v))))
      false)))

(define-fun-rec AllBinaryMatrix ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (and (IsBinaryList (head v)) (AllBinaryMatrix (tail v)))
      false)))

; === Inputs ===
(declare-const grid Value)
(declare-const capacity Value)

; === BASIC STRUCTURE ===
(assert (IsList grid))
(assert (AllLists grid))
(assert (is-IntVal capacity))

; === Contract predicates ===
(define-fun C0 () Bool
  (and (<= 1 (length grid)) (<= (length grid) 100)))
(define-fun C1 () Bool
  (and (= (maxRowLen grid) (minRowLen grid))
       (<= 1 (maxRowLen grid)) (<= (maxRowLen grid) 100)))
(define-fun C2 () Bool
  (AllBinaryMatrix grid))
(define-fun C3 () Bool
  (let ((cap (ite (is-IntVal capacity) (ival capacity) 0)))
    (and (<= 1 cap) (<= cap 10))))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)
(assert C3)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/116 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_nonneg_int ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (is-Cons lst)
            (let ((hd (head lst)) (tl (tail lst)))
               (and (is-IntVal hd)
                    (let ((i (ival hd))) (>= i 0))
                    (list_all_nonneg_int tl)))
            false)))

; === Inputs ===
(declare-const arr Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (list_all_nonneg_int arr))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'arr': [2.0]}
    Solution 2:
      test_case: {'arr': [3.0]}
    Solution 3:
      test_case: {'arr': [4.0]}
    Solution 4:
      test_case: {'arr': [5.0]}
    Solution 5:
      test_case: {'arr': [6.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_nonneg_int ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (is-Cons lst)
            (let ((hd (head lst)) (tl (tail lst)))
               (and (is-IntVal hd)
                    (let ((i (ival hd))) (>= i 0))
                    (list_all_nonneg_int tl)))
            false)))

; === Inputs ===
(declare-const arr Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (list_all_nonneg_int arr))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_nonneg_int ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (is-Cons lst)
            (let ((hd (head lst)) (tl (tail lst)))
               (and (is-IntVal hd)
                    (let ((i (ival hd))) (>= i 0))
                    (list_all_nonneg_int tl)))
            false)))

; === Inputs ===
(declare-const arr Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (list_all_nonneg_int arr))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'arr': []}
    Solution 2:
      test_case: {'arr': [0]}
    Solution 3:
      test_case: {'arr': [2437]}
    Solution 4:
      test_case: {'arr': [8365]}
    Solution 5:
      test_case: {'arr': [30612]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_nonneg_int ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (is-Cons lst)
            (let ((hd (head lst)) (tl (tail lst)))
               (and (is-IntVal hd)
                    (let ((i (ival hd))) (>= i 0))
                    (list_all_nonneg_int tl)))
            false)))

; === Inputs ===
(declare-const arr Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (list_all_nonneg_int arr))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/117 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1;assert_2;assert_3
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False, 'assert_3': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_3'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun is_string_and_valid_chars ((v Value)) Bool (ite (is-StrVal v) (str.in.re (sval v) (str.to.re "[A-Za-z ]*")) false))
(define-fun is_nonneg_int ((v Value)) Bool (ite (is-IntVal v) (>= (ival v) 0) false))

; === Inputs ===
(declare-const s Value)
(declare-const n Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal s))
(assert (is-IntVal n))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal s))
(define-fun C1 () Bool (ite (is-StrVal s) (str.in.re (sval s) (str.to.re "[A-Za-z ]*")) false))
(define-fun C2 () Bool (is-IntVal n))
(define-fun C3 () Bool (ite (is-IntVal n) (>= (ival n) 0) false))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1;assert_2;assert_3
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False, 'assert_3': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1', 'assert_2', 'assert_3'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun is_string_and_valid_chars ((v Value)) Bool (ite (is-StrVal v) (str.in.re (sval v) (str.to.re "[A-Za-z ]*")) false))
(define-fun is_nonneg_int ((v Value)) Bool (ite (is-IntVal v) (>= (ival v) 0) false))

; === Inputs ===
(declare-const s Value)
(declare-const n Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal s))
(assert (is-IntVal n))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal s))
(define-fun C1 () Bool (ite (is-StrVal s) (str.in.re (sval s) (str.to.re "[A-Za-z ]*")) false))
(define-fun C2 () Bool (is-IntVal n))
(define-fun C3 () Bool (ite (is-IntVal n) (>= (ival n) 0) false))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0;assert_2;assert_3
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False, 'assert_3': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0', 'assert_2', 'assert_3'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun is_string_and_valid_chars ((v Value)) Bool (ite (is-StrVal v) (str.in.re (sval v) (str.to.re "[A-Za-z ]*")) false))
(define-fun is_nonneg_int ((v Value)) Bool (ite (is-IntVal v) (>= (ival v) 0) false))

; === Inputs ===
(declare-const s Value)
(declare-const n Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal s))
(assert (is-IntVal n))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal s))
(define-fun C1 () Bool (ite (is-StrVal s) (str.in.re (sval s) (str.to.re "[A-Za-z ]*")) false))
(define-fun C2 () Bool (is-IntVal n))
(define-fun C3 () Bool (ite (is-IntVal n) (>= (ival n) 0) false))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_assert_2;assert_3
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False, 'assert_3': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': ['assert_2', 'assert_3'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun is_string_and_valid_chars ((v Value)) Bool (ite (is-StrVal v) (str.in.re (sval v) (str.to.re "[A-Za-z ]*")) false))
(define-fun is_nonneg_int ((v Value)) Bool (ite (is-IntVal v) (>= (ival v) 0) false))

; === Inputs ===
(declare-const s Value)
(declare-const n Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal s))
(assert (is-IntVal n))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal s))
(define-fun C1 () Bool (ite (is-StrVal s) (str.in.re (sval s) (str.to.re "[A-Za-z ]*")) false))
(define-fun C2 () Bool (is-IntVal n))
(define-fun C3 () Bool (ite (is-IntVal n) (>= (ival n) 0) false))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 5: satisfied_assert_2, violated_assert_0;assert_1;assert_3
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True, 'assert_3': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_2'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_3'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun is_string_and_valid_chars ((v Value)) Bool (ite (is-StrVal v) (str.in.re (sval v) (str.to.re "[A-Za-z ]*")) false))
(define-fun is_nonneg_int ((v Value)) Bool (ite (is-IntVal v) (>= (ival v) 0) false))

; === Inputs ===
(declare-const s Value)
(declare-const n Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal s))
(assert (is-IntVal n))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal s))
(define-fun C1 () Bool (ite (is-StrVal s) (str.in.re (sval s) (str.to.re "[A-Za-z ]*")) false))
(define-fun C2 () Bool (is-IntVal n))
(define-fun C3 () Bool (ite (is-IntVal n) (>= (ival n) 0) false))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 6: satisfied_assert_0;assert_2, violated_assert_1;assert_3
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True, 'assert_3': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2'], 'violated_contracts': ['assert_1', 'assert_3'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'s': '[', 'n': -1}
    Solution 2:
      test_case: {'n': -1, 's': 'A'}
    Solution 3:
      test_case: {'n': -7720, 's': '-'}
    Solution 4:
      test_case: {'n': -7720, 's': 'Z'}
    Solution 5:
      test_case: {'n': -7720, 's': 'a'}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun is_string_and_valid_chars ((v Value)) Bool (ite (is-StrVal v) (str.in.re (sval v) (str.to.re "[A-Za-z ]*")) false))
(define-fun is_nonneg_int ((v Value)) Bool (ite (is-IntVal v) (>= (ival v) 0) false))

; === Inputs ===
(declare-const s Value)
(declare-const n Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal s))
(assert (is-IntVal n))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal s))
(define-fun C1 () Bool (ite (is-StrVal s) (str.in.re (sval s) (str.to.re "[A-Za-z ]*")) false))
(define-fun C2 () Bool (is-IntVal n))
(define-fun C3 () Bool (ite (is-IntVal n) (>= (ival n) 0) false))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 7: satisfied_assert_1;assert_2, violated_assert_0;assert_3
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True, 'assert_3': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2'], 'violated_contracts': ['assert_0', 'assert_3'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun is_string_and_valid_chars ((v Value)) Bool (ite (is-StrVal v) (str.in.re (sval v) (str.to.re "[A-Za-z ]*")) false))
(define-fun is_nonneg_int ((v Value)) Bool (ite (is-IntVal v) (>= (ival v) 0) false))

; === Inputs ===
(declare-const s Value)
(declare-const n Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal s))
(assert (is-IntVal n))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal s))
(define-fun C1 () Bool (ite (is-StrVal s) (str.in.re (sval s) (str.to.re "[A-Za-z ]*")) false))
(define-fun C2 () Bool (is-IntVal n))
(define-fun C3 () Bool (ite (is-IntVal n) (>= (ival n) 0) false))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 8: satisfied_assert_0;assert_1;assert_2, violated_assert_3
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True, 'assert_3': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2'], 'violated_contracts': ['assert_3'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'s': '[A-Za-z ]*', 'n': -1}
    Solution 2:
      test_case: {'n': -7720, 's': '[A-Za-z ]*'}
    Solution 3:
      test_case: {'n': -10157, 's': '[A-Za-z ]*'}
    Solution 4:
      test_case: {'n': -21954, 's': '[A-Za-z ]*'}
    Solution 5:
      test_case: {'n': -54239, 's': '[A-Za-z ]*'}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun is_string_and_valid_chars ((v Value)) Bool (ite (is-StrVal v) (str.in.re (sval v) (str.to.re "[A-Za-z ]*")) false))
(define-fun is_nonneg_int ((v Value)) Bool (ite (is-IntVal v) (>= (ival v) 0) false))

; === Inputs ===
(declare-const s Value)
(declare-const n Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal s))
(assert (is-IntVal n))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal s))
(define-fun C1 () Bool (ite (is-StrVal s) (str.in.re (sval s) (str.to.re "[A-Za-z ]*")) false))
(define-fun C2 () Bool (is-IntVal n))
(define-fun C3 () Bool (ite (is-IntVal n) (>= (ival n) 0) false))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 9: satisfied_assert_3, violated_assert_0;assert_1;assert_2
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False, 'assert_3': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_3'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun is_string_and_valid_chars ((v Value)) Bool (ite (is-StrVal v) (str.in.re (sval v) (str.to.re "[A-Za-z ]*")) false))
(define-fun is_nonneg_int ((v Value)) Bool (ite (is-IntVal v) (>= (ival v) 0) false))

; === Inputs ===
(declare-const s Value)
(declare-const n Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal s))
(assert (is-IntVal n))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal s))
(define-fun C1 () Bool (ite (is-StrVal s) (str.in.re (sval s) (str.to.re "[A-Za-z ]*")) false))
(define-fun C2 () Bool (is-IntVal n))
(define-fun C3 () Bool (ite (is-IntVal n) (>= (ival n) 0) false))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 10: satisfied_assert_0;assert_3, violated_assert_1;assert_2
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False, 'assert_3': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_3'], 'violated_contracts': ['assert_1', 'assert_2'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun is_string_and_valid_chars ((v Value)) Bool (ite (is-StrVal v) (str.in.re (sval v) (str.to.re "[A-Za-z ]*")) false))
(define-fun is_nonneg_int ((v Value)) Bool (ite (is-IntVal v) (>= (ival v) 0) false))

; === Inputs ===
(declare-const s Value)
(declare-const n Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal s))
(assert (is-IntVal n))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal s))
(define-fun C1 () Bool (ite (is-StrVal s) (str.in.re (sval s) (str.to.re "[A-Za-z ]*")) false))
(define-fun C2 () Bool (is-IntVal n))
(define-fun C3 () Bool (ite (is-IntVal n) (>= (ival n) 0) false))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 11: satisfied_assert_1;assert_3, violated_assert_0;assert_2
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False, 'assert_3': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_3'], 'violated_contracts': ['assert_0', 'assert_2'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun is_string_and_valid_chars ((v Value)) Bool (ite (is-StrVal v) (str.in.re (sval v) (str.to.re "[A-Za-z ]*")) false))
(define-fun is_nonneg_int ((v Value)) Bool (ite (is-IntVal v) (>= (ival v) 0) false))

; === Inputs ===
(declare-const s Value)
(declare-const n Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal s))
(assert (is-IntVal n))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal s))
(define-fun C1 () Bool (ite (is-StrVal s) (str.in.re (sval s) (str.to.re "[A-Za-z ]*")) false))
(define-fun C2 () Bool (is-IntVal n))
(define-fun C3 () Bool (ite (is-IntVal n) (>= (ival n) 0) false))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 12: satisfied_assert_0;assert_1;assert_3, violated_assert_2
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False, 'assert_3': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_3'], 'violated_contracts': ['assert_2'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun is_string_and_valid_chars ((v Value)) Bool (ite (is-StrVal v) (str.in.re (sval v) (str.to.re "[A-Za-z ]*")) false))
(define-fun is_nonneg_int ((v Value)) Bool (ite (is-IntVal v) (>= (ival v) 0) false))

; === Inputs ===
(declare-const s Value)
(declare-const n Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal s))
(assert (is-IntVal n))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal s))
(define-fun C1 () Bool (ite (is-StrVal s) (str.in.re (sval s) (str.to.re "[A-Za-z ]*")) false))
(define-fun C2 () Bool (is-IntVal n))
(define-fun C3 () Bool (ite (is-IntVal n) (>= (ival n) 0) false))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 13: satisfied_assert_2;assert_3, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True, 'assert_3': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_2', 'assert_3'], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun is_string_and_valid_chars ((v Value)) Bool (ite (is-StrVal v) (str.in.re (sval v) (str.to.re "[A-Za-z ]*")) false))
(define-fun is_nonneg_int ((v Value)) Bool (ite (is-IntVal v) (>= (ival v) 0) false))

; === Inputs ===
(declare-const s Value)
(declare-const n Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal s))
(assert (is-IntVal n))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal s))
(define-fun C1 () Bool (ite (is-StrVal s) (str.in.re (sval s) (str.to.re "[A-Za-z ]*")) false))
(define-fun C2 () Bool (is-IntVal n))
(define-fun C3 () Bool (ite (is-IntVal n) (>= (ival n) 0) false))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 14: satisfied_assert_0;assert_2;assert_3, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True, 'assert_3': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2', 'assert_3'], 'violated_contracts': ['assert_1'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'s': '[', 'n': 0}
    Solution 2:
      test_case: {'n': 7719, 's': 'A'}
    Solution 3:
      test_case: {'n': 7719, 's': '-'}
    Solution 4:
      test_case: {'n': 10156, 's': 'Z'}
    Solution 5:
      test_case: {'n': 10156, 's': 'a'}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun is_string_and_valid_chars ((v Value)) Bool (ite (is-StrVal v) (str.in.re (sval v) (str.to.re "[A-Za-z ]*")) false))
(define-fun is_nonneg_int ((v Value)) Bool (ite (is-IntVal v) (>= (ival v) 0) false))

; === Inputs ===
(declare-const s Value)
(declare-const n Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal s))
(assert (is-IntVal n))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal s))
(define-fun C1 () Bool (ite (is-StrVal s) (str.in.re (sval s) (str.to.re "[A-Za-z ]*")) false))
(define-fun C2 () Bool (is-IntVal n))
(define-fun C3 () Bool (ite (is-IntVal n) (>= (ival n) 0) false))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 15: satisfied_assert_1;assert_2;assert_3, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True, 'assert_3': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2', 'assert_3'], 'violated_contracts': ['assert_0'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun is_string_and_valid_chars ((v Value)) Bool (ite (is-StrVal v) (str.in.re (sval v) (str.to.re "[A-Za-z ]*")) false))
(define-fun is_nonneg_int ((v Value)) Bool (ite (is-IntVal v) (>= (ival v) 0) false))

; === Inputs ===
(declare-const s Value)
(declare-const n Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal s))
(assert (is-IntVal n))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal s))
(define-fun C1 () Bool (ite (is-StrVal s) (str.in.re (sval s) (str.to.re "[A-Za-z ]*")) false))
(define-fun C2 () Bool (is-IntVal n))
(define-fun C3 () Bool (ite (is-IntVal n) (>= (ival n) 0) false))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 16: satisfied_assert_0;assert_1;assert_2;assert_3, violated_
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True, 'assert_3': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_3'], 'violated_contracts': [], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'s': '[A-Za-z ]*', 'n': 0}
    Solution 2:
      test_case: {'n': 7719, 's': '[A-Za-z ]*'}
    Solution 3:
      test_case: {'n': 10156, 's': '[A-Za-z ]*'}
    Solution 4:
      test_case: {'n': 21953, 's': '[A-Za-z ]*'}
    Solution 5:
      test_case: {'n': 54238, 's': '[A-Za-z ]*'}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun is_string_and_valid_chars ((v Value)) Bool (ite (is-StrVal v) (str.in.re (sval v) (str.to.re "[A-Za-z ]*")) false))
(define-fun is_nonneg_int ((v Value)) Bool (ite (is-IntVal v) (>= (ival v) 0) false))

; === Inputs ===
(declare-const s Value)
(declare-const n Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal s))
(assert (is-IntVal n))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal s))
(define-fun C1 () Bool (ite (is-StrVal s) (str.in.re (sval s) (str.to.re "[A-Za-z ]*")) false))
(define-fun C2 () Bool (is-IntVal n))
(define-fun C3 () Bool (ite (is-IntVal n) (>= (ival n) 0) false))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)
(assert C3)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/118 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun is_letters ((s String)) Bool
  (str.in.re s (str.to.re "[A-Za-z]*")))

; === Inputs ===
(declare-const word Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal word))

; === Contract predicates ===
(define-fun C0 () Bool
  (is-StrVal word))
(define-fun C1 () Bool
  (and (is-StrVal word)
       (or (= (sval word) "")
           (is_letters (sval word)))))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'word': '['}
    Solution 2:
      test_case: {'word': 'A'}
    Solution 3:
      test_case: {'word': '-'}
    Solution 4:
      test_case: {'word': 'Z'}
    Solution 5:
      test_case: {'word': 'a'}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun is_letters ((s String)) Bool
  (str.in.re s (str.to.re "[A-Za-z]*")))

; === Inputs ===
(declare-const word Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal word))

; === Contract predicates ===
(define-fun C0 () Bool
  (is-StrVal word))
(define-fun C1 () Bool
  (and (is-StrVal word)
       (or (= (sval word) "")
           (is_letters (sval word)))))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun is_letters ((s String)) Bool
  (str.in.re s (str.to.re "[A-Za-z]*")))

; === Inputs ===
(declare-const word Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal word))

; === Contract predicates ===
(define-fun C0 () Bool
  (is-StrVal word))
(define-fun C1 () Bool
  (and (is-StrVal word)
       (or (= (sval word) "")
           (is_letters (sval word)))))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 2
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'word': ''}
    Solution 2:
      test_case: {'word': '[A-Za-z]*'}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun is_letters ((s String)) Bool
  (str.in.re s (str.to.re "[A-Za-z]*")))

; === Inputs ===
(declare-const word Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal word))

; === Contract predicates ===
(define-fun C0 () Bool
  (is-StrVal word))
(define-fun C1 () Bool
  (and (is-StrVal word)
       (or (= (sval word) "")
           (is_letters (sval word)))))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/119 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1;assert_2;assert_3;assert_4
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False, 'assert_3': False, 'assert_4': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_3', 'assert_4'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v) (isList (tail v)))))

(define-fun-rec list_all_str ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (is-StrVal (head v))
           (list_all_str (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))

(define-fun SafeS ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (isList lst))

; === Contract predicates ===
(define-fun C0 () Bool (isList lst))
(define-fun C1 () Bool (list_all_str lst))
(define-fun C2 () Bool (= (length lst) 2))
(define-fun C3 () Bool
  (let ((str0 (SafeS (head lst))))
    (str.in.re str0 (str.to.re "[()]*"))))
(define-fun C4 () Bool
  (let ((str1 (SafeS (head (tail lst)))))
    (str.in.re str1 (str.to.re "[()]*"))))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))
(assert (not C3))
(assert (not C4))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1;assert_2;assert_3;assert_4
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False, 'assert_3': False, 'assert_4': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1', 'assert_2', 'assert_3', 'assert_4'], 'total_contracts': 5}
  Solutions:
    Solution 1:
      test_case: {'lst': [3.0]}
    Solution 2:
      test_case: {'lst': [2.0]}
    Solution 3:
      test_case: {'lst': [4.0]}
    Solution 4:
      test_case: {'lst': [5.0]}
    Solution 5:
      test_case: {'lst': [6.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v) (isList (tail v)))))

(define-fun-rec list_all_str ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (is-StrVal (head v))
           (list_all_str (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))

(define-fun SafeS ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (isList lst))

; === Contract predicates ===
(define-fun C0 () Bool (isList lst))
(define-fun C1 () Bool (list_all_str lst))
(define-fun C2 () Bool (= (length lst) 2))
(define-fun C3 () Bool
  (let ((str0 (SafeS (head lst))))
    (str.in.re str0 (str.to.re "[()]*"))))
(define-fun C4 () Bool
  (let ((str1 (SafeS (head (tail lst)))))
    (str.in.re str1 (str.to.re "[()]*"))))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))
(assert (not C3))
(assert (not C4))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0;assert_2;assert_3;assert_4
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False, 'assert_3': False, 'assert_4': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0', 'assert_2', 'assert_3', 'assert_4'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v) (isList (tail v)))))

(define-fun-rec list_all_str ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (is-StrVal (head v))
           (list_all_str (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))

(define-fun SafeS ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (isList lst))

; === Contract predicates ===
(define-fun C0 () Bool (isList lst))
(define-fun C1 () Bool (list_all_str lst))
(define-fun C2 () Bool (= (length lst) 2))
(define-fun C3 () Bool
  (let ((str0 (SafeS (head lst))))
    (str.in.re str0 (str.to.re "[()]*"))))
(define-fun C4 () Bool
  (let ((str1 (SafeS (head (tail lst)))))
    (str.in.re str1 (str.to.re "[()]*"))))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))
(assert (not C3))
(assert (not C4))

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_assert_2;assert_3;assert_4
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False, 'assert_3': False, 'assert_4': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': ['assert_2', 'assert_3', 'assert_4'], 'total_contracts': 5}
  Solutions:
    Solution 1:
      test_case: {'lst': []}
    Solution 2:
      test_case: {'lst': ['A']}
    Solution 3:
      test_case: {'lst': ['']}
    Solution 4:
      test_case: {'lst': ['B']}
    Solution 5:
      test_case: {'lst': ['C']}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v) (isList (tail v)))))

(define-fun-rec list_all_str ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (is-StrVal (head v))
           (list_all_str (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))

(define-fun SafeS ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (isList lst))

; === Contract predicates ===
(define-fun C0 () Bool (isList lst))
(define-fun C1 () Bool (list_all_str lst))
(define-fun C2 () Bool (= (length lst) 2))
(define-fun C3 () Bool
  (let ((str0 (SafeS (head lst))))
    (str.in.re str0 (str.to.re "[()]*"))))
(define-fun C4 () Bool
  (let ((str1 (SafeS (head (tail lst)))))
    (str.in.re str1 (str.to.re "[()]*"))))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))
(assert (not C3))
(assert (not C4))

(check-sat)
(get-model)

------------------------------
  Test Case 5: satisfied_assert_2, violated_assert_0;assert_1;assert_3;assert_4
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True, 'assert_3': False, 'assert_4': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_2'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_3', 'assert_4'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v) (isList (tail v)))))

(define-fun-rec list_all_str ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (is-StrVal (head v))
           (list_all_str (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))

(define-fun SafeS ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (isList lst))

; === Contract predicates ===
(define-fun C0 () Bool (isList lst))
(define-fun C1 () Bool (list_all_str lst))
(define-fun C2 () Bool (= (length lst) 2))
(define-fun C3 () Bool
  (let ((str0 (SafeS (head lst))))
    (str.in.re str0 (str.to.re "[()]*"))))
(define-fun C4 () Bool
  (let ((str1 (SafeS (head (tail lst)))))
    (str.in.re str1 (str.to.re "[()]*"))))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)
(assert (not C3))
(assert (not C4))

(check-sat)
(get-model)

------------------------------
  Test Case 6: satisfied_assert_0;assert_2, violated_assert_1;assert_3;assert_4
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True, 'assert_3': False, 'assert_4': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2'], 'violated_contracts': ['assert_1', 'assert_3', 'assert_4'], 'total_contracts': 5}
  Solutions:
    Solution 1:
      test_case: {'lst': [2.0, 3.0]}
    Solution 2:
      test_case: {'lst': [5.0, 4.0]}
    Solution 3:
      test_case: {'lst': [6.0, 7.0]}
    Solution 4:
      test_case: {'lst': [9.0, 8.0]}
    Solution 5:
      test_case: {'lst': [11.0, 10.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v) (isList (tail v)))))

(define-fun-rec list_all_str ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (is-StrVal (head v))
           (list_all_str (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))

(define-fun SafeS ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (isList lst))

; === Contract predicates ===
(define-fun C0 () Bool (isList lst))
(define-fun C1 () Bool (list_all_str lst))
(define-fun C2 () Bool (= (length lst) 2))
(define-fun C3 () Bool
  (let ((str0 (SafeS (head lst))))
    (str.in.re str0 (str.to.re "[()]*"))))
(define-fun C4 () Bool
  (let ((str1 (SafeS (head (tail lst)))))
    (str.in.re str1 (str.to.re "[()]*"))))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)
(assert (not C3))
(assert (not C4))

(check-sat)
(get-model)

------------------------------
  Test Case 7: satisfied_assert_1;assert_2, violated_assert_0;assert_3;assert_4
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True, 'assert_3': False, 'assert_4': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2'], 'violated_contracts': ['assert_0', 'assert_3', 'assert_4'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v) (isList (tail v)))))

(define-fun-rec list_all_str ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (is-StrVal (head v))
           (list_all_str (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))

(define-fun SafeS ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (isList lst))

; === Contract predicates ===
(define-fun C0 () Bool (isList lst))
(define-fun C1 () Bool (list_all_str lst))
(define-fun C2 () Bool (= (length lst) 2))
(define-fun C3 () Bool
  (let ((str0 (SafeS (head lst))))
    (str.in.re str0 (str.to.re "[()]*"))))
(define-fun C4 () Bool
  (let ((str1 (SafeS (head (tail lst)))))
    (str.in.re str1 (str.to.re "[()]*"))))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)
(assert (not C3))
(assert (not C4))

(check-sat)
(get-model)

------------------------------
  Test Case 8: satisfied_assert_0;assert_1;assert_2, violated_assert_3;assert_4
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True, 'assert_3': False, 'assert_4': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2'], 'violated_contracts': ['assert_3', 'assert_4'], 'total_contracts': 5}
  Solutions:
    Solution 1:
      test_case: {'lst': ['[', '(']}
    Solution 2:
      test_case: {'lst': ['[', '[']}
    Solution 3:
      test_case: {'lst': ['(', '']}
    Solution 4:
      test_case: {'lst': ['', '']}
    Solution 5:
      test_case: {'lst': ['', '[']}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v) (isList (tail v)))))

(define-fun-rec list_all_str ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (is-StrVal (head v))
           (list_all_str (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))

(define-fun SafeS ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (isList lst))

; === Contract predicates ===
(define-fun C0 () Bool (isList lst))
(define-fun C1 () Bool (list_all_str lst))
(define-fun C2 () Bool (= (length lst) 2))
(define-fun C3 () Bool
  (let ((str0 (SafeS (head lst))))
    (str.in.re str0 (str.to.re "[()]*"))))
(define-fun C4 () Bool
  (let ((str1 (SafeS (head (tail lst)))))
    (str.in.re str1 (str.to.re "[()]*"))))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)
(assert (not C3))
(assert (not C4))

(check-sat)
(get-model)

------------------------------
  Test Case 9: satisfied_assert_3, violated_assert_0;assert_1;assert_2;assert_4
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False, 'assert_3': True, 'assert_4': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_3'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_4'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v) (isList (tail v)))))

(define-fun-rec list_all_str ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (is-StrVal (head v))
           (list_all_str (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))

(define-fun SafeS ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (isList lst))

; === Contract predicates ===
(define-fun C0 () Bool (isList lst))
(define-fun C1 () Bool (list_all_str lst))
(define-fun C2 () Bool (= (length lst) 2))
(define-fun C3 () Bool
  (let ((str0 (SafeS (head lst))))
    (str.in.re str0 (str.to.re "[()]*"))))
(define-fun C4 () Bool
  (let ((str1 (SafeS (head (tail lst)))))
    (str.in.re str1 (str.to.re "[()]*"))))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))
(assert C3)
(assert (not C4))

(check-sat)
(get-model)

------------------------------
  Test Case 10: satisfied_assert_0;assert_3, violated_assert_1;assert_2;assert_4
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False, 'assert_3': True, 'assert_4': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_3'], 'violated_contracts': ['assert_1', 'assert_2', 'assert_4'], 'total_contracts': 5}
  Solutions:
    Solution 1:
      test_case: {'lst': ['[()]*', 2.0, 3.0]}
    Solution 2:
      test_case: {'lst': ['[()]*', '[', 5.0]}
    Solution 3:
      test_case: {'lst': ['[()]*', 6.0, 4.0]}
    Solution 4:
      test_case: {'lst': ['[()]*', 7.0, 8.0]}
    Solution 5:
      test_case: {'lst': ['[()]*', 9.0, 10.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v) (isList (tail v)))))

(define-fun-rec list_all_str ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (is-StrVal (head v))
           (list_all_str (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))

(define-fun SafeS ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (isList lst))

; === Contract predicates ===
(define-fun C0 () Bool (isList lst))
(define-fun C1 () Bool (list_all_str lst))
(define-fun C2 () Bool (= (length lst) 2))
(define-fun C3 () Bool
  (let ((str0 (SafeS (head lst))))
    (str.in.re str0 (str.to.re "[()]*"))))
(define-fun C4 () Bool
  (let ((str1 (SafeS (head (tail lst)))))
    (str.in.re str1 (str.to.re "[()]*"))))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))
(assert C3)
(assert (not C4))

(check-sat)
(get-model)

------------------------------
  Test Case 11: satisfied_assert_1;assert_3, violated_assert_0;assert_2;assert_4
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False, 'assert_3': True, 'assert_4': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_3'], 'violated_contracts': ['assert_0', 'assert_2', 'assert_4'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v) (isList (tail v)))))

(define-fun-rec list_all_str ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (is-StrVal (head v))
           (list_all_str (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))

(define-fun SafeS ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (isList lst))

; === Contract predicates ===
(define-fun C0 () Bool (isList lst))
(define-fun C1 () Bool (list_all_str lst))
(define-fun C2 () Bool (= (length lst) 2))
(define-fun C3 () Bool
  (let ((str0 (SafeS (head lst))))
    (str.in.re str0 (str.to.re "[()]*"))))
(define-fun C4 () Bool
  (let ((str1 (SafeS (head (tail lst)))))
    (str.in.re str1 (str.to.re "[()]*"))))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))
(assert C3)
(assert (not C4))

(check-sat)
(get-model)

------------------------------
  Test Case 12: satisfied_assert_0;assert_1;assert_3, violated_assert_2;assert_4
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False, 'assert_3': True, 'assert_4': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_3'], 'violated_contracts': ['assert_2', 'assert_4'], 'total_contracts': 5}
  Solutions:
    Solution 1:
      test_case: {'lst': []}
    Solution 2:
      test_case: {'lst': ['[()]*']}
    Solution 3:
      test_case: {'lst': ['[()]*', '', '[']}
    Solution 4:
      test_case: {'lst': ['[()]*', '', '']}
    Solution 5:
      test_case: {'lst': ['[()]*', 'A', '']}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v) (isList (tail v)))))

(define-fun-rec list_all_str ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (is-StrVal (head v))
           (list_all_str (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))

(define-fun SafeS ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (isList lst))

; === Contract predicates ===
(define-fun C0 () Bool (isList lst))
(define-fun C1 () Bool (list_all_str lst))
(define-fun C2 () Bool (= (length lst) 2))
(define-fun C3 () Bool
  (let ((str0 (SafeS (head lst))))
    (str.in.re str0 (str.to.re "[()]*"))))
(define-fun C4 () Bool
  (let ((str1 (SafeS (head (tail lst)))))
    (str.in.re str1 (str.to.re "[()]*"))))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))
(assert C3)
(assert (not C4))

(check-sat)
(get-model)

------------------------------
  Test Case 13: satisfied_assert_2;assert_3, violated_assert_0;assert_1;assert_4
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True, 'assert_3': True, 'assert_4': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_2', 'assert_3'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_4'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v) (isList (tail v)))))

(define-fun-rec list_all_str ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (is-StrVal (head v))
           (list_all_str (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))

(define-fun SafeS ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (isList lst))

; === Contract predicates ===
(define-fun C0 () Bool (isList lst))
(define-fun C1 () Bool (list_all_str lst))
(define-fun C2 () Bool (= (length lst) 2))
(define-fun C3 () Bool
  (let ((str0 (SafeS (head lst))))
    (str.in.re str0 (str.to.re "[()]*"))))
(define-fun C4 () Bool
  (let ((str1 (SafeS (head (tail lst)))))
    (str.in.re str1 (str.to.re "[()]*"))))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)
(assert C3)
(assert (not C4))

(check-sat)
(get-model)

------------------------------
  Test Case 14: satisfied_assert_0;assert_2;assert_3, violated_assert_1;assert_4
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True, 'assert_3': True, 'assert_4': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2', 'assert_3'], 'violated_contracts': ['assert_1', 'assert_4'], 'total_contracts': 5}
  Solutions:
    Solution 1:
      test_case: {'lst': ['[()]*', 2.0]}
    Solution 2:
      test_case: {'lst': ['[()]*', 4.0]}
    Solution 3:
      test_case: {'lst': ['[()]*', 3.0]}
    Solution 4:
      test_case: {'lst': ['[()]*', 5.0]}
    Solution 5:
      test_case: {'lst': ['[()]*', 6.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v) (isList (tail v)))))

(define-fun-rec list_all_str ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (is-StrVal (head v))
           (list_all_str (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))

(define-fun SafeS ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (isList lst))

; === Contract predicates ===
(define-fun C0 () Bool (isList lst))
(define-fun C1 () Bool (list_all_str lst))
(define-fun C2 () Bool (= (length lst) 2))
(define-fun C3 () Bool
  (let ((str0 (SafeS (head lst))))
    (str.in.re str0 (str.to.re "[()]*"))))
(define-fun C4 () Bool
  (let ((str1 (SafeS (head (tail lst)))))
    (str.in.re str1 (str.to.re "[()]*"))))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)
(assert C3)
(assert (not C4))

(check-sat)
(get-model)

------------------------------
  Test Case 15: satisfied_assert_1;assert_2;assert_3, violated_assert_0;assert_4
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True, 'assert_3': True, 'assert_4': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2', 'assert_3'], 'violated_contracts': ['assert_0', 'assert_4'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v) (isList (tail v)))))

(define-fun-rec list_all_str ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (is-StrVal (head v))
           (list_all_str (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))

(define-fun SafeS ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (isList lst))

; === Contract predicates ===
(define-fun C0 () Bool (isList lst))
(define-fun C1 () Bool (list_all_str lst))
(define-fun C2 () Bool (= (length lst) 2))
(define-fun C3 () Bool
  (let ((str0 (SafeS (head lst))))
    (str.in.re str0 (str.to.re "[()]*"))))
(define-fun C4 () Bool
  (let ((str1 (SafeS (head (tail lst)))))
    (str.in.re str1 (str.to.re "[()]*"))))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)
(assert C3)
(assert (not C4))

(check-sat)
(get-model)

------------------------------
  Test Case 16: satisfied_assert_0;assert_1;assert_2;assert_3, violated_assert_4
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True, 'assert_3': True, 'assert_4': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_3'], 'violated_contracts': ['assert_4'], 'total_contracts': 5}
  Solutions:
    Solution 1:
      test_case: {'lst': ['[()]*', '[']}
    Solution 2:
      test_case: {'lst': ['[()]*', '(']}
    Solution 3:
      test_case: {'lst': ['[()]*', '']}
    Solution 4:
      test_case: {'lst': ['[()]*', 'A']}
    Solution 5:
      test_case: {'lst': ['[()]*', 'B']}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v) (isList (tail v)))))

(define-fun-rec list_all_str ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (is-StrVal (head v))
           (list_all_str (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))

(define-fun SafeS ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (isList lst))

; === Contract predicates ===
(define-fun C0 () Bool (isList lst))
(define-fun C1 () Bool (list_all_str lst))
(define-fun C2 () Bool (= (length lst) 2))
(define-fun C3 () Bool
  (let ((str0 (SafeS (head lst))))
    (str.in.re str0 (str.to.re "[()]*"))))
(define-fun C4 () Bool
  (let ((str1 (SafeS (head (tail lst)))))
    (str.in.re str1 (str.to.re "[()]*"))))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)
(assert C3)
(assert (not C4))

(check-sat)
(get-model)

------------------------------
  Test Case 17: satisfied_assert_4, violated_assert_0;assert_1;assert_2;assert_3
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False, 'assert_3': False, 'assert_4': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_4'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_3'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v) (isList (tail v)))))

(define-fun-rec list_all_str ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (is-StrVal (head v))
           (list_all_str (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))

(define-fun SafeS ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (isList lst))

; === Contract predicates ===
(define-fun C0 () Bool (isList lst))
(define-fun C1 () Bool (list_all_str lst))
(define-fun C2 () Bool (= (length lst) 2))
(define-fun C3 () Bool
  (let ((str0 (SafeS (head lst))))
    (str.in.re str0 (str.to.re "[()]*"))))
(define-fun C4 () Bool
  (let ((str1 (SafeS (head (tail lst)))))
    (str.in.re str1 (str.to.re "[()]*"))))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))
(assert (not C3))
(assert C4)

(check-sat)
(get-model)

------------------------------
  Test Case 18: satisfied_assert_0;assert_4, violated_assert_1;assert_2;assert_3
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False, 'assert_3': False, 'assert_4': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_4'], 'violated_contracts': ['assert_1', 'assert_2', 'assert_3'], 'total_contracts': 5}
  Solutions:
    Solution 1:
      test_case: {'lst': [2.0]}
    Solution 2:
      test_case: {'lst': [3.0]}
    Solution 3:
      test_case: {'lst': [4.0]}
    Solution 4:
      test_case: {'lst': [5.0]}
    Solution 5:
      test_case: {'lst': [6.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v) (isList (tail v)))))

(define-fun-rec list_all_str ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (is-StrVal (head v))
           (list_all_str (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))

(define-fun SafeS ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (isList lst))

; === Contract predicates ===
(define-fun C0 () Bool (isList lst))
(define-fun C1 () Bool (list_all_str lst))
(define-fun C2 () Bool (= (length lst) 2))
(define-fun C3 () Bool
  (let ((str0 (SafeS (head lst))))
    (str.in.re str0 (str.to.re "[()]*"))))
(define-fun C4 () Bool
  (let ((str1 (SafeS (head (tail lst)))))
    (str.in.re str1 (str.to.re "[()]*"))))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))
(assert (not C3))
(assert C4)

(check-sat)
(get-model)

------------------------------
  Test Case 19: satisfied_assert_1;assert_4, violated_assert_0;assert_2;assert_3
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False, 'assert_3': False, 'assert_4': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_4'], 'violated_contracts': ['assert_0', 'assert_2', 'assert_3'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v) (isList (tail v)))))

(define-fun-rec list_all_str ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (is-StrVal (head v))
           (list_all_str (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))

(define-fun SafeS ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (isList lst))

; === Contract predicates ===
(define-fun C0 () Bool (isList lst))
(define-fun C1 () Bool (list_all_str lst))
(define-fun C2 () Bool (= (length lst) 2))
(define-fun C3 () Bool
  (let ((str0 (SafeS (head lst))))
    (str.in.re str0 (str.to.re "[()]*"))))
(define-fun C4 () Bool
  (let ((str1 (SafeS (head (tail lst)))))
    (str.in.re str1 (str.to.re "[()]*"))))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))
(assert (not C3))
(assert C4)

(check-sat)
(get-model)

------------------------------
  Test Case 20: satisfied_assert_0;assert_1;assert_4, violated_assert_2;assert_3
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False, 'assert_3': False, 'assert_4': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_4'], 'violated_contracts': ['assert_2', 'assert_3'], 'total_contracts': 5}
  Solutions:
    Solution 1:
      test_case: {'lst': []}
    Solution 2:
      test_case: {'lst': ['A']}
    Solution 3:
      test_case: {'lst': ['']}
    Solution 4:
      test_case: {'lst': ['[']}
    Solution 5:
      test_case: {'lst': ['B']}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v) (isList (tail v)))))

(define-fun-rec list_all_str ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (is-StrVal (head v))
           (list_all_str (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))

(define-fun SafeS ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (isList lst))

; === Contract predicates ===
(define-fun C0 () Bool (isList lst))
(define-fun C1 () Bool (list_all_str lst))
(define-fun C2 () Bool (= (length lst) 2))
(define-fun C3 () Bool
  (let ((str0 (SafeS (head lst))))
    (str.in.re str0 (str.to.re "[()]*"))))
(define-fun C4 () Bool
  (let ((str1 (SafeS (head (tail lst)))))
    (str.in.re str1 (str.to.re "[()]*"))))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))
(assert (not C3))
(assert C4)

(check-sat)
(get-model)

------------------------------
  Test Case 21: satisfied_assert_2;assert_4, violated_assert_0;assert_1;assert_3
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True, 'assert_3': False, 'assert_4': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_2', 'assert_4'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_3'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v) (isList (tail v)))))

(define-fun-rec list_all_str ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (is-StrVal (head v))
           (list_all_str (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))

(define-fun SafeS ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (isList lst))

; === Contract predicates ===
(define-fun C0 () Bool (isList lst))
(define-fun C1 () Bool (list_all_str lst))
(define-fun C2 () Bool (= (length lst) 2))
(define-fun C3 () Bool
  (let ((str0 (SafeS (head lst))))
    (str.in.re str0 (str.to.re "[()]*"))))
(define-fun C4 () Bool
  (let ((str1 (SafeS (head (tail lst)))))
    (str.in.re str1 (str.to.re "[()]*"))))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)
(assert (not C3))
(assert C4)

(check-sat)
(get-model)

------------------------------
  Test Case 22: satisfied_assert_0;assert_2;assert_4, violated_assert_1;assert_3
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True, 'assert_3': False, 'assert_4': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2', 'assert_4'], 'violated_contracts': ['assert_1', 'assert_3'], 'total_contracts': 5}
  Solutions:
    Solution 1:
      test_case: {'lst': [4.0, '[()]*']}
    Solution 2:
      test_case: {'lst': [2.0, '[()]*']}
    Solution 3:
      test_case: {'lst': [5.0, '[()]*']}
    Solution 4:
      test_case: {'lst': [6.0, '[()]*']}
    Solution 5:
      test_case: {'lst': [7.0, '[()]*']}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v) (isList (tail v)))))

(define-fun-rec list_all_str ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (is-StrVal (head v))
           (list_all_str (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))

(define-fun SafeS ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (isList lst))

; === Contract predicates ===
(define-fun C0 () Bool (isList lst))
(define-fun C1 () Bool (list_all_str lst))
(define-fun C2 () Bool (= (length lst) 2))
(define-fun C3 () Bool
  (let ((str0 (SafeS (head lst))))
    (str.in.re str0 (str.to.re "[()]*"))))
(define-fun C4 () Bool
  (let ((str1 (SafeS (head (tail lst)))))
    (str.in.re str1 (str.to.re "[()]*"))))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)
(assert (not C3))
(assert C4)

(check-sat)
(get-model)

------------------------------
  Test Case 23: satisfied_assert_1;assert_2;assert_4, violated_assert_0;assert_3
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True, 'assert_3': False, 'assert_4': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2', 'assert_4'], 'violated_contracts': ['assert_0', 'assert_3'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v) (isList (tail v)))))

(define-fun-rec list_all_str ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (is-StrVal (head v))
           (list_all_str (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))

(define-fun SafeS ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (isList lst))

; === Contract predicates ===
(define-fun C0 () Bool (isList lst))
(define-fun C1 () Bool (list_all_str lst))
(define-fun C2 () Bool (= (length lst) 2))
(define-fun C3 () Bool
  (let ((str0 (SafeS (head lst))))
    (str.in.re str0 (str.to.re "[()]*"))))
(define-fun C4 () Bool
  (let ((str1 (SafeS (head (tail lst)))))
    (str.in.re str1 (str.to.re "[()]*"))))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)
(assert (not C3))
(assert C4)

(check-sat)
(get-model)

------------------------------
  Test Case 24: satisfied_assert_0;assert_1;assert_2;assert_4, violated_assert_3
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True, 'assert_3': False, 'assert_4': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_4'], 'violated_contracts': ['assert_3'], 'total_contracts': 5}
  Solutions:
    Solution 1:
      test_case: {'lst': ['[', '[()]*']}
    Solution 2:
      test_case: {'lst': ['(', '[()]*']}
    Solution 3:
      test_case: {'lst': ['', '[()]*']}
    Solution 4:
      test_case: {'lst': ['A', '[()]*']}
    Solution 5:
      test_case: {'lst': ['B', '[()]*']}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v) (isList (tail v)))))

(define-fun-rec list_all_str ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (is-StrVal (head v))
           (list_all_str (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))

(define-fun SafeS ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (isList lst))

; === Contract predicates ===
(define-fun C0 () Bool (isList lst))
(define-fun C1 () Bool (list_all_str lst))
(define-fun C2 () Bool (= (length lst) 2))
(define-fun C3 () Bool
  (let ((str0 (SafeS (head lst))))
    (str.in.re str0 (str.to.re "[()]*"))))
(define-fun C4 () Bool
  (let ((str1 (SafeS (head (tail lst)))))
    (str.in.re str1 (str.to.re "[()]*"))))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)
(assert (not C3))
(assert C4)

(check-sat)
(get-model)

------------------------------
  Test Case 25: satisfied_assert_3;assert_4, violated_assert_0;assert_1;assert_2
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False, 'assert_3': True, 'assert_4': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_3', 'assert_4'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v) (isList (tail v)))))

(define-fun-rec list_all_str ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (is-StrVal (head v))
           (list_all_str (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))

(define-fun SafeS ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (isList lst))

; === Contract predicates ===
(define-fun C0 () Bool (isList lst))
(define-fun C1 () Bool (list_all_str lst))
(define-fun C2 () Bool (= (length lst) 2))
(define-fun C3 () Bool
  (let ((str0 (SafeS (head lst))))
    (str.in.re str0 (str.to.re "[()]*"))))
(define-fun C4 () Bool
  (let ((str1 (SafeS (head (tail lst)))))
    (str.in.re str1 (str.to.re "[()]*"))))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))
(assert C3)
(assert C4)

(check-sat)
(get-model)

------------------------------
  Test Case 26: satisfied_assert_0;assert_3;assert_4, violated_assert_1;assert_2
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False, 'assert_3': True, 'assert_4': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_3', 'assert_4'], 'violated_contracts': ['assert_1', 'assert_2'], 'total_contracts': 5}
  Solutions:
    Solution 1:
      test_case: {'lst': ['[()]*', '[()]*', 3.0]}
    Solution 2:
      test_case: {'lst': ['[()]*', '[()]*', 2.0]}
    Solution 3:
      test_case: {'lst': ['[()]*', '[()]*', 4.0]}
    Solution 4:
      test_case: {'lst': ['[()]*', '[()]*', 5.0]}
    Solution 5:
      test_case: {'lst': ['[()]*', '[()]*', 6.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v) (isList (tail v)))))

(define-fun-rec list_all_str ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (is-StrVal (head v))
           (list_all_str (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))

(define-fun SafeS ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (isList lst))

; === Contract predicates ===
(define-fun C0 () Bool (isList lst))
(define-fun C1 () Bool (list_all_str lst))
(define-fun C2 () Bool (= (length lst) 2))
(define-fun C3 () Bool
  (let ((str0 (SafeS (head lst))))
    (str.in.re str0 (str.to.re "[()]*"))))
(define-fun C4 () Bool
  (let ((str1 (SafeS (head (tail lst)))))
    (str.in.re str1 (str.to.re "[()]*"))))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))
(assert C3)
(assert C4)

(check-sat)
(get-model)

------------------------------
  Test Case 27: satisfied_assert_1;assert_3;assert_4, violated_assert_0;assert_2
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False, 'assert_3': True, 'assert_4': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_3', 'assert_4'], 'violated_contracts': ['assert_0', 'assert_2'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v) (isList (tail v)))))

(define-fun-rec list_all_str ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (is-StrVal (head v))
           (list_all_str (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))

(define-fun SafeS ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (isList lst))

; === Contract predicates ===
(define-fun C0 () Bool (isList lst))
(define-fun C1 () Bool (list_all_str lst))
(define-fun C2 () Bool (= (length lst) 2))
(define-fun C3 () Bool
  (let ((str0 (SafeS (head lst))))
    (str.in.re str0 (str.to.re "[()]*"))))
(define-fun C4 () Bool
  (let ((str1 (SafeS (head (tail lst)))))
    (str.in.re str1 (str.to.re "[()]*"))))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))
(assert C3)
(assert C4)

(check-sat)
(get-model)

------------------------------
  Test Case 28: satisfied_assert_0;assert_1;assert_3;assert_4, violated_assert_2
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False, 'assert_3': True, 'assert_4': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_3', 'assert_4'], 'violated_contracts': ['assert_2'], 'total_contracts': 5}
  Solutions:
    Solution 1:
      test_case: {'lst': []}
    Solution 2:
      test_case: {'lst': ['[()]*']}
    Solution 3:
      test_case: {'lst': ['[()]*', '[()]*', '']}
    Solution 4:
      test_case: {'lst': ['[()]*', '[()]*', '[']}
    Solution 5:
      test_case: {'lst': ['[()]*', '[()]*', '(']}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v) (isList (tail v)))))

(define-fun-rec list_all_str ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (is-StrVal (head v))
           (list_all_str (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))

(define-fun SafeS ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (isList lst))

; === Contract predicates ===
(define-fun C0 () Bool (isList lst))
(define-fun C1 () Bool (list_all_str lst))
(define-fun C2 () Bool (= (length lst) 2))
(define-fun C3 () Bool
  (let ((str0 (SafeS (head lst))))
    (str.in.re str0 (str.to.re "[()]*"))))
(define-fun C4 () Bool
  (let ((str1 (SafeS (head (tail lst)))))
    (str.in.re str1 (str.to.re "[()]*"))))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))
(assert C3)
(assert C4)

(check-sat)
(get-model)

------------------------------
  Test Case 29: satisfied_assert_2;assert_3;assert_4, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True, 'assert_3': True, 'assert_4': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_2', 'assert_3', 'assert_4'], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v) (isList (tail v)))))

(define-fun-rec list_all_str ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (is-StrVal (head v))
           (list_all_str (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))

(define-fun SafeS ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (isList lst))

; === Contract predicates ===
(define-fun C0 () Bool (isList lst))
(define-fun C1 () Bool (list_all_str lst))
(define-fun C2 () Bool (= (length lst) 2))
(define-fun C3 () Bool
  (let ((str0 (SafeS (head lst))))
    (str.in.re str0 (str.to.re "[()]*"))))
(define-fun C4 () Bool
  (let ((str1 (SafeS (head (tail lst)))))
    (str.in.re str1 (str.to.re "[()]*"))))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)
(assert C3)
(assert C4)

(check-sat)
(get-model)

------------------------------
  Test Case 30: satisfied_assert_0;assert_2;assert_3;assert_4, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True, 'assert_3': True, 'assert_4': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2', 'assert_3', 'assert_4'], 'violated_contracts': ['assert_1'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v) (isList (tail v)))))

(define-fun-rec list_all_str ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (is-StrVal (head v))
           (list_all_str (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))

(define-fun SafeS ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (isList lst))

; === Contract predicates ===
(define-fun C0 () Bool (isList lst))
(define-fun C1 () Bool (list_all_str lst))
(define-fun C2 () Bool (= (length lst) 2))
(define-fun C3 () Bool
  (let ((str0 (SafeS (head lst))))
    (str.in.re str0 (str.to.re "[()]*"))))
(define-fun C4 () Bool
  (let ((str1 (SafeS (head (tail lst)))))
    (str.in.re str1 (str.to.re "[()]*"))))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)
(assert C3)
(assert C4)

(check-sat)
(get-model)

------------------------------
  Test Case 31: satisfied_assert_1;assert_2;assert_3;assert_4, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True, 'assert_3': True, 'assert_4': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2', 'assert_3', 'assert_4'], 'violated_contracts': ['assert_0'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v) (isList (tail v)))))

(define-fun-rec list_all_str ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (is-StrVal (head v))
           (list_all_str (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))

(define-fun SafeS ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (isList lst))

; === Contract predicates ===
(define-fun C0 () Bool (isList lst))
(define-fun C1 () Bool (list_all_str lst))
(define-fun C2 () Bool (= (length lst) 2))
(define-fun C3 () Bool
  (let ((str0 (SafeS (head lst))))
    (str.in.re str0 (str.to.re "[()]*"))))
(define-fun C4 () Bool
  (let ((str1 (SafeS (head (tail lst)))))
    (str.in.re str1 (str.to.re "[()]*"))))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)
(assert C3)
(assert C4)

(check-sat)
(get-model)

------------------------------
  Test Case 32: satisfied_assert_0;assert_1;assert_2;assert_3;assert_4, violated_
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True, 'assert_3': True, 'assert_4': True}
  Satisfiable: True
  Solution Count: 1
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_3', 'assert_4'], 'violated_contracts': [], 'total_contracts': 5}
  Solutions:
    Solution 1:
      test_case: {'lst': ['[()]*', '[()]*']}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec isList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v) (isList (tail v)))))

(define-fun-rec list_all_str ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (is-StrVal (head v))
           (list_all_str (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))

(define-fun SafeS ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (isList lst))

; === Contract predicates ===
(define-fun C0 () Bool (isList lst))
(define-fun C1 () Bool (list_all_str lst))
(define-fun C2 () Bool (= (length lst) 2))
(define-fun C3 () Bool
  (let ((str0 (SafeS (head lst))))
    (str.in.re str0 (str.to.re "[()]*"))))
(define-fun C4 () Bool
  (let ((str1 (SafeS (head (tail lst)))))
    (str.in.re str1 (str.to.re "[()]*"))))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)
(assert C3)
(assert C4)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/120 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1;assert_2;assert_3;assert_4
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False, 'assert_3': False, 'assert_4': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_3', 'assert_4'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (IsList (tail v))
      false)))

(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

(define-fun-rec length ((xs Value)) Int
  (ite (is-Nil xs) 0
    (ite (is-Cons xs)
      (+ 1 (length (tail xs)))
      0)))

(define-fun-rec all_in_range ((xs Value)) Bool
  (ite (is-Nil xs) true
    (ite (and (is-Cons xs)
              (is-IntVal (head xs))
              (let ((i (ival (head xs))))
                (and (<= (- 1000) i) (<= i 1000))))
      (all_in_range (tail xs))
      false)))

; === Inputs ===
(declare-const arr Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))
(assert (is-IntVal k))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (and (<= 1 (length arr)) (<= (length arr) 1000)))
(define-fun C2 () Bool (all_in_range arr))
(define-fun C3 () Bool (is-IntVal k))
(define-fun C4 () Bool (and (<= 0 (SafeI k)) (<= (SafeI k) (length arr))))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))
(assert (not C3))
(assert (not C4))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1;assert_2;assert_3;assert_4
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False, 'assert_3': False, 'assert_4': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1', 'assert_2', 'assert_3', 'assert_4'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (IsList (tail v))
      false)))

(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

(define-fun-rec length ((xs Value)) Int
  (ite (is-Nil xs) 0
    (ite (is-Cons xs)
      (+ 1 (length (tail xs)))
      0)))

(define-fun-rec all_in_range ((xs Value)) Bool
  (ite (is-Nil xs) true
    (ite (and (is-Cons xs)
              (is-IntVal (head xs))
              (let ((i (ival (head xs))))
                (and (<= (- 1000) i) (<= i 1000))))
      (all_in_range (tail xs))
      false)))

; === Inputs ===
(declare-const arr Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))
(assert (is-IntVal k))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (and (<= 1 (length arr)) (<= (length arr) 1000)))
(define-fun C2 () Bool (all_in_range arr))
(define-fun C3 () Bool (is-IntVal k))
(define-fun C4 () Bool (and (<= 0 (SafeI k)) (<= (SafeI k) (length arr))))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))
(assert (not C3))
(assert (not C4))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0;assert_2;assert_3;assert_4
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False, 'assert_3': False, 'assert_4': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0', 'assert_2', 'assert_3', 'assert_4'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (IsList (tail v))
      false)))

(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

(define-fun-rec length ((xs Value)) Int
  (ite (is-Nil xs) 0
    (ite (is-Cons xs)
      (+ 1 (length (tail xs)))
      0)))

(define-fun-rec all_in_range ((xs Value)) Bool
  (ite (is-Nil xs) true
    (ite (and (is-Cons xs)
              (is-IntVal (head xs))
              (let ((i (ival (head xs))))
                (and (<= (- 1000) i) (<= i 1000))))
      (all_in_range (tail xs))
      false)))

; === Inputs ===
(declare-const arr Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))
(assert (is-IntVal k))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (and (<= 1 (length arr)) (<= (length arr) 1000)))
(define-fun C2 () Bool (all_in_range arr))
(define-fun C3 () Bool (is-IntVal k))
(define-fun C4 () Bool (and (<= 0 (SafeI k)) (<= (SafeI k) (length arr))))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))
(assert (not C3))
(assert (not C4))

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_assert_2;assert_3;assert_4
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False, 'assert_3': False, 'assert_4': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': ['assert_2', 'assert_3', 'assert_4'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (IsList (tail v))
      false)))

(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

(define-fun-rec length ((xs Value)) Int
  (ite (is-Nil xs) 0
    (ite (is-Cons xs)
      (+ 1 (length (tail xs)))
      0)))

(define-fun-rec all_in_range ((xs Value)) Bool
  (ite (is-Nil xs) true
    (ite (and (is-Cons xs)
              (is-IntVal (head xs))
              (let ((i (ival (head xs))))
                (and (<= (- 1000) i) (<= i 1000))))
      (all_in_range (tail xs))
      false)))

; === Inputs ===
(declare-const arr Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))
(assert (is-IntVal k))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (and (<= 1 (length arr)) (<= (length arr) 1000)))
(define-fun C2 () Bool (all_in_range arr))
(define-fun C3 () Bool (is-IntVal k))
(define-fun C4 () Bool (and (<= 0 (SafeI k)) (<= (SafeI k) (length arr))))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))
(assert (not C3))
(assert (not C4))

(check-sat)
(get-model)

------------------------------
  Test Case 5: satisfied_assert_2, violated_assert_0;assert_1;assert_3;assert_4
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True, 'assert_3': False, 'assert_4': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_2'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_3', 'assert_4'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (IsList (tail v))
      false)))

(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

(define-fun-rec length ((xs Value)) Int
  (ite (is-Nil xs) 0
    (ite (is-Cons xs)
      (+ 1 (length (tail xs)))
      0)))

(define-fun-rec all_in_range ((xs Value)) Bool
  (ite (is-Nil xs) true
    (ite (and (is-Cons xs)
              (is-IntVal (head xs))
              (let ((i (ival (head xs))))
                (and (<= (- 1000) i) (<= i 1000))))
      (all_in_range (tail xs))
      false)))

; === Inputs ===
(declare-const arr Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))
(assert (is-IntVal k))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (and (<= 1 (length arr)) (<= (length arr) 1000)))
(define-fun C2 () Bool (all_in_range arr))
(define-fun C3 () Bool (is-IntVal k))
(define-fun C4 () Bool (and (<= 0 (SafeI k)) (<= (SafeI k) (length arr))))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)
(assert (not C3))
(assert (not C4))

(check-sat)
(get-model)

------------------------------
  Test Case 6: satisfied_assert_0;assert_2, violated_assert_1;assert_3;assert_4
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True, 'assert_3': False, 'assert_4': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2'], 'violated_contracts': ['assert_1', 'assert_3', 'assert_4'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (IsList (tail v))
      false)))

(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

(define-fun-rec length ((xs Value)) Int
  (ite (is-Nil xs) 0
    (ite (is-Cons xs)
      (+ 1 (length (tail xs)))
      0)))

(define-fun-rec all_in_range ((xs Value)) Bool
  (ite (is-Nil xs) true
    (ite (and (is-Cons xs)
              (is-IntVal (head xs))
              (let ((i (ival (head xs))))
                (and (<= (- 1000) i) (<= i 1000))))
      (all_in_range (tail xs))
      false)))

; === Inputs ===
(declare-const arr Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))
(assert (is-IntVal k))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (and (<= 1 (length arr)) (<= (length arr) 1000)))
(define-fun C2 () Bool (all_in_range arr))
(define-fun C3 () Bool (is-IntVal k))
(define-fun C4 () Bool (and (<= 0 (SafeI k)) (<= (SafeI k) (length arr))))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)
(assert (not C3))
(assert (not C4))

(check-sat)
(get-model)

------------------------------
  Test Case 7: satisfied_assert_1;assert_2, violated_assert_0;assert_3;assert_4
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True, 'assert_3': False, 'assert_4': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2'], 'violated_contracts': ['assert_0', 'assert_3', 'assert_4'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (IsList (tail v))
      false)))

(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

(define-fun-rec length ((xs Value)) Int
  (ite (is-Nil xs) 0
    (ite (is-Cons xs)
      (+ 1 (length (tail xs)))
      0)))

(define-fun-rec all_in_range ((xs Value)) Bool
  (ite (is-Nil xs) true
    (ite (and (is-Cons xs)
              (is-IntVal (head xs))
              (let ((i (ival (head xs))))
                (and (<= (- 1000) i) (<= i 1000))))
      (all_in_range (tail xs))
      false)))

; === Inputs ===
(declare-const arr Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))
(assert (is-IntVal k))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (and (<= 1 (length arr)) (<= (length arr) 1000)))
(define-fun C2 () Bool (all_in_range arr))
(define-fun C3 () Bool (is-IntVal k))
(define-fun C4 () Bool (and (<= 0 (SafeI k)) (<= (SafeI k) (length arr))))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)
(assert (not C3))
(assert (not C4))

(check-sat)
(get-model)

------------------------------
  Test Case 8: satisfied_assert_0;assert_1;assert_2, violated_assert_3;assert_4
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True, 'assert_3': False, 'assert_4': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2'], 'violated_contracts': ['assert_3', 'assert_4'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (IsList (tail v))
      false)))

(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

(define-fun-rec length ((xs Value)) Int
  (ite (is-Nil xs) 0
    (ite (is-Cons xs)
      (+ 1 (length (tail xs)))
      0)))

(define-fun-rec all_in_range ((xs Value)) Bool
  (ite (is-Nil xs) true
    (ite (and (is-Cons xs)
              (is-IntVal (head xs))
              (let ((i (ival (head xs))))
                (and (<= (- 1000) i) (<= i 1000))))
      (all_in_range (tail xs))
      false)))

; === Inputs ===
(declare-const arr Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))
(assert (is-IntVal k))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (and (<= 1 (length arr)) (<= (length arr) 1000)))
(define-fun C2 () Bool (all_in_range arr))
(define-fun C3 () Bool (is-IntVal k))
(define-fun C4 () Bool (and (<= 0 (SafeI k)) (<= (SafeI k) (length arr))))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)
(assert (not C3))
(assert (not C4))

(check-sat)
(get-model)

------------------------------
  Test Case 9: satisfied_assert_3, violated_assert_0;assert_1;assert_2;assert_4
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False, 'assert_3': True, 'assert_4': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_3'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_4'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (IsList (tail v))
      false)))

(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

(define-fun-rec length ((xs Value)) Int
  (ite (is-Nil xs) 0
    (ite (is-Cons xs)
      (+ 1 (length (tail xs)))
      0)))

(define-fun-rec all_in_range ((xs Value)) Bool
  (ite (is-Nil xs) true
    (ite (and (is-Cons xs)
              (is-IntVal (head xs))
              (let ((i (ival (head xs))))
                (and (<= (- 1000) i) (<= i 1000))))
      (all_in_range (tail xs))
      false)))

; === Inputs ===
(declare-const arr Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))
(assert (is-IntVal k))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (and (<= 1 (length arr)) (<= (length arr) 1000)))
(define-fun C2 () Bool (all_in_range arr))
(define-fun C3 () Bool (is-IntVal k))
(define-fun C4 () Bool (and (<= 0 (SafeI k)) (<= (SafeI k) (length arr))))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))
(assert C3)
(assert (not C4))

(check-sat)
(get-model)

------------------------------
  Test Case 10: satisfied_assert_0;assert_3, violated_assert_1;assert_2;assert_4
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False, 'assert_3': True, 'assert_4': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_3'], 'violated_contracts': ['assert_1', 'assert_2', 'assert_4'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (IsList (tail v))
      false)))

(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

(define-fun-rec length ((xs Value)) Int
  (ite (is-Nil xs) 0
    (ite (is-Cons xs)
      (+ 1 (length (tail xs)))
      0)))

(define-fun-rec all_in_range ((xs Value)) Bool
  (ite (is-Nil xs) true
    (ite (and (is-Cons xs)
              (is-IntVal (head xs))
              (let ((i (ival (head xs))))
                (and (<= (- 1000) i) (<= i 1000))))
      (all_in_range (tail xs))
      false)))

; === Inputs ===
(declare-const arr Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))
(assert (is-IntVal k))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (and (<= 1 (length arr)) (<= (length arr) 1000)))
(define-fun C2 () Bool (all_in_range arr))
(define-fun C3 () Bool (is-IntVal k))
(define-fun C4 () Bool (and (<= 0 (SafeI k)) (<= (SafeI k) (length arr))))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))
(assert C3)
(assert (not C4))

(check-sat)
(get-model)

------------------------------
  Test Case 11: satisfied_assert_1;assert_3, violated_assert_0;assert_2;assert_4
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False, 'assert_3': True, 'assert_4': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_3'], 'violated_contracts': ['assert_0', 'assert_2', 'assert_4'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (IsList (tail v))
      false)))

(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

(define-fun-rec length ((xs Value)) Int
  (ite (is-Nil xs) 0
    (ite (is-Cons xs)
      (+ 1 (length (tail xs)))
      0)))

(define-fun-rec all_in_range ((xs Value)) Bool
  (ite (is-Nil xs) true
    (ite (and (is-Cons xs)
              (is-IntVal (head xs))
              (let ((i (ival (head xs))))
                (and (<= (- 1000) i) (<= i 1000))))
      (all_in_range (tail xs))
      false)))

; === Inputs ===
(declare-const arr Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))
(assert (is-IntVal k))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (and (<= 1 (length arr)) (<= (length arr) 1000)))
(define-fun C2 () Bool (all_in_range arr))
(define-fun C3 () Bool (is-IntVal k))
(define-fun C4 () Bool (and (<= 0 (SafeI k)) (<= (SafeI k) (length arr))))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))
(assert C3)
(assert (not C4))

(check-sat)
(get-model)

------------------------------
  Test Case 12: satisfied_assert_0;assert_1;assert_3, violated_assert_2;assert_4
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False, 'assert_3': True, 'assert_4': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_3'], 'violated_contracts': ['assert_2', 'assert_4'], 'total_contracts': 5}
  Solutions:
    Solution 1:
      test_case: {'arr': [2.0], 'k': 2}
    Solution 2:
      test_case: {'k': 2, 'arr': [3.0]}
    Solution 3:
      test_case: {'k': 2, 'arr': [4.0]}
    Solution 4:
      test_case: {'k': 1144, 'arr': [5.0]}
    Solution 5:
      test_case: {'k': 1144, 'arr': [6.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (IsList (tail v))
      false)))

(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

(define-fun-rec length ((xs Value)) Int
  (ite (is-Nil xs) 0
    (ite (is-Cons xs)
      (+ 1 (length (tail xs)))
      0)))

(define-fun-rec all_in_range ((xs Value)) Bool
  (ite (is-Nil xs) true
    (ite (and (is-Cons xs)
              (is-IntVal (head xs))
              (let ((i (ival (head xs))))
                (and (<= (- 1000) i) (<= i 1000))))
      (all_in_range (tail xs))
      false)))

; === Inputs ===
(declare-const arr Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))
(assert (is-IntVal k))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (and (<= 1 (length arr)) (<= (length arr) 1000)))
(define-fun C2 () Bool (all_in_range arr))
(define-fun C3 () Bool (is-IntVal k))
(define-fun C4 () Bool (and (<= 0 (SafeI k)) (<= (SafeI k) (length arr))))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))
(assert C3)
(assert (not C4))

(check-sat)
(get-model)

------------------------------
  Test Case 13: satisfied_assert_2;assert_3, violated_assert_0;assert_1;assert_4
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True, 'assert_3': True, 'assert_4': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_2', 'assert_3'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_4'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (IsList (tail v))
      false)))

(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

(define-fun-rec length ((xs Value)) Int
  (ite (is-Nil xs) 0
    (ite (is-Cons xs)
      (+ 1 (length (tail xs)))
      0)))

(define-fun-rec all_in_range ((xs Value)) Bool
  (ite (is-Nil xs) true
    (ite (and (is-Cons xs)
              (is-IntVal (head xs))
              (let ((i (ival (head xs))))
                (and (<= (- 1000) i) (<= i 1000))))
      (all_in_range (tail xs))
      false)))

; === Inputs ===
(declare-const arr Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))
(assert (is-IntVal k))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (and (<= 1 (length arr)) (<= (length arr) 1000)))
(define-fun C2 () Bool (all_in_range arr))
(define-fun C3 () Bool (is-IntVal k))
(define-fun C4 () Bool (and (<= 0 (SafeI k)) (<= (SafeI k) (length arr))))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)
(assert C3)
(assert (not C4))

(check-sat)
(get-model)

------------------------------
  Test Case 14: satisfied_assert_0;assert_2;assert_3, violated_assert_1;assert_4
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True, 'assert_3': True, 'assert_4': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2', 'assert_3'], 'violated_contracts': ['assert_1', 'assert_4'], 'total_contracts': 5}
  Solutions:
    Solution 1:
      test_case: {'arr': [], 'k': 1}
    Solution 2:
      test_case: {'k': 8856, 'arr': []}
    Solution 3:
      test_case: {'k': 19306, 'arr': []}
    Solution 4:
      test_case: {'k': 20448, 'arr': []}
    Solution 5:
      test_case: {'arr': [], 'k': 29393}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (IsList (tail v))
      false)))

(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

(define-fun-rec length ((xs Value)) Int
  (ite (is-Nil xs) 0
    (ite (is-Cons xs)
      (+ 1 (length (tail xs)))
      0)))

(define-fun-rec all_in_range ((xs Value)) Bool
  (ite (is-Nil xs) true
    (ite (and (is-Cons xs)
              (is-IntVal (head xs))
              (let ((i (ival (head xs))))
                (and (<= (- 1000) i) (<= i 1000))))
      (all_in_range (tail xs))
      false)))

; === Inputs ===
(declare-const arr Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))
(assert (is-IntVal k))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (and (<= 1 (length arr)) (<= (length arr) 1000)))
(define-fun C2 () Bool (all_in_range arr))
(define-fun C3 () Bool (is-IntVal k))
(define-fun C4 () Bool (and (<= 0 (SafeI k)) (<= (SafeI k) (length arr))))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)
(assert C3)
(assert (not C4))

(check-sat)
(get-model)

------------------------------
  Test Case 15: satisfied_assert_1;assert_2;assert_3, violated_assert_0;assert_4
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True, 'assert_3': True, 'assert_4': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2', 'assert_3'], 'violated_contracts': ['assert_0', 'assert_4'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (IsList (tail v))
      false)))

(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

(define-fun-rec length ((xs Value)) Int
  (ite (is-Nil xs) 0
    (ite (is-Cons xs)
      (+ 1 (length (tail xs)))
      0)))

(define-fun-rec all_in_range ((xs Value)) Bool
  (ite (is-Nil xs) true
    (ite (and (is-Cons xs)
              (is-IntVal (head xs))
              (let ((i (ival (head xs))))
                (and (<= (- 1000) i) (<= i 1000))))
      (all_in_range (tail xs))
      false)))

; === Inputs ===
(declare-const arr Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))
(assert (is-IntVal k))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (and (<= 1 (length arr)) (<= (length arr) 1000)))
(define-fun C2 () Bool (all_in_range arr))
(define-fun C3 () Bool (is-IntVal k))
(define-fun C4 () Bool (and (<= 0 (SafeI k)) (<= (SafeI k) (length arr))))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)
(assert C3)
(assert (not C4))

(check-sat)
(get-model)

------------------------------
  Test Case 16: satisfied_assert_0;assert_1;assert_2;assert_3, violated_assert_4
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True, 'assert_3': True, 'assert_4': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_3'], 'violated_contracts': ['assert_4'], 'total_contracts': 5}
  Solutions:
    Solution 1:
      test_case: {'arr': [0], 'k': 2}
    Solution 2:
      test_case: {'k': 2, 'arr': [-555]}
    Solution 3:
      test_case: {'arr': [-473], 'k': 2}
    Solution 4:
      test_case: {'k': 2, 'arr': [-34]}
    Solution 5:
      test_case: {'k': 2, 'arr': [-761]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (IsList (tail v))
      false)))

(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

(define-fun-rec length ((xs Value)) Int
  (ite (is-Nil xs) 0
    (ite (is-Cons xs)
      (+ 1 (length (tail xs)))
      0)))

(define-fun-rec all_in_range ((xs Value)) Bool
  (ite (is-Nil xs) true
    (ite (and (is-Cons xs)
              (is-IntVal (head xs))
              (let ((i (ival (head xs))))
                (and (<= (- 1000) i) (<= i 1000))))
      (all_in_range (tail xs))
      false)))

; === Inputs ===
(declare-const arr Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))
(assert (is-IntVal k))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (and (<= 1 (length arr)) (<= (length arr) 1000)))
(define-fun C2 () Bool (all_in_range arr))
(define-fun C3 () Bool (is-IntVal k))
(define-fun C4 () Bool (and (<= 0 (SafeI k)) (<= (SafeI k) (length arr))))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)
(assert C3)
(assert (not C4))

(check-sat)
(get-model)

------------------------------
  Test Case 17: satisfied_assert_4, violated_assert_0;assert_1;assert_2;assert_3
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False, 'assert_3': False, 'assert_4': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_4'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_3'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (IsList (tail v))
      false)))

(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

(define-fun-rec length ((xs Value)) Int
  (ite (is-Nil xs) 0
    (ite (is-Cons xs)
      (+ 1 (length (tail xs)))
      0)))

(define-fun-rec all_in_range ((xs Value)) Bool
  (ite (is-Nil xs) true
    (ite (and (is-Cons xs)
              (is-IntVal (head xs))
              (let ((i (ival (head xs))))
                (and (<= (- 1000) i) (<= i 1000))))
      (all_in_range (tail xs))
      false)))

; === Inputs ===
(declare-const arr Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))
(assert (is-IntVal k))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (and (<= 1 (length arr)) (<= (length arr) 1000)))
(define-fun C2 () Bool (all_in_range arr))
(define-fun C3 () Bool (is-IntVal k))
(define-fun C4 () Bool (and (<= 0 (SafeI k)) (<= (SafeI k) (length arr))))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))
(assert (not C3))
(assert C4)

(check-sat)
(get-model)

------------------------------
  Test Case 18: satisfied_assert_0;assert_4, violated_assert_1;assert_2;assert_3
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False, 'assert_3': False, 'assert_4': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_4'], 'violated_contracts': ['assert_1', 'assert_2', 'assert_3'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (IsList (tail v))
      false)))

(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

(define-fun-rec length ((xs Value)) Int
  (ite (is-Nil xs) 0
    (ite (is-Cons xs)
      (+ 1 (length (tail xs)))
      0)))

(define-fun-rec all_in_range ((xs Value)) Bool
  (ite (is-Nil xs) true
    (ite (and (is-Cons xs)
              (is-IntVal (head xs))
              (let ((i (ival (head xs))))
                (and (<= (- 1000) i) (<= i 1000))))
      (all_in_range (tail xs))
      false)))

; === Inputs ===
(declare-const arr Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))
(assert (is-IntVal k))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (and (<= 1 (length arr)) (<= (length arr) 1000)))
(define-fun C2 () Bool (all_in_range arr))
(define-fun C3 () Bool (is-IntVal k))
(define-fun C4 () Bool (and (<= 0 (SafeI k)) (<= (SafeI k) (length arr))))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))
(assert (not C3))
(assert C4)

(check-sat)
(get-model)

------------------------------
  Test Case 19: satisfied_assert_1;assert_4, violated_assert_0;assert_2;assert_3
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False, 'assert_3': False, 'assert_4': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_4'], 'violated_contracts': ['assert_0', 'assert_2', 'assert_3'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (IsList (tail v))
      false)))

(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

(define-fun-rec length ((xs Value)) Int
  (ite (is-Nil xs) 0
    (ite (is-Cons xs)
      (+ 1 (length (tail xs)))
      0)))

(define-fun-rec all_in_range ((xs Value)) Bool
  (ite (is-Nil xs) true
    (ite (and (is-Cons xs)
              (is-IntVal (head xs))
              (let ((i (ival (head xs))))
                (and (<= (- 1000) i) (<= i 1000))))
      (all_in_range (tail xs))
      false)))

; === Inputs ===
(declare-const arr Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))
(assert (is-IntVal k))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (and (<= 1 (length arr)) (<= (length arr) 1000)))
(define-fun C2 () Bool (all_in_range arr))
(define-fun C3 () Bool (is-IntVal k))
(define-fun C4 () Bool (and (<= 0 (SafeI k)) (<= (SafeI k) (length arr))))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))
(assert (not C3))
(assert C4)

(check-sat)
(get-model)

------------------------------
  Test Case 20: satisfied_assert_0;assert_1;assert_4, violated_assert_2;assert_3
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False, 'assert_3': False, 'assert_4': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_4'], 'violated_contracts': ['assert_2', 'assert_3'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (IsList (tail v))
      false)))

(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

(define-fun-rec length ((xs Value)) Int
  (ite (is-Nil xs) 0
    (ite (is-Cons xs)
      (+ 1 (length (tail xs)))
      0)))

(define-fun-rec all_in_range ((xs Value)) Bool
  (ite (is-Nil xs) true
    (ite (and (is-Cons xs)
              (is-IntVal (head xs))
              (let ((i (ival (head xs))))
                (and (<= (- 1000) i) (<= i 1000))))
      (all_in_range (tail xs))
      false)))

; === Inputs ===
(declare-const arr Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))
(assert (is-IntVal k))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (and (<= 1 (length arr)) (<= (length arr) 1000)))
(define-fun C2 () Bool (all_in_range arr))
(define-fun C3 () Bool (is-IntVal k))
(define-fun C4 () Bool (and (<= 0 (SafeI k)) (<= (SafeI k) (length arr))))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))
(assert (not C3))
(assert C4)

(check-sat)
(get-model)

------------------------------
  Test Case 21: satisfied_assert_2;assert_4, violated_assert_0;assert_1;assert_3
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True, 'assert_3': False, 'assert_4': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_2', 'assert_4'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_3'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (IsList (tail v))
      false)))

(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

(define-fun-rec length ((xs Value)) Int
  (ite (is-Nil xs) 0
    (ite (is-Cons xs)
      (+ 1 (length (tail xs)))
      0)))

(define-fun-rec all_in_range ((xs Value)) Bool
  (ite (is-Nil xs) true
    (ite (and (is-Cons xs)
              (is-IntVal (head xs))
              (let ((i (ival (head xs))))
                (and (<= (- 1000) i) (<= i 1000))))
      (all_in_range (tail xs))
      false)))

; === Inputs ===
(declare-const arr Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))
(assert (is-IntVal k))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (and (<= 1 (length arr)) (<= (length arr) 1000)))
(define-fun C2 () Bool (all_in_range arr))
(define-fun C3 () Bool (is-IntVal k))
(define-fun C4 () Bool (and (<= 0 (SafeI k)) (<= (SafeI k) (length arr))))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)
(assert (not C3))
(assert C4)

(check-sat)
(get-model)

------------------------------
  Test Case 22: satisfied_assert_0;assert_2;assert_4, violated_assert_1;assert_3
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True, 'assert_3': False, 'assert_4': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2', 'assert_4'], 'violated_contracts': ['assert_1', 'assert_3'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (IsList (tail v))
      false)))

(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

(define-fun-rec length ((xs Value)) Int
  (ite (is-Nil xs) 0
    (ite (is-Cons xs)
      (+ 1 (length (tail xs)))
      0)))

(define-fun-rec all_in_range ((xs Value)) Bool
  (ite (is-Nil xs) true
    (ite (and (is-Cons xs)
              (is-IntVal (head xs))
              (let ((i (ival (head xs))))
                (and (<= (- 1000) i) (<= i 1000))))
      (all_in_range (tail xs))
      false)))

; === Inputs ===
(declare-const arr Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))
(assert (is-IntVal k))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (and (<= 1 (length arr)) (<= (length arr) 1000)))
(define-fun C2 () Bool (all_in_range arr))
(define-fun C3 () Bool (is-IntVal k))
(define-fun C4 () Bool (and (<= 0 (SafeI k)) (<= (SafeI k) (length arr))))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)
(assert (not C3))
(assert C4)

(check-sat)
(get-model)

------------------------------
  Test Case 23: satisfied_assert_1;assert_2;assert_4, violated_assert_0;assert_3
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True, 'assert_3': False, 'assert_4': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2', 'assert_4'], 'violated_contracts': ['assert_0', 'assert_3'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (IsList (tail v))
      false)))

(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

(define-fun-rec length ((xs Value)) Int
  (ite (is-Nil xs) 0
    (ite (is-Cons xs)
      (+ 1 (length (tail xs)))
      0)))

(define-fun-rec all_in_range ((xs Value)) Bool
  (ite (is-Nil xs) true
    (ite (and (is-Cons xs)
              (is-IntVal (head xs))
              (let ((i (ival (head xs))))
                (and (<= (- 1000) i) (<= i 1000))))
      (all_in_range (tail xs))
      false)))

; === Inputs ===
(declare-const arr Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))
(assert (is-IntVal k))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (and (<= 1 (length arr)) (<= (length arr) 1000)))
(define-fun C2 () Bool (all_in_range arr))
(define-fun C3 () Bool (is-IntVal k))
(define-fun C4 () Bool (and (<= 0 (SafeI k)) (<= (SafeI k) (length arr))))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)
(assert (not C3))
(assert C4)

(check-sat)
(get-model)

------------------------------
  Test Case 24: satisfied_assert_0;assert_1;assert_2;assert_4, violated_assert_3
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True, 'assert_3': False, 'assert_4': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_4'], 'violated_contracts': ['assert_3'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (IsList (tail v))
      false)))

(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

(define-fun-rec length ((xs Value)) Int
  (ite (is-Nil xs) 0
    (ite (is-Cons xs)
      (+ 1 (length (tail xs)))
      0)))

(define-fun-rec all_in_range ((xs Value)) Bool
  (ite (is-Nil xs) true
    (ite (and (is-Cons xs)
              (is-IntVal (head xs))
              (let ((i (ival (head xs))))
                (and (<= (- 1000) i) (<= i 1000))))
      (all_in_range (tail xs))
      false)))

; === Inputs ===
(declare-const arr Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))
(assert (is-IntVal k))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (and (<= 1 (length arr)) (<= (length arr) 1000)))
(define-fun C2 () Bool (all_in_range arr))
(define-fun C3 () Bool (is-IntVal k))
(define-fun C4 () Bool (and (<= 0 (SafeI k)) (<= (SafeI k) (length arr))))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)
(assert (not C3))
(assert C4)

(check-sat)
(get-model)

------------------------------
  Test Case 25: satisfied_assert_3;assert_4, violated_assert_0;assert_1;assert_2
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False, 'assert_3': True, 'assert_4': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_3', 'assert_4'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (IsList (tail v))
      false)))

(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

(define-fun-rec length ((xs Value)) Int
  (ite (is-Nil xs) 0
    (ite (is-Cons xs)
      (+ 1 (length (tail xs)))
      0)))

(define-fun-rec all_in_range ((xs Value)) Bool
  (ite (is-Nil xs) true
    (ite (and (is-Cons xs)
              (is-IntVal (head xs))
              (let ((i (ival (head xs))))
                (and (<= (- 1000) i) (<= i 1000))))
      (all_in_range (tail xs))
      false)))

; === Inputs ===
(declare-const arr Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))
(assert (is-IntVal k))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (and (<= 1 (length arr)) (<= (length arr) 1000)))
(define-fun C2 () Bool (all_in_range arr))
(define-fun C3 () Bool (is-IntVal k))
(define-fun C4 () Bool (and (<= 0 (SafeI k)) (<= (SafeI k) (length arr))))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))
(assert C3)
(assert C4)

(check-sat)
(get-model)

------------------------------
  Test Case 26: satisfied_assert_0;assert_3;assert_4, violated_assert_1;assert_2
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False, 'assert_3': True, 'assert_4': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_3', 'assert_4'], 'violated_contracts': ['assert_1', 'assert_2'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (IsList (tail v))
      false)))

(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

(define-fun-rec length ((xs Value)) Int
  (ite (is-Nil xs) 0
    (ite (is-Cons xs)
      (+ 1 (length (tail xs)))
      0)))

(define-fun-rec all_in_range ((xs Value)) Bool
  (ite (is-Nil xs) true
    (ite (and (is-Cons xs)
              (is-IntVal (head xs))
              (let ((i (ival (head xs))))
                (and (<= (- 1000) i) (<= i 1000))))
      (all_in_range (tail xs))
      false)))

; === Inputs ===
(declare-const arr Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))
(assert (is-IntVal k))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (and (<= 1 (length arr)) (<= (length arr) 1000)))
(define-fun C2 () Bool (all_in_range arr))
(define-fun C3 () Bool (is-IntVal k))
(define-fun C4 () Bool (and (<= 0 (SafeI k)) (<= (SafeI k) (length arr))))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))
(assert C3)
(assert C4)

(check-sat)
(get-model)

------------------------------
  Test Case 27: satisfied_assert_1;assert_3;assert_4, violated_assert_0;assert_2
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False, 'assert_3': True, 'assert_4': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_3', 'assert_4'], 'violated_contracts': ['assert_0', 'assert_2'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (IsList (tail v))
      false)))

(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

(define-fun-rec length ((xs Value)) Int
  (ite (is-Nil xs) 0
    (ite (is-Cons xs)
      (+ 1 (length (tail xs)))
      0)))

(define-fun-rec all_in_range ((xs Value)) Bool
  (ite (is-Nil xs) true
    (ite (and (is-Cons xs)
              (is-IntVal (head xs))
              (let ((i (ival (head xs))))
                (and (<= (- 1000) i) (<= i 1000))))
      (all_in_range (tail xs))
      false)))

; === Inputs ===
(declare-const arr Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))
(assert (is-IntVal k))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (and (<= 1 (length arr)) (<= (length arr) 1000)))
(define-fun C2 () Bool (all_in_range arr))
(define-fun C3 () Bool (is-IntVal k))
(define-fun C4 () Bool (and (<= 0 (SafeI k)) (<= (SafeI k) (length arr))))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))
(assert C3)
(assert C4)

(check-sat)
(get-model)

------------------------------
  Test Case 28: satisfied_assert_0;assert_1;assert_3;assert_4, violated_assert_2
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False, 'assert_3': True, 'assert_4': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_3', 'assert_4'], 'violated_contracts': ['assert_2'], 'total_contracts': 5}
  Solutions:
    Solution 1:
      test_case: {'arr': [2.0], 'k': 0}
    Solution 2:
      test_case: {'k': 1, 'arr': [3.0]}
    Solution 3:
      test_case: {'k': 0, 'arr': [4.0]}
    Solution 4:
      test_case: {'k': 0, 'arr': [5.0]}
    Solution 5:
      test_case: {'k': 0, 'arr': [6.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (IsList (tail v))
      false)))

(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

(define-fun-rec length ((xs Value)) Int
  (ite (is-Nil xs) 0
    (ite (is-Cons xs)
      (+ 1 (length (tail xs)))
      0)))

(define-fun-rec all_in_range ((xs Value)) Bool
  (ite (is-Nil xs) true
    (ite (and (is-Cons xs)
              (is-IntVal (head xs))
              (let ((i (ival (head xs))))
                (and (<= (- 1000) i) (<= i 1000))))
      (all_in_range (tail xs))
      false)))

; === Inputs ===
(declare-const arr Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))
(assert (is-IntVal k))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (and (<= 1 (length arr)) (<= (length arr) 1000)))
(define-fun C2 () Bool (all_in_range arr))
(define-fun C3 () Bool (is-IntVal k))
(define-fun C4 () Bool (and (<= 0 (SafeI k)) (<= (SafeI k) (length arr))))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))
(assert C3)
(assert C4)

(check-sat)
(get-model)

------------------------------
  Test Case 29: satisfied_assert_2;assert_3;assert_4, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True, 'assert_3': True, 'assert_4': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_2', 'assert_3', 'assert_4'], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (IsList (tail v))
      false)))

(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

(define-fun-rec length ((xs Value)) Int
  (ite (is-Nil xs) 0
    (ite (is-Cons xs)
      (+ 1 (length (tail xs)))
      0)))

(define-fun-rec all_in_range ((xs Value)) Bool
  (ite (is-Nil xs) true
    (ite (and (is-Cons xs)
              (is-IntVal (head xs))
              (let ((i (ival (head xs))))
                (and (<= (- 1000) i) (<= i 1000))))
      (all_in_range (tail xs))
      false)))

; === Inputs ===
(declare-const arr Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))
(assert (is-IntVal k))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (and (<= 1 (length arr)) (<= (length arr) 1000)))
(define-fun C2 () Bool (all_in_range arr))
(define-fun C3 () Bool (is-IntVal k))
(define-fun C4 () Bool (and (<= 0 (SafeI k)) (<= (SafeI k) (length arr))))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)
(assert C3)
(assert C4)

(check-sat)
(get-model)

------------------------------
  Test Case 30: satisfied_assert_0;assert_2;assert_3;assert_4, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True, 'assert_3': True, 'assert_4': True}
  Satisfiable: True
  Solution Count: 1
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2', 'assert_3', 'assert_4'], 'violated_contracts': ['assert_1'], 'total_contracts': 5}
  Solutions:
    Solution 1:
      test_case: {'arr': [], 'k': 0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (IsList (tail v))
      false)))

(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

(define-fun-rec length ((xs Value)) Int
  (ite (is-Nil xs) 0
    (ite (is-Cons xs)
      (+ 1 (length (tail xs)))
      0)))

(define-fun-rec all_in_range ((xs Value)) Bool
  (ite (is-Nil xs) true
    (ite (and (is-Cons xs)
              (is-IntVal (head xs))
              (let ((i (ival (head xs))))
                (and (<= (- 1000) i) (<= i 1000))))
      (all_in_range (tail xs))
      false)))

; === Inputs ===
(declare-const arr Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))
(assert (is-IntVal k))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (and (<= 1 (length arr)) (<= (length arr) 1000)))
(define-fun C2 () Bool (all_in_range arr))
(define-fun C3 () Bool (is-IntVal k))
(define-fun C4 () Bool (and (<= 0 (SafeI k)) (<= (SafeI k) (length arr))))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)
(assert C3)
(assert C4)

(check-sat)
(get-model)

------------------------------
  Test Case 31: satisfied_assert_1;assert_2;assert_3;assert_4, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True, 'assert_3': True, 'assert_4': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2', 'assert_3', 'assert_4'], 'violated_contracts': ['assert_0'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (IsList (tail v))
      false)))

(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

(define-fun-rec length ((xs Value)) Int
  (ite (is-Nil xs) 0
    (ite (is-Cons xs)
      (+ 1 (length (tail xs)))
      0)))

(define-fun-rec all_in_range ((xs Value)) Bool
  (ite (is-Nil xs) true
    (ite (and (is-Cons xs)
              (is-IntVal (head xs))
              (let ((i (ival (head xs))))
                (and (<= (- 1000) i) (<= i 1000))))
      (all_in_range (tail xs))
      false)))

; === Inputs ===
(declare-const arr Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))
(assert (is-IntVal k))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (and (<= 1 (length arr)) (<= (length arr) 1000)))
(define-fun C2 () Bool (all_in_range arr))
(define-fun C3 () Bool (is-IntVal k))
(define-fun C4 () Bool (and (<= 0 (SafeI k)) (<= (SafeI k) (length arr))))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)
(assert C3)
(assert C4)

(check-sat)
(get-model)

------------------------------
  Test Case 32: satisfied_assert_0;assert_1;assert_2;assert_3;assert_4, violated_
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True, 'assert_3': True, 'assert_4': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_3', 'assert_4'], 'violated_contracts': [], 'total_contracts': 5}
  Solutions:
    Solution 1:
      test_case: {'arr': [-639], 'k': 0}
    Solution 2:
      test_case: {'k': 1, 'arr': [-638]}
    Solution 3:
      test_case: {'k': 0, 'arr': [-640]}
    Solution 4:
      test_case: {'arr': [-999], 'k': 0}
    Solution 5:
      test_case: {'k': 0, 'arr': [-824]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (IsList (tail v))
      false)))

(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

(define-fun-rec length ((xs Value)) Int
  (ite (is-Nil xs) 0
    (ite (is-Cons xs)
      (+ 1 (length (tail xs)))
      0)))

(define-fun-rec all_in_range ((xs Value)) Bool
  (ite (is-Nil xs) true
    (ite (and (is-Cons xs)
              (is-IntVal (head xs))
              (let ((i (ival (head xs))))
                (and (<= (- 1000) i) (<= i 1000))))
      (all_in_range (tail xs))
      false)))

; === Inputs ===
(declare-const arr Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))
(assert (is-IntVal k))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (and (<= 1 (length arr)) (<= (length arr) 1000)))
(define-fun C2 () Bool (all_in_range arr))
(define-fun C3 () Bool (is-IntVal k))
(define-fun C4 () Bool (and (<= 0 (SafeI k)) (<= (SafeI k) (length arr))))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)
(assert C3)
(assert C4)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/121 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1;assert_2
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2'], 'total_contracts': 3}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_int ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (is-IntVal (head v))
                 (list_all_int (tail v)))
            false)))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v)
       0
       (ite (is-Cons v)
            (+ 1 (length (tail v)))
            0)))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (IsList lst))

; === Contract predicates ===
(define-fun C0 () Bool (IsList lst))
(define-fun C1 () Bool (list_all_int lst))
(define-fun C2 () Bool (> (length lst) 0))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1;assert_2
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1', 'assert_2'], 'total_contracts': 3}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_int ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (is-IntVal (head v))
                 (list_all_int (tail v)))
            false)))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v)
       0
       (ite (is-Cons v)
            (+ 1 (length (tail v)))
            0)))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (IsList lst))

; === Contract predicates ===
(define-fun C0 () Bool (IsList lst))
(define-fun C1 () Bool (list_all_int lst))
(define-fun C2 () Bool (> (length lst) 0))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0;assert_2
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0', 'assert_2'], 'total_contracts': 3}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_int ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (is-IntVal (head v))
                 (list_all_int (tail v)))
            false)))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v)
       0
       (ite (is-Cons v)
            (+ 1 (length (tail v)))
            0)))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (IsList lst))

; === Contract predicates ===
(define-fun C0 () Bool (IsList lst))
(define-fun C1 () Bool (list_all_int lst))
(define-fun C2 () Bool (> (length lst) 0))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_assert_2
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False}
  Satisfiable: True
  Solution Count: 1
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': ['assert_2'], 'total_contracts': 3}
  Solutions:
    Solution 1:
      test_case: {'lst': []}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_int ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (is-IntVal (head v))
                 (list_all_int (tail v)))
            false)))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v)
       0
       (ite (is-Cons v)
            (+ 1 (length (tail v)))
            0)))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (IsList lst))

; === Contract predicates ===
(define-fun C0 () Bool (IsList lst))
(define-fun C1 () Bool (list_all_int lst))
(define-fun C2 () Bool (> (length lst) 0))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))

(check-sat)
(get-model)

------------------------------
  Test Case 5: satisfied_assert_2, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_2'], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 3}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_int ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (is-IntVal (head v))
                 (list_all_int (tail v)))
            false)))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v)
       0
       (ite (is-Cons v)
            (+ 1 (length (tail v)))
            0)))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (IsList lst))

; === Contract predicates ===
(define-fun C0 () Bool (IsList lst))
(define-fun C1 () Bool (list_all_int lst))
(define-fun C2 () Bool (> (length lst) 0))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)

(check-sat)
(get-model)

------------------------------
  Test Case 6: satisfied_assert_0;assert_2, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2'], 'violated_contracts': ['assert_1'], 'total_contracts': 3}
  Solutions:
    Solution 1:
      test_case: {'lst': [2.0]}
    Solution 2:
      test_case: {'lst': [3.0]}
    Solution 3:
      test_case: {'lst': [4.0]}
    Solution 4:
      test_case: {'lst': [5.0]}
    Solution 5:
      test_case: {'lst': [6.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_int ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (is-IntVal (head v))
                 (list_all_int (tail v)))
            false)))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v)
       0
       (ite (is-Cons v)
            (+ 1 (length (tail v)))
            0)))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (IsList lst))

; === Contract predicates ===
(define-fun C0 () Bool (IsList lst))
(define-fun C1 () Bool (list_all_int lst))
(define-fun C2 () Bool (> (length lst) 0))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)

(check-sat)
(get-model)

------------------------------
  Test Case 7: satisfied_assert_1;assert_2, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2'], 'violated_contracts': ['assert_0'], 'total_contracts': 3}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_int ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (is-IntVal (head v))
                 (list_all_int (tail v)))
            false)))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v)
       0
       (ite (is-Cons v)
            (+ 1 (length (tail v)))
            0)))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (IsList lst))

; === Contract predicates ===
(define-fun C0 () Bool (IsList lst))
(define-fun C1 () Bool (list_all_int lst))
(define-fun C2 () Bool (> (length lst) 0))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)

(check-sat)
(get-model)

------------------------------
  Test Case 8: satisfied_assert_0;assert_1;assert_2, violated_
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2'], 'violated_contracts': [], 'total_contracts': 3}
  Solutions:
    Solution 1:
      test_case: {'lst': [4]}
    Solution 2:
      test_case: {'lst': [5]}
    Solution 3:
      test_case: {'lst': [6]}
    Solution 4:
      test_case: {'lst': [7]}
    Solution 5:
      test_case: {'lst': [8]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_int ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (is-IntVal (head v))
                 (list_all_int (tail v)))
            false)))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v)
       0
       (ite (is-Cons v)
            (+ 1 (length (tail v)))
            0)))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (IsList lst))

; === Contract predicates ===
(define-fun C0 () Bool (IsList lst))
(define-fun C1 () Bool (list_all_int lst))
(define-fun C2 () Bool (> (length lst) 0))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/122 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1;assert_2;assert_3;assert_4
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False, 'assert_3': False, 'assert_4': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_3', 'assert_4'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (IsList (tail v))
         false)))
(define-fun-rec ListAllInt ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (and (is-IntVal (head v)) (ListAllInt (tail v)))
         false)))
(define-fun-rec Length ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
         (+ 1 (Length (tail v)))
         0)))
(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const arr Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (ListAllInt arr))
(define-fun C2 () Bool (and (<= 1 (Length arr)) (<= (Length arr) 100)))
(define-fun C3 () Bool (is-IntVal k))
(define-fun C4 () Bool (and (<= 1 (SafeI k)) (<= (SafeI k) (Length arr))))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))
(assert (not C3))
(assert (not C4))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1;assert_2;assert_3;assert_4
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False, 'assert_3': False, 'assert_4': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1', 'assert_2', 'assert_3', 'assert_4'], 'total_contracts': 5}
  Solutions:
    Solution 1:
      test_case: {'arr': [20.0, 19.0, 93.0, 52.0, 94.0, 70.0, 35.0, 9.0, 30.0, 83.0, 62.0, 4.0, 15.0, 103.0, 8.0, 18.0, 57.0, 102.0, 79.0, 58.0, 43.0, 72.0, 75.0, 50.0, 41.0, 16.0, 2.0, 98.0, 49.0, 26.0, 48.0, 82.0, 89.0, 39.0, 27.0, 3.0, 67.0, 37.0, 99.0, 14.0, 47.0, 7.0, 68.0, 40.0, 29.0, 88.0, 6.0, 65.0, 5.0, 10.0, 42.0, 95.0, 59.0, 101.0, 21.0, 85.0, 100.0, 97.0, 55.0, 44.0, 17.0, 92.0, 66.0, 28.0, 11.0, 77.0, 56.0, 96.0, 84.0, 76.0, 23.0, 64.0, 36.0, 78.0, 45.0, 13.0, 81.0, 74.0, 60.0, 90.0, 80.0, 46.0, 34.0, 24.0, 86.0, 91.0, 38.0, 63.0, 12.0, 31.0, 53.0, 54.0, 33.0, 22.0, 25.0, 73.0, 69.0, 51.0, 87.0, 32.0, 71.0], 'k': 61.0}
    Solution 2:
      test_case: {'arr': [203.0, 114.0, 106.0, 195.0, 174.0, 143.0, 186.0, 196.0, 181.0, 140.0, 166.0, 176.0, 172.0, 124.0, 137.0, 141.0, 145.0, 183.0, 149.0, 178.0, 204.0, 160.0, 168.0, 104.0, 170.0, 132.0, 110.0, 188.0, 200.0, 173.0, 148.0, 129.0, 138.0, 157.0, 115.0, 142.0, 191.0, 107.0, 159.0, 198.0, 154.0, 125.0, 111.0, 199.0, 156.0, 123.0, 158.0, 152.0, 194.0, 197.0, 144.0, 155.0, 127.0, 153.0, 105.0, 187.0, 117.0, 130.0, 147.0, 108.0, 113.0, 151.0, 205.0, 119.0, 193.0, 179.0, 177.0, 180.0, 164.0, 146.0, 161.0, 184.0, 116.0, 122.0, 112.0, 190.0, 134.0, 175.0, 120.0, 162.0, 139.0, 136.0, 169.0, 202.0, 121.0, 189.0, 118.0, 109.0, 128.0, 150.0, 131.0, 182.0, 135.0, 201.0, 192.0, 163.0, 185.0, 167.0, 126.0, 133.0, 165.0], 'k': 171.0}
    Solution 3:
      test_case: {'k': 265.0, 'arr': [235.0, 292.0, 255.0, 291.0, 214.0, 306.0, 276.0, 270.0, 212.0, 250.0, 305.0, 274.0, 284.0, 264.0, 267.0, 236.0, 246.0, 245.0, 207.0, 262.0, 253.0, 225.0, 259.0, 224.0, 229.0, 282.0, 226.0, 302.0, 294.0, 234.0, 210.0, 254.0, 251.0, 280.0, 232.0, 297.0, 239.0, 275.0, 298.0, 237.0, 263.0, 290.0, 222.0, 278.0, 238.0, 230.0, 283.0, 296.0, 240.0, 277.0, 221.0, 271.0, 286.0, 288.0, 279.0, 206.0, 215.0, 247.0, 252.0, 269.0, 228.0, 213.0, 211.0, 304.0, 266.0, 219.0, 260.0, 285.0, 248.0, 220.0, 295.0, 303.0, 223.0, 287.0, 242.0, 243.0, 241.0, 217.0, 256.0, 231.0, 261.0, 272.0, 249.0, 293.0, 227.0, 244.0, 300.0, 258.0, 299.0, 281.0, 218.0, 257.0, 209.0, 273.0, 301.0, 216.0, 208.0, 233.0, 307.0, 289.0, 268.0]}
    Solution 4:
      test_case: {'k': 394.0, 'arr': [358.0, 407.0, 315.0, 353.0, 360.0, 365.0, 383.0, 313.0, 341.0, 350.0, 372.0, 333.0, 402.0, 310.0, 403.0, 316.0, 338.0, 361.0, 395.0, 327.0, 367.0, 308.0, 309.0, 400.0, 356.0, 393.0, 334.0, 349.0, 398.0, 324.0, 343.0, 406.0, 332.0, 311.0, 405.0, 384.0, 345.0, 352.0, 319.0, 325.0, 369.0, 323.0, 331.0, 329.0, 409.0, 344.0, 354.0, 330.0, 355.0, 363.0, 312.0, 368.0, 382.0, 404.0, 346.0, 386.0, 373.0, 359.0, 351.0, 390.0, 322.0, 391.0, 379.0, 321.0, 399.0, 362.0, 347.0, 408.0, 371.0, 378.0, 326.0, 357.0, 396.0, 320.0, 375.0, 377.0, 380.0, 401.0, 388.0, 337.0, 364.0, 342.0, 387.0, 366.0, 336.0, 335.0, 348.0, 385.0, 381.0, 397.0, 374.0, 317.0, 339.0, 328.0, 389.0, 376.0, 392.0, 314.0, 340.0, 370.0, 318.0]}
    Solution 5:
      test_case: {'arr': [462.0, 470.0, 412.0, 460.0, 426.0, 435.0, 497.0, 438.0, 498.0, 484.0, 432.0, 410.0, 503.0, 483.0, 428.0, 418.0, 480.0, 479.0, 485.0, 494.0, 469.0, 427.0, 461.0, 507.0, 474.0, 447.0, 454.0, 430.0, 463.0, 439.0, 411.0, 495.0, 424.0, 441.0, 455.0, 473.0, 431.0, 505.0, 472.0, 502.0, 416.0, 501.0, 499.0, 488.0, 487.0, 504.0, 468.0, 458.0, 492.0, 450.0, 443.0, 496.0, 482.0, 481.0, 493.0, 422.0, 478.0, 415.0, 486.0, 413.0, 414.0, 451.0, 467.0, 448.0, 475.0, 434.0, 489.0, 419.0, 508.0, 421.0, 466.0, 491.0, 452.0, 465.0, 425.0, 477.0, 506.0, 417.0, 429.0, 436.0, 471.0, 464.0, 511.0, 437.0, 442.0, 446.0, 444.0, 510.0, 449.0, 453.0, 456.0, 459.0, 500.0, 420.0, 423.0, 476.0, 509.0, 440.0, 433.0, 490.0, 457.0], 'k': 445.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (IsList (tail v))
         false)))
(define-fun-rec ListAllInt ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (and (is-IntVal (head v)) (ListAllInt (tail v)))
         false)))
(define-fun-rec Length ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
         (+ 1 (Length (tail v)))
         0)))
(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const arr Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (ListAllInt arr))
(define-fun C2 () Bool (and (<= 1 (Length arr)) (<= (Length arr) 100)))
(define-fun C3 () Bool (is-IntVal k))
(define-fun C4 () Bool (and (<= 1 (SafeI k)) (<= (SafeI k) (Length arr))))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))
(assert (not C3))
(assert (not C4))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0;assert_2;assert_3;assert_4
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False, 'assert_3': False, 'assert_4': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0', 'assert_2', 'assert_3', 'assert_4'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (IsList (tail v))
         false)))
(define-fun-rec ListAllInt ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (and (is-IntVal (head v)) (ListAllInt (tail v)))
         false)))
(define-fun-rec Length ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
         (+ 1 (Length (tail v)))
         0)))
(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const arr Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (ListAllInt arr))
(define-fun C2 () Bool (and (<= 1 (Length arr)) (<= (Length arr) 100)))
(define-fun C3 () Bool (is-IntVal k))
(define-fun C4 () Bool (and (<= 1 (SafeI k)) (<= (SafeI k) (Length arr))))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))
(assert (not C3))
(assert (not C4))

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_assert_2;assert_3;assert_4
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False, 'assert_3': False, 'assert_4': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': ['assert_2', 'assert_3', 'assert_4'], 'total_contracts': 5}
  Solutions:
    Solution 1:
      test_case: {'arr': [], 'k': 2.0}
    Solution 2:
      test_case: {'k': 3.0, 'arr': []}
    Solution 3:
      test_case: {'k': 4.0, 'arr': []}
    Solution 4:
      test_case: {'k': 5.0, 'arr': []}
    Solution 5:
      test_case: {'arr': [], 'k': 6.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (IsList (tail v))
         false)))
(define-fun-rec ListAllInt ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (and (is-IntVal (head v)) (ListAllInt (tail v)))
         false)))
(define-fun-rec Length ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
         (+ 1 (Length (tail v)))
         0)))
(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const arr Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (ListAllInt arr))
(define-fun C2 () Bool (and (<= 1 (Length arr)) (<= (Length arr) 100)))
(define-fun C3 () Bool (is-IntVal k))
(define-fun C4 () Bool (and (<= 1 (SafeI k)) (<= (SafeI k) (Length arr))))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))
(assert (not C3))
(assert (not C4))

(check-sat)
(get-model)

------------------------------
  Test Case 5: satisfied_assert_2, violated_assert_0;assert_1;assert_3;assert_4
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True, 'assert_3': False, 'assert_4': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_2'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_3', 'assert_4'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (IsList (tail v))
         false)))
(define-fun-rec ListAllInt ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (and (is-IntVal (head v)) (ListAllInt (tail v)))
         false)))
(define-fun-rec Length ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
         (+ 1 (Length (tail v)))
         0)))
(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const arr Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (ListAllInt arr))
(define-fun C2 () Bool (and (<= 1 (Length arr)) (<= (Length arr) 100)))
(define-fun C3 () Bool (is-IntVal k))
(define-fun C4 () Bool (and (<= 1 (SafeI k)) (<= (SafeI k) (Length arr))))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)
(assert (not C3))
(assert (not C4))

(check-sat)
(get-model)

------------------------------
  Test Case 6: satisfied_assert_0;assert_2, violated_assert_1;assert_3;assert_4
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True, 'assert_3': False, 'assert_4': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2'], 'violated_contracts': ['assert_1', 'assert_3', 'assert_4'], 'total_contracts': 5}
  Solutions:
    Solution 1:
      test_case: {'arr': [3.0], 'k': 2.0}
    Solution 2:
      test_case: {'k': 4.0, 'arr': [5.0]}
    Solution 3:
      test_case: {'k': 6.0, 'arr': [7.0]}
    Solution 4:
      test_case: {'k': 9.0, 'arr': [8.0]}
    Solution 5:
      test_case: {'k': 10.0, 'arr': [11.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (IsList (tail v))
         false)))
(define-fun-rec ListAllInt ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (and (is-IntVal (head v)) (ListAllInt (tail v)))
         false)))
(define-fun-rec Length ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
         (+ 1 (Length (tail v)))
         0)))
(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const arr Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (ListAllInt arr))
(define-fun C2 () Bool (and (<= 1 (Length arr)) (<= (Length arr) 100)))
(define-fun C3 () Bool (is-IntVal k))
(define-fun C4 () Bool (and (<= 1 (SafeI k)) (<= (SafeI k) (Length arr))))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)
(assert (not C3))
(assert (not C4))

(check-sat)
(get-model)

------------------------------
  Test Case 7: satisfied_assert_1;assert_2, violated_assert_0;assert_3;assert_4
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True, 'assert_3': False, 'assert_4': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2'], 'violated_contracts': ['assert_0', 'assert_3', 'assert_4'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (IsList (tail v))
         false)))
(define-fun-rec ListAllInt ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (and (is-IntVal (head v)) (ListAllInt (tail v)))
         false)))
(define-fun-rec Length ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
         (+ 1 (Length (tail v)))
         0)))
(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const arr Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (ListAllInt arr))
(define-fun C2 () Bool (and (<= 1 (Length arr)) (<= (Length arr) 100)))
(define-fun C3 () Bool (is-IntVal k))
(define-fun C4 () Bool (and (<= 1 (SafeI k)) (<= (SafeI k) (Length arr))))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)
(assert (not C3))
(assert (not C4))

(check-sat)
(get-model)

------------------------------
  Test Case 8: satisfied_assert_0;assert_1;assert_2, violated_assert_3;assert_4
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True, 'assert_3': False, 'assert_4': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2'], 'violated_contracts': ['assert_3', 'assert_4'], 'total_contracts': 5}
  Solutions:
    Solution 1:
      test_case: {'arr': [4], 'k': 2.0}
    Solution 2:
      test_case: {'k': 3.0, 'arr': [5]}
    Solution 3:
      test_case: {'k': 4.0, 'arr': [6]}
    Solution 4:
      test_case: {'k': 5.0, 'arr': [7]}
    Solution 5:
      test_case: {'k': 6.0, 'arr': [8]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (IsList (tail v))
         false)))
(define-fun-rec ListAllInt ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (and (is-IntVal (head v)) (ListAllInt (tail v)))
         false)))
(define-fun-rec Length ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
         (+ 1 (Length (tail v)))
         0)))
(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const arr Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (ListAllInt arr))
(define-fun C2 () Bool (and (<= 1 (Length arr)) (<= (Length arr) 100)))
(define-fun C3 () Bool (is-IntVal k))
(define-fun C4 () Bool (and (<= 1 (SafeI k)) (<= (SafeI k) (Length arr))))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)
(assert (not C3))
(assert (not C4))

(check-sat)
(get-model)

------------------------------
  Test Case 9: satisfied_assert_3, violated_assert_0;assert_1;assert_2;assert_4
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False, 'assert_3': True, 'assert_4': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_3'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_4'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (IsList (tail v))
         false)))
(define-fun-rec ListAllInt ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (and (is-IntVal (head v)) (ListAllInt (tail v)))
         false)))
(define-fun-rec Length ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
         (+ 1 (Length (tail v)))
         0)))
(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const arr Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (ListAllInt arr))
(define-fun C2 () Bool (and (<= 1 (Length arr)) (<= (Length arr) 100)))
(define-fun C3 () Bool (is-IntVal k))
(define-fun C4 () Bool (and (<= 1 (SafeI k)) (<= (SafeI k) (Length arr))))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))
(assert C3)
(assert (not C4))

(check-sat)
(get-model)

------------------------------
  Test Case 10: satisfied_assert_0;assert_3, violated_assert_1;assert_2;assert_4
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False, 'assert_3': True, 'assert_4': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_3'], 'violated_contracts': ['assert_1', 'assert_2', 'assert_4'], 'total_contracts': 5}
  Solutions:
    Solution 1:
      test_case: {'arr': [38.0, 36.0, 74.0, 87.0, 56.0, 72.0, 62.0, 20.0, 32.0, 69.0, 86.0, 41.0, 68.0, 100.0, 12.0, 4.0, 93.0, 73.0, 42.0, 84.0, 94.0, 81.0, 37.0, 64.0, 76.0, 70.0, 23.0, 33.0, 39.0, 44.0, 82.0, 48.0, 78.0, 101.0, 59.0, 65.0, 2.0, 67.0, 29.0, 8.0, 88.0, 98.0, 71.0, 47.0, 27.0, 34.0, 55.0, 13.0, 40.0, 90.0, 5.0, 58.0, 96.0, 52.0, 24.0, 9.0, 97.0, 54.0, 22.0, 57.0, 50.0, 92.0, 95.0, 43.0, 53.0, 25.0, 51.0, 3.0, 85.0, 15.0, 28.0, 46.0, 6.0, 11.0, 49.0, 102.0, 17.0, 91.0, 80.0, 77.0, 79.0, 63.0, 45.0, 60.0, 83.0, 26.0, 14.0, 21.0, 10.0, 89.0, 30.0, 75.0, 18.0, 61.0, 35.0, 31.0, 66.0, 99.0, 19.0, 16.0, 7.0], 'k': 0}
    Solution 2:
      test_case: {'k': 102, 'arr': [153.0, 198.0, 137.0, 140.0, 150.0, 148.0, 131.0, 162.0, 161.0, 169.0, 104.0, 180.0, 151.0, 108.0, 129.0, 118.0, 127.0, 143.0, 202.0, 124.0, 142.0, 141.0, 119.0, 191.0, 113.0, 196.0, 128.0, 125.0, 172.0, 147.0, 195.0, 105.0, 186.0, 122.0, 152.0, 165.0, 120.0, 106.0, 176.0, 123.0, 133.0, 164.0, 112.0, 103.0, 185.0, 167.0, 126.0, 158.0, 201.0, 145.0, 190.0, 110.0, 177.0, 192.0, 183.0, 194.0, 199.0, 111.0, 132.0, 121.0, 146.0, 135.0, 116.0, 178.0, 109.0, 179.0, 188.0, 130.0, 160.0, 182.0, 175.0, 193.0, 168.0, 174.0, 170.0, 156.0, 149.0, 203.0, 157.0, 171.0, 187.0, 184.0, 159.0, 163.0, 107.0, 115.0, 139.0, 138.0, 181.0, 197.0, 134.0, 144.0, 189.0, 173.0, 117.0, 136.0, 154.0, 155.0, 166.0, 114.0, 200.0]}
    Solution 3:
      test_case: {'k': 102, 'arr': [268.0, 304.0, 236.0, 261.0, 232.0, 298.0, 248.0, 297.0, 243.0, 295.0, 258.0, 283.0, 285.0, 235.0, 292.0, 284.0, 238.0, 303.0, 269.0, 224.0, 276.0, 240.0, 213.0, 300.0, 221.0, 271.0, 293.0, 228.0, 205.0, 226.0, 210.0, 211.0, 253.0, 225.0, 289.0, 259.0, 217.0, 227.0, 275.0, 234.0, 214.0, 239.0, 249.0, 279.0, 229.0, 260.0, 291.0, 288.0, 246.0, 256.0, 242.0, 270.0, 241.0, 296.0, 208.0, 247.0, 251.0, 290.0, 287.0, 257.0, 250.0, 254.0, 263.0, 245.0, 280.0, 265.0, 282.0, 222.0, 299.0, 215.0, 237.0, 266.0, 274.0, 255.0, 264.0, 209.0, 244.0, 267.0, 207.0, 273.0, 223.0, 262.0, 278.0, 220.0, 216.0, 301.0, 204.0, 252.0, 230.0, 233.0, 277.0, 281.0, 231.0, 272.0, 219.0, 294.0, 212.0, 286.0, 206.0, 302.0, 218.0]}
    Solution 4:
      test_case: {'k': 102, 'arr': [326.0, 360.0, 337.0, 376.0, 385.0, 347.0, 383.0, 349.0, 390.0, 400.0, 315.0, 380.0, 359.0, 388.0, 353.0, 351.0, 335.0, 313.0, 371.0, 357.0, 306.0, 317.0, 395.0, 378.0, 332.0, 316.0, 344.0, 403.0, 330.0, 324.0, 342.0, 319.0, 368.0, 382.0, 323.0, 352.0, 320.0, 361.0, 356.0, 314.0, 336.0, 389.0, 381.0, 401.0, 311.0, 346.0, 334.0, 369.0, 333.0, 341.0, 404.0, 364.0, 394.0, 398.0, 370.0, 309.0, 312.0, 402.0, 345.0, 362.0, 393.0, 343.0, 327.0, 405.0, 325.0, 391.0, 366.0, 354.0, 339.0, 386.0, 384.0, 307.0, 318.0, 329.0, 328.0, 350.0, 397.0, 392.0, 365.0, 308.0, 338.0, 374.0, 363.0, 305.0, 348.0, 355.0, 372.0, 340.0, 321.0, 310.0, 367.0, 377.0, 375.0, 322.0, 373.0, 399.0, 331.0, 387.0, 358.0, 396.0, 379.0]}
    Solution 5:
      test_case: {'k': 27590, 'arr': [500.0, 505.0, 446.0, 407.0, 450.0, 409.0, 451.0, 440.0, 448.0, 477.0, 423.0, 430.0, 464.0, 485.0, 463.0, 466.0, 497.0, 492.0, 413.0, 504.0, 436.0, 422.0, 454.0, 457.0, 420.0, 494.0, 408.0, 491.0, 478.0, 484.0, 417.0, 482.0, 415.0, 469.0, 473.0, 442.0, 496.0, 480.0, 462.0, 445.0, 410.0, 495.0, 406.0, 434.0, 501.0, 476.0, 411.0, 447.0, 418.0, 438.0, 429.0, 499.0, 474.0, 479.0, 421.0, 414.0, 444.0, 435.0, 475.0, 439.0, 428.0, 490.0, 416.0, 503.0, 431.0, 493.0, 481.0, 449.0, 460.0, 470.0, 443.0, 437.0, 425.0, 419.0, 412.0, 471.0, 453.0, 465.0, 502.0, 433.0, 432.0, 424.0, 498.0, 461.0, 426.0, 506.0, 427.0, 489.0, 441.0, 488.0, 455.0, 483.0, 452.0, 487.0, 486.0, 456.0, 472.0, 459.0, 458.0, 467.0, 468.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (IsList (tail v))
         false)))
(define-fun-rec ListAllInt ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (and (is-IntVal (head v)) (ListAllInt (tail v)))
         false)))
(define-fun-rec Length ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
         (+ 1 (Length (tail v)))
         0)))
(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const arr Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (ListAllInt arr))
(define-fun C2 () Bool (and (<= 1 (Length arr)) (<= (Length arr) 100)))
(define-fun C3 () Bool (is-IntVal k))
(define-fun C4 () Bool (and (<= 1 (SafeI k)) (<= (SafeI k) (Length arr))))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))
(assert C3)
(assert (not C4))

(check-sat)
(get-model)

------------------------------
  Test Case 11: satisfied_assert_1;assert_3, violated_assert_0;assert_2;assert_4
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False, 'assert_3': True, 'assert_4': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_3'], 'violated_contracts': ['assert_0', 'assert_2', 'assert_4'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (IsList (tail v))
         false)))
(define-fun-rec ListAllInt ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (and (is-IntVal (head v)) (ListAllInt (tail v)))
         false)))
(define-fun-rec Length ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
         (+ 1 (Length (tail v)))
         0)))
(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const arr Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (ListAllInt arr))
(define-fun C2 () Bool (and (<= 1 (Length arr)) (<= (Length arr) 100)))
(define-fun C3 () Bool (is-IntVal k))
(define-fun C4 () Bool (and (<= 1 (SafeI k)) (<= (SafeI k) (Length arr))))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))
(assert C3)
(assert (not C4))

(check-sat)
(get-model)

------------------------------
  Test Case 12: satisfied_assert_0;assert_1;assert_3, violated_assert_2;assert_4
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False, 'assert_3': True, 'assert_4': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_3'], 'violated_contracts': ['assert_2', 'assert_4'], 'total_contracts': 5}
  Solutions:
    Solution 1:
      test_case: {'arr': [], 'k': 1}
    Solution 2:
      test_case: {'k': 8856, 'arr': []}
    Solution 3:
      test_case: {'arr': [], 'k': 19306}
    Solution 4:
      test_case: {'k': 20448, 'arr': []}
    Solution 5:
      test_case: {'k': 29393, 'arr': []}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (IsList (tail v))
         false)))
(define-fun-rec ListAllInt ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (and (is-IntVal (head v)) (ListAllInt (tail v)))
         false)))
(define-fun-rec Length ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
         (+ 1 (Length (tail v)))
         0)))
(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const arr Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (ListAllInt arr))
(define-fun C2 () Bool (and (<= 1 (Length arr)) (<= (Length arr) 100)))
(define-fun C3 () Bool (is-IntVal k))
(define-fun C4 () Bool (and (<= 1 (SafeI k)) (<= (SafeI k) (Length arr))))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))
(assert C3)
(assert (not C4))

(check-sat)
(get-model)

------------------------------
  Test Case 13: satisfied_assert_2;assert_3, violated_assert_0;assert_1;assert_4
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True, 'assert_3': True, 'assert_4': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_2', 'assert_3'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_4'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (IsList (tail v))
         false)))
(define-fun-rec ListAllInt ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (and (is-IntVal (head v)) (ListAllInt (tail v)))
         false)))
(define-fun-rec Length ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
         (+ 1 (Length (tail v)))
         0)))
(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const arr Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (ListAllInt arr))
(define-fun C2 () Bool (and (<= 1 (Length arr)) (<= (Length arr) 100)))
(define-fun C3 () Bool (is-IntVal k))
(define-fun C4 () Bool (and (<= 1 (SafeI k)) (<= (SafeI k) (Length arr))))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)
(assert C3)
(assert (not C4))

(check-sat)
(get-model)

------------------------------
  Test Case 14: satisfied_assert_0;assert_2;assert_3, violated_assert_1;assert_4
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True, 'assert_3': True, 'assert_4': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2', 'assert_3'], 'violated_contracts': ['assert_1', 'assert_4'], 'total_contracts': 5}
  Solutions:
    Solution 1:
      test_case: {'arr': [2.0], 'k': 0}
    Solution 2:
      test_case: {'k': 2, 'arr': [3.0]}
    Solution 3:
      test_case: {'k': 2, 'arr': [4.0]}
    Solution 4:
      test_case: {'k': 2, 'arr': [5.0]}
    Solution 5:
      test_case: {'arr': [6.0], 'k': 20539}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (IsList (tail v))
         false)))
(define-fun-rec ListAllInt ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (and (is-IntVal (head v)) (ListAllInt (tail v)))
         false)))
(define-fun-rec Length ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
         (+ 1 (Length (tail v)))
         0)))
(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const arr Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (ListAllInt arr))
(define-fun C2 () Bool (and (<= 1 (Length arr)) (<= (Length arr) 100)))
(define-fun C3 () Bool (is-IntVal k))
(define-fun C4 () Bool (and (<= 1 (SafeI k)) (<= (SafeI k) (Length arr))))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)
(assert C3)
(assert (not C4))

(check-sat)
(get-model)

------------------------------
  Test Case 15: satisfied_assert_1;assert_2;assert_3, violated_assert_0;assert_4
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True, 'assert_3': True, 'assert_4': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2', 'assert_3'], 'violated_contracts': ['assert_0', 'assert_4'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (IsList (tail v))
         false)))
(define-fun-rec ListAllInt ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (and (is-IntVal (head v)) (ListAllInt (tail v)))
         false)))
(define-fun-rec Length ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
         (+ 1 (Length (tail v)))
         0)))
(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const arr Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (ListAllInt arr))
(define-fun C2 () Bool (and (<= 1 (Length arr)) (<= (Length arr) 100)))
(define-fun C3 () Bool (is-IntVal k))
(define-fun C4 () Bool (and (<= 1 (SafeI k)) (<= (SafeI k) (Length arr))))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)
(assert C3)
(assert (not C4))

(check-sat)
(get-model)

------------------------------
  Test Case 16: satisfied_assert_0;assert_1;assert_2;assert_3, violated_assert_4
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True, 'assert_3': True, 'assert_4': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_3'], 'violated_contracts': ['assert_4'], 'total_contracts': 5}
  Solutions:
    Solution 1:
      test_case: {'arr': [4], 'k': 0}
    Solution 2:
      test_case: {'k': 2, 'arr': [6]}
    Solution 3:
      test_case: {'arr': [7], 'k': 2}
    Solution 4:
      test_case: {'k': 2, 'arr': [8]}
    Solution 5:
      test_case: {'k': 28883, 'arr': [9]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (IsList (tail v))
         false)))
(define-fun-rec ListAllInt ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (and (is-IntVal (head v)) (ListAllInt (tail v)))
         false)))
(define-fun-rec Length ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
         (+ 1 (Length (tail v)))
         0)))
(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const arr Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (ListAllInt arr))
(define-fun C2 () Bool (and (<= 1 (Length arr)) (<= (Length arr) 100)))
(define-fun C3 () Bool (is-IntVal k))
(define-fun C4 () Bool (and (<= 1 (SafeI k)) (<= (SafeI k) (Length arr))))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)
(assert C3)
(assert (not C4))

(check-sat)
(get-model)

------------------------------
  Test Case 17: satisfied_assert_4, violated_assert_0;assert_1;assert_2;assert_3
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False, 'assert_3': False, 'assert_4': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_4'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_3'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (IsList (tail v))
         false)))
(define-fun-rec ListAllInt ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (and (is-IntVal (head v)) (ListAllInt (tail v)))
         false)))
(define-fun-rec Length ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
         (+ 1 (Length (tail v)))
         0)))
(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const arr Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (ListAllInt arr))
(define-fun C2 () Bool (and (<= 1 (Length arr)) (<= (Length arr) 100)))
(define-fun C3 () Bool (is-IntVal k))
(define-fun C4 () Bool (and (<= 1 (SafeI k)) (<= (SafeI k) (Length arr))))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))
(assert (not C3))
(assert C4)

(check-sat)
(get-model)

------------------------------
  Test Case 18: satisfied_assert_0;assert_4, violated_assert_1;assert_2;assert_3
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False, 'assert_3': False, 'assert_4': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_4'], 'violated_contracts': ['assert_1', 'assert_2', 'assert_3'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (IsList (tail v))
         false)))
(define-fun-rec ListAllInt ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (and (is-IntVal (head v)) (ListAllInt (tail v)))
         false)))
(define-fun-rec Length ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
         (+ 1 (Length (tail v)))
         0)))
(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const arr Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (ListAllInt arr))
(define-fun C2 () Bool (and (<= 1 (Length arr)) (<= (Length arr) 100)))
(define-fun C3 () Bool (is-IntVal k))
(define-fun C4 () Bool (and (<= 1 (SafeI k)) (<= (SafeI k) (Length arr))))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))
(assert (not C3))
(assert C4)

(check-sat)
(get-model)

------------------------------
  Test Case 19: satisfied_assert_1;assert_4, violated_assert_0;assert_2;assert_3
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False, 'assert_3': False, 'assert_4': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_4'], 'violated_contracts': ['assert_0', 'assert_2', 'assert_3'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (IsList (tail v))
         false)))
(define-fun-rec ListAllInt ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (and (is-IntVal (head v)) (ListAllInt (tail v)))
         false)))
(define-fun-rec Length ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
         (+ 1 (Length (tail v)))
         0)))
(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const arr Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (ListAllInt arr))
(define-fun C2 () Bool (and (<= 1 (Length arr)) (<= (Length arr) 100)))
(define-fun C3 () Bool (is-IntVal k))
(define-fun C4 () Bool (and (<= 1 (SafeI k)) (<= (SafeI k) (Length arr))))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))
(assert (not C3))
(assert C4)

(check-sat)
(get-model)

------------------------------
  Test Case 20: satisfied_assert_0;assert_1;assert_4, violated_assert_2;assert_3
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False, 'assert_3': False, 'assert_4': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_4'], 'violated_contracts': ['assert_2', 'assert_3'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (IsList (tail v))
         false)))
(define-fun-rec ListAllInt ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (and (is-IntVal (head v)) (ListAllInt (tail v)))
         false)))
(define-fun-rec Length ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
         (+ 1 (Length (tail v)))
         0)))
(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const arr Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (ListAllInt arr))
(define-fun C2 () Bool (and (<= 1 (Length arr)) (<= (Length arr) 100)))
(define-fun C3 () Bool (is-IntVal k))
(define-fun C4 () Bool (and (<= 1 (SafeI k)) (<= (SafeI k) (Length arr))))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))
(assert (not C3))
(assert C4)

(check-sat)
(get-model)

------------------------------
  Test Case 21: satisfied_assert_2;assert_4, violated_assert_0;assert_1;assert_3
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True, 'assert_3': False, 'assert_4': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_2', 'assert_4'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_3'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (IsList (tail v))
         false)))
(define-fun-rec ListAllInt ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (and (is-IntVal (head v)) (ListAllInt (tail v)))
         false)))
(define-fun-rec Length ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
         (+ 1 (Length (tail v)))
         0)))
(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const arr Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (ListAllInt arr))
(define-fun C2 () Bool (and (<= 1 (Length arr)) (<= (Length arr) 100)))
(define-fun C3 () Bool (is-IntVal k))
(define-fun C4 () Bool (and (<= 1 (SafeI k)) (<= (SafeI k) (Length arr))))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)
(assert (not C3))
(assert C4)

(check-sat)
(get-model)

------------------------------
  Test Case 22: satisfied_assert_0;assert_2;assert_4, violated_assert_1;assert_3
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True, 'assert_3': False, 'assert_4': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2', 'assert_4'], 'violated_contracts': ['assert_1', 'assert_3'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (IsList (tail v))
         false)))
(define-fun-rec ListAllInt ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (and (is-IntVal (head v)) (ListAllInt (tail v)))
         false)))
(define-fun-rec Length ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
         (+ 1 (Length (tail v)))
         0)))
(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const arr Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (ListAllInt arr))
(define-fun C2 () Bool (and (<= 1 (Length arr)) (<= (Length arr) 100)))
(define-fun C3 () Bool (is-IntVal k))
(define-fun C4 () Bool (and (<= 1 (SafeI k)) (<= (SafeI k) (Length arr))))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)
(assert (not C3))
(assert C4)

(check-sat)
(get-model)

------------------------------
  Test Case 23: satisfied_assert_1;assert_2;assert_4, violated_assert_0;assert_3
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True, 'assert_3': False, 'assert_4': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2', 'assert_4'], 'violated_contracts': ['assert_0', 'assert_3'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (IsList (tail v))
         false)))
(define-fun-rec ListAllInt ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (and (is-IntVal (head v)) (ListAllInt (tail v)))
         false)))
(define-fun-rec Length ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
         (+ 1 (Length (tail v)))
         0)))
(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const arr Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (ListAllInt arr))
(define-fun C2 () Bool (and (<= 1 (Length arr)) (<= (Length arr) 100)))
(define-fun C3 () Bool (is-IntVal k))
(define-fun C4 () Bool (and (<= 1 (SafeI k)) (<= (SafeI k) (Length arr))))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)
(assert (not C3))
(assert C4)

(check-sat)
(get-model)

------------------------------
  Test Case 24: satisfied_assert_0;assert_1;assert_2;assert_4, violated_assert_3
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True, 'assert_3': False, 'assert_4': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_4'], 'violated_contracts': ['assert_3'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (IsList (tail v))
         false)))
(define-fun-rec ListAllInt ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (and (is-IntVal (head v)) (ListAllInt (tail v)))
         false)))
(define-fun-rec Length ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
         (+ 1 (Length (tail v)))
         0)))
(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const arr Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (ListAllInt arr))
(define-fun C2 () Bool (and (<= 1 (Length arr)) (<= (Length arr) 100)))
(define-fun C3 () Bool (is-IntVal k))
(define-fun C4 () Bool (and (<= 1 (SafeI k)) (<= (SafeI k) (Length arr))))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)
(assert (not C3))
(assert C4)

(check-sat)
(get-model)

------------------------------
  Test Case 25: satisfied_assert_3;assert_4, violated_assert_0;assert_1;assert_2
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False, 'assert_3': True, 'assert_4': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_3', 'assert_4'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (IsList (tail v))
         false)))
(define-fun-rec ListAllInt ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (and (is-IntVal (head v)) (ListAllInt (tail v)))
         false)))
(define-fun-rec Length ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
         (+ 1 (Length (tail v)))
         0)))
(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const arr Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (ListAllInt arr))
(define-fun C2 () Bool (and (<= 1 (Length arr)) (<= (Length arr) 100)))
(define-fun C3 () Bool (is-IntVal k))
(define-fun C4 () Bool (and (<= 1 (SafeI k)) (<= (SafeI k) (Length arr))))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))
(assert C3)
(assert C4)

(check-sat)
(get-model)

------------------------------
  Test Case 26: satisfied_assert_0;assert_3;assert_4, violated_assert_1;assert_2
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False, 'assert_3': True, 'assert_4': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_3', 'assert_4'], 'violated_contracts': ['assert_1', 'assert_2'], 'total_contracts': 5}
  Solutions:
    Solution 1:
      test_case: {'arr': [70.0, 84.0, 30.0, 93.0, 82.0, 65.0, 16.0, 17.0, 73.0, 41.0, 60.0, 85.0, 50.0, 43.0, 44.0, 102.0, 13.0, 22.0, 66.0, 15.0, 31.0, 68.0, 42.0, 40.0, 55.0, 61.0, 12.0, 96.0, 80.0, 26.0, 79.0, 4.0, 53.0, 88.0, 37.0, 75.0, 59.0, 3.0, 72.0, 98.0, 97.0, 25.0, 19.0, 27.0, 89.0, 18.0, 69.0, 49.0, 57.0, 38.0, 46.0, 24.0, 76.0, 32.0, 78.0, 48.0, 83.0, 77.0, 87.0, 92.0, 8.0, 20.0, 33.0, 23.0, 52.0, 39.0, 94.0, 71.0, 54.0, 36.0, 62.0, 51.0, 56.0, 2.0, 47.0, 91.0, 9.0, 100.0, 95.0, 81.0, 45.0, 7.0, 28.0, 86.0, 6.0, 21.0, 67.0, 35.0, 99.0, 101.0, 29.0, 11.0, 64.0, 5.0, 74.0, 90.0, 14.0, 63.0, 34.0, 10.0, 58.0], 'k': 101}
    Solution 2:
      test_case: {'k': 17, 'arr': [156.0, 179.0, 166.0, 134.0, 160.0, 186.0, 175.0, 187.0, 122.0, 189.0, 121.0, 104.0, 195.0, 149.0, 146.0, 124.0, 125.0, 152.0, 154.0, 127.0, 162.0, 167.0, 113.0, 141.0, 184.0, 177.0, 114.0, 144.0, 133.0, 174.0, 130.0, 157.0, 173.0, 188.0, 153.0, 151.0, 201.0, 109.0, 129.0, 191.0, 135.0, 163.0, 164.0, 112.0, 136.0, 198.0, 117.0, 147.0, 110.0, 120.0, 131.0, 139.0, 159.0, 115.0, 202.0, 182.0, 203.0, 192.0, 197.0, 143.0, 170.0, 171.0, 137.0, 183.0, 172.0, 119.0, 138.0, 108.0, 126.0, 190.0, 111.0, 169.0, 199.0, 123.0, 128.0, 140.0, 176.0, 150.0, 158.0, 194.0, 148.0, 118.0, 105.0, 155.0, 145.0, 196.0, 180.0, 178.0, 185.0, 193.0, 168.0, 103.0, 116.0, 132.0, 142.0, 106.0, 181.0, 107.0, 161.0, 200.0, 165.0]}
    Solution 3:
      test_case: {'k': 23, 'arr': [245.0, 297.0, 290.0, 277.0, 248.0, 221.0, 214.0, 298.0, 204.0, 269.0, 234.0, 273.0, 207.0, 278.0, 233.0, 293.0, 285.0, 260.0, 215.0, 244.0, 300.0, 302.0, 235.0, 250.0, 287.0, 267.0, 213.0, 218.0, 225.0, 240.0, 228.0, 258.0, 222.0, 246.0, 254.0, 288.0, 255.0, 259.0, 227.0, 231.0, 219.0, 296.0, 209.0, 232.0, 216.0, 226.0, 304.0, 212.0, 211.0, 220.0, 205.0, 272.0, 266.0, 275.0, 264.0, 291.0, 274.0, 257.0, 208.0, 262.0, 294.0, 271.0, 242.0, 299.0, 251.0, 239.0, 303.0, 265.0, 292.0, 268.0, 206.0, 238.0, 223.0, 236.0, 224.0, 295.0, 247.0, 263.0, 279.0, 229.0, 230.0, 241.0, 284.0, 243.0, 261.0, 256.0, 252.0, 289.0, 280.0, 270.0, 286.0, 253.0, 276.0, 210.0, 282.0, 301.0, 283.0, 249.0, 237.0, 281.0, 217.0]}
    Solution 4:
      test_case: {'k': 88, 'arr': [379.0, 382.0, 390.0, 378.0, 351.0, 307.0, 317.0, 397.0, 322.0, 328.0, 335.0, 388.0, 402.0, 324.0, 394.0, 320.0, 311.0, 331.0, 305.0, 343.0, 395.0, 377.0, 391.0, 353.0, 352.0, 399.0, 380.0, 348.0, 345.0, 308.0, 384.0, 341.0, 333.0, 362.0, 323.0, 340.0, 318.0, 404.0, 373.0, 370.0, 376.0, 338.0, 336.0, 386.0, 319.0, 316.0, 347.0, 329.0, 360.0, 342.0, 381.0, 361.0, 314.0, 400.0, 389.0, 405.0, 401.0, 365.0, 396.0, 321.0, 372.0, 354.0, 337.0, 312.0, 350.0, 327.0, 398.0, 392.0, 325.0, 349.0, 356.0, 310.0, 332.0, 366.0, 367.0, 315.0, 374.0, 339.0, 383.0, 355.0, 385.0, 387.0, 375.0, 359.0, 357.0, 313.0, 344.0, 326.0, 330.0, 403.0, 306.0, 369.0, 363.0, 334.0, 309.0, 346.0, 358.0, 393.0, 368.0, 364.0, 371.0]}
    Solution 5:
      test_case: {'k': 33, 'arr': [490.0, 493.0, 431.0, 428.0, 409.0, 460.0, 451.0, 443.0, 475.0, 418.0, 505.0, 440.0, 424.0, 452.0, 432.0, 444.0, 468.0, 472.0, 455.0, 438.0, 478.0, 499.0, 506.0, 495.0, 457.0, 479.0, 437.0, 464.0, 416.0, 469.0, 450.0, 485.0, 497.0, 406.0, 447.0, 492.0, 494.0, 425.0, 458.0, 436.0, 427.0, 448.0, 446.0, 442.0, 445.0, 415.0, 413.0, 433.0, 500.0, 435.0, 429.0, 483.0, 473.0, 408.0, 456.0, 502.0, 419.0, 421.0, 481.0, 453.0, 414.0, 486.0, 462.0, 477.0, 467.0, 412.0, 480.0, 430.0, 484.0, 471.0, 463.0, 454.0, 470.0, 465.0, 501.0, 426.0, 407.0, 417.0, 496.0, 439.0, 498.0, 461.0, 420.0, 503.0, 410.0, 423.0, 459.0, 487.0, 476.0, 449.0, 441.0, 504.0, 422.0, 491.0, 482.0, 434.0, 488.0, 411.0, 474.0, 489.0, 466.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (IsList (tail v))
         false)))
(define-fun-rec ListAllInt ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (and (is-IntVal (head v)) (ListAllInt (tail v)))
         false)))
(define-fun-rec Length ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
         (+ 1 (Length (tail v)))
         0)))
(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const arr Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (ListAllInt arr))
(define-fun C2 () Bool (and (<= 1 (Length arr)) (<= (Length arr) 100)))
(define-fun C3 () Bool (is-IntVal k))
(define-fun C4 () Bool (and (<= 1 (SafeI k)) (<= (SafeI k) (Length arr))))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))
(assert C3)
(assert C4)

(check-sat)
(get-model)

------------------------------
  Test Case 27: satisfied_assert_1;assert_3;assert_4, violated_assert_0;assert_2
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False, 'assert_3': True, 'assert_4': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_3', 'assert_4'], 'violated_contracts': ['assert_0', 'assert_2'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (IsList (tail v))
         false)))
(define-fun-rec ListAllInt ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (and (is-IntVal (head v)) (ListAllInt (tail v)))
         false)))
(define-fun-rec Length ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
         (+ 1 (Length (tail v)))
         0)))
(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const arr Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (ListAllInt arr))
(define-fun C2 () Bool (and (<= 1 (Length arr)) (<= (Length arr) 100)))
(define-fun C3 () Bool (is-IntVal k))
(define-fun C4 () Bool (and (<= 1 (SafeI k)) (<= (SafeI k) (Length arr))))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))
(assert C3)
(assert C4)

(check-sat)
(get-model)

------------------------------
  Test Case 28: satisfied_assert_0;assert_1;assert_3;assert_4, violated_assert_2
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False, 'assert_3': True, 'assert_4': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_3', 'assert_4'], 'violated_contracts': ['assert_2'], 'total_contracts': 5}
  Solutions:
    Solution 1:
      test_case: {'arr': [105, 107, 109, 111, 113, 115, 117, 119, 121, 123, 125, 127, 129, 131, 133, 135, 137, 139, 141, 143, 145, 147, 149, 151, 153, 155, 157, 159, 161, 163, 165, 167, 169, 171, 173, 175, 177, 179, 181, 183, 185, 187, 189, 191, 193, 195, 197, 199, 201, 203, 205, 207, 209, 211, 213, 215, 217, 219, 221, 223, 225, 227, 229, 231, 233, 235, 237, 239, 241, 243, 245, 247, 249, 251, 253, 255, 257, 259, 261, 263, 265, 267, 269, 271, 273, 275, 277, 279, 281, 283, 285, 287, 289, 291, 293, 295, 297, 299, 301, 303, 305], 'k': 101}
    Solution 2:
      test_case: {'k': 17, 'arr': [106, 110, 114, 118, 122, 126, 130, 134, 138, 142, 146, 150, 154, 158, 162, 166, 170, 174, 178, 182, 186, 190, 194, 198, 202, 206, 210, 214, 218, 222, 226, 230, 234, 238, 242, 246, 250, 254, 258, 262, 266, 270, 274, 278, 282, 286, 290, 294, 298, 302, 306, 308, 310, 312, 314, 316, 318, 320, 322, 324, 326, 328, 330, 332, 334, 336, 338, 340, 342, 344, 346, 348, 350, 352, 354, 356, 358, 360, 362, 364, 366, 368, 370, 372, 374, 376, 378, 380, 382, 384, 386, 388, 390, 392, 394, 396, 398, 400, 402, 404, 406]}
    Solution 3:
      test_case: {'k': 17, 'arr': [108, 116, 124, 132, 140, 148, 156, 164, 172, 180, 188, 196, 204, 212, 220, 228, 236, 244, 252, 260, 268, 276, 284, 292, 300, 307, 311, 315, 319, 323, 327, 331, 335, 339, 343, 347, 351, 355, 359, 363, 367, 371, 375, 379, 383, 387, 391, 395, 399, 403, 407, 409, 411, 413, 415, 417, 419, 421, 423, 425, 427, 429, 431, 433, 435, 437, 439, 441, 443, 445, 447, 449, 451, 453, 455, 457, 459, 461, 463, 465, 467, 469, 471, 473, 475, 477, 479, 481, 483, 485, 487, 489, 491, 493, 495, 497, 499, 501, 503, 505, 507]}
    Solution 4:
      test_case: {'k': 17, 'arr': [112, 128, 144, 160, 176, 192, 208, 224, 240, 256, 272, 288, 304, 313, 321, 329, 337, 345, 353, 361, 369, 377, 385, 393, 401, 408, 412, 416, 420, 424, 428, 432, 436, 440, 444, 448, 452, 456, 460, 464, 468, 472, 476, 480, 484, 488, 492, 496, 500, 504, 508, 510, 512, 514, 516, 518, 520, 522, 524, 526, 528, 530, 532, 534, 536, 538, 540, 542, 544, 546, 548, 550, 552, 554, 556, 558, 560, 562, 564, 566, 568, 570, 572, 574, 576, 578, 580, 582, 584, 586, 588, 590, 592, 594, 596, 598, 600, 602, 604, 606, 608]}
    Solution 5:
      test_case: {'k': 17, 'arr': [120, 152, 184, 216, 248, 280, 309, 325, 341, 357, 373, 389, 405, 414, 422, 430, 438, 446, 454, 462, 470, 478, 486, 494, 502, 509, 513, 517, 521, 525, 529, 533, 537, 541, 545, 549, 553, 557, 561, 565, 569, 573, 577, 581, 585, 589, 593, 597, 601, 605, 609, 611, 613, 615, 617, 619, 621, 623, 625, 627, 629, 631, 633, 635, 637, 639, 641, 643, 645, 647, 649, 651, 653, 655, 657, 659, 661, 663, 665, 667, 669, 671, 673, 675, 677, 679, 681, 683, 685, 687, 689, 691, 693, 695, 697, 699, 701, 703, 705, 707, 709]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (IsList (tail v))
         false)))
(define-fun-rec ListAllInt ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (and (is-IntVal (head v)) (ListAllInt (tail v)))
         false)))
(define-fun-rec Length ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
         (+ 1 (Length (tail v)))
         0)))
(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const arr Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (ListAllInt arr))
(define-fun C2 () Bool (and (<= 1 (Length arr)) (<= (Length arr) 100)))
(define-fun C3 () Bool (is-IntVal k))
(define-fun C4 () Bool (and (<= 1 (SafeI k)) (<= (SafeI k) (Length arr))))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))
(assert C3)
(assert C4)

(check-sat)
(get-model)

------------------------------
  Test Case 29: satisfied_assert_2;assert_3;assert_4, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True, 'assert_3': True, 'assert_4': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_2', 'assert_3', 'assert_4'], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (IsList (tail v))
         false)))
(define-fun-rec ListAllInt ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (and (is-IntVal (head v)) (ListAllInt (tail v)))
         false)))
(define-fun-rec Length ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
         (+ 1 (Length (tail v)))
         0)))
(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const arr Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (ListAllInt arr))
(define-fun C2 () Bool (and (<= 1 (Length arr)) (<= (Length arr) 100)))
(define-fun C3 () Bool (is-IntVal k))
(define-fun C4 () Bool (and (<= 1 (SafeI k)) (<= (SafeI k) (Length arr))))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)
(assert C3)
(assert C4)

(check-sat)
(get-model)

------------------------------
  Test Case 30: satisfied_assert_0;assert_2;assert_3;assert_4, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True, 'assert_3': True, 'assert_4': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2', 'assert_3', 'assert_4'], 'violated_contracts': ['assert_1'], 'total_contracts': 5}
  Solutions:
    Solution 1:
      test_case: {'arr': [2.0], 'k': 1}
    Solution 2:
      test_case: {'k': 1, 'arr': [3.0]}
    Solution 3:
      test_case: {'k': 1, 'arr': [4.0]}
    Solution 4:
      test_case: {'k': 1, 'arr': [5.0]}
    Solution 5:
      test_case: {'k': 1, 'arr': [6.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (IsList (tail v))
         false)))
(define-fun-rec ListAllInt ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (and (is-IntVal (head v)) (ListAllInt (tail v)))
         false)))
(define-fun-rec Length ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
         (+ 1 (Length (tail v)))
         0)))
(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const arr Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (ListAllInt arr))
(define-fun C2 () Bool (and (<= 1 (Length arr)) (<= (Length arr) 100)))
(define-fun C3 () Bool (is-IntVal k))
(define-fun C4 () Bool (and (<= 1 (SafeI k)) (<= (SafeI k) (Length arr))))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)
(assert C3)
(assert C4)

(check-sat)
(get-model)

------------------------------
  Test Case 31: satisfied_assert_1;assert_2;assert_3;assert_4, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True, 'assert_3': True, 'assert_4': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2', 'assert_3', 'assert_4'], 'violated_contracts': ['assert_0'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (IsList (tail v))
         false)))
(define-fun-rec ListAllInt ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (and (is-IntVal (head v)) (ListAllInt (tail v)))
         false)))
(define-fun-rec Length ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
         (+ 1 (Length (tail v)))
         0)))
(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const arr Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (ListAllInt arr))
(define-fun C2 () Bool (and (<= 1 (Length arr)) (<= (Length arr) 100)))
(define-fun C3 () Bool (is-IntVal k))
(define-fun C4 () Bool (and (<= 1 (SafeI k)) (<= (SafeI k) (Length arr))))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)
(assert C3)
(assert C4)

(check-sat)
(get-model)

------------------------------
  Test Case 32: satisfied_assert_0;assert_1;assert_2;assert_3;assert_4, violated_
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True, 'assert_3': True, 'assert_4': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_3', 'assert_4'], 'violated_contracts': [], 'total_contracts': 5}
  Solutions:
    Solution 1:
      test_case: {'arr': [4], 'k': 1}
    Solution 2:
      test_case: {'k': 1, 'arr': [6]}
    Solution 3:
      test_case: {'k': 1, 'arr': [7]}
    Solution 4:
      test_case: {'k': 1, 'arr': [8]}
    Solution 5:
      test_case: {'arr': [9], 'k': 1}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (IsList (tail v))
         false)))
(define-fun-rec ListAllInt ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
         (and (is-IntVal (head v)) (ListAllInt (tail v)))
         false)))
(define-fun-rec Length ((v Value)) Int
  (ite (is-Nil v) 0
    (ite (is-Cons v)
         (+ 1 (Length (tail v)))
         0)))
(define-fun SafeI ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const arr Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (ListAllInt arr))
(define-fun C2 () Bool (and (<= 1 (Length arr)) (<= (Length arr) 100)))
(define-fun C3 () Bool (is-IntVal k))
(define-fun C4 () Bool (and (<= 1 (SafeI k)) (<= (SafeI k) (Length arr))))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)
(assert C3)
(assert C4)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/123 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun get-int ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===
(assert (is-IntVal n))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))
(define-fun C1 () Bool (> (get-int n) 0))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'n': 0}
    Solution 2:
      test_case: {'n': -7719}
    Solution 3:
      test_case: {'n': -10156}
    Solution 4:
      test_case: {'n': -21953}
    Solution 5:
      test_case: {'n': -54238}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun get-int ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===
(assert (is-IntVal n))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))
(define-fun C1 () Bool (> (get-int n) 0))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun get-int ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===
(assert (is-IntVal n))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))
(define-fun C1 () Bool (> (get-int n) 0))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'n': 1}
    Solution 2:
      test_case: {'n': 7720}
    Solution 3:
      test_case: {'n': 10157}
    Solution 4:
      test_case: {'n': 21954}
    Solution 5:
      test_case: {'n': 54239}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun get-int ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===
(assert (is-IntVal n))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))
(define-fun C1 () Bool (> (get-int n) 0))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/124 ===
  Test Case 1: satisfied_, violated_assert_0
  Combination: {'assert_0': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0'], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'date': 2.0}
    Solution 2:
      test_case: {'date': 3.0}
    Solution 3:
      test_case: {'date': 4.0}
    Solution 4:
      test_case: {'date': 5.0}
    Solution 5:
      test_case: {'date': 6.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeS ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

(define-fun s_len ((v Value)) Int
  (str.len (SafeS v)))

(define-fun s_char ((v Value) (i Int)) String
  (str.substr (SafeS v) i 1))

(define-fun str_to_int2 ((v Value)) Int
  (let ((s (SafeS v))
        (c0 (str.substr (SafeS v) 0 1))
        (c1 (str.substr (SafeS v) 1 1)))
    (+ (* (- (str.to_code c0) 48) 10)
       (- (str.to_code c1) 48))))

; === Inputs ===
(declare-const date Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal date))

; === COMBINATION ===
(assert (not C0))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_
  Combination: {'assert_0': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': [], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'date': '!0!'}
    Solution 2:
      test_case: {'date': '!'}
    Solution 3:
      test_case: {'date': '0'}
    Solution 4:
      test_case: {'date': '0!'}
    Solution 5:
      test_case: {'date': ''}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeS ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))

(define-fun s_len ((v Value)) Int
  (str.len (SafeS v)))

(define-fun s_char ((v Value) (i Int)) String
  (str.substr (SafeS v) i 1))

(define-fun str_to_int2 ((v Value)) Int
  (let ((s (SafeS v))
        (c0 (str.substr (SafeS v) 0 1))
        (c1 (str.substr (SafeS v) 1 1)))
    (+ (* (- (str.to_code c0) 48) 10)
       (- (str.to_code c1) 48))))

; === Inputs ===
(declare-const date Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal date))

; === COMBINATION ===
(assert C0)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/125 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const txt Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal txt))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal txt))
(define-fun C1 () Bool (and (is-StrVal txt) (not (str.prefixof " " (sval txt))) (not (str.prefixof "," (sval txt))) (not (str.suffixof " " (sval txt))) (not (str.suffixof "," (sval txt)))))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'txt': ' A'}
    Solution 2:
      test_case: {'txt': ' B'}
    Solution 3:
      test_case: {'txt': ' '}
    Solution 4:
      test_case: {'txt': ','}
    Solution 5:
      test_case: {'txt': ',D'}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const txt Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal txt))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal txt))
(define-fun C1 () Bool (and (is-StrVal txt) (not (str.prefixof " " (sval txt))) (not (str.prefixof "," (sval txt))) (not (str.suffixof " " (sval txt))) (not (str.suffixof "," (sval txt)))))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const txt Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal txt))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal txt))
(define-fun C1 () Bool (and (is-StrVal txt) (not (str.prefixof " " (sval txt))) (not (str.prefixof "," (sval txt))) (not (str.suffixof " " (sval txt))) (not (str.suffixof "," (sval txt)))))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'txt': 'A'}
    Solution 2:
      test_case: {'txt': 'B'}
    Solution 3:
      test_case: {'txt': 'C'}
    Solution 4:
      test_case: {'txt': 'D'}
    Solution 5:
      test_case: {'txt': 'E'}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const txt Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal txt))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal txt))
(define-fun C1 () Bool (and (is-StrVal txt) (not (str.prefixof " " (sval txt))) (not (str.prefixof "," (sval txt))) (not (str.suffixof " " (sval txt))) (not (str.suffixof "," (sval txt)))))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/126 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (IsList (tail l))
            false)))

(define-fun-rec all_nonneg_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (let ((elem (head l)))
              (let ((i (ival elem))
                    (rest (tail l)))
                (and (is-IntVal elem) (>= i 0) (all_nonneg_int rest))))
            false)))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (IsList lst))

; === Contract predicates ===
(define-fun C0 () Bool (IsList lst))
(define-fun C1 () Bool (all_nonneg_int lst))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'lst': [2.0]}
    Solution 2:
      test_case: {'lst': [3.0]}
    Solution 3:
      test_case: {'lst': [4.0]}
    Solution 4:
      test_case: {'lst': [5.0]}
    Solution 5:
      test_case: {'lst': [6.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (IsList (tail l))
            false)))

(define-fun-rec all_nonneg_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (let ((elem (head l)))
              (let ((i (ival elem))
                    (rest (tail l)))
                (and (is-IntVal elem) (>= i 0) (all_nonneg_int rest))))
            false)))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (IsList lst))

; === Contract predicates ===
(define-fun C0 () Bool (IsList lst))
(define-fun C1 () Bool (all_nonneg_int lst))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (IsList (tail l))
            false)))

(define-fun-rec all_nonneg_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (let ((elem (head l)))
              (let ((i (ival elem))
                    (rest (tail l)))
                (and (is-IntVal elem) (>= i 0) (all_nonneg_int rest))))
            false)))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (IsList lst))

; === Contract predicates ===
(define-fun C0 () Bool (IsList lst))
(define-fun C1 () Bool (all_nonneg_int lst))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'lst': []}
    Solution 2:
      test_case: {'lst': [0]}
    Solution 3:
      test_case: {'lst': [2437]}
    Solution 4:
      test_case: {'lst': [8365]}
    Solution 5:
      test_case: {'lst': [30612]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (IsList (tail l))
            false)))

(define-fun-rec all_nonneg_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (let ((elem (head l)))
              (let ((i (ival elem))
                    (rest (tail l)))
                (and (is-IntVal elem) (>= i 0) (all_nonneg_int rest))))
            false)))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (IsList lst))

; === Contract predicates ===
(define-fun C0 () Bool (IsList lst))
(define-fun C1 () Bool (all_nonneg_int lst))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/127 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1;assert_2;assert_3
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False, 'assert_3': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_3'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'interval1': [4.0], 'interval2': [3.0, -1]}
    Solution 2:
      test_case: {'interval1': [5.0], 'interval2': [2.0]}
    Solution 3:
      test_case: {'interval2': [6.0], 'interval1': [8.0]}
    Solution 4:
      test_case: {'interval2': [9.0], 'interval1': [10.0]}
    Solution 5:
      test_case: {'interval2': [11.0], 'interval1': [12.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (IsList (tail l))
            false)))

(define-fun-rec length ((l Value)) Int
  (ite (is-Nil l)
       0
       (ite (is-Cons l)
            (+ 1 (length (tail l)))
            0)))

(define-fun SafeIntVal ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

(define-fun SafeHead ((l Value)) Int
  (ite (is-Cons l)
       (SafeIntVal (head l))
       0))

(define-fun SafeSecond ((l Value)) Int
  (let ((t (ite (is-Cons l) (tail l) Nil)))
    (ite (is-Cons t)
         (SafeIntVal (head t))
         0)))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (and (is-IntVal (head l)) (list_all_int (tail l)))
            false)))

; === Inputs ===
(declare-const interval1 Value)
(declare-const interval2 Value)

; === BASIC STRUCTURE ===
(assert (IsList interval1))
(assert (IsList interval2))

; === Contract predicates ===
(define-fun C0 () Bool
  (and (= (length interval1) 2)
       (<= (SafeHead interval1) (SafeSecond interval1))))
(define-fun C1 () Bool
  (list_all_int interval1))
(define-fun C2 () Bool
  (and (= (length interval2) 2)
       (<= (SafeHead interval2) (SafeSecond interval2))))
(define-fun C3 () Bool
  (list_all_int interval2))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1;assert_2;assert_3
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False, 'assert_3': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1', 'assert_2', 'assert_3'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'interval1': [2.0, 0], 'interval2': [4.0]}
    Solution 2:
      test_case: {'interval2': [6.0], 'interval1': [-28100, 5.0]}
    Solution 3:
      test_case: {'interval2': [7.0], 'interval1': [-49076, 3.0]}
    Solution 4:
      test_case: {'interval2': [8.0], 'interval1': [-51316, 10.0]}
    Solution 5:
      test_case: {'interval2': [9.0], 'interval1': [-74927, 11.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (IsList (tail l))
            false)))

(define-fun-rec length ((l Value)) Int
  (ite (is-Nil l)
       0
       (ite (is-Cons l)
            (+ 1 (length (tail l)))
            0)))

(define-fun SafeIntVal ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

(define-fun SafeHead ((l Value)) Int
  (ite (is-Cons l)
       (SafeIntVal (head l))
       0))

(define-fun SafeSecond ((l Value)) Int
  (let ((t (ite (is-Cons l) (tail l) Nil)))
    (ite (is-Cons t)
         (SafeIntVal (head t))
         0)))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (and (is-IntVal (head l)) (list_all_int (tail l)))
            false)))

; === Inputs ===
(declare-const interval1 Value)
(declare-const interval2 Value)

; === BASIC STRUCTURE ===
(assert (IsList interval1))
(assert (IsList interval2))

; === Contract predicates ===
(define-fun C0 () Bool
  (and (= (length interval1) 2)
       (<= (SafeHead interval1) (SafeSecond interval1))))
(define-fun C1 () Bool
  (list_all_int interval1))
(define-fun C2 () Bool
  (and (= (length interval2) 2)
       (<= (SafeHead interval2) (SafeSecond interval2))))
(define-fun C3 () Bool
  (list_all_int interval2))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0;assert_2;assert_3
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False, 'assert_3': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0', 'assert_2', 'assert_3'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'interval1': [], 'interval2': [3.0]}
    Solution 2:
      test_case: {'interval2': [2.0], 'interval1': []}
    Solution 3:
      test_case: {'interval2': [4.0], 'interval1': []}
    Solution 4:
      test_case: {'interval2': [6.0], 'interval1': []}
    Solution 5:
      test_case: {'interval2': [7.0], 'interval1': []}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (IsList (tail l))
            false)))

(define-fun-rec length ((l Value)) Int
  (ite (is-Nil l)
       0
       (ite (is-Cons l)
            (+ 1 (length (tail l)))
            0)))

(define-fun SafeIntVal ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

(define-fun SafeHead ((l Value)) Int
  (ite (is-Cons l)
       (SafeIntVal (head l))
       0))

(define-fun SafeSecond ((l Value)) Int
  (let ((t (ite (is-Cons l) (tail l) Nil)))
    (ite (is-Cons t)
         (SafeIntVal (head t))
         0)))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (and (is-IntVal (head l)) (list_all_int (tail l)))
            false)))

; === Inputs ===
(declare-const interval1 Value)
(declare-const interval2 Value)

; === BASIC STRUCTURE ===
(assert (IsList interval1))
(assert (IsList interval2))

; === Contract predicates ===
(define-fun C0 () Bool
  (and (= (length interval1) 2)
       (<= (SafeHead interval1) (SafeSecond interval1))))
(define-fun C1 () Bool
  (list_all_int interval1))
(define-fun C2 () Bool
  (and (= (length interval2) 2)
       (<= (SafeHead interval2) (SafeSecond interval2))))
(define-fun C3 () Bool
  (list_all_int interval2))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_assert_2;assert_3
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False, 'assert_3': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': ['assert_2', 'assert_3'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'interval2': [2.0, -1], 'interval1': [0, 1323]}
    Solution 2:
      test_case: {'interval1': [-1323, 28881], 'interval2': [4.0]}
    Solution 3:
      test_case: {'interval2': [6.0], 'interval1': [-2190, 58414]}
    Solution 4:
      test_case: {'interval2': [7.0], 'interval1': [-19256, 66043]}
    Solution 5:
      test_case: {'interval2': [8.0], 'interval1': [-38520, 88157]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (IsList (tail l))
            false)))

(define-fun-rec length ((l Value)) Int
  (ite (is-Nil l)
       0
       (ite (is-Cons l)
            (+ 1 (length (tail l)))
            0)))

(define-fun SafeIntVal ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

(define-fun SafeHead ((l Value)) Int
  (ite (is-Cons l)
       (SafeIntVal (head l))
       0))

(define-fun SafeSecond ((l Value)) Int
  (let ((t (ite (is-Cons l) (tail l) Nil)))
    (ite (is-Cons t)
         (SafeIntVal (head t))
         0)))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (and (is-IntVal (head l)) (list_all_int (tail l)))
            false)))

; === Inputs ===
(declare-const interval1 Value)
(declare-const interval2 Value)

; === BASIC STRUCTURE ===
(assert (IsList interval1))
(assert (IsList interval2))

; === Contract predicates ===
(define-fun C0 () Bool
  (and (= (length interval1) 2)
       (<= (SafeHead interval1) (SafeSecond interval1))))
(define-fun C1 () Bool
  (list_all_int interval1))
(define-fun C2 () Bool
  (and (= (length interval2) 2)
       (<= (SafeHead interval2) (SafeSecond interval2))))
(define-fun C3 () Bool
  (list_all_int interval2))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 5: satisfied_assert_2, violated_assert_0;assert_1;assert_3
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True, 'assert_3': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_2'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_3'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'interval1': [2.0], 'interval2': [0, 4.0]}
    Solution 2:
      test_case: {'interval2': [5.0, 7.0], 'interval1': [3.0]}
    Solution 3:
      test_case: {'interval2': [9.0, 6.0], 'interval1': [8.0]}
    Solution 4:
      test_case: {'interval2': [12.0, 10.0], 'interval1': [13.0]}
    Solution 5:
      test_case: {'interval2': [15.0, 11.0], 'interval1': [14.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (IsList (tail l))
            false)))

(define-fun-rec length ((l Value)) Int
  (ite (is-Nil l)
       0
       (ite (is-Cons l)
            (+ 1 (length (tail l)))
            0)))

(define-fun SafeIntVal ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

(define-fun SafeHead ((l Value)) Int
  (ite (is-Cons l)
       (SafeIntVal (head l))
       0))

(define-fun SafeSecond ((l Value)) Int
  (let ((t (ite (is-Cons l) (tail l) Nil)))
    (ite (is-Cons t)
         (SafeIntVal (head t))
         0)))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (and (is-IntVal (head l)) (list_all_int (tail l)))
            false)))

; === Inputs ===
(declare-const interval1 Value)
(declare-const interval2 Value)

; === BASIC STRUCTURE ===
(assert (IsList interval1))
(assert (IsList interval2))

; === Contract predicates ===
(define-fun C0 () Bool
  (and (= (length interval1) 2)
       (<= (SafeHead interval1) (SafeSecond interval1))))
(define-fun C1 () Bool
  (list_all_int interval1))
(define-fun C2 () Bool
  (and (= (length interval2) 2)
       (<= (SafeHead interval2) (SafeSecond interval2))))
(define-fun C3 () Bool
  (list_all_int interval2))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 6: satisfied_assert_0;assert_2, violated_assert_1;assert_3
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True, 'assert_3': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2'], 'violated_contracts': ['assert_1', 'assert_3'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'interval1': [4.0, 2.0], 'interval2': [0, 3.0]}
    Solution 2:
      test_case: {'interval2': [-10450, 6.0], 'interval1': [-32285, 5.0]}
    Solution 3:
      test_case: {'interval2': [-10731, 7.0], 'interval1': [-33427, 8.0]}
    Solution 4:
      test_case: {'interval2': [-37016, 10.0], 'interval1': [-36424, 9.0]}
    Solution 5:
      test_case: {'interval2': [-62922, 11.0], 'interval1': [-58079, 12.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (IsList (tail l))
            false)))

(define-fun-rec length ((l Value)) Int
  (ite (is-Nil l)
       0
       (ite (is-Cons l)
            (+ 1 (length (tail l)))
            0)))

(define-fun SafeIntVal ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

(define-fun SafeHead ((l Value)) Int
  (ite (is-Cons l)
       (SafeIntVal (head l))
       0))

(define-fun SafeSecond ((l Value)) Int
  (let ((t (ite (is-Cons l) (tail l) Nil)))
    (ite (is-Cons t)
         (SafeIntVal (head t))
         0)))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (and (is-IntVal (head l)) (list_all_int (tail l)))
            false)))

; === Inputs ===
(declare-const interval1 Value)
(declare-const interval2 Value)

; === BASIC STRUCTURE ===
(assert (IsList interval1))
(assert (IsList interval2))

; === Contract predicates ===
(define-fun C0 () Bool
  (and (= (length interval1) 2)
       (<= (SafeHead interval1) (SafeSecond interval1))))
(define-fun C1 () Bool
  (list_all_int interval1))
(define-fun C2 () Bool
  (and (= (length interval2) 2)
       (<= (SafeHead interval2) (SafeSecond interval2))))
(define-fun C3 () Bool
  (list_all_int interval2))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 7: satisfied_assert_1;assert_2, violated_assert_0;assert_3
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True, 'assert_3': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2'], 'violated_contracts': ['assert_0', 'assert_3'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'interval1': [], 'interval2': [2.0, 3.0]}
    Solution 2:
      test_case: {'interval1': [], 'interval2': [4.0, 6.0]}
    Solution 3:
      test_case: {'interval2': [7.0, 8.0], 'interval1': []}
    Solution 4:
      test_case: {'interval2': [10.0, 5.0], 'interval1': []}
    Solution 5:
      test_case: {'interval2': [9.0, 11.0], 'interval1': []}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (IsList (tail l))
            false)))

(define-fun-rec length ((l Value)) Int
  (ite (is-Nil l)
       0
       (ite (is-Cons l)
            (+ 1 (length (tail l)))
            0)))

(define-fun SafeIntVal ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

(define-fun SafeHead ((l Value)) Int
  (ite (is-Cons l)
       (SafeIntVal (head l))
       0))

(define-fun SafeSecond ((l Value)) Int
  (let ((t (ite (is-Cons l) (tail l) Nil)))
    (ite (is-Cons t)
         (SafeIntVal (head t))
         0)))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (and (is-IntVal (head l)) (list_all_int (tail l)))
            false)))

; === Inputs ===
(declare-const interval1 Value)
(declare-const interval2 Value)

; === BASIC STRUCTURE ===
(assert (IsList interval1))
(assert (IsList interval2))

; === Contract predicates ===
(define-fun C0 () Bool
  (and (= (length interval1) 2)
       (<= (SafeHead interval1) (SafeSecond interval1))))
(define-fun C1 () Bool
  (list_all_int interval1))
(define-fun C2 () Bool
  (and (= (length interval2) 2)
       (<= (SafeHead interval2) (SafeSecond interval2))))
(define-fun C3 () Bool
  (list_all_int interval2))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 8: satisfied_assert_0;assert_1;assert_2, violated_assert_3
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True, 'assert_3': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2'], 'violated_contracts': ['assert_3'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'interval1': [-18457, 0], 'interval2': [2.0, 3.0]}
    Solution 2:
      test_case: {'interval1': [-20976, 31891], 'interval2': [5.0, 4.0]}
    Solution 3:
      test_case: {'interval2': [7.0, 6.0], 'interval1': [-30701, 64169]}
    Solution 4:
      test_case: {'interval2': [8.0, 9.0], 'interval1': [-54312, 76786]}
    Solution 5:
      test_case: {'interval2': [10.0, 11.0], 'interval1': [-85909, 97370]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (IsList (tail l))
            false)))

(define-fun-rec length ((l Value)) Int
  (ite (is-Nil l)
       0
       (ite (is-Cons l)
            (+ 1 (length (tail l)))
            0)))

(define-fun SafeIntVal ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

(define-fun SafeHead ((l Value)) Int
  (ite (is-Cons l)
       (SafeIntVal (head l))
       0))

(define-fun SafeSecond ((l Value)) Int
  (let ((t (ite (is-Cons l) (tail l) Nil)))
    (ite (is-Cons t)
         (SafeIntVal (head t))
         0)))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (and (is-IntVal (head l)) (list_all_int (tail l)))
            false)))

; === Inputs ===
(declare-const interval1 Value)
(declare-const interval2 Value)

; === BASIC STRUCTURE ===
(assert (IsList interval1))
(assert (IsList interval2))

; === Contract predicates ===
(define-fun C0 () Bool
  (and (= (length interval1) 2)
       (<= (SafeHead interval1) (SafeSecond interval1))))
(define-fun C1 () Bool
  (list_all_int interval1))
(define-fun C2 () Bool
  (and (= (length interval2) 2)
       (<= (SafeHead interval2) (SafeSecond interval2))))
(define-fun C3 () Bool
  (list_all_int interval2))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 9: satisfied_assert_3, violated_assert_0;assert_1;assert_2
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False, 'assert_3': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_3'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'interval1': [3.0, -1], 'interval2': []}
    Solution 2:
      test_case: {'interval1': [4.0], 'interval2': []}
    Solution 3:
      test_case: {'interval2': [], 'interval1': [2.0]}
    Solution 4:
      test_case: {'interval2': [], 'interval1': [6.0]}
    Solution 5:
      test_case: {'interval2': [], 'interval1': [7.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (IsList (tail l))
            false)))

(define-fun-rec length ((l Value)) Int
  (ite (is-Nil l)
       0
       (ite (is-Cons l)
            (+ 1 (length (tail l)))
            0)))

(define-fun SafeIntVal ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

(define-fun SafeHead ((l Value)) Int
  (ite (is-Cons l)
       (SafeIntVal (head l))
       0))

(define-fun SafeSecond ((l Value)) Int
  (let ((t (ite (is-Cons l) (tail l) Nil)))
    (ite (is-Cons t)
         (SafeIntVal (head t))
         0)))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (and (is-IntVal (head l)) (list_all_int (tail l)))
            false)))

; === Inputs ===
(declare-const interval1 Value)
(declare-const interval2 Value)

; === BASIC STRUCTURE ===
(assert (IsList interval1))
(assert (IsList interval2))

; === Contract predicates ===
(define-fun C0 () Bool
  (and (= (length interval1) 2)
       (<= (SafeHead interval1) (SafeSecond interval1))))
(define-fun C1 () Bool
  (list_all_int interval1))
(define-fun C2 () Bool
  (and (= (length interval2) 2)
       (<= (SafeHead interval2) (SafeSecond interval2))))
(define-fun C3 () Bool
  (list_all_int interval2))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 10: satisfied_assert_0;assert_3, violated_assert_1;assert_2
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False, 'assert_3': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_3'], 'violated_contracts': ['assert_1', 'assert_2'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'interval1': [2.0, 3.0], 'interval2': []}
    Solution 2:
      test_case: {'interval2': [], 'interval1': [5.0, 4.0]}
    Solution 3:
      test_case: {'interval2': [], 'interval1': [6.0, 8.0]}
    Solution 4:
      test_case: {'interval2': [], 'interval1': [10.0, 9.0]}
    Solution 5:
      test_case: {'interval2': [], 'interval1': [7.0, 12.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (IsList (tail l))
            false)))

(define-fun-rec length ((l Value)) Int
  (ite (is-Nil l)
       0
       (ite (is-Cons l)
            (+ 1 (length (tail l)))
            0)))

(define-fun SafeIntVal ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

(define-fun SafeHead ((l Value)) Int
  (ite (is-Cons l)
       (SafeIntVal (head l))
       0))

(define-fun SafeSecond ((l Value)) Int
  (let ((t (ite (is-Cons l) (tail l) Nil)))
    (ite (is-Cons t)
         (SafeIntVal (head t))
         0)))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (and (is-IntVal (head l)) (list_all_int (tail l)))
            false)))

; === Inputs ===
(declare-const interval1 Value)
(declare-const interval2 Value)

; === BASIC STRUCTURE ===
(assert (IsList interval1))
(assert (IsList interval2))

; === Contract predicates ===
(define-fun C0 () Bool
  (and (= (length interval1) 2)
       (<= (SafeHead interval1) (SafeSecond interval1))))
(define-fun C1 () Bool
  (list_all_int interval1))
(define-fun C2 () Bool
  (and (= (length interval2) 2)
       (<= (SafeHead interval2) (SafeSecond interval2))))
(define-fun C3 () Bool
  (list_all_int interval2))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 11: satisfied_assert_1;assert_3, violated_assert_0;assert_2
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False, 'assert_3': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_3'], 'violated_contracts': ['assert_0', 'assert_2'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'interval2': [], 'interval1': []}
    Solution 2:
      test_case: {'interval1': [1], 'interval2': []}
    Solution 3:
      test_case: {'interval1': [1143], 'interval2': []}
    Solution 4:
      test_case: {'interval2': [], 'interval1': [10088]}
    Solution 5:
      test_case: {'interval1': [31064], 'interval2': []}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (IsList (tail l))
            false)))

(define-fun-rec length ((l Value)) Int
  (ite (is-Nil l)
       0
       (ite (is-Cons l)
            (+ 1 (length (tail l)))
            0)))

(define-fun SafeIntVal ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

(define-fun SafeHead ((l Value)) Int
  (ite (is-Cons l)
       (SafeIntVal (head l))
       0))

(define-fun SafeSecond ((l Value)) Int
  (let ((t (ite (is-Cons l) (tail l) Nil)))
    (ite (is-Cons t)
         (SafeIntVal (head t))
         0)))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (and (is-IntVal (head l)) (list_all_int (tail l)))
            false)))

; === Inputs ===
(declare-const interval1 Value)
(declare-const interval2 Value)

; === BASIC STRUCTURE ===
(assert (IsList interval1))
(assert (IsList interval2))

; === Contract predicates ===
(define-fun C0 () Bool
  (and (= (length interval1) 2)
       (<= (SafeHead interval1) (SafeSecond interval1))))
(define-fun C1 () Bool
  (list_all_int interval1))
(define-fun C2 () Bool
  (and (= (length interval2) 2)
       (<= (SafeHead interval2) (SafeSecond interval2))))
(define-fun C3 () Bool
  (list_all_int interval2))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 12: satisfied_assert_0;assert_1;assert_3, violated_assert_2
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False, 'assert_3': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_3'], 'violated_contracts': ['assert_2'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'interval2': [], 'interval1': [-15921, 0]}
    Solution 2:
      test_case: {'interval1': [-8945, 15921], 'interval2': []}
    Solution 3:
      test_case: {'interval2': [], 'interval1': [-40836, 37576]}
    Solution 4:
      test_case: {'interval2': [], 'interval1': [-43076, 47301]}
    Solution 5:
      test_case: {'interval2': [], 'interval1': [-61663, 64208]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (IsList (tail l))
            false)))

(define-fun-rec length ((l Value)) Int
  (ite (is-Nil l)
       0
       (ite (is-Cons l)
            (+ 1 (length (tail l)))
            0)))

(define-fun SafeIntVal ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

(define-fun SafeHead ((l Value)) Int
  (ite (is-Cons l)
       (SafeIntVal (head l))
       0))

(define-fun SafeSecond ((l Value)) Int
  (let ((t (ite (is-Cons l) (tail l) Nil)))
    (ite (is-Cons t)
         (SafeIntVal (head t))
         0)))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (and (is-IntVal (head l)) (list_all_int (tail l)))
            false)))

; === Inputs ===
(declare-const interval1 Value)
(declare-const interval2 Value)

; === BASIC STRUCTURE ===
(assert (IsList interval1))
(assert (IsList interval2))

; === Contract predicates ===
(define-fun C0 () Bool
  (and (= (length interval1) 2)
       (<= (SafeHead interval1) (SafeSecond interval1))))
(define-fun C1 () Bool
  (list_all_int interval1))
(define-fun C2 () Bool
  (and (= (length interval2) 2)
       (<= (SafeHead interval2) (SafeSecond interval2))))
(define-fun C3 () Bool
  (list_all_int interval2))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 13: satisfied_assert_2;assert_3, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True, 'assert_3': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_2', 'assert_3'], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'interval1': [4.0], 'interval2': [0, 2240]}
    Solution 2:
      test_case: {'interval1': [2.0, -1], 'interval2': [-1323, 18457]}
    Solution 3:
      test_case: {'interval2': [-19910, 35364], 'interval1': [3.0, -841]}
    Solution 4:
      test_case: {'interval2': [-48133, 53251], 'interval1': [5.0, -7719]}
    Solution 5:
      test_case: {'interval2': [-55762, 82655], 'interval1': [6.0, -19998]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (IsList (tail l))
            false)))

(define-fun-rec length ((l Value)) Int
  (ite (is-Nil l)
       0
       (ite (is-Cons l)
            (+ 1 (length (tail l)))
            0)))

(define-fun SafeIntVal ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

(define-fun SafeHead ((l Value)) Int
  (ite (is-Cons l)
       (SafeIntVal (head l))
       0))

(define-fun SafeSecond ((l Value)) Int
  (let ((t (ite (is-Cons l) (tail l) Nil)))
    (ite (is-Cons t)
         (SafeIntVal (head t))
         0)))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (and (is-IntVal (head l)) (list_all_int (tail l)))
            false)))

; === Inputs ===
(declare-const interval1 Value)
(declare-const interval2 Value)

; === BASIC STRUCTURE ===
(assert (IsList interval1))
(assert (IsList interval2))

; === Contract predicates ===
(define-fun C0 () Bool
  (and (= (length interval1) 2)
       (<= (SafeHead interval1) (SafeSecond interval1))))
(define-fun C1 () Bool
  (list_all_int interval1))
(define-fun C2 () Bool
  (and (= (length interval2) 2)
       (<= (SafeHead interval2) (SafeSecond interval2))))
(define-fun C3 () Bool
  (list_all_int interval2))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 14: satisfied_assert_0;assert_2;assert_3, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True, 'assert_3': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2', 'assert_3'], 'violated_contracts': ['assert_1'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'interval1': [0, 2.0], 'interval2': [-25906, 21655]}
    Solution 2:
      test_case: {'interval2': [-2240, 9725], 'interval1': [3.0, 4.0]}
    Solution 3:
      test_case: {'interval2': [-23477, 33336], 'interval1': [6.0, 5.0]}
    Solution 4:
      test_case: {'interval2': [-41364, 64933], 'interval1': [8.0, 7.0]}
    Solution 5:
      test_case: {'interval2': [-70768, 77212], 'interval1': [9.0, 10.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (IsList (tail l))
            false)))

(define-fun-rec length ((l Value)) Int
  (ite (is-Nil l)
       0
       (ite (is-Cons l)
            (+ 1 (length (tail l)))
            0)))

(define-fun SafeIntVal ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

(define-fun SafeHead ((l Value)) Int
  (ite (is-Cons l)
       (SafeIntVal (head l))
       0))

(define-fun SafeSecond ((l Value)) Int
  (let ((t (ite (is-Cons l) (tail l) Nil)))
    (ite (is-Cons t)
         (SafeIntVal (head t))
         0)))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (and (is-IntVal (head l)) (list_all_int (tail l)))
            false)))

; === Inputs ===
(declare-const interval1 Value)
(declare-const interval2 Value)

; === BASIC STRUCTURE ===
(assert (IsList interval1))
(assert (IsList interval2))

; === Contract predicates ===
(define-fun C0 () Bool
  (and (= (length interval1) 2)
       (<= (SafeHead interval1) (SafeSecond interval1))))
(define-fun C1 () Bool
  (list_all_int interval1))
(define-fun C2 () Bool
  (and (= (length interval2) 2)
       (<= (SafeHead interval2) (SafeSecond interval2))))
(define-fun C3 () Bool
  (list_all_int interval2))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 15: satisfied_assert_1;assert_2;assert_3, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True, 'assert_3': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2', 'assert_3'], 'violated_contracts': ['assert_0'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'interval2': [-20537, 0], 'interval1': []}
    Solution 2:
      test_case: {'interval1': [], 'interval2': [-42192, 15921]}
    Solution 3:
      test_case: {'interval2': [-51917, 48199], 'interval1': []}
    Solution 4:
      test_case: {'interval2': [-73154, 71810], 'interval1': []}
    Solution 5:
      test_case: {'interval2': [-85366, 102921], 'interval1': []}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (IsList (tail l))
            false)))

(define-fun-rec length ((l Value)) Int
  (ite (is-Nil l)
       0
       (ite (is-Cons l)
            (+ 1 (length (tail l)))
            0)))

(define-fun SafeIntVal ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

(define-fun SafeHead ((l Value)) Int
  (ite (is-Cons l)
       (SafeIntVal (head l))
       0))

(define-fun SafeSecond ((l Value)) Int
  (let ((t (ite (is-Cons l) (tail l) Nil)))
    (ite (is-Cons t)
         (SafeIntVal (head t))
         0)))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (and (is-IntVal (head l)) (list_all_int (tail l)))
            false)))

; === Inputs ===
(declare-const interval1 Value)
(declare-const interval2 Value)

; === BASIC STRUCTURE ===
(assert (IsList interval1))
(assert (IsList interval2))

; === Contract predicates ===
(define-fun C0 () Bool
  (and (= (length interval1) 2)
       (<= (SafeHead interval1) (SafeSecond interval1))))
(define-fun C1 () Bool
  (list_all_int interval1))
(define-fun C2 () Bool
  (and (= (length interval2) 2)
       (<= (SafeHead interval2) (SafeSecond interval2))))
(define-fun C3 () Bool
  (list_all_int interval2))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 16: satisfied_assert_0;assert_1;assert_2;assert_3, violated_
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True, 'assert_3': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_3'], 'violated_contracts': [], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'interval1': [-20976, 0], 'interval2': [-31891, 21655]}
    Solution 2:
      test_case: {'interval1': [-21655, 31891], 'interval2': [-25906, 18457]}
    Solution 3:
      test_case: {'interval2': [-26746, 37044], 'interval1': [-24101, 32481]}
    Solution 4:
      test_case: {'interval2': [-39202, 37911], 'interval1': [-53634, 39359]}
    Solution 5:
      test_case: {'interval2': [-46780, 54977], 'interval1': [-65846, 70470]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (IsList (tail l))
            false)))

(define-fun-rec length ((l Value)) Int
  (ite (is-Nil l)
       0
       (ite (is-Cons l)
            (+ 1 (length (tail l)))
            0)))

(define-fun SafeIntVal ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

(define-fun SafeHead ((l Value)) Int
  (ite (is-Cons l)
       (SafeIntVal (head l))
       0))

(define-fun SafeSecond ((l Value)) Int
  (let ((t (ite (is-Cons l) (tail l) Nil)))
    (ite (is-Cons t)
         (SafeIntVal (head t))
         0)))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (and (is-IntVal (head l)) (list_all_int (tail l)))
            false)))

; === Inputs ===
(declare-const interval1 Value)
(declare-const interval2 Value)

; === BASIC STRUCTURE ===
(assert (IsList interval1))
(assert (IsList interval2))

; === Contract predicates ===
(define-fun C0 () Bool
  (and (= (length interval1) 2)
       (<= (SafeHead interval1) (SafeSecond interval1))))
(define-fun C1 () Bool
  (list_all_int interval1))
(define-fun C2 () Bool
  (and (= (length interval2) 2)
       (<= (SafeHead interval2) (SafeSecond interval2))))
(define-fun C3 () Bool
  (list_all_int interval2))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)
(assert C3)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/128 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))
(define-fun-rec list_all_int ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (is-IntVal (head v))
                 (list_all_int (tail v)))
            false)))

; === Inputs ===
(declare-const arr Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (list_all_int arr))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'arr': [2.0]}
    Solution 2:
      test_case: {'arr': [3.0]}
    Solution 3:
      test_case: {'arr': [4.0]}
    Solution 4:
      test_case: {'arr': [5.0]}
    Solution 5:
      test_case: {'arr': [6.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))
(define-fun-rec list_all_int ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (is-IntVal (head v))
                 (list_all_int (tail v)))
            false)))

; === Inputs ===
(declare-const arr Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (list_all_int arr))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))
(define-fun-rec list_all_int ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (is-IntVal (head v))
                 (list_all_int (tail v)))
            false)))

; === Inputs ===
(declare-const arr Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (list_all_int arr))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'arr': []}
    Solution 2:
      test_case: {'arr': [2]}
    Solution 3:
      test_case: {'arr': [3]}
    Solution 4:
      test_case: {'arr': [4]}
    Solution 5:
      test_case: {'arr': [5]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))
(define-fun-rec list_all_int ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (is-IntVal (head v))
                 (list_all_int (tail v)))
            false)))

; === Inputs ===
(declare-const arr Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (list_all_int arr))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/129 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1;assert_2;assert_3;assert_4
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False, 'assert_3': False, 'assert_4': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_3', 'assert_4'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (IsList (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))

(define-fun-rec list_nth ((l Value) (idx Int)) Value
  (ite (not (is-Cons l))
       Nil
       (ite (= idx 0)
            (head l)
            (list_nth (tail l) (- idx 1)))))

(define-fun-rec AllRowsSameLen ((rows Value) (n Int)) Bool
  (ite (is-Nil rows)
       true
       (and (is-Cons rows)
            (let ((row (head rows)))
              (and (IsList row)
                   (= (length row) n)
                   (AllRowsSameLen (tail rows) n))))))

(define-fun-rec RowOK ((row Value) (j Int) (i Int) (n Int)) Bool
  (ite (= j n)
       (is-Nil row)
       (and (is-Cons row)
            (is-IntVal (head row))
            (= (ival (head row)) (+ 1 j (* i n)))
            (RowOK (tail row) (+ j 1) i n))))

(define-fun-rec GridOK ((rows Value) (i Int) (n Int)) Bool
  (ite (= i n)
       (is-Nil rows)
       (and (is-Cons rows)
            (RowOK (head rows) 0 i n)
            (GridOK (tail rows) (+ i 1) n))))

; === Inputs ===
(declare-const grid Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList grid))
(assert (is-IntVal k))
(assert (<= (length grid) 3))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal k))
(define-fun C1 () Bool (and (is-IntVal k) (> (ival k) 0)))
(define-fun C2 () Bool (and (IsList grid) (>= (length grid) 2)))
(define-fun C3 () Bool (and (IsList grid) (AllRowsSameLen grid (length grid))))
(define-fun C4 () Bool (let ((n (length grid))) (GridOK grid 0 n)))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))
(assert (not C3))
(assert (not C4))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1;assert_2;assert_3;assert_4
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False, 'assert_3': False, 'assert_4': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1', 'assert_2', 'assert_3', 'assert_4'], 'total_contracts': 5}
  Solutions:
    Solution 1:
      test_case: {'k': 0, 'grid': [3.0]}
    Solution 2:
      test_case: {'k': -21655, 'grid': [6.0]}
    Solution 3:
      test_case: {'grid': [7.0], 'k': -21655}
    Solution 4:
      test_case: {'k': -24101, 'grid': [5.0]}
    Solution 5:
      test_case: {'k': -24101, 'grid': [9.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (IsList (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))

(define-fun-rec list_nth ((l Value) (idx Int)) Value
  (ite (not (is-Cons l))
       Nil
       (ite (= idx 0)
            (head l)
            (list_nth (tail l) (- idx 1)))))

(define-fun-rec AllRowsSameLen ((rows Value) (n Int)) Bool
  (ite (is-Nil rows)
       true
       (and (is-Cons rows)
            (let ((row (head rows)))
              (and (IsList row)
                   (= (length row) n)
                   (AllRowsSameLen (tail rows) n))))))

(define-fun-rec RowOK ((row Value) (j Int) (i Int) (n Int)) Bool
  (ite (= j n)
       (is-Nil row)
       (and (is-Cons row)
            (is-IntVal (head row))
            (= (ival (head row)) (+ 1 j (* i n)))
            (RowOK (tail row) (+ j 1) i n))))

(define-fun-rec GridOK ((rows Value) (i Int) (n Int)) Bool
  (ite (= i n)
       (is-Nil rows)
       (and (is-Cons rows)
            (RowOK (head rows) 0 i n)
            (GridOK (tail rows) (+ i 1) n))))

; === Inputs ===
(declare-const grid Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList grid))
(assert (is-IntVal k))
(assert (<= (length grid) 3))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal k))
(define-fun C1 () Bool (and (is-IntVal k) (> (ival k) 0)))
(define-fun C2 () Bool (and (IsList grid) (>= (length grid) 2)))
(define-fun C3 () Bool (and (IsList grid) (AllRowsSameLen grid (length grid))))
(define-fun C4 () Bool (let ((n (length grid))) (GridOK grid 0 n)))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))
(assert (not C3))
(assert (not C4))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0;assert_2;assert_3;assert_4
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False, 'assert_3': False, 'assert_4': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0', 'assert_2', 'assert_3', 'assert_4'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (IsList (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))

(define-fun-rec list_nth ((l Value) (idx Int)) Value
  (ite (not (is-Cons l))
       Nil
       (ite (= idx 0)
            (head l)
            (list_nth (tail l) (- idx 1)))))

(define-fun-rec AllRowsSameLen ((rows Value) (n Int)) Bool
  (ite (is-Nil rows)
       true
       (and (is-Cons rows)
            (let ((row (head rows)))
              (and (IsList row)
                   (= (length row) n)
                   (AllRowsSameLen (tail rows) n))))))

(define-fun-rec RowOK ((row Value) (j Int) (i Int) (n Int)) Bool
  (ite (= j n)
       (is-Nil row)
       (and (is-Cons row)
            (is-IntVal (head row))
            (= (ival (head row)) (+ 1 j (* i n)))
            (RowOK (tail row) (+ j 1) i n))))

(define-fun-rec GridOK ((rows Value) (i Int) (n Int)) Bool
  (ite (= i n)
       (is-Nil rows)
       (and (is-Cons rows)
            (RowOK (head rows) 0 i n)
            (GridOK (tail rows) (+ i 1) n))))

; === Inputs ===
(declare-const grid Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList grid))
(assert (is-IntVal k))
(assert (<= (length grid) 3))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal k))
(define-fun C1 () Bool (and (is-IntVal k) (> (ival k) 0)))
(define-fun C2 () Bool (and (IsList grid) (>= (length grid) 2)))
(define-fun C3 () Bool (and (IsList grid) (AllRowsSameLen grid (length grid))))
(define-fun C4 () Bool (let ((n (length grid))) (GridOK grid 0 n)))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))
(assert (not C3))
(assert (not C4))

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_assert_2;assert_3;assert_4
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False, 'assert_3': False, 'assert_4': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': ['assert_2', 'assert_3', 'assert_4'], 'total_contracts': 5}
  Solutions:
    Solution 1:
      test_case: {'k': 1, 'grid': [3.0]}
    Solution 2:
      test_case: {'k': 21656, 'grid': [4.0]}
    Solution 3:
      test_case: {'k': 50537, 'grid': [6.0]}
    Solution 4:
      test_case: {'k': 52983, 'grid': [7.0]}
    Solution 5:
      test_case: {'k': 52983, 'grid': [8.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (IsList (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))

(define-fun-rec list_nth ((l Value) (idx Int)) Value
  (ite (not (is-Cons l))
       Nil
       (ite (= idx 0)
            (head l)
            (list_nth (tail l) (- idx 1)))))

(define-fun-rec AllRowsSameLen ((rows Value) (n Int)) Bool
  (ite (is-Nil rows)
       true
       (and (is-Cons rows)
            (let ((row (head rows)))
              (and (IsList row)
                   (= (length row) n)
                   (AllRowsSameLen (tail rows) n))))))

(define-fun-rec RowOK ((row Value) (j Int) (i Int) (n Int)) Bool
  (ite (= j n)
       (is-Nil row)
       (and (is-Cons row)
            (is-IntVal (head row))
            (= (ival (head row)) (+ 1 j (* i n)))
            (RowOK (tail row) (+ j 1) i n))))

(define-fun-rec GridOK ((rows Value) (i Int) (n Int)) Bool
  (ite (= i n)
       (is-Nil rows)
       (and (is-Cons rows)
            (RowOK (head rows) 0 i n)
            (GridOK (tail rows) (+ i 1) n))))

; === Inputs ===
(declare-const grid Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList grid))
(assert (is-IntVal k))
(assert (<= (length grid) 3))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal k))
(define-fun C1 () Bool (and (is-IntVal k) (> (ival k) 0)))
(define-fun C2 () Bool (and (IsList grid) (>= (length grid) 2)))
(define-fun C3 () Bool (and (IsList grid) (AllRowsSameLen grid (length grid))))
(define-fun C4 () Bool (let ((n (length grid))) (GridOK grid 0 n)))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))
(assert (not C3))
(assert (not C4))

(check-sat)
(get-model)

------------------------------
  Test Case 5: satisfied_assert_2, violated_assert_0;assert_1;assert_3;assert_4
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True, 'assert_3': False, 'assert_4': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_2'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_3', 'assert_4'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (IsList (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))

(define-fun-rec list_nth ((l Value) (idx Int)) Value
  (ite (not (is-Cons l))
       Nil
       (ite (= idx 0)
            (head l)
            (list_nth (tail l) (- idx 1)))))

(define-fun-rec AllRowsSameLen ((rows Value) (n Int)) Bool
  (ite (is-Nil rows)
       true
       (and (is-Cons rows)
            (let ((row (head rows)))
              (and (IsList row)
                   (= (length row) n)
                   (AllRowsSameLen (tail rows) n))))))

(define-fun-rec RowOK ((row Value) (j Int) (i Int) (n Int)) Bool
  (ite (= j n)
       (is-Nil row)
       (and (is-Cons row)
            (is-IntVal (head row))
            (= (ival (head row)) (+ 1 j (* i n)))
            (RowOK (tail row) (+ j 1) i n))))

(define-fun-rec GridOK ((rows Value) (i Int) (n Int)) Bool
  (ite (= i n)
       (is-Nil rows)
       (and (is-Cons rows)
            (RowOK (head rows) 0 i n)
            (GridOK (tail rows) (+ i 1) n))))

; === Inputs ===
(declare-const grid Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList grid))
(assert (is-IntVal k))
(assert (<= (length grid) 3))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal k))
(define-fun C1 () Bool (and (is-IntVal k) (> (ival k) 0)))
(define-fun C2 () Bool (and (IsList grid) (>= (length grid) 2)))
(define-fun C3 () Bool (and (IsList grid) (AllRowsSameLen grid (length grid))))
(define-fun C4 () Bool (let ((n (length grid))) (GridOK grid 0 n)))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)
(assert (not C3))
(assert (not C4))

(check-sat)
(get-model)

------------------------------
  Test Case 6: satisfied_assert_0;assert_2, violated_assert_1;assert_3;assert_4
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True, 'assert_3': False, 'assert_4': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2'], 'violated_contracts': ['assert_1', 'assert_3', 'assert_4'], 'total_contracts': 5}
  Solutions:
    Solution 1:
      test_case: {'k': 0, 'grid': [5.0, 4.0]}
    Solution 2:
      test_case: {'k': -25906, 'grid': [[], 8.0]}
    Solution 3:
      test_case: {'k': -25906, 'grid': [[], 9.0]}
    Solution 4:
      test_case: {'k': -26496, 'grid': [[], 10.0]}
    Solution 5:
      test_case: {'k': -26496, 'grid': [[], 11.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (IsList (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))

(define-fun-rec list_nth ((l Value) (idx Int)) Value
  (ite (not (is-Cons l))
       Nil
       (ite (= idx 0)
            (head l)
            (list_nth (tail l) (- idx 1)))))

(define-fun-rec AllRowsSameLen ((rows Value) (n Int)) Bool
  (ite (is-Nil rows)
       true
       (and (is-Cons rows)
            (let ((row (head rows)))
              (and (IsList row)
                   (= (length row) n)
                   (AllRowsSameLen (tail rows) n))))))

(define-fun-rec RowOK ((row Value) (j Int) (i Int) (n Int)) Bool
  (ite (= j n)
       (is-Nil row)
       (and (is-Cons row)
            (is-IntVal (head row))
            (= (ival (head row)) (+ 1 j (* i n)))
            (RowOK (tail row) (+ j 1) i n))))

(define-fun-rec GridOK ((rows Value) (i Int) (n Int)) Bool
  (ite (= i n)
       (is-Nil rows)
       (and (is-Cons rows)
            (RowOK (head rows) 0 i n)
            (GridOK (tail rows) (+ i 1) n))))

; === Inputs ===
(declare-const grid Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList grid))
(assert (is-IntVal k))
(assert (<= (length grid) 3))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal k))
(define-fun C1 () Bool (and (is-IntVal k) (> (ival k) 0)))
(define-fun C2 () Bool (and (IsList grid) (>= (length grid) 2)))
(define-fun C3 () Bool (and (IsList grid) (AllRowsSameLen grid (length grid))))
(define-fun C4 () Bool (let ((n (length grid))) (GridOK grid 0 n)))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)
(assert (not C3))
(assert (not C4))

(check-sat)
(get-model)

------------------------------
  Test Case 7: satisfied_assert_1;assert_2, violated_assert_0;assert_3;assert_4
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True, 'assert_3': False, 'assert_4': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2'], 'violated_contracts': ['assert_0', 'assert_3', 'assert_4'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (IsList (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))

(define-fun-rec list_nth ((l Value) (idx Int)) Value
  (ite (not (is-Cons l))
       Nil
       (ite (= idx 0)
            (head l)
            (list_nth (tail l) (- idx 1)))))

(define-fun-rec AllRowsSameLen ((rows Value) (n Int)) Bool
  (ite (is-Nil rows)
       true
       (and (is-Cons rows)
            (let ((row (head rows)))
              (and (IsList row)
                   (= (length row) n)
                   (AllRowsSameLen (tail rows) n))))))

(define-fun-rec RowOK ((row Value) (j Int) (i Int) (n Int)) Bool
  (ite (= j n)
       (is-Nil row)
       (and (is-Cons row)
            (is-IntVal (head row))
            (= (ival (head row)) (+ 1 j (* i n)))
            (RowOK (tail row) (+ j 1) i n))))

(define-fun-rec GridOK ((rows Value) (i Int) (n Int)) Bool
  (ite (= i n)
       (is-Nil rows)
       (and (is-Cons rows)
            (RowOK (head rows) 0 i n)
            (GridOK (tail rows) (+ i 1) n))))

; === Inputs ===
(declare-const grid Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList grid))
(assert (is-IntVal k))
(assert (<= (length grid) 3))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal k))
(define-fun C1 () Bool (and (is-IntVal k) (> (ival k) 0)))
(define-fun C2 () Bool (and (IsList grid) (>= (length grid) 2)))
(define-fun C3 () Bool (and (IsList grid) (AllRowsSameLen grid (length grid))))
(define-fun C4 () Bool (let ((n (length grid))) (GridOK grid 0 n)))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)
(assert (not C3))
(assert (not C4))

(check-sat)
(get-model)

------------------------------
  Test Case 8: satisfied_assert_0;assert_1;assert_2, violated_assert_3;assert_4
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True, 'assert_3': False, 'assert_4': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2'], 'violated_contracts': ['assert_3', 'assert_4'], 'total_contracts': 5}
  Solutions:
    Solution 1:
      test_case: {'k': 1, 'grid': [5.0, 4.0]}
    Solution 2:
      test_case: {'k': 25907, 'grid': [[], 8.0]}
    Solution 3:
      test_case: {'k': 25907, 'grid': [[], 9.0]}
    Solution 4:
      test_case: {'k': 26497, 'grid': [[], 10.0]}
    Solution 5:
      test_case: {'k': 26497, 'grid': [[], 11.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (IsList (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))

(define-fun-rec list_nth ((l Value) (idx Int)) Value
  (ite (not (is-Cons l))
       Nil
       (ite (= idx 0)
            (head l)
            (list_nth (tail l) (- idx 1)))))

(define-fun-rec AllRowsSameLen ((rows Value) (n Int)) Bool
  (ite (is-Nil rows)
       true
       (and (is-Cons rows)
            (let ((row (head rows)))
              (and (IsList row)
                   (= (length row) n)
                   (AllRowsSameLen (tail rows) n))))))

(define-fun-rec RowOK ((row Value) (j Int) (i Int) (n Int)) Bool
  (ite (= j n)
       (is-Nil row)
       (and (is-Cons row)
            (is-IntVal (head row))
            (= (ival (head row)) (+ 1 j (* i n)))
            (RowOK (tail row) (+ j 1) i n))))

(define-fun-rec GridOK ((rows Value) (i Int) (n Int)) Bool
  (ite (= i n)
       (is-Nil rows)
       (and (is-Cons rows)
            (RowOK (head rows) 0 i n)
            (GridOK (tail rows) (+ i 1) n))))

; === Inputs ===
(declare-const grid Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList grid))
(assert (is-IntVal k))
(assert (<= (length grid) 3))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal k))
(define-fun C1 () Bool (and (is-IntVal k) (> (ival k) 0)))
(define-fun C2 () Bool (and (IsList grid) (>= (length grid) 2)))
(define-fun C3 () Bool (and (IsList grid) (AllRowsSameLen grid (length grid))))
(define-fun C4 () Bool (let ((n (length grid))) (GridOK grid 0 n)))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)
(assert (not C3))
(assert (not C4))

(check-sat)
(get-model)

------------------------------
  Test Case 9: satisfied_assert_3, violated_assert_0;assert_1;assert_2;assert_4
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False, 'assert_3': True, 'assert_4': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_3'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_4'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (IsList (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))

(define-fun-rec list_nth ((l Value) (idx Int)) Value
  (ite (not (is-Cons l))
       Nil
       (ite (= idx 0)
            (head l)
            (list_nth (tail l) (- idx 1)))))

(define-fun-rec AllRowsSameLen ((rows Value) (n Int)) Bool
  (ite (is-Nil rows)
       true
       (and (is-Cons rows)
            (let ((row (head rows)))
              (and (IsList row)
                   (= (length row) n)
                   (AllRowsSameLen (tail rows) n))))))

(define-fun-rec RowOK ((row Value) (j Int) (i Int) (n Int)) Bool
  (ite (= j n)
       (is-Nil row)
       (and (is-Cons row)
            (is-IntVal (head row))
            (= (ival (head row)) (+ 1 j (* i n)))
            (RowOK (tail row) (+ j 1) i n))))

(define-fun-rec GridOK ((rows Value) (i Int) (n Int)) Bool
  (ite (= i n)
       (is-Nil rows)
       (and (is-Cons rows)
            (RowOK (head rows) 0 i n)
            (GridOK (tail rows) (+ i 1) n))))

; === Inputs ===
(declare-const grid Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList grid))
(assert (is-IntVal k))
(assert (<= (length grid) 3))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal k))
(define-fun C1 () Bool (and (is-IntVal k) (> (ival k) 0)))
(define-fun C2 () Bool (and (IsList grid) (>= (length grid) 2)))
(define-fun C3 () Bool (and (IsList grid) (AllRowsSameLen grid (length grid))))
(define-fun C4 () Bool (let ((n (length grid))) (GridOK grid 0 n)))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))
(assert C3)
(assert (not C4))

(check-sat)
(get-model)

------------------------------
  Test Case 10: satisfied_assert_0;assert_3, violated_assert_1;assert_2;assert_4
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False, 'assert_3': True, 'assert_4': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_3'], 'violated_contracts': ['assert_1', 'assert_2', 'assert_4'], 'total_contracts': 5}
  Solutions:
    Solution 1:
      test_case: {'k': 0, 'grid': [[2.0]]}
    Solution 2:
      test_case: {'k': -590, 'grid': [[3.0]]}
    Solution 3:
      test_case: {'k': -590, 'grid': [[4.0]]}
    Solution 4:
      test_case: {'k': -590, 'grid': [[5.0]]}
    Solution 5:
      test_case: {'k': -8219, 'grid': [[6.0]]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (IsList (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))

(define-fun-rec list_nth ((l Value) (idx Int)) Value
  (ite (not (is-Cons l))
       Nil
       (ite (= idx 0)
            (head l)
            (list_nth (tail l) (- idx 1)))))

(define-fun-rec AllRowsSameLen ((rows Value) (n Int)) Bool
  (ite (is-Nil rows)
       true
       (and (is-Cons rows)
            (let ((row (head rows)))
              (and (IsList row)
                   (= (length row) n)
                   (AllRowsSameLen (tail rows) n))))))

(define-fun-rec RowOK ((row Value) (j Int) (i Int) (n Int)) Bool
  (ite (= j n)
       (is-Nil row)
       (and (is-Cons row)
            (is-IntVal (head row))
            (= (ival (head row)) (+ 1 j (* i n)))
            (RowOK (tail row) (+ j 1) i n))))

(define-fun-rec GridOK ((rows Value) (i Int) (n Int)) Bool
  (ite (= i n)
       (is-Nil rows)
       (and (is-Cons rows)
            (RowOK (head rows) 0 i n)
            (GridOK (tail rows) (+ i 1) n))))

; === Inputs ===
(declare-const grid Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList grid))
(assert (is-IntVal k))
(assert (<= (length grid) 3))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal k))
(define-fun C1 () Bool (and (is-IntVal k) (> (ival k) 0)))
(define-fun C2 () Bool (and (IsList grid) (>= (length grid) 2)))
(define-fun C3 () Bool (and (IsList grid) (AllRowsSameLen grid (length grid))))
(define-fun C4 () Bool (let ((n (length grid))) (GridOK grid 0 n)))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))
(assert C3)
(assert (not C4))

(check-sat)
(get-model)

------------------------------
  Test Case 11: satisfied_assert_1;assert_3, violated_assert_0;assert_2;assert_4
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False, 'assert_3': True, 'assert_4': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_3'], 'violated_contracts': ['assert_0', 'assert_2', 'assert_4'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (IsList (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))

(define-fun-rec list_nth ((l Value) (idx Int)) Value
  (ite (not (is-Cons l))
       Nil
       (ite (= idx 0)
            (head l)
            (list_nth (tail l) (- idx 1)))))

(define-fun-rec AllRowsSameLen ((rows Value) (n Int)) Bool
  (ite (is-Nil rows)
       true
       (and (is-Cons rows)
            (let ((row (head rows)))
              (and (IsList row)
                   (= (length row) n)
                   (AllRowsSameLen (tail rows) n))))))

(define-fun-rec RowOK ((row Value) (j Int) (i Int) (n Int)) Bool
  (ite (= j n)
       (is-Nil row)
       (and (is-Cons row)
            (is-IntVal (head row))
            (= (ival (head row)) (+ 1 j (* i n)))
            (RowOK (tail row) (+ j 1) i n))))

(define-fun-rec GridOK ((rows Value) (i Int) (n Int)) Bool
  (ite (= i n)
       (is-Nil rows)
       (and (is-Cons rows)
            (RowOK (head rows) 0 i n)
            (GridOK (tail rows) (+ i 1) n))))

; === Inputs ===
(declare-const grid Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList grid))
(assert (is-IntVal k))
(assert (<= (length grid) 3))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal k))
(define-fun C1 () Bool (and (is-IntVal k) (> (ival k) 0)))
(define-fun C2 () Bool (and (IsList grid) (>= (length grid) 2)))
(define-fun C3 () Bool (and (IsList grid) (AllRowsSameLen grid (length grid))))
(define-fun C4 () Bool (let ((n (length grid))) (GridOK grid 0 n)))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))
(assert C3)
(assert (not C4))

(check-sat)
(get-model)

------------------------------
  Test Case 12: satisfied_assert_0;assert_1;assert_3, violated_assert_2;assert_4
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False, 'assert_3': True, 'assert_4': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_3'], 'violated_contracts': ['assert_2', 'assert_4'], 'total_contracts': 5}
  Solutions:
    Solution 1:
      test_case: {'k': 1, 'grid': [[2.0]]}
    Solution 2:
      test_case: {'k': 591, 'grid': [[3.0]]}
    Solution 3:
      test_case: {'grid': [[4.0]], 'k': 591}
    Solution 4:
      test_case: {'grid': [[5.0]], 'k': 591}
    Solution 5:
      test_case: {'grid': [[6.0]], 'k': 8220}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (IsList (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))

(define-fun-rec list_nth ((l Value) (idx Int)) Value
  (ite (not (is-Cons l))
       Nil
       (ite (= idx 0)
            (head l)
            (list_nth (tail l) (- idx 1)))))

(define-fun-rec AllRowsSameLen ((rows Value) (n Int)) Bool
  (ite (is-Nil rows)
       true
       (and (is-Cons rows)
            (let ((row (head rows)))
              (and (IsList row)
                   (= (length row) n)
                   (AllRowsSameLen (tail rows) n))))))

(define-fun-rec RowOK ((row Value) (j Int) (i Int) (n Int)) Bool
  (ite (= j n)
       (is-Nil row)
       (and (is-Cons row)
            (is-IntVal (head row))
            (= (ival (head row)) (+ 1 j (* i n)))
            (RowOK (tail row) (+ j 1) i n))))

(define-fun-rec GridOK ((rows Value) (i Int) (n Int)) Bool
  (ite (= i n)
       (is-Nil rows)
       (and (is-Cons rows)
            (RowOK (head rows) 0 i n)
            (GridOK (tail rows) (+ i 1) n))))

; === Inputs ===
(declare-const grid Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList grid))
(assert (is-IntVal k))
(assert (<= (length grid) 3))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal k))
(define-fun C1 () Bool (and (is-IntVal k) (> (ival k) 0)))
(define-fun C2 () Bool (and (IsList grid) (>= (length grid) 2)))
(define-fun C3 () Bool (and (IsList grid) (AllRowsSameLen grid (length grid))))
(define-fun C4 () Bool (let ((n (length grid))) (GridOK grid 0 n)))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))
(assert C3)
(assert (not C4))

(check-sat)
(get-model)

------------------------------
  Test Case 13: satisfied_assert_2;assert_3, violated_assert_0;assert_1;assert_4
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True, 'assert_3': True, 'assert_4': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_2', 'assert_3'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_4'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (IsList (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))

(define-fun-rec list_nth ((l Value) (idx Int)) Value
  (ite (not (is-Cons l))
       Nil
       (ite (= idx 0)
            (head l)
            (list_nth (tail l) (- idx 1)))))

(define-fun-rec AllRowsSameLen ((rows Value) (n Int)) Bool
  (ite (is-Nil rows)
       true
       (and (is-Cons rows)
            (let ((row (head rows)))
              (and (IsList row)
                   (= (length row) n)
                   (AllRowsSameLen (tail rows) n))))))

(define-fun-rec RowOK ((row Value) (j Int) (i Int) (n Int)) Bool
  (ite (= j n)
       (is-Nil row)
       (and (is-Cons row)
            (is-IntVal (head row))
            (= (ival (head row)) (+ 1 j (* i n)))
            (RowOK (tail row) (+ j 1) i n))))

(define-fun-rec GridOK ((rows Value) (i Int) (n Int)) Bool
  (ite (= i n)
       (is-Nil rows)
       (and (is-Cons rows)
            (RowOK (head rows) 0 i n)
            (GridOK (tail rows) (+ i 1) n))))

; === Inputs ===
(declare-const grid Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList grid))
(assert (is-IntVal k))
(assert (<= (length grid) 3))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal k))
(define-fun C1 () Bool (and (is-IntVal k) (> (ival k) 0)))
(define-fun C2 () Bool (and (IsList grid) (>= (length grid) 2)))
(define-fun C3 () Bool (and (IsList grid) (AllRowsSameLen grid (length grid))))
(define-fun C4 () Bool (let ((n (length grid))) (GridOK grid 0 n)))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)
(assert C3)
(assert (not C4))

(check-sat)
(get-model)

------------------------------
  Test Case 14: satisfied_assert_0;assert_2;assert_3, violated_assert_1;assert_4
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True, 'assert_3': True, 'assert_4': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2', 'assert_3'], 'violated_contracts': ['assert_1', 'assert_4'], 'total_contracts': 5}
  Solutions:
    Solution 1:
      test_case: {'k': 0, 'grid': [[2.0, 3.0], [4.0, 4]]}
    Solution 2:
      test_case: {'k': -18457, 'grid': [[5.0, 6.0], [7.0, 4]]}
    Solution 3:
      test_case: {'k': -18457, 'grid': [[9.0, 10.0], [8.0, 4]]}
    Solution 4:
      test_case: {'k': -18457, 'grid': [[11.0, 13.0], [12.0, 4]]}
    Solution 5:
      test_case: {'k': -18457, 'grid': [[16.0, 15.0], [14.0, 4]]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (IsList (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))

(define-fun-rec list_nth ((l Value) (idx Int)) Value
  (ite (not (is-Cons l))
       Nil
       (ite (= idx 0)
            (head l)
            (list_nth (tail l) (- idx 1)))))

(define-fun-rec AllRowsSameLen ((rows Value) (n Int)) Bool
  (ite (is-Nil rows)
       true
       (and (is-Cons rows)
            (let ((row (head rows)))
              (and (IsList row)
                   (= (length row) n)
                   (AllRowsSameLen (tail rows) n))))))

(define-fun-rec RowOK ((row Value) (j Int) (i Int) (n Int)) Bool
  (ite (= j n)
       (is-Nil row)
       (and (is-Cons row)
            (is-IntVal (head row))
            (= (ival (head row)) (+ 1 j (* i n)))
            (RowOK (tail row) (+ j 1) i n))))

(define-fun-rec GridOK ((rows Value) (i Int) (n Int)) Bool
  (ite (= i n)
       (is-Nil rows)
       (and (is-Cons rows)
            (RowOK (head rows) 0 i n)
            (GridOK (tail rows) (+ i 1) n))))

; === Inputs ===
(declare-const grid Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList grid))
(assert (is-IntVal k))
(assert (<= (length grid) 3))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal k))
(define-fun C1 () Bool (and (is-IntVal k) (> (ival k) 0)))
(define-fun C2 () Bool (and (IsList grid) (>= (length grid) 2)))
(define-fun C3 () Bool (and (IsList grid) (AllRowsSameLen grid (length grid))))
(define-fun C4 () Bool (let ((n (length grid))) (GridOK grid 0 n)))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)
(assert C3)
(assert (not C4))

(check-sat)
(get-model)

------------------------------
  Test Case 15: satisfied_assert_1;assert_2;assert_3, violated_assert_0;assert_4
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True, 'assert_3': True, 'assert_4': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2', 'assert_3'], 'violated_contracts': ['assert_0', 'assert_4'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (IsList (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))

(define-fun-rec list_nth ((l Value) (idx Int)) Value
  (ite (not (is-Cons l))
       Nil
       (ite (= idx 0)
            (head l)
            (list_nth (tail l) (- idx 1)))))

(define-fun-rec AllRowsSameLen ((rows Value) (n Int)) Bool
  (ite (is-Nil rows)
       true
       (and (is-Cons rows)
            (let ((row (head rows)))
              (and (IsList row)
                   (= (length row) n)
                   (AllRowsSameLen (tail rows) n))))))

(define-fun-rec RowOK ((row Value) (j Int) (i Int) (n Int)) Bool
  (ite (= j n)
       (is-Nil row)
       (and (is-Cons row)
            (is-IntVal (head row))
            (= (ival (head row)) (+ 1 j (* i n)))
            (RowOK (tail row) (+ j 1) i n))))

(define-fun-rec GridOK ((rows Value) (i Int) (n Int)) Bool
  (ite (= i n)
       (is-Nil rows)
       (and (is-Cons rows)
            (RowOK (head rows) 0 i n)
            (GridOK (tail rows) (+ i 1) n))))

; === Inputs ===
(declare-const grid Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList grid))
(assert (is-IntVal k))
(assert (<= (length grid) 3))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal k))
(define-fun C1 () Bool (and (is-IntVal k) (> (ival k) 0)))
(define-fun C2 () Bool (and (IsList grid) (>= (length grid) 2)))
(define-fun C3 () Bool (and (IsList grid) (AllRowsSameLen grid (length grid))))
(define-fun C4 () Bool (let ((n (length grid))) (GridOK grid 0 n)))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)
(assert C3)
(assert (not C4))

(check-sat)
(get-model)

------------------------------
  Test Case 16: satisfied_assert_0;assert_1;assert_2;assert_3, violated_assert_4
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True, 'assert_3': True, 'assert_4': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_3'], 'violated_contracts': ['assert_4'], 'total_contracts': 5}
  Solutions:
    Solution 1:
      test_case: {'k': 1, 'grid': [[2.0, 3.0], [4.0, 4]]}
    Solution 2:
      test_case: {'k': 18458, 'grid': [[5.0, 6.0], [7.0, 4]]}
    Solution 3:
      test_case: {'k': 18458, 'grid': [[9.0, 10.0], [8.0, 4]]}
    Solution 4:
      test_case: {'k': 18458, 'grid': [[11.0, 13.0], [12.0, 4]]}
    Solution 5:
      test_case: {'k': 18458, 'grid': [[16.0, 15.0], [14.0, 4]]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (IsList (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))

(define-fun-rec list_nth ((l Value) (idx Int)) Value
  (ite (not (is-Cons l))
       Nil
       (ite (= idx 0)
            (head l)
            (list_nth (tail l) (- idx 1)))))

(define-fun-rec AllRowsSameLen ((rows Value) (n Int)) Bool
  (ite (is-Nil rows)
       true
       (and (is-Cons rows)
            (let ((row (head rows)))
              (and (IsList row)
                   (= (length row) n)
                   (AllRowsSameLen (tail rows) n))))))

(define-fun-rec RowOK ((row Value) (j Int) (i Int) (n Int)) Bool
  (ite (= j n)
       (is-Nil row)
       (and (is-Cons row)
            (is-IntVal (head row))
            (= (ival (head row)) (+ 1 j (* i n)))
            (RowOK (tail row) (+ j 1) i n))))

(define-fun-rec GridOK ((rows Value) (i Int) (n Int)) Bool
  (ite (= i n)
       (is-Nil rows)
       (and (is-Cons rows)
            (RowOK (head rows) 0 i n)
            (GridOK (tail rows) (+ i 1) n))))

; === Inputs ===
(declare-const grid Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList grid))
(assert (is-IntVal k))
(assert (<= (length grid) 3))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal k))
(define-fun C1 () Bool (and (is-IntVal k) (> (ival k) 0)))
(define-fun C2 () Bool (and (IsList grid) (>= (length grid) 2)))
(define-fun C3 () Bool (and (IsList grid) (AllRowsSameLen grid (length grid))))
(define-fun C4 () Bool (let ((n (length grid))) (GridOK grid 0 n)))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)
(assert C3)
(assert (not C4))

(check-sat)
(get-model)

------------------------------
  Test Case 17: satisfied_assert_4, violated_assert_0;assert_1;assert_2;assert_3
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False, 'assert_3': False, 'assert_4': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_4'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_3'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (IsList (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))

(define-fun-rec list_nth ((l Value) (idx Int)) Value
  (ite (not (is-Cons l))
       Nil
       (ite (= idx 0)
            (head l)
            (list_nth (tail l) (- idx 1)))))

(define-fun-rec AllRowsSameLen ((rows Value) (n Int)) Bool
  (ite (is-Nil rows)
       true
       (and (is-Cons rows)
            (let ((row (head rows)))
              (and (IsList row)
                   (= (length row) n)
                   (AllRowsSameLen (tail rows) n))))))

(define-fun-rec RowOK ((row Value) (j Int) (i Int) (n Int)) Bool
  (ite (= j n)
       (is-Nil row)
       (and (is-Cons row)
            (is-IntVal (head row))
            (= (ival (head row)) (+ 1 j (* i n)))
            (RowOK (tail row) (+ j 1) i n))))

(define-fun-rec GridOK ((rows Value) (i Int) (n Int)) Bool
  (ite (= i n)
       (is-Nil rows)
       (and (is-Cons rows)
            (RowOK (head rows) 0 i n)
            (GridOK (tail rows) (+ i 1) n))))

; === Inputs ===
(declare-const grid Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList grid))
(assert (is-IntVal k))
(assert (<= (length grid) 3))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal k))
(define-fun C1 () Bool (and (is-IntVal k) (> (ival k) 0)))
(define-fun C2 () Bool (and (IsList grid) (>= (length grid) 2)))
(define-fun C3 () Bool (and (IsList grid) (AllRowsSameLen grid (length grid))))
(define-fun C4 () Bool (let ((n (length grid))) (GridOK grid 0 n)))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))
(assert (not C3))
(assert C4)

(check-sat)
(get-model)

------------------------------
  Test Case 18: satisfied_assert_0;assert_4, violated_assert_1;assert_2;assert_3
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False, 'assert_3': False, 'assert_4': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_4'], 'violated_contracts': ['assert_1', 'assert_2', 'assert_3'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (IsList (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))

(define-fun-rec list_nth ((l Value) (idx Int)) Value
  (ite (not (is-Cons l))
       Nil
       (ite (= idx 0)
            (head l)
            (list_nth (tail l) (- idx 1)))))

(define-fun-rec AllRowsSameLen ((rows Value) (n Int)) Bool
  (ite (is-Nil rows)
       true
       (and (is-Cons rows)
            (let ((row (head rows)))
              (and (IsList row)
                   (= (length row) n)
                   (AllRowsSameLen (tail rows) n))))))

(define-fun-rec RowOK ((row Value) (j Int) (i Int) (n Int)) Bool
  (ite (= j n)
       (is-Nil row)
       (and (is-Cons row)
            (is-IntVal (head row))
            (= (ival (head row)) (+ 1 j (* i n)))
            (RowOK (tail row) (+ j 1) i n))))

(define-fun-rec GridOK ((rows Value) (i Int) (n Int)) Bool
  (ite (= i n)
       (is-Nil rows)
       (and (is-Cons rows)
            (RowOK (head rows) 0 i n)
            (GridOK (tail rows) (+ i 1) n))))

; === Inputs ===
(declare-const grid Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList grid))
(assert (is-IntVal k))
(assert (<= (length grid) 3))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal k))
(define-fun C1 () Bool (and (is-IntVal k) (> (ival k) 0)))
(define-fun C2 () Bool (and (IsList grid) (>= (length grid) 2)))
(define-fun C3 () Bool (and (IsList grid) (AllRowsSameLen grid (length grid))))
(define-fun C4 () Bool (let ((n (length grid))) (GridOK grid 0 n)))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))
(assert (not C3))
(assert C4)

(check-sat)
(get-model)

------------------------------
  Test Case 19: satisfied_assert_1;assert_4, violated_assert_0;assert_2;assert_3
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False, 'assert_3': False, 'assert_4': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_4'], 'violated_contracts': ['assert_0', 'assert_2', 'assert_3'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (IsList (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))

(define-fun-rec list_nth ((l Value) (idx Int)) Value
  (ite (not (is-Cons l))
       Nil
       (ite (= idx 0)
            (head l)
            (list_nth (tail l) (- idx 1)))))

(define-fun-rec AllRowsSameLen ((rows Value) (n Int)) Bool
  (ite (is-Nil rows)
       true
       (and (is-Cons rows)
            (let ((row (head rows)))
              (and (IsList row)
                   (= (length row) n)
                   (AllRowsSameLen (tail rows) n))))))

(define-fun-rec RowOK ((row Value) (j Int) (i Int) (n Int)) Bool
  (ite (= j n)
       (is-Nil row)
       (and (is-Cons row)
            (is-IntVal (head row))
            (= (ival (head row)) (+ 1 j (* i n)))
            (RowOK (tail row) (+ j 1) i n))))

(define-fun-rec GridOK ((rows Value) (i Int) (n Int)) Bool
  (ite (= i n)
       (is-Nil rows)
       (and (is-Cons rows)
            (RowOK (head rows) 0 i n)
            (GridOK (tail rows) (+ i 1) n))))

; === Inputs ===
(declare-const grid Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList grid))
(assert (is-IntVal k))
(assert (<= (length grid) 3))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal k))
(define-fun C1 () Bool (and (is-IntVal k) (> (ival k) 0)))
(define-fun C2 () Bool (and (IsList grid) (>= (length grid) 2)))
(define-fun C3 () Bool (and (IsList grid) (AllRowsSameLen grid (length grid))))
(define-fun C4 () Bool (let ((n (length grid))) (GridOK grid 0 n)))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))
(assert (not C3))
(assert C4)

(check-sat)
(get-model)

------------------------------
  Test Case 20: satisfied_assert_0;assert_1;assert_4, violated_assert_2;assert_3
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False, 'assert_3': False, 'assert_4': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_4'], 'violated_contracts': ['assert_2', 'assert_3'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (IsList (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))

(define-fun-rec list_nth ((l Value) (idx Int)) Value
  (ite (not (is-Cons l))
       Nil
       (ite (= idx 0)
            (head l)
            (list_nth (tail l) (- idx 1)))))

(define-fun-rec AllRowsSameLen ((rows Value) (n Int)) Bool
  (ite (is-Nil rows)
       true
       (and (is-Cons rows)
            (let ((row (head rows)))
              (and (IsList row)
                   (= (length row) n)
                   (AllRowsSameLen (tail rows) n))))))

(define-fun-rec RowOK ((row Value) (j Int) (i Int) (n Int)) Bool
  (ite (= j n)
       (is-Nil row)
       (and (is-Cons row)
            (is-IntVal (head row))
            (= (ival (head row)) (+ 1 j (* i n)))
            (RowOK (tail row) (+ j 1) i n))))

(define-fun-rec GridOK ((rows Value) (i Int) (n Int)) Bool
  (ite (= i n)
       (is-Nil rows)
       (and (is-Cons rows)
            (RowOK (head rows) 0 i n)
            (GridOK (tail rows) (+ i 1) n))))

; === Inputs ===
(declare-const grid Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList grid))
(assert (is-IntVal k))
(assert (<= (length grid) 3))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal k))
(define-fun C1 () Bool (and (is-IntVal k) (> (ival k) 0)))
(define-fun C2 () Bool (and (IsList grid) (>= (length grid) 2)))
(define-fun C3 () Bool (and (IsList grid) (AllRowsSameLen grid (length grid))))
(define-fun C4 () Bool (let ((n (length grid))) (GridOK grid 0 n)))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))
(assert (not C3))
(assert C4)

(check-sat)
(get-model)

------------------------------
  Test Case 21: satisfied_assert_2;assert_4, violated_assert_0;assert_1;assert_3
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True, 'assert_3': False, 'assert_4': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_2', 'assert_4'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_3'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (IsList (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))

(define-fun-rec list_nth ((l Value) (idx Int)) Value
  (ite (not (is-Cons l))
       Nil
       (ite (= idx 0)
            (head l)
            (list_nth (tail l) (- idx 1)))))

(define-fun-rec AllRowsSameLen ((rows Value) (n Int)) Bool
  (ite (is-Nil rows)
       true
       (and (is-Cons rows)
            (let ((row (head rows)))
              (and (IsList row)
                   (= (length row) n)
                   (AllRowsSameLen (tail rows) n))))))

(define-fun-rec RowOK ((row Value) (j Int) (i Int) (n Int)) Bool
  (ite (= j n)
       (is-Nil row)
       (and (is-Cons row)
            (is-IntVal (head row))
            (= (ival (head row)) (+ 1 j (* i n)))
            (RowOK (tail row) (+ j 1) i n))))

(define-fun-rec GridOK ((rows Value) (i Int) (n Int)) Bool
  (ite (= i n)
       (is-Nil rows)
       (and (is-Cons rows)
            (RowOK (head rows) 0 i n)
            (GridOK (tail rows) (+ i 1) n))))

; === Inputs ===
(declare-const grid Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList grid))
(assert (is-IntVal k))
(assert (<= (length grid) 3))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal k))
(define-fun C1 () Bool (and (is-IntVal k) (> (ival k) 0)))
(define-fun C2 () Bool (and (IsList grid) (>= (length grid) 2)))
(define-fun C3 () Bool (and (IsList grid) (AllRowsSameLen grid (length grid))))
(define-fun C4 () Bool (let ((n (length grid))) (GridOK grid 0 n)))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)
(assert (not C3))
(assert C4)

(check-sat)
(get-model)

------------------------------
  Test Case 22: satisfied_assert_0;assert_2;assert_4, violated_assert_1;assert_3
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True, 'assert_3': False, 'assert_4': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2', 'assert_4'], 'violated_contracts': ['assert_1', 'assert_3'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (IsList (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))

(define-fun-rec list_nth ((l Value) (idx Int)) Value
  (ite (not (is-Cons l))
       Nil
       (ite (= idx 0)
            (head l)
            (list_nth (tail l) (- idx 1)))))

(define-fun-rec AllRowsSameLen ((rows Value) (n Int)) Bool
  (ite (is-Nil rows)
       true
       (and (is-Cons rows)
            (let ((row (head rows)))
              (and (IsList row)
                   (= (length row) n)
                   (AllRowsSameLen (tail rows) n))))))

(define-fun-rec RowOK ((row Value) (j Int) (i Int) (n Int)) Bool
  (ite (= j n)
       (is-Nil row)
       (and (is-Cons row)
            (is-IntVal (head row))
            (= (ival (head row)) (+ 1 j (* i n)))
            (RowOK (tail row) (+ j 1) i n))))

(define-fun-rec GridOK ((rows Value) (i Int) (n Int)) Bool
  (ite (= i n)
       (is-Nil rows)
       (and (is-Cons rows)
            (RowOK (head rows) 0 i n)
            (GridOK (tail rows) (+ i 1) n))))

; === Inputs ===
(declare-const grid Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList grid))
(assert (is-IntVal k))
(assert (<= (length grid) 3))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal k))
(define-fun C1 () Bool (and (is-IntVal k) (> (ival k) 0)))
(define-fun C2 () Bool (and (IsList grid) (>= (length grid) 2)))
(define-fun C3 () Bool (and (IsList grid) (AllRowsSameLen grid (length grid))))
(define-fun C4 () Bool (let ((n (length grid))) (GridOK grid 0 n)))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)
(assert (not C3))
(assert C4)

(check-sat)
(get-model)

------------------------------
  Test Case 23: satisfied_assert_1;assert_2;assert_4, violated_assert_0;assert_3
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True, 'assert_3': False, 'assert_4': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2', 'assert_4'], 'violated_contracts': ['assert_0', 'assert_3'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (IsList (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))

(define-fun-rec list_nth ((l Value) (idx Int)) Value
  (ite (not (is-Cons l))
       Nil
       (ite (= idx 0)
            (head l)
            (list_nth (tail l) (- idx 1)))))

(define-fun-rec AllRowsSameLen ((rows Value) (n Int)) Bool
  (ite (is-Nil rows)
       true
       (and (is-Cons rows)
            (let ((row (head rows)))
              (and (IsList row)
                   (= (length row) n)
                   (AllRowsSameLen (tail rows) n))))))

(define-fun-rec RowOK ((row Value) (j Int) (i Int) (n Int)) Bool
  (ite (= j n)
       (is-Nil row)
       (and (is-Cons row)
            (is-IntVal (head row))
            (= (ival (head row)) (+ 1 j (* i n)))
            (RowOK (tail row) (+ j 1) i n))))

(define-fun-rec GridOK ((rows Value) (i Int) (n Int)) Bool
  (ite (= i n)
       (is-Nil rows)
       (and (is-Cons rows)
            (RowOK (head rows) 0 i n)
            (GridOK (tail rows) (+ i 1) n))))

; === Inputs ===
(declare-const grid Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList grid))
(assert (is-IntVal k))
(assert (<= (length grid) 3))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal k))
(define-fun C1 () Bool (and (is-IntVal k) (> (ival k) 0)))
(define-fun C2 () Bool (and (IsList grid) (>= (length grid) 2)))
(define-fun C3 () Bool (and (IsList grid) (AllRowsSameLen grid (length grid))))
(define-fun C4 () Bool (let ((n (length grid))) (GridOK grid 0 n)))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)
(assert (not C3))
(assert C4)

(check-sat)
(get-model)

------------------------------
  Test Case 24: satisfied_assert_0;assert_1;assert_2;assert_4, violated_assert_3
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True, 'assert_3': False, 'assert_4': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_4'], 'violated_contracts': ['assert_3'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (IsList (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))

(define-fun-rec list_nth ((l Value) (idx Int)) Value
  (ite (not (is-Cons l))
       Nil
       (ite (= idx 0)
            (head l)
            (list_nth (tail l) (- idx 1)))))

(define-fun-rec AllRowsSameLen ((rows Value) (n Int)) Bool
  (ite (is-Nil rows)
       true
       (and (is-Cons rows)
            (let ((row (head rows)))
              (and (IsList row)
                   (= (length row) n)
                   (AllRowsSameLen (tail rows) n))))))

(define-fun-rec RowOK ((row Value) (j Int) (i Int) (n Int)) Bool
  (ite (= j n)
       (is-Nil row)
       (and (is-Cons row)
            (is-IntVal (head row))
            (= (ival (head row)) (+ 1 j (* i n)))
            (RowOK (tail row) (+ j 1) i n))))

(define-fun-rec GridOK ((rows Value) (i Int) (n Int)) Bool
  (ite (= i n)
       (is-Nil rows)
       (and (is-Cons rows)
            (RowOK (head rows) 0 i n)
            (GridOK (tail rows) (+ i 1) n))))

; === Inputs ===
(declare-const grid Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList grid))
(assert (is-IntVal k))
(assert (<= (length grid) 3))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal k))
(define-fun C1 () Bool (and (is-IntVal k) (> (ival k) 0)))
(define-fun C2 () Bool (and (IsList grid) (>= (length grid) 2)))
(define-fun C3 () Bool (and (IsList grid) (AllRowsSameLen grid (length grid))))
(define-fun C4 () Bool (let ((n (length grid))) (GridOK grid 0 n)))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)
(assert (not C3))
(assert C4)

(check-sat)
(get-model)

------------------------------
  Test Case 25: satisfied_assert_3;assert_4, violated_assert_0;assert_1;assert_2
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False, 'assert_3': True, 'assert_4': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_3', 'assert_4'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (IsList (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))

(define-fun-rec list_nth ((l Value) (idx Int)) Value
  (ite (not (is-Cons l))
       Nil
       (ite (= idx 0)
            (head l)
            (list_nth (tail l) (- idx 1)))))

(define-fun-rec AllRowsSameLen ((rows Value) (n Int)) Bool
  (ite (is-Nil rows)
       true
       (and (is-Cons rows)
            (let ((row (head rows)))
              (and (IsList row)
                   (= (length row) n)
                   (AllRowsSameLen (tail rows) n))))))

(define-fun-rec RowOK ((row Value) (j Int) (i Int) (n Int)) Bool
  (ite (= j n)
       (is-Nil row)
       (and (is-Cons row)
            (is-IntVal (head row))
            (= (ival (head row)) (+ 1 j (* i n)))
            (RowOK (tail row) (+ j 1) i n))))

(define-fun-rec GridOK ((rows Value) (i Int) (n Int)) Bool
  (ite (= i n)
       (is-Nil rows)
       (and (is-Cons rows)
            (RowOK (head rows) 0 i n)
            (GridOK (tail rows) (+ i 1) n))))

; === Inputs ===
(declare-const grid Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList grid))
(assert (is-IntVal k))
(assert (<= (length grid) 3))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal k))
(define-fun C1 () Bool (and (is-IntVal k) (> (ival k) 0)))
(define-fun C2 () Bool (and (IsList grid) (>= (length grid) 2)))
(define-fun C3 () Bool (and (IsList grid) (AllRowsSameLen grid (length grid))))
(define-fun C4 () Bool (let ((n (length grid))) (GridOK grid 0 n)))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))
(assert C3)
(assert C4)

(check-sat)
(get-model)

------------------------------
  Test Case 26: satisfied_assert_0;assert_3;assert_4, violated_assert_1;assert_2
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False, 'assert_3': True, 'assert_4': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_3', 'assert_4'], 'violated_contracts': ['assert_1', 'assert_2'], 'total_contracts': 5}
  Solutions:
    Solution 1:
      test_case: {'k': 0, 'grid': []}
    Solution 2:
      test_case: {'k': -21238, 'grid': []}
    Solution 3:
      test_case: {'k': -33035, 'grid': []}
    Solution 4:
      test_case: {'k': -43485, 'grid': []}
    Solution 5:
      test_case: {'k': -71585, 'grid': []}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (IsList (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))

(define-fun-rec list_nth ((l Value) (idx Int)) Value
  (ite (not (is-Cons l))
       Nil
       (ite (= idx 0)
            (head l)
            (list_nth (tail l) (- idx 1)))))

(define-fun-rec AllRowsSameLen ((rows Value) (n Int)) Bool
  (ite (is-Nil rows)
       true
       (and (is-Cons rows)
            (let ((row (head rows)))
              (and (IsList row)
                   (= (length row) n)
                   (AllRowsSameLen (tail rows) n))))))

(define-fun-rec RowOK ((row Value) (j Int) (i Int) (n Int)) Bool
  (ite (= j n)
       (is-Nil row)
       (and (is-Cons row)
            (is-IntVal (head row))
            (= (ival (head row)) (+ 1 j (* i n)))
            (RowOK (tail row) (+ j 1) i n))))

(define-fun-rec GridOK ((rows Value) (i Int) (n Int)) Bool
  (ite (= i n)
       (is-Nil rows)
       (and (is-Cons rows)
            (RowOK (head rows) 0 i n)
            (GridOK (tail rows) (+ i 1) n))))

; === Inputs ===
(declare-const grid Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList grid))
(assert (is-IntVal k))
(assert (<= (length grid) 3))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal k))
(define-fun C1 () Bool (and (is-IntVal k) (> (ival k) 0)))
(define-fun C2 () Bool (and (IsList grid) (>= (length grid) 2)))
(define-fun C3 () Bool (and (IsList grid) (AllRowsSameLen grid (length grid))))
(define-fun C4 () Bool (let ((n (length grid))) (GridOK grid 0 n)))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))
(assert C3)
(assert C4)

(check-sat)
(get-model)

------------------------------
  Test Case 27: satisfied_assert_1;assert_3;assert_4, violated_assert_0;assert_2
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False, 'assert_3': True, 'assert_4': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_3', 'assert_4'], 'violated_contracts': ['assert_0', 'assert_2'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (IsList (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))

(define-fun-rec list_nth ((l Value) (idx Int)) Value
  (ite (not (is-Cons l))
       Nil
       (ite (= idx 0)
            (head l)
            (list_nth (tail l) (- idx 1)))))

(define-fun-rec AllRowsSameLen ((rows Value) (n Int)) Bool
  (ite (is-Nil rows)
       true
       (and (is-Cons rows)
            (let ((row (head rows)))
              (and (IsList row)
                   (= (length row) n)
                   (AllRowsSameLen (tail rows) n))))))

(define-fun-rec RowOK ((row Value) (j Int) (i Int) (n Int)) Bool
  (ite (= j n)
       (is-Nil row)
       (and (is-Cons row)
            (is-IntVal (head row))
            (= (ival (head row)) (+ 1 j (* i n)))
            (RowOK (tail row) (+ j 1) i n))))

(define-fun-rec GridOK ((rows Value) (i Int) (n Int)) Bool
  (ite (= i n)
       (is-Nil rows)
       (and (is-Cons rows)
            (RowOK (head rows) 0 i n)
            (GridOK (tail rows) (+ i 1) n))))

; === Inputs ===
(declare-const grid Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList grid))
(assert (is-IntVal k))
(assert (<= (length grid) 3))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal k))
(define-fun C1 () Bool (and (is-IntVal k) (> (ival k) 0)))
(define-fun C2 () Bool (and (IsList grid) (>= (length grid) 2)))
(define-fun C3 () Bool (and (IsList grid) (AllRowsSameLen grid (length grid))))
(define-fun C4 () Bool (let ((n (length grid))) (GridOK grid 0 n)))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))
(assert C3)
(assert C4)

(check-sat)
(get-model)

------------------------------
  Test Case 28: satisfied_assert_0;assert_1;assert_3;assert_4, violated_assert_2
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False, 'assert_3': True, 'assert_4': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_3', 'assert_4'], 'violated_contracts': ['assert_2'], 'total_contracts': 5}
  Solutions:
    Solution 1:
      test_case: {'k': 1, 'grid': []}
    Solution 2:
      test_case: {'k': 21239, 'grid': []}
    Solution 3:
      test_case: {'k': 33036, 'grid': []}
    Solution 4:
      test_case: {'k': 43486, 'grid': []}
    Solution 5:
      test_case: {'k': 71586, 'grid': []}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (IsList (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))

(define-fun-rec list_nth ((l Value) (idx Int)) Value
  (ite (not (is-Cons l))
       Nil
       (ite (= idx 0)
            (head l)
            (list_nth (tail l) (- idx 1)))))

(define-fun-rec AllRowsSameLen ((rows Value) (n Int)) Bool
  (ite (is-Nil rows)
       true
       (and (is-Cons rows)
            (let ((row (head rows)))
              (and (IsList row)
                   (= (length row) n)
                   (AllRowsSameLen (tail rows) n))))))

(define-fun-rec RowOK ((row Value) (j Int) (i Int) (n Int)) Bool
  (ite (= j n)
       (is-Nil row)
       (and (is-Cons row)
            (is-IntVal (head row))
            (= (ival (head row)) (+ 1 j (* i n)))
            (RowOK (tail row) (+ j 1) i n))))

(define-fun-rec GridOK ((rows Value) (i Int) (n Int)) Bool
  (ite (= i n)
       (is-Nil rows)
       (and (is-Cons rows)
            (RowOK (head rows) 0 i n)
            (GridOK (tail rows) (+ i 1) n))))

; === Inputs ===
(declare-const grid Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList grid))
(assert (is-IntVal k))
(assert (<= (length grid) 3))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal k))
(define-fun C1 () Bool (and (is-IntVal k) (> (ival k) 0)))
(define-fun C2 () Bool (and (IsList grid) (>= (length grid) 2)))
(define-fun C3 () Bool (and (IsList grid) (AllRowsSameLen grid (length grid))))
(define-fun C4 () Bool (let ((n (length grid))) (GridOK grid 0 n)))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))
(assert C3)
(assert C4)

(check-sat)
(get-model)

------------------------------
  Test Case 29: satisfied_assert_2;assert_3;assert_4, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True, 'assert_3': True, 'assert_4': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_2', 'assert_3', 'assert_4'], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (IsList (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))

(define-fun-rec list_nth ((l Value) (idx Int)) Value
  (ite (not (is-Cons l))
       Nil
       (ite (= idx 0)
            (head l)
            (list_nth (tail l) (- idx 1)))))

(define-fun-rec AllRowsSameLen ((rows Value) (n Int)) Bool
  (ite (is-Nil rows)
       true
       (and (is-Cons rows)
            (let ((row (head rows)))
              (and (IsList row)
                   (= (length row) n)
                   (AllRowsSameLen (tail rows) n))))))

(define-fun-rec RowOK ((row Value) (j Int) (i Int) (n Int)) Bool
  (ite (= j n)
       (is-Nil row)
       (and (is-Cons row)
            (is-IntVal (head row))
            (= (ival (head row)) (+ 1 j (* i n)))
            (RowOK (tail row) (+ j 1) i n))))

(define-fun-rec GridOK ((rows Value) (i Int) (n Int)) Bool
  (ite (= i n)
       (is-Nil rows)
       (and (is-Cons rows)
            (RowOK (head rows) 0 i n)
            (GridOK (tail rows) (+ i 1) n))))

; === Inputs ===
(declare-const grid Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList grid))
(assert (is-IntVal k))
(assert (<= (length grid) 3))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal k))
(define-fun C1 () Bool (and (is-IntVal k) (> (ival k) 0)))
(define-fun C2 () Bool (and (IsList grid) (>= (length grid) 2)))
(define-fun C3 () Bool (and (IsList grid) (AllRowsSameLen grid (length grid))))
(define-fun C4 () Bool (let ((n (length grid))) (GridOK grid 0 n)))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)
(assert C3)
(assert C4)

(check-sat)
(get-model)

------------------------------
  Test Case 30: satisfied_assert_0;assert_2;assert_3;assert_4, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True, 'assert_3': True, 'assert_4': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2', 'assert_3', 'assert_4'], 'violated_contracts': ['assert_1'], 'total_contracts': 5}
  Solutions:
    Solution 1:
      test_case: {'k': 0, 'grid': [[1, 2], [3, 4]]}
    Solution 2:
      test_case: {'k': -20537, 'grid': [[1, 2], [3, 4]]}
    Solution 3:
      test_case: {'k': -23534, 'grid': [[1, 2], [3, 4]]}
    Solution 4:
      test_case: {'k': -45189, 'grid': [[1, 2], [3, 4]]}
    Solution 5:
      test_case: {'k': -74070, 'grid': [[1, 2], [3, 4]]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (IsList (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))

(define-fun-rec list_nth ((l Value) (idx Int)) Value
  (ite (not (is-Cons l))
       Nil
       (ite (= idx 0)
            (head l)
            (list_nth (tail l) (- idx 1)))))

(define-fun-rec AllRowsSameLen ((rows Value) (n Int)) Bool
  (ite (is-Nil rows)
       true
       (and (is-Cons rows)
            (let ((row (head rows)))
              (and (IsList row)
                   (= (length row) n)
                   (AllRowsSameLen (tail rows) n))))))

(define-fun-rec RowOK ((row Value) (j Int) (i Int) (n Int)) Bool
  (ite (= j n)
       (is-Nil row)
       (and (is-Cons row)
            (is-IntVal (head row))
            (= (ival (head row)) (+ 1 j (* i n)))
            (RowOK (tail row) (+ j 1) i n))))

(define-fun-rec GridOK ((rows Value) (i Int) (n Int)) Bool
  (ite (= i n)
       (is-Nil rows)
       (and (is-Cons rows)
            (RowOK (head rows) 0 i n)
            (GridOK (tail rows) (+ i 1) n))))

; === Inputs ===
(declare-const grid Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList grid))
(assert (is-IntVal k))
(assert (<= (length grid) 3))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal k))
(define-fun C1 () Bool (and (is-IntVal k) (> (ival k) 0)))
(define-fun C2 () Bool (and (IsList grid) (>= (length grid) 2)))
(define-fun C3 () Bool (and (IsList grid) (AllRowsSameLen grid (length grid))))
(define-fun C4 () Bool (let ((n (length grid))) (GridOK grid 0 n)))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)
(assert C3)
(assert C4)

(check-sat)
(get-model)

------------------------------
  Test Case 31: satisfied_assert_1;assert_2;assert_3;assert_4, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True, 'assert_3': True, 'assert_4': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2', 'assert_3', 'assert_4'], 'violated_contracts': ['assert_0'], 'total_contracts': 5}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (IsList (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))

(define-fun-rec list_nth ((l Value) (idx Int)) Value
  (ite (not (is-Cons l))
       Nil
       (ite (= idx 0)
            (head l)
            (list_nth (tail l) (- idx 1)))))

(define-fun-rec AllRowsSameLen ((rows Value) (n Int)) Bool
  (ite (is-Nil rows)
       true
       (and (is-Cons rows)
            (let ((row (head rows)))
              (and (IsList row)
                   (= (length row) n)
                   (AllRowsSameLen (tail rows) n))))))

(define-fun-rec RowOK ((row Value) (j Int) (i Int) (n Int)) Bool
  (ite (= j n)
       (is-Nil row)
       (and (is-Cons row)
            (is-IntVal (head row))
            (= (ival (head row)) (+ 1 j (* i n)))
            (RowOK (tail row) (+ j 1) i n))))

(define-fun-rec GridOK ((rows Value) (i Int) (n Int)) Bool
  (ite (= i n)
       (is-Nil rows)
       (and (is-Cons rows)
            (RowOK (head rows) 0 i n)
            (GridOK (tail rows) (+ i 1) n))))

; === Inputs ===
(declare-const grid Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList grid))
(assert (is-IntVal k))
(assert (<= (length grid) 3))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal k))
(define-fun C1 () Bool (and (is-IntVal k) (> (ival k) 0)))
(define-fun C2 () Bool (and (IsList grid) (>= (length grid) 2)))
(define-fun C3 () Bool (and (IsList grid) (AllRowsSameLen grid (length grid))))
(define-fun C4 () Bool (let ((n (length grid))) (GridOK grid 0 n)))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)
(assert C3)
(assert C4)

(check-sat)
(get-model)

------------------------------
  Test Case 32: satisfied_assert_0;assert_1;assert_2;assert_3;assert_4, violated_
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True, 'assert_3': True, 'assert_4': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_3', 'assert_4'], 'violated_contracts': [], 'total_contracts': 5}
  Solutions:
    Solution 1:
      test_case: {'k': 20538, 'grid': [[1, 2], [3, 4]]}
    Solution 2:
      test_case: {'k': 20539, 'grid': [[1, 2], [3, 4]]}
    Solution 3:
      test_case: {'k': 20537, 'grid': [[1, 2], [3, 4]]}
    Solution 4:
      test_case: {'k': 1324, 'grid': [[1, 2], [3, 4]]}
    Solution 5:
      test_case: {'k': 2447, 'grid': [[1, 2], [3, 4]]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (or (is-Nil v)
      (and (is-Cons v)
           (IsList (tail v)))))

(define-fun-rec length ((v Value)) Int
  (ite (is-Nil v) 0
       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))

(define-fun-rec list_nth ((l Value) (idx Int)) Value
  (ite (not (is-Cons l))
       Nil
       (ite (= idx 0)
            (head l)
            (list_nth (tail l) (- idx 1)))))

(define-fun-rec AllRowsSameLen ((rows Value) (n Int)) Bool
  (ite (is-Nil rows)
       true
       (and (is-Cons rows)
            (let ((row (head rows)))
              (and (IsList row)
                   (= (length row) n)
                   (AllRowsSameLen (tail rows) n))))))

(define-fun-rec RowOK ((row Value) (j Int) (i Int) (n Int)) Bool
  (ite (= j n)
       (is-Nil row)
       (and (is-Cons row)
            (is-IntVal (head row))
            (= (ival (head row)) (+ 1 j (* i n)))
            (RowOK (tail row) (+ j 1) i n))))

(define-fun-rec GridOK ((rows Value) (i Int) (n Int)) Bool
  (ite (= i n)
       (is-Nil rows)
       (and (is-Cons rows)
            (RowOK (head rows) 0 i n)
            (GridOK (tail rows) (+ i 1) n))))

; === Inputs ===
(declare-const grid Value)
(declare-const k Value)

; === BASIC STRUCTURE ===
(assert (IsList grid))
(assert (is-IntVal k))
(assert (<= (length grid) 3))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal k))
(define-fun C1 () Bool (and (is-IntVal k) (> (ival k) 0)))
(define-fun C2 () Bool (and (IsList grid) (>= (length grid) 2)))
(define-fun C3 () Bool (and (IsList grid) (AllRowsSameLen grid (length grid))))
(define-fun C4 () Bool (let ((n (length grid))) (GridOK grid 0 n)))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)
(assert C3)
(assert C4)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/130 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===
(assert (is-IntVal n))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))
(define-fun C1 () Bool (ite (is-IntVal n) (>= (ival n) 0) false))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'n': -1}
    Solution 2:
      test_case: {'n': -7720}
    Solution 3:
      test_case: {'n': -10157}
    Solution 4:
      test_case: {'n': -21954}
    Solution 5:
      test_case: {'n': -54239}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===
(assert (is-IntVal n))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))
(define-fun C1 () Bool (ite (is-IntVal n) (>= (ival n) 0) false))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===
(assert (is-IntVal n))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))
(define-fun C1 () Bool (ite (is-IntVal n) (>= (ival n) 0) false))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'n': 0}
    Solution 2:
      test_case: {'n': 7719}
    Solution 3:
      test_case: {'n': 10156}
    Solution 4:
      test_case: {'n': 21953}
    Solution 5:
      test_case: {'n': 54238}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===
(assert (is-IntVal n))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))
(define-fun C1 () Bool (ite (is-IntVal n) (>= (ival n) 0) false))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/131 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun get-Int ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===
(assert (is-IntVal n))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))
(define-fun C1 () Bool (> (get-Int n) 0))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'n': 0}
    Solution 2:
      test_case: {'n': -7719}
    Solution 3:
      test_case: {'n': -10156}
    Solution 4:
      test_case: {'n': -21953}
    Solution 5:
      test_case: {'n': -54238}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun get-Int ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===
(assert (is-IntVal n))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))
(define-fun C1 () Bool (> (get-Int n) 0))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun get-Int ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===
(assert (is-IntVal n))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))
(define-fun C1 () Bool (> (get-Int n) 0))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'n': 1}
    Solution 2:
      test_case: {'n': 7720}
    Solution 3:
      test_case: {'n': 10157}
    Solution 4:
      test_case: {'n': 21954}
    Solution 5:
      test_case: {'n': 54239}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun get-Int ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===
(assert (is-IntVal n))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))
(define-fun C1 () Bool (> (get-Int n) 0))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/132 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'string': 2.0}
    Solution 2:
      test_case: {'string': 3.0}
    Solution 3:
      test_case: {'string': 4.0}
    Solution 4:
      test_case: {'string': 5.0}
    Solution 5:
      test_case: {'string': 6.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec all_brackets ((sVal Value) (pos Int)) Bool
  (ite (not (is-StrVal sVal))
       false
       (let ((str (sval sVal))
             (len (str.len (sval sVal))))
         (ite (>= pos len)
              true
              (let ((ch (str.substr str pos 1)))
                (ite (or (= ch "[") (= ch "]"))
                     (all_brackets sVal (+ pos 1))
                     false))))))

; === Inputs ===
(declare-const string Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal string))
(define-fun C1 () Bool (all_brackets string 0))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'string': 'A'}
    Solution 2:
      test_case: {'string': 'B'}
    Solution 3:
      test_case: {'string': 'C'}
    Solution 4:
      test_case: {'string': 'D'}
    Solution 5:
      test_case: {'string': 'E'}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec all_brackets ((sVal Value) (pos Int)) Bool
  (ite (not (is-StrVal sVal))
       false
       (let ((str (sval sVal))
             (len (str.len (sval sVal))))
         (ite (>= pos len)
              true
              (let ((ch (str.substr str pos 1)))
                (ite (or (= ch "[") (= ch "]"))
                     (all_brackets sVal (+ pos 1))
                     false))))))

; === Inputs ===
(declare-const string Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal string))
(define-fun C1 () Bool (all_brackets string 0))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec all_brackets ((sVal Value) (pos Int)) Bool
  (ite (not (is-StrVal sVal))
       false
       (let ((str (sval sVal))
             (len (str.len (sval sVal))))
         (ite (>= pos len)
              true
              (let ((ch (str.substr str pos 1)))
                (ite (or (= ch "[") (= ch "]"))
                     (all_brackets sVal (+ pos 1))
                     false))))))

; === Inputs ===
(declare-const string Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal string))
(define-fun C1 () Bool (all_brackets string 0))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'string': ''}
    Solution 2:
      test_case: {'string': '['}
    Solution 3:
      test_case: {'string': ']'}
    Solution 4:
      test_case: {'string': ']['}
    Solution 5:
      test_case: {'string': ']]'}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec all_brackets ((sVal Value) (pos Int)) Bool
  (ite (not (is-StrVal sVal))
       false
       (let ((str (sval sVal))
             (len (str.len (sval sVal))))
         (ite (>= pos len)
              true
              (let ((ch (str.substr str pos 1)))
                (ite (or (= ch "[") (= ch "]"))
                     (all_brackets sVal (+ pos 1))
                     false))))))

; === Inputs ===
(declare-const string Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal string))
(define-fun C1 () Bool (all_brackets string 0))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/133 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'lst': 2.0}
    Solution 2:
      test_case: {'lst': 3.0}
    Solution 3:
      test_case: {'lst': 4.0}
    Solution 4:
      test_case: {'lst': 5.0}
    Solution 5:
      test_case: {'lst': 6.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun isList ((v Value)) Bool (or (is-Nil v) (is-Cons v)))
(define-fun-rec list_all_numeric ((l Value)) Bool
  (ite (is-Nil l) true
    (ite (is-Cons l)
      (and (or (is-IntVal (head l)) (is-FloatVal (head l)))
           (list_all_numeric (tail l)))
      false)))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (isList lst))
(define-fun C1 () Bool (list_all_numeric lst))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'lst': ['!0!', 2.0]}
    Solution 2:
      test_case: {'lst': ['!', 3.0]}
    Solution 3:
      test_case: {'lst': ['0', 4.0]}
    Solution 4:
      test_case: {'lst': ['0!', 5.0]}
    Solution 5:
      test_case: {'lst': ['!0!', 6.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun isList ((v Value)) Bool (or (is-Nil v) (is-Cons v)))
(define-fun-rec list_all_numeric ((l Value)) Bool
  (ite (is-Nil l) true
    (ite (is-Cons l)
      (and (or (is-IntVal (head l)) (is-FloatVal (head l)))
           (list_all_numeric (tail l)))
      false)))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (isList lst))
(define-fun C1 () Bool (list_all_numeric lst))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun isList ((v Value)) Bool (or (is-Nil v) (is-Cons v)))
(define-fun-rec list_all_numeric ((l Value)) Bool
  (ite (is-Nil l) true
    (ite (is-Cons l)
      (and (or (is-IntVal (head l)) (is-FloatVal (head l)))
           (list_all_numeric (tail l)))
      false)))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (isList lst))
(define-fun C1 () Bool (list_all_numeric lst))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'lst': []}
    Solution 2:
      test_case: {'lst': [2]}
    Solution 3:
      test_case: {'lst': [2.0]}
    Solution 4:
      test_case: {'lst': [3.0]}
    Solution 5:
      test_case: {'lst': [4.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun isList ((v Value)) Bool (or (is-Nil v) (is-Cons v)))
(define-fun-rec list_all_numeric ((l Value)) Bool
  (ite (is-Nil l) true
    (ite (is-Cons l)
      (and (or (is-IntVal (head l)) (is-FloatVal (head l)))
           (list_all_numeric (tail l)))
      false)))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (isList lst))
(define-fun C1 () Bool (list_all_numeric lst))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/134 ===
  Test Case 1: satisfied_, violated_assert_0
  Combination: {'assert_0': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0'], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'txt': 2.0}
    Solution 2:
      test_case: {'txt': 3.0}
    Solution 3:
      test_case: {'txt': 4.0}
    Solution 4:
      test_case: {'txt': 5.0}
    Solution 5:
      test_case: {'txt': 6.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeStr ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))
(define-fun is-alpha-char ((c String)) Bool
  (str.in.re c (str.to.re "[A-Za-z]")))

; === Inputs ===
(declare-const txt Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool
  (is-StrVal txt))

; === COMBINATION ===
(assert (not C0))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_
  Combination: {'assert_0': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': [], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'txt': '!0!'}
    Solution 2:
      test_case: {'txt': '!'}
    Solution 3:
      test_case: {'txt': '0'}
    Solution 4:
      test_case: {'txt': '0!'}
    Solution 5:
      test_case: {'txt': ''}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeStr ((v Value)) String
  (ite (is-StrVal v) (sval v) ""))
(define-fun is-alpha-char ((c String)) Bool
  (str.in.re c (str.to.re "[A-Za-z]")))

; === Inputs ===
(declare-const txt Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool
  (is-StrVal txt))

; === COMBINATION ===
(assert C0)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/135 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1;assert_2
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2'], 'total_contracts': 3}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_numeric ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (or (is-IntVal (head v)) (is-FloatVal (head v)))
                 (list_all_numeric (tail v)))
            false)))

(define-fun value_eq ((v1 Value) (v2 Value)) Bool
  (or (and (is-IntVal v1) (is-IntVal v2)
           (= (ival v1) (ival v2)))
      (and (is-FloatVal v1) (is-FloatVal v2)
           (= (fval v1) (fval v2)))
      (and (is-IntVal v1) (is-FloatVal v2)
           (= (to_real (ival v1)) (fval v2)))
      (and (is-FloatVal v1) (is-IntVal v2)
           (= (fval v1) (to_real (ival v2))))))

(define-fun-rec list_contains ((e Value) (v Value)) Bool
  (ite (is-Nil v)
       false
       (ite (value_eq e (head v))
            true
            (list_contains e (tail v)))))

(define-fun-rec list_unique ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (not (list_contains (head v) (tail v)))
                 (list_unique (tail v)))
            false)))

; === Inputs ===
(declare-const arr Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (list_all_numeric arr))
(define-fun C2 () Bool (list_unique arr))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1;assert_2
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1', 'assert_2'], 'total_contracts': 3}
  Solutions:
    Solution 1:
      test_case: {'arr': [0.0, 'A', 0.0]}
    Solution 2:
      test_case: {'arr': [0, 'A', 0.0]}
    Solution 3:
      test_case: {'arr': [21595, False, 21595.0]}
    Solution 4:
      test_case: {'arr': [40284, [], 40284.0]}
    Solution 5:
      test_case: {'arr': [77841, [4.0, 7.0], 77841.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_numeric ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (or (is-IntVal (head v)) (is-FloatVal (head v)))
                 (list_all_numeric (tail v)))
            false)))

(define-fun value_eq ((v1 Value) (v2 Value)) Bool
  (or (and (is-IntVal v1) (is-IntVal v2)
           (= (ival v1) (ival v2)))
      (and (is-FloatVal v1) (is-FloatVal v2)
           (= (fval v1) (fval v2)))
      (and (is-IntVal v1) (is-FloatVal v2)
           (= (to_real (ival v1)) (fval v2)))
      (and (is-FloatVal v1) (is-IntVal v2)
           (= (fval v1) (to_real (ival v2))))))

(define-fun-rec list_contains ((e Value) (v Value)) Bool
  (ite (is-Nil v)
       false
       (ite (value_eq e (head v))
            true
            (list_contains e (tail v)))))

(define-fun-rec list_unique ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (not (list_contains (head v) (tail v)))
                 (list_unique (tail v)))
            false)))

; === Inputs ===
(declare-const arr Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (list_all_numeric arr))
(define-fun C2 () Bool (list_unique arr))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0;assert_2
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0', 'assert_2'], 'total_contracts': 3}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_numeric ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (or (is-IntVal (head v)) (is-FloatVal (head v)))
                 (list_all_numeric (tail v)))
            false)))

(define-fun value_eq ((v1 Value) (v2 Value)) Bool
  (or (and (is-IntVal v1) (is-IntVal v2)
           (= (ival v1) (ival v2)))
      (and (is-FloatVal v1) (is-FloatVal v2)
           (= (fval v1) (fval v2)))
      (and (is-IntVal v1) (is-FloatVal v2)
           (= (to_real (ival v1)) (fval v2)))
      (and (is-FloatVal v1) (is-IntVal v2)
           (= (fval v1) (to_real (ival v2))))))

(define-fun-rec list_contains ((e Value) (v Value)) Bool
  (ite (is-Nil v)
       false
       (ite (value_eq e (head v))
            true
            (list_contains e (tail v)))))

(define-fun-rec list_unique ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (not (list_contains (head v) (tail v)))
                 (list_unique (tail v)))
            false)))

; === Inputs ===
(declare-const arr Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (list_all_numeric arr))
(define-fun C2 () Bool (list_unique arr))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_assert_2
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': ['assert_2'], 'total_contracts': 3}
  Solutions:
    Solution 1:
      test_case: {'arr': [0.0, 0]}
    Solution 2:
      test_case: {'arr': [0, 0]}
    Solution 3:
      test_case: {'arr': [1, 1.0]}
    Solution 4:
      test_case: {'arr': [38144, 38144.0]}
    Solution 5:
      test_case: {'arr': [68544, 68544.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_numeric ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (or (is-IntVal (head v)) (is-FloatVal (head v)))
                 (list_all_numeric (tail v)))
            false)))

(define-fun value_eq ((v1 Value) (v2 Value)) Bool
  (or (and (is-IntVal v1) (is-IntVal v2)
           (= (ival v1) (ival v2)))
      (and (is-FloatVal v1) (is-FloatVal v2)
           (= (fval v1) (fval v2)))
      (and (is-IntVal v1) (is-FloatVal v2)
           (= (to_real (ival v1)) (fval v2)))
      (and (is-FloatVal v1) (is-IntVal v2)
           (= (fval v1) (to_real (ival v2))))))

(define-fun-rec list_contains ((e Value) (v Value)) Bool
  (ite (is-Nil v)
       false
       (ite (value_eq e (head v))
            true
            (list_contains e (tail v)))))

(define-fun-rec list_unique ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (not (list_contains (head v) (tail v)))
                 (list_unique (tail v)))
            false)))

; === Inputs ===
(declare-const arr Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (list_all_numeric arr))
(define-fun C2 () Bool (list_unique arr))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))

(check-sat)
(get-model)

------------------------------
  Test Case 5: satisfied_assert_2, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_2'], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 3}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_numeric ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (or (is-IntVal (head v)) (is-FloatVal (head v)))
                 (list_all_numeric (tail v)))
            false)))

(define-fun value_eq ((v1 Value) (v2 Value)) Bool
  (or (and (is-IntVal v1) (is-IntVal v2)
           (= (ival v1) (ival v2)))
      (and (is-FloatVal v1) (is-FloatVal v2)
           (= (fval v1) (fval v2)))
      (and (is-IntVal v1) (is-FloatVal v2)
           (= (to_real (ival v1)) (fval v2)))
      (and (is-FloatVal v1) (is-IntVal v2)
           (= (fval v1) (to_real (ival v2))))))

(define-fun-rec list_contains ((e Value) (v Value)) Bool
  (ite (is-Nil v)
       false
       (ite (value_eq e (head v))
            true
            (list_contains e (tail v)))))

(define-fun-rec list_unique ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (not (list_contains (head v) (tail v)))
                 (list_unique (tail v)))
            false)))

; === Inputs ===
(declare-const arr Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (list_all_numeric arr))
(define-fun C2 () Bool (list_unique arr))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)

(check-sat)
(get-model)

------------------------------
  Test Case 6: satisfied_assert_0;assert_2, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2'], 'violated_contracts': ['assert_1'], 'total_contracts': 3}
  Solutions:
    Solution 1:
      test_case: {'arr': ['A']}
    Solution 2:
      test_case: {'arr': ['']}
    Solution 3:
      test_case: {'arr': [False]}
    Solution 4:
      test_case: {'arr': [True]}
    Solution 5:
      test_case: {'arr': [[]]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_numeric ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (or (is-IntVal (head v)) (is-FloatVal (head v)))
                 (list_all_numeric (tail v)))
            false)))

(define-fun value_eq ((v1 Value) (v2 Value)) Bool
  (or (and (is-IntVal v1) (is-IntVal v2)
           (= (ival v1) (ival v2)))
      (and (is-FloatVal v1) (is-FloatVal v2)
           (= (fval v1) (fval v2)))
      (and (is-IntVal v1) (is-FloatVal v2)
           (= (to_real (ival v1)) (fval v2)))
      (and (is-FloatVal v1) (is-IntVal v2)
           (= (fval v1) (to_real (ival v2))))))

(define-fun-rec list_contains ((e Value) (v Value)) Bool
  (ite (is-Nil v)
       false
       (ite (value_eq e (head v))
            true
            (list_contains e (tail v)))))

(define-fun-rec list_unique ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (not (list_contains (head v) (tail v)))
                 (list_unique (tail v)))
            false)))

; === Inputs ===
(declare-const arr Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (list_all_numeric arr))
(define-fun C2 () Bool (list_unique arr))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)

(check-sat)
(get-model)

------------------------------
  Test Case 7: satisfied_assert_1;assert_2, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2'], 'violated_contracts': ['assert_0'], 'total_contracts': 3}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_numeric ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (or (is-IntVal (head v)) (is-FloatVal (head v)))
                 (list_all_numeric (tail v)))
            false)))

(define-fun value_eq ((v1 Value) (v2 Value)) Bool
  (or (and (is-IntVal v1) (is-IntVal v2)
           (= (ival v1) (ival v2)))
      (and (is-FloatVal v1) (is-FloatVal v2)
           (= (fval v1) (fval v2)))
      (and (is-IntVal v1) (is-FloatVal v2)
           (= (to_real (ival v1)) (fval v2)))
      (and (is-FloatVal v1) (is-IntVal v2)
           (= (fval v1) (to_real (ival v2))))))

(define-fun-rec list_contains ((e Value) (v Value)) Bool
  (ite (is-Nil v)
       false
       (ite (value_eq e (head v))
            true
            (list_contains e (tail v)))))

(define-fun-rec list_unique ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (not (list_contains (head v) (tail v)))
                 (list_unique (tail v)))
            false)))

; === Inputs ===
(declare-const arr Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (list_all_numeric arr))
(define-fun C2 () Bool (list_unique arr))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)

(check-sat)
(get-model)

------------------------------
  Test Case 8: satisfied_assert_0;assert_1;assert_2, violated_
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2'], 'violated_contracts': [], 'total_contracts': 3}
  Solutions:
    Solution 1:
      test_case: {'arr': []}
    Solution 2:
      test_case: {'arr': [0]}
    Solution 3:
      test_case: {'arr': [-1]}
    Solution 4:
      test_case: {'arr': [0.5]}
    Solution 5:
      test_case: {'arr': [0.25]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_numeric ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (or (is-IntVal (head v)) (is-FloatVal (head v)))
                 (list_all_numeric (tail v)))
            false)))

(define-fun value_eq ((v1 Value) (v2 Value)) Bool
  (or (and (is-IntVal v1) (is-IntVal v2)
           (= (ival v1) (ival v2)))
      (and (is-FloatVal v1) (is-FloatVal v2)
           (= (fval v1) (fval v2)))
      (and (is-IntVal v1) (is-FloatVal v2)
           (= (to_real (ival v1)) (fval v2)))
      (and (is-FloatVal v1) (is-IntVal v2)
           (= (fval v1) (to_real (ival v2))))))

(define-fun-rec list_contains ((e Value) (v Value)) Bool
  (ite (is-Nil v)
       false
       (ite (value_eq e (head v))
            true
            (list_contains e (tail v)))))

(define-fun-rec list_unique ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (not (list_contains (head v) (tail v)))
                 (list_unique (tail v)))
            false)))

; === Inputs ===
(declare-const arr Value)

; === BASIC STRUCTURE ===
(assert (IsList arr))

; === Contract predicates ===
(define-fun C0 () Bool (IsList arr))
(define-fun C1 () Bool (list_all_numeric arr))
(define-fun C2 () Bool (list_unique arr))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/136 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun is-list ((v Value)) Bool
  (or (is-Nil v)
      (is-Cons v)))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (let ((h (head l))
                  (t (tail l)))
              (and (is-IntVal h)
                   (list_all_int t)))
            false)))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (is-list lst))

; === Contract predicates ===
(define-fun C0 () Bool
  (is-list lst))
(define-fun C1 () Bool
  (list_all_int lst))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'lst': [3.0, 2.0]}
    Solution 2:
      test_case: {'lst': [5.0, 4.0]}
    Solution 3:
      test_case: {'lst': [6.0, 7.0]}
    Solution 4:
      test_case: {'lst': [9.0, 8.0]}
    Solution 5:
      test_case: {'lst': [10.0, 11.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun is-list ((v Value)) Bool
  (or (is-Nil v)
      (is-Cons v)))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (let ((h (head l))
                  (t (tail l)))
              (and (is-IntVal h)
                   (list_all_int t)))
            false)))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (is-list lst))

; === Contract predicates ===
(define-fun C0 () Bool
  (is-list lst))
(define-fun C1 () Bool
  (list_all_int lst))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun is-list ((v Value)) Bool
  (or (is-Nil v)
      (is-Cons v)))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (let ((h (head l))
                  (t (tail l)))
              (and (is-IntVal h)
                   (list_all_int t)))
            false)))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (is-list lst))

; === Contract predicates ===
(define-fun C0 () Bool
  (is-list lst))
(define-fun C1 () Bool
  (list_all_int lst))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'lst': []}
    Solution 2:
      test_case: {'lst': [2]}
    Solution 3:
      test_case: {'lst': [3]}
    Solution 4:
      test_case: {'lst': [4]}
    Solution 5:
      test_case: {'lst': [5]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun is-list ((v Value)) Bool
  (or (is-Nil v)
      (is-Cons v)))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (let ((h (head l))
                  (t (tail l)))
              (and (is-IntVal h)
                   (list_all_int t)))
            false)))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (is-list lst))

; === Contract predicates ===
(define-fun C0 () Bool
  (is-list lst))
(define-fun C1 () Bool
  (list_all_int lst))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/137 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'b': False, 'a': False}
    Solution 2:
      test_case: {'b': True, 'a': True}
    Solution 3:
      test_case: {'b': [], 'a': []}
    Solution 4:
      test_case: {'b': [2.0, 4.0], 'a': [5.0, 3.0]}
    Solution 5:
      test_case: {'b': [9.0, 6.0], 'a': [7.0, 8.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const a Value)
(declare-const b Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (or (is-IntVal a) (is-FloatVal a) (is-StrVal a)))
(define-fun C1 () Bool (or (is-IntVal b) (is-FloatVal b) (is-StrVal b)))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'b': False, 'a': 2}
    Solution 2:
      test_case: {'b': True, 'a': 3}
    Solution 3:
      test_case: {'b': [], 'a': 4}
    Solution 4:
      test_case: {'b': [3.0, 2.0], 'a': 5}
    Solution 5:
      test_case: {'b': [5.0, 4.0], 'a': 6}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const a Value)
(declare-const b Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (or (is-IntVal a) (is-FloatVal a) (is-StrVal a)))
(define-fun C1 () Bool (or (is-IntVal b) (is-FloatVal b) (is-StrVal b)))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'b': '!0!', 'a': False}
    Solution 2:
      test_case: {'b': '!', 'a': True}
    Solution 3:
      test_case: {'b': '0', 'a': []}
    Solution 4:
      test_case: {'b': '0!', 'a': [2.0, 3.0]}
    Solution 5:
      test_case: {'b': '', 'a': [5.0, 4.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const a Value)
(declare-const b Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (or (is-IntVal a) (is-FloatVal a) (is-StrVal a)))
(define-fun C1 () Bool (or (is-IntVal b) (is-FloatVal b) (is-StrVal b)))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'b': '!0!', 'a': 2}
    Solution 2:
      test_case: {'b': '!', 'a': 3}
    Solution 3:
      test_case: {'b': '0', 'a': 4}
    Solution 4:
      test_case: {'b': '0!', 'a': 5}
    Solution 5:
      test_case: {'b': '', 'a': 6}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const a Value)
(declare-const b Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (or (is-IntVal a) (is-FloatVal a) (is-StrVal a)))
(define-fun C1 () Bool (or (is-IntVal b) (is-FloatVal b) (is-StrVal b)))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/138 ===
  Test Case 1: satisfied_, violated_assert_0
  Combination: {'assert_0': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0'], 'total_contracts': 1}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeIval ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===
(assert (is-IntVal n))

; === Contract predicates ===
(define-fun C0 () Bool
  (is-IntVal n))

; === COMBINATION ===
(assert (not C0))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_
  Combination: {'assert_0': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': [], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'n': 2}
    Solution 2:
      test_case: {'n': 3}
    Solution 3:
      test_case: {'n': 4}
    Solution 4:
      test_case: {'n': 5}
    Solution 5:
      test_case: {'n': 6}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeIval ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===
(assert (is-IntVal n))

; === Contract predicates ===
(define-fun C0 () Bool
  (is-IntVal n))

; === COMBINATION ===
(assert C0)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/139 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===
(assert (is-IntVal n))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))
(define-fun C1 () Bool (ite (is-IntVal n) (> (ival n) 0) false))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'n': 0}
    Solution 2:
      test_case: {'n': -7719}
    Solution 3:
      test_case: {'n': -10156}
    Solution 4:
      test_case: {'n': -21953}
    Solution 5:
      test_case: {'n': -54238}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===
(assert (is-IntVal n))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))
(define-fun C1 () Bool (ite (is-IntVal n) (> (ival n) 0) false))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===
(assert (is-IntVal n))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))
(define-fun C1 () Bool (ite (is-IntVal n) (> (ival n) 0) false))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'n': 1}
    Solution 2:
      test_case: {'n': 7720}
    Solution 3:
      test_case: {'n': 10157}
    Solution 4:
      test_case: {'n': 21954}
    Solution 5:
      test_case: {'n': 54239}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===
(assert (is-IntVal n))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))
(define-fun C1 () Bool (ite (is-IntVal n) (> (ival n) 0) false))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/140 ===
  Test Case 1: satisfied_, violated_assert_0
  Combination: {'assert_0': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0'], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'text': 2.0}
    Solution 2:
      test_case: {'text': 3.0}
    Solution 3:
      test_case: {'text': 4.0}
    Solution 4:
      test_case: {'text': 5.0}
    Solution 5:
      test_case: {'text': 6.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const text Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal text))

; === COMBINATION ===
(assert (not C0))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_
  Combination: {'assert_0': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': [], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'text': '!0!'}
    Solution 2:
      test_case: {'text': '!'}
    Solution 3:
      test_case: {'text': '0'}
    Solution 4:
      test_case: {'text': '0!'}
    Solution 5:
      test_case: {'text': ''}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const text Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal text))

; === COMBINATION ===
(assert C0)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/141 ===
  Test Case 1: satisfied_, violated_assert_0
  Combination: {'assert_0': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0'], 'total_contracts': 1}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const file_name Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal file_name))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal file_name))

; === COMBINATION ===
(assert (not C0))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_
  Combination: {'assert_0': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': [], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'file_name': '!0!'}
    Solution 2:
      test_case: {'file_name': '!'}
    Solution 3:
      test_case: {'file_name': '0'}
    Solution 4:
      test_case: {'file_name': '0!'}
    Solution 5:
      test_case: {'file_name': ''}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const file_name Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal file_name))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal file_name))

; === COMBINATION ===
(assert C0)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/142 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_int ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (is-IntVal (head v))
                 (list_all_int (tail v)))
            false)))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (IsList lst))

; === Contract predicates ===
(define-fun C0 () Bool (IsList lst))
(define-fun C1 () Bool (list_all_int lst))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'lst': [2.0]}
    Solution 2:
      test_case: {'lst': [3.0]}
    Solution 3:
      test_case: {'lst': [4.0]}
    Solution 4:
      test_case: {'lst': [5.0]}
    Solution 5:
      test_case: {'lst': [6.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_int ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (is-IntVal (head v))
                 (list_all_int (tail v)))
            false)))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (IsList lst))

; === Contract predicates ===
(define-fun C0 () Bool (IsList lst))
(define-fun C1 () Bool (list_all_int lst))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_int ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (is-IntVal (head v))
                 (list_all_int (tail v)))
            false)))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (IsList lst))

; === Contract predicates ===
(define-fun C0 () Bool (IsList lst))
(define-fun C1 () Bool (list_all_int lst))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'lst': []}
    Solution 2:
      test_case: {'lst': [2]}
    Solution 3:
      test_case: {'lst': [3]}
    Solution 4:
      test_case: {'lst': [4]}
    Solution 5:
      test_case: {'lst': [5]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_int ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (is-IntVal (head v))
                 (list_all_int (tail v)))
            false)))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (IsList lst))

; === Contract predicates ===
(define-fun C0 () Bool (IsList lst))
(define-fun C1 () Bool (list_all_int lst))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/143 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1;assert_2;assert_3
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False, 'assert_3': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_3'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeStrLen ((s Value)) Int
  (ite (is-StrVal s) (str.len (sval s)) 0))

(define-fun-rec is_prime ((n Int)) Bool
  (and (>= n 2)
       (not (exists ((x Int))
               (and (>= x 2)
                    (<= (* x x) n)
                    (= (mod n x) 0))))))

(define-fun-rec all_alpha_words ((s Value)) Bool
  (ite (not (is-StrVal s))
       false
       (let ((str (sval s)))
         (ite (str.contains str " ")
              (let ((idx (str.indexof str " " 0)))
                (let ((headVal (StrVal (str.substr str 0 idx)))
                      (tailVal (StrVal (str.substr str (+ idx 1)
                                           (- (str.len str) (+ idx 1))))))
                  (and (all_alpha_words headVal)
                       (all_alpha_words tailVal))))
              (str.in.re str
                         (re.* (re.union
                                  (re.range "A" "Z")
                                  (re.range "a" "z"))))))))

; === Inputs ===
(declare-const sentence Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal sentence))

; === Contract predicates ===
(define-fun C0 () Bool
  (is-StrVal sentence))
(define-fun C1 () Bool
  (let ((len (ite (is-StrVal sentence)
                  (str.len (sval sentence))
                  0)))
    (and (<= 1 len)
         (<= len 100))))
(define-fun C2 () Bool
  (and (is-StrVal sentence)
       (not (str.contains (sval sentence) "  "))))
(define-fun C3 () Bool
  (all_alpha_words sentence))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1;assert_2;assert_3
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False, 'assert_3': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1', 'assert_2', 'assert_3'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeStrLen ((s Value)) Int
  (ite (is-StrVal s) (str.len (sval s)) 0))

(define-fun-rec is_prime ((n Int)) Bool
  (and (>= n 2)
       (not (exists ((x Int))
               (and (>= x 2)
                    (<= (* x x) n)
                    (= (mod n x) 0))))))

(define-fun-rec all_alpha_words ((s Value)) Bool
  (ite (not (is-StrVal s))
       false
       (let ((str (sval s)))
         (ite (str.contains str " ")
              (let ((idx (str.indexof str " " 0)))
                (let ((headVal (StrVal (str.substr str 0 idx)))
                      (tailVal (StrVal (str.substr str (+ idx 1)
                                           (- (str.len str) (+ idx 1))))))
                  (and (all_alpha_words headVal)
                       (all_alpha_words tailVal))))
              (str.in.re str
                         (re.* (re.union
                                  (re.range "A" "Z")
                                  (re.range "a" "z"))))))))

; === Inputs ===
(declare-const sentence Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal sentence))

; === Contract predicates ===
(define-fun C0 () Bool
  (is-StrVal sentence))
(define-fun C1 () Bool
  (let ((len (ite (is-StrVal sentence)
                  (str.len (sval sentence))
                  0)))
    (and (<= 1 len)
         (<= len 100))))
(define-fun C2 () Bool
  (and (is-StrVal sentence)
       (not (str.contains (sval sentence) "  "))))
(define-fun C3 () Bool
  (all_alpha_words sentence))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0;assert_2;assert_3
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False, 'assert_3': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0', 'assert_2', 'assert_3'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeStrLen ((s Value)) Int
  (ite (is-StrVal s) (str.len (sval s)) 0))

(define-fun-rec is_prime ((n Int)) Bool
  (and (>= n 2)
       (not (exists ((x Int))
               (and (>= x 2)
                    (<= (* x x) n)
                    (= (mod n x) 0))))))

(define-fun-rec all_alpha_words ((s Value)) Bool
  (ite (not (is-StrVal s))
       false
       (let ((str (sval s)))
         (ite (str.contains str " ")
              (let ((idx (str.indexof str " " 0)))
                (let ((headVal (StrVal (str.substr str 0 idx)))
                      (tailVal (StrVal (str.substr str (+ idx 1)
                                           (- (str.len str) (+ idx 1))))))
                  (and (all_alpha_words headVal)
                       (all_alpha_words tailVal))))
              (str.in.re str
                         (re.* (re.union
                                  (re.range "A" "Z")
                                  (re.range "a" "z"))))))))

; === Inputs ===
(declare-const sentence Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal sentence))

; === Contract predicates ===
(define-fun C0 () Bool
  (is-StrVal sentence))
(define-fun C1 () Bool
  (let ((len (ite (is-StrVal sentence)
                  (str.len (sval sentence))
                  0)))
    (and (<= 1 len)
         (<= len 100))))
(define-fun C2 () Bool
  (and (is-StrVal sentence)
       (not (str.contains (sval sentence) "  "))))
(define-fun C3 () Bool
  (all_alpha_words sentence))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_assert_2;assert_3
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False, 'assert_3': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': ['assert_2', 'assert_3'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeStrLen ((s Value)) Int
  (ite (is-StrVal s) (str.len (sval s)) 0))

(define-fun-rec is_prime ((n Int)) Bool
  (and (>= n 2)
       (not (exists ((x Int))
               (and (>= x 2)
                    (<= (* x x) n)
                    (= (mod n x) 0))))))

(define-fun-rec all_alpha_words ((s Value)) Bool
  (ite (not (is-StrVal s))
       false
       (let ((str (sval s)))
         (ite (str.contains str " ")
              (let ((idx (str.indexof str " " 0)))
                (let ((headVal (StrVal (str.substr str 0 idx)))
                      (tailVal (StrVal (str.substr str (+ idx 1)
                                           (- (str.len str) (+ idx 1))))))
                  (and (all_alpha_words headVal)
                       (all_alpha_words tailVal))))
              (str.in.re str
                         (re.* (re.union
                                  (re.range "A" "Z")
                                  (re.range "a" "z"))))))))

; === Inputs ===
(declare-const sentence Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal sentence))

; === Contract predicates ===
(define-fun C0 () Bool
  (is-StrVal sentence))
(define-fun C1 () Bool
  (let ((len (ite (is-StrVal sentence)
                  (str.len (sval sentence))
                  0)))
    (and (<= 1 len)
         (<= len 100))))
(define-fun C2 () Bool
  (and (is-StrVal sentence)
       (not (str.contains (sval sentence) "  "))))
(define-fun C3 () Bool
  (all_alpha_words sentence))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 5: satisfied_assert_2, violated_assert_0;assert_1;assert_3
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True, 'assert_3': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_2'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_3'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeStrLen ((s Value)) Int
  (ite (is-StrVal s) (str.len (sval s)) 0))

(define-fun-rec is_prime ((n Int)) Bool
  (and (>= n 2)
       (not (exists ((x Int))
               (and (>= x 2)
                    (<= (* x x) n)
                    (= (mod n x) 0))))))

(define-fun-rec all_alpha_words ((s Value)) Bool
  (ite (not (is-StrVal s))
       false
       (let ((str (sval s)))
         (ite (str.contains str " ")
              (let ((idx (str.indexof str " " 0)))
                (let ((headVal (StrVal (str.substr str 0 idx)))
                      (tailVal (StrVal (str.substr str (+ idx 1)
                                           (- (str.len str) (+ idx 1))))))
                  (and (all_alpha_words headVal)
                       (all_alpha_words tailVal))))
              (str.in.re str
                         (re.* (re.union
                                  (re.range "A" "Z")
                                  (re.range "a" "z"))))))))

; === Inputs ===
(declare-const sentence Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal sentence))

; === Contract predicates ===
(define-fun C0 () Bool
  (is-StrVal sentence))
(define-fun C1 () Bool
  (let ((len (ite (is-StrVal sentence)
                  (str.len (sval sentence))
                  0)))
    (and (<= 1 len)
         (<= len 100))))
(define-fun C2 () Bool
  (and (is-StrVal sentence)
       (not (str.contains (sval sentence) "  "))))
(define-fun C3 () Bool
  (all_alpha_words sentence))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 6: satisfied_assert_0;assert_2, violated_assert_1;assert_3
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True, 'assert_3': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2'], 'violated_contracts': ['assert_1', 'assert_3'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeStrLen ((s Value)) Int
  (ite (is-StrVal s) (str.len (sval s)) 0))

(define-fun-rec is_prime ((n Int)) Bool
  (and (>= n 2)
       (not (exists ((x Int))
               (and (>= x 2)
                    (<= (* x x) n)
                    (= (mod n x) 0))))))

(define-fun-rec all_alpha_words ((s Value)) Bool
  (ite (not (is-StrVal s))
       false
       (let ((str (sval s)))
         (ite (str.contains str " ")
              (let ((idx (str.indexof str " " 0)))
                (let ((headVal (StrVal (str.substr str 0 idx)))
                      (tailVal (StrVal (str.substr str (+ idx 1)
                                           (- (str.len str) (+ idx 1))))))
                  (and (all_alpha_words headVal)
                       (all_alpha_words tailVal))))
              (str.in.re str
                         (re.* (re.union
                                  (re.range "A" "Z")
                                  (re.range "a" "z"))))))))

; === Inputs ===
(declare-const sentence Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal sentence))

; === Contract predicates ===
(define-fun C0 () Bool
  (is-StrVal sentence))
(define-fun C1 () Bool
  (let ((len (ite (is-StrVal sentence)
                  (str.len (sval sentence))
                  0)))
    (and (<= 1 len)
         (<= len 100))))
(define-fun C2 () Bool
  (and (is-StrVal sentence)
       (not (str.contains (sval sentence) "  "))))
(define-fun C3 () Bool
  (all_alpha_words sentence))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 7: satisfied_assert_1;assert_2, violated_assert_0;assert_3
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True, 'assert_3': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2'], 'violated_contracts': ['assert_0', 'assert_3'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeStrLen ((s Value)) Int
  (ite (is-StrVal s) (str.len (sval s)) 0))

(define-fun-rec is_prime ((n Int)) Bool
  (and (>= n 2)
       (not (exists ((x Int))
               (and (>= x 2)
                    (<= (* x x) n)
                    (= (mod n x) 0))))))

(define-fun-rec all_alpha_words ((s Value)) Bool
  (ite (not (is-StrVal s))
       false
       (let ((str (sval s)))
         (ite (str.contains str " ")
              (let ((idx (str.indexof str " " 0)))
                (let ((headVal (StrVal (str.substr str 0 idx)))
                      (tailVal (StrVal (str.substr str (+ idx 1)
                                           (- (str.len str) (+ idx 1))))))
                  (and (all_alpha_words headVal)
                       (all_alpha_words tailVal))))
              (str.in.re str
                         (re.* (re.union
                                  (re.range "A" "Z")
                                  (re.range "a" "z"))))))))

; === Inputs ===
(declare-const sentence Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal sentence))

; === Contract predicates ===
(define-fun C0 () Bool
  (is-StrVal sentence))
(define-fun C1 () Bool
  (let ((len (ite (is-StrVal sentence)
                  (str.len (sval sentence))
                  0)))
    (and (<= 1 len)
         (<= len 100))))
(define-fun C2 () Bool
  (and (is-StrVal sentence)
       (not (str.contains (sval sentence) "  "))))
(define-fun C3 () Bool
  (all_alpha_words sentence))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 8: satisfied_assert_0;assert_1;assert_2, violated_assert_3
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True, 'assert_3': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2'], 'violated_contracts': ['assert_3'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'sentence': '\\u{1005b}'}
    Solution 2:
      test_case: {'sentence': '\\u{1000b}'}
    Solution 3:
      test_case: {'sentence': '\\u{160}'}
    Solution 4:
      test_case: {'sentence': '|'}
    Solution 5:
      test_case: {'sentence': '\\u{107c}'}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeStrLen ((s Value)) Int
  (ite (is-StrVal s) (str.len (sval s)) 0))

(define-fun-rec is_prime ((n Int)) Bool
  (and (>= n 2)
       (not (exists ((x Int))
               (and (>= x 2)
                    (<= (* x x) n)
                    (= (mod n x) 0))))))

(define-fun-rec all_alpha_words ((s Value)) Bool
  (ite (not (is-StrVal s))
       false
       (let ((str (sval s)))
         (ite (str.contains str " ")
              (let ((idx (str.indexof str " " 0)))
                (let ((headVal (StrVal (str.substr str 0 idx)))
                      (tailVal (StrVal (str.substr str (+ idx 1)
                                           (- (str.len str) (+ idx 1))))))
                  (and (all_alpha_words headVal)
                       (all_alpha_words tailVal))))
              (str.in.re str
                         (re.* (re.union
                                  (re.range "A" "Z")
                                  (re.range "a" "z"))))))))

; === Inputs ===
(declare-const sentence Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal sentence))

; === Contract predicates ===
(define-fun C0 () Bool
  (is-StrVal sentence))
(define-fun C1 () Bool
  (let ((len (ite (is-StrVal sentence)
                  (str.len (sval sentence))
                  0)))
    (and (<= 1 len)
         (<= len 100))))
(define-fun C2 () Bool
  (and (is-StrVal sentence)
       (not (str.contains (sval sentence) "  "))))
(define-fun C3 () Bool
  (all_alpha_words sentence))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 9: satisfied_assert_3, violated_assert_0;assert_1;assert_2
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False, 'assert_3': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_3'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeStrLen ((s Value)) Int
  (ite (is-StrVal s) (str.len (sval s)) 0))

(define-fun-rec is_prime ((n Int)) Bool
  (and (>= n 2)
       (not (exists ((x Int))
               (and (>= x 2)
                    (<= (* x x) n)
                    (= (mod n x) 0))))))

(define-fun-rec all_alpha_words ((s Value)) Bool
  (ite (not (is-StrVal s))
       false
       (let ((str (sval s)))
         (ite (str.contains str " ")
              (let ((idx (str.indexof str " " 0)))
                (let ((headVal (StrVal (str.substr str 0 idx)))
                      (tailVal (StrVal (str.substr str (+ idx 1)
                                           (- (str.len str) (+ idx 1))))))
                  (and (all_alpha_words headVal)
                       (all_alpha_words tailVal))))
              (str.in.re str
                         (re.* (re.union
                                  (re.range "A" "Z")
                                  (re.range "a" "z"))))))))

; === Inputs ===
(declare-const sentence Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal sentence))

; === Contract predicates ===
(define-fun C0 () Bool
  (is-StrVal sentence))
(define-fun C1 () Bool
  (let ((len (ite (is-StrVal sentence)
                  (str.len (sval sentence))
                  0)))
    (and (<= 1 len)
         (<= len 100))))
(define-fun C2 () Bool
  (and (is-StrVal sentence)
       (not (str.contains (sval sentence) "  "))))
(define-fun C3 () Bool
  (all_alpha_words sentence))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 10: satisfied_assert_0;assert_3, violated_assert_1;assert_2
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False, 'assert_3': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_3'], 'violated_contracts': ['assert_1', 'assert_2'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeStrLen ((s Value)) Int
  (ite (is-StrVal s) (str.len (sval s)) 0))

(define-fun-rec is_prime ((n Int)) Bool
  (and (>= n 2)
       (not (exists ((x Int))
               (and (>= x 2)
                    (<= (* x x) n)
                    (= (mod n x) 0))))))

(define-fun-rec all_alpha_words ((s Value)) Bool
  (ite (not (is-StrVal s))
       false
       (let ((str (sval s)))
         (ite (str.contains str " ")
              (let ((idx (str.indexof str " " 0)))
                (let ((headVal (StrVal (str.substr str 0 idx)))
                      (tailVal (StrVal (str.substr str (+ idx 1)
                                           (- (str.len str) (+ idx 1))))))
                  (and (all_alpha_words headVal)
                       (all_alpha_words tailVal))))
              (str.in.re str
                         (re.* (re.union
                                  (re.range "A" "Z")
                                  (re.range "a" "z"))))))))

; === Inputs ===
(declare-const sentence Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal sentence))

; === Contract predicates ===
(define-fun C0 () Bool
  (is-StrVal sentence))
(define-fun C1 () Bool
  (let ((len (ite (is-StrVal sentence)
                  (str.len (sval sentence))
                  0)))
    (and (<= 1 len)
         (<= len 100))))
(define-fun C2 () Bool
  (and (is-StrVal sentence)
       (not (str.contains (sval sentence) "  "))))
(define-fun C3 () Bool
  (all_alpha_words sentence))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 11: satisfied_assert_1;assert_3, violated_assert_0;assert_2
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False, 'assert_3': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_3'], 'violated_contracts': ['assert_0', 'assert_2'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeStrLen ((s Value)) Int
  (ite (is-StrVal s) (str.len (sval s)) 0))

(define-fun-rec is_prime ((n Int)) Bool
  (and (>= n 2)
       (not (exists ((x Int))
               (and (>= x 2)
                    (<= (* x x) n)
                    (= (mod n x) 0))))))

(define-fun-rec all_alpha_words ((s Value)) Bool
  (ite (not (is-StrVal s))
       false
       (let ((str (sval s)))
         (ite (str.contains str " ")
              (let ((idx (str.indexof str " " 0)))
                (let ((headVal (StrVal (str.substr str 0 idx)))
                      (tailVal (StrVal (str.substr str (+ idx 1)
                                           (- (str.len str) (+ idx 1))))))
                  (and (all_alpha_words headVal)
                       (all_alpha_words tailVal))))
              (str.in.re str
                         (re.* (re.union
                                  (re.range "A" "Z")
                                  (re.range "a" "z"))))))))

; === Inputs ===
(declare-const sentence Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal sentence))

; === Contract predicates ===
(define-fun C0 () Bool
  (is-StrVal sentence))
(define-fun C1 () Bool
  (let ((len (ite (is-StrVal sentence)
                  (str.len (sval sentence))
                  0)))
    (and (<= 1 len)
         (<= len 100))))
(define-fun C2 () Bool
  (and (is-StrVal sentence)
       (not (str.contains (sval sentence) "  "))))
(define-fun C3 () Bool
  (all_alpha_words sentence))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 12: satisfied_assert_0;assert_1;assert_3, violated_assert_2
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False, 'assert_3': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_3'], 'violated_contracts': ['assert_2'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeStrLen ((s Value)) Int
  (ite (is-StrVal s) (str.len (sval s)) 0))

(define-fun-rec is_prime ((n Int)) Bool
  (and (>= n 2)
       (not (exists ((x Int))
               (and (>= x 2)
                    (<= (* x x) n)
                    (= (mod n x) 0))))))

(define-fun-rec all_alpha_words ((s Value)) Bool
  (ite (not (is-StrVal s))
       false
       (let ((str (sval s)))
         (ite (str.contains str " ")
              (let ((idx (str.indexof str " " 0)))
                (let ((headVal (StrVal (str.substr str 0 idx)))
                      (tailVal (StrVal (str.substr str (+ idx 1)
                                           (- (str.len str) (+ idx 1))))))
                  (and (all_alpha_words headVal)
                       (all_alpha_words tailVal))))
              (str.in.re str
                         (re.* (re.union
                                  (re.range "A" "Z")
                                  (re.range "a" "z"))))))))

; === Inputs ===
(declare-const sentence Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal sentence))

; === Contract predicates ===
(define-fun C0 () Bool
  (is-StrVal sentence))
(define-fun C1 () Bool
  (let ((len (ite (is-StrVal sentence)
                  (str.len (sval sentence))
                  0)))
    (and (<= 1 len)
         (<= len 100))))
(define-fun C2 () Bool
  (and (is-StrVal sentence)
       (not (str.contains (sval sentence) "  "))))
(define-fun C3 () Bool
  (all_alpha_words sentence))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 13: satisfied_assert_2;assert_3, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True, 'assert_3': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_2', 'assert_3'], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeStrLen ((s Value)) Int
  (ite (is-StrVal s) (str.len (sval s)) 0))

(define-fun-rec is_prime ((n Int)) Bool
  (and (>= n 2)
       (not (exists ((x Int))
               (and (>= x 2)
                    (<= (* x x) n)
                    (= (mod n x) 0))))))

(define-fun-rec all_alpha_words ((s Value)) Bool
  (ite (not (is-StrVal s))
       false
       (let ((str (sval s)))
         (ite (str.contains str " ")
              (let ((idx (str.indexof str " " 0)))
                (let ((headVal (StrVal (str.substr str 0 idx)))
                      (tailVal (StrVal (str.substr str (+ idx 1)
                                           (- (str.len str) (+ idx 1))))))
                  (and (all_alpha_words headVal)
                       (all_alpha_words tailVal))))
              (str.in.re str
                         (re.* (re.union
                                  (re.range "A" "Z")
                                  (re.range "a" "z"))))))))

; === Inputs ===
(declare-const sentence Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal sentence))

; === Contract predicates ===
(define-fun C0 () Bool
  (is-StrVal sentence))
(define-fun C1 () Bool
  (let ((len (ite (is-StrVal sentence)
                  (str.len (sval sentence))
                  0)))
    (and (<= 1 len)
         (<= len 100))))
(define-fun C2 () Bool
  (and (is-StrVal sentence)
       (not (str.contains (sval sentence) "  "))))
(define-fun C3 () Bool
  (all_alpha_words sentence))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 14: satisfied_assert_0;assert_2;assert_3, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True, 'assert_3': True}
  Satisfiable: True
  Solution Count: 1
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2', 'assert_3'], 'violated_contracts': ['assert_1'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'sentence': ''}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeStrLen ((s Value)) Int
  (ite (is-StrVal s) (str.len (sval s)) 0))

(define-fun-rec is_prime ((n Int)) Bool
  (and (>= n 2)
       (not (exists ((x Int))
               (and (>= x 2)
                    (<= (* x x) n)
                    (= (mod n x) 0))))))

(define-fun-rec all_alpha_words ((s Value)) Bool
  (ite (not (is-StrVal s))
       false
       (let ((str (sval s)))
         (ite (str.contains str " ")
              (let ((idx (str.indexof str " " 0)))
                (let ((headVal (StrVal (str.substr str 0 idx)))
                      (tailVal (StrVal (str.substr str (+ idx 1)
                                           (- (str.len str) (+ idx 1))))))
                  (and (all_alpha_words headVal)
                       (all_alpha_words tailVal))))
              (str.in.re str
                         (re.* (re.union
                                  (re.range "A" "Z")
                                  (re.range "a" "z"))))))))

; === Inputs ===
(declare-const sentence Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal sentence))

; === Contract predicates ===
(define-fun C0 () Bool
  (is-StrVal sentence))
(define-fun C1 () Bool
  (let ((len (ite (is-StrVal sentence)
                  (str.len (sval sentence))
                  0)))
    (and (<= 1 len)
         (<= len 100))))
(define-fun C2 () Bool
  (and (is-StrVal sentence)
       (not (str.contains (sval sentence) "  "))))
(define-fun C3 () Bool
  (all_alpha_words sentence))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 15: satisfied_assert_1;assert_2;assert_3, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True, 'assert_3': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2', 'assert_3'], 'violated_contracts': ['assert_0'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeStrLen ((s Value)) Int
  (ite (is-StrVal s) (str.len (sval s)) 0))

(define-fun-rec is_prime ((n Int)) Bool
  (and (>= n 2)
       (not (exists ((x Int))
               (and (>= x 2)
                    (<= (* x x) n)
                    (= (mod n x) 0))))))

(define-fun-rec all_alpha_words ((s Value)) Bool
  (ite (not (is-StrVal s))
       false
       (let ((str (sval s)))
         (ite (str.contains str " ")
              (let ((idx (str.indexof str " " 0)))
                (let ((headVal (StrVal (str.substr str 0 idx)))
                      (tailVal (StrVal (str.substr str (+ idx 1)
                                           (- (str.len str) (+ idx 1))))))
                  (and (all_alpha_words headVal)
                       (all_alpha_words tailVal))))
              (str.in.re str
                         (re.* (re.union
                                  (re.range "A" "Z")
                                  (re.range "a" "z"))))))))

; === Inputs ===
(declare-const sentence Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal sentence))

; === Contract predicates ===
(define-fun C0 () Bool
  (is-StrVal sentence))
(define-fun C1 () Bool
  (let ((len (ite (is-StrVal sentence)
                  (str.len (sval sentence))
                  0)))
    (and (<= 1 len)
         (<= len 100))))
(define-fun C2 () Bool
  (and (is-StrVal sentence)
       (not (str.contains (sval sentence) "  "))))
(define-fun C3 () Bool
  (all_alpha_words sentence))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 16: satisfied_assert_0;assert_1;assert_2;assert_3, violated_
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True, 'assert_3': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_3'], 'violated_contracts': [], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'sentence': 'D'}
    Solution 2:
      test_case: {'sentence': 'X'}
    Solution 3:
      test_case: {'sentence': 'P'}
    Solution 4:
      test_case: {'sentence': 'H'}
    Solution 5:
      test_case: {'sentence': 'L'}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeStrLen ((s Value)) Int
  (ite (is-StrVal s) (str.len (sval s)) 0))

(define-fun-rec is_prime ((n Int)) Bool
  (and (>= n 2)
       (not (exists ((x Int))
               (and (>= x 2)
                    (<= (* x x) n)
                    (= (mod n x) 0))))))

(define-fun-rec all_alpha_words ((s Value)) Bool
  (ite (not (is-StrVal s))
       false
       (let ((str (sval s)))
         (ite (str.contains str " ")
              (let ((idx (str.indexof str " " 0)))
                (let ((headVal (StrVal (str.substr str 0 idx)))
                      (tailVal (StrVal (str.substr str (+ idx 1)
                                           (- (str.len str) (+ idx 1))))))
                  (and (all_alpha_words headVal)
                       (all_alpha_words tailVal))))
              (str.in.re str
                         (re.* (re.union
                                  (re.range "A" "Z")
                                  (re.range "a" "z"))))))))

; === Inputs ===
(declare-const sentence Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal sentence))

; === Contract predicates ===
(define-fun C0 () Bool
  (is-StrVal sentence))
(define-fun C1 () Bool
  (let ((len (ite (is-StrVal sentence)
                  (str.len (sval sentence))
                  0)))
    (and (<= 1 len)
         (<= len 100))))
(define-fun C2 () Bool
  (and (is-StrVal sentence)
       (not (str.contains (sval sentence) "  "))))
(define-fun C3 () Bool
  (all_alpha_words sentence))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)
(assert C3)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/144 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1;assert_2;assert_3
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False, 'assert_3': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_3'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun DIGIT () (RegEx String) (re.range "0" "9"))
(define-fun POSINT () (RegEx String) (re.++ (re.range "1" "9") (re.* DIGIT)))

; === Inputs ===
(declare-const x Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal x))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal x))
(define-fun C1 () Bool
  (let ((svx (sval x)) (idx (str.indexof (sval x) "/" 0)))
    (and (>= idx 0) (= (str.indexof svx "/" (+ idx 1)) -1))))
(define-fun C2 () Bool
  (let ((svx (sval x)) (idx (str.indexof (sval x) "/" 0)))
    (let ((num (str.substr svx 0 idx)))
      (and (not (= num "")) (str.in.re num POSINT)))))
(define-fun C3 () Bool
  (let ((svx (sval x)) (idx (str.indexof (sval x) "/" 0)))
    (let ((den (str.substr svx (+ idx 1) (- (str.len svx) (+ idx 1)))))
      (and (not (= den "")) (str.in.re den POSINT)))))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1;assert_2;assert_3
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False, 'assert_3': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1', 'assert_2', 'assert_3'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'x': ''}
    Solution 2:
      test_case: {'x': 'D'}
    Solution 3:
      test_case: {'x': ':'}
    Solution 4:
      test_case: {'x': '\\u{1003a}'}
    Solution 5:
      test_case: {'x': '\\u{803a}'}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun DIGIT () (RegEx String) (re.range "0" "9"))
(define-fun POSINT () (RegEx String) (re.++ (re.range "1" "9") (re.* DIGIT)))

; === Inputs ===
(declare-const x Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal x))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal x))
(define-fun C1 () Bool
  (let ((svx (sval x)) (idx (str.indexof (sval x) "/" 0)))
    (and (>= idx 0) (= (str.indexof svx "/" (+ idx 1)) -1))))
(define-fun C2 () Bool
  (let ((svx (sval x)) (idx (str.indexof (sval x) "/" 0)))
    (let ((num (str.substr svx 0 idx)))
      (and (not (= num "")) (str.in.re num POSINT)))))
(define-fun C3 () Bool
  (let ((svx (sval x)) (idx (str.indexof (sval x) "/" 0)))
    (let ((den (str.substr svx (+ idx 1) (- (str.len svx) (+ idx 1)))))
      (and (not (= den "")) (str.in.re den POSINT)))))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0;assert_2;assert_3
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False, 'assert_3': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0', 'assert_2', 'assert_3'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun DIGIT () (RegEx String) (re.range "0" "9"))
(define-fun POSINT () (RegEx String) (re.++ (re.range "1" "9") (re.* DIGIT)))

; === Inputs ===
(declare-const x Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal x))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal x))
(define-fun C1 () Bool
  (let ((svx (sval x)) (idx (str.indexof (sval x) "/" 0)))
    (and (>= idx 0) (= (str.indexof svx "/" (+ idx 1)) -1))))
(define-fun C2 () Bool
  (let ((svx (sval x)) (idx (str.indexof (sval x) "/" 0)))
    (let ((num (str.substr svx 0 idx)))
      (and (not (= num "")) (str.in.re num POSINT)))))
(define-fun C3 () Bool
  (let ((svx (sval x)) (idx (str.indexof (sval x) "/" 0)))
    (let ((den (str.substr svx (+ idx 1) (- (str.len svx) (+ idx 1)))))
      (and (not (= den "")) (str.in.re den POSINT)))))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_assert_2;assert_3
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False, 'assert_3': False}
  Satisfiable: True
  Solution Count: 1
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': ['assert_2', 'assert_3'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'x': '/'}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun DIGIT () (RegEx String) (re.range "0" "9"))
(define-fun POSINT () (RegEx String) (re.++ (re.range "1" "9") (re.* DIGIT)))

; === Inputs ===
(declare-const x Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal x))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal x))
(define-fun C1 () Bool
  (let ((svx (sval x)) (idx (str.indexof (sval x) "/" 0)))
    (and (>= idx 0) (= (str.indexof svx "/" (+ idx 1)) -1))))
(define-fun C2 () Bool
  (let ((svx (sval x)) (idx (str.indexof (sval x) "/" 0)))
    (let ((num (str.substr svx 0 idx)))
      (and (not (= num "")) (str.in.re num POSINT)))))
(define-fun C3 () Bool
  (let ((svx (sval x)) (idx (str.indexof (sval x) "/" 0)))
    (let ((den (str.substr svx (+ idx 1) (- (str.len svx) (+ idx 1)))))
      (and (not (= den "")) (str.in.re den POSINT)))))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 5: satisfied_assert_2, violated_assert_0;assert_1;assert_3
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True, 'assert_3': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_2'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_3'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun DIGIT () (RegEx String) (re.range "0" "9"))
(define-fun POSINT () (RegEx String) (re.++ (re.range "1" "9") (re.* DIGIT)))

; === Inputs ===
(declare-const x Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal x))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal x))
(define-fun C1 () Bool
  (let ((svx (sval x)) (idx (str.indexof (sval x) "/" 0)))
    (and (>= idx 0) (= (str.indexof svx "/" (+ idx 1)) -1))))
(define-fun C2 () Bool
  (let ((svx (sval x)) (idx (str.indexof (sval x) "/" 0)))
    (let ((num (str.substr svx 0 idx)))
      (and (not (= num "")) (str.in.re num POSINT)))))
(define-fun C3 () Bool
  (let ((svx (sval x)) (idx (str.indexof (sval x) "/" 0)))
    (let ((den (str.substr svx (+ idx 1) (- (str.len svx) (+ idx 1)))))
      (and (not (= den "")) (str.in.re den POSINT)))))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 6: satisfied_assert_0;assert_2, violated_assert_1;assert_3
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True, 'assert_3': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2'], 'violated_contracts': ['assert_1', 'assert_3'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun DIGIT () (RegEx String) (re.range "0" "9"))
(define-fun POSINT () (RegEx String) (re.++ (re.range "1" "9") (re.* DIGIT)))

; === Inputs ===
(declare-const x Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal x))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal x))
(define-fun C1 () Bool
  (let ((svx (sval x)) (idx (str.indexof (sval x) "/" 0)))
    (and (>= idx 0) (= (str.indexof svx "/" (+ idx 1)) -1))))
(define-fun C2 () Bool
  (let ((svx (sval x)) (idx (str.indexof (sval x) "/" 0)))
    (let ((num (str.substr svx 0 idx)))
      (and (not (= num "")) (str.in.re num POSINT)))))
(define-fun C3 () Bool
  (let ((svx (sval x)) (idx (str.indexof (sval x) "/" 0)))
    (let ((den (str.substr svx (+ idx 1) (- (str.len svx) (+ idx 1)))))
      (and (not (= den "")) (str.in.re den POSINT)))))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 7: satisfied_assert_1;assert_2, violated_assert_0;assert_3
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True, 'assert_3': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2'], 'violated_contracts': ['assert_0', 'assert_3'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun DIGIT () (RegEx String) (re.range "0" "9"))
(define-fun POSINT () (RegEx String) (re.++ (re.range "1" "9") (re.* DIGIT)))

; === Inputs ===
(declare-const x Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal x))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal x))
(define-fun C1 () Bool
  (let ((svx (sval x)) (idx (str.indexof (sval x) "/" 0)))
    (and (>= idx 0) (= (str.indexof svx "/" (+ idx 1)) -1))))
(define-fun C2 () Bool
  (let ((svx (sval x)) (idx (str.indexof (sval x) "/" 0)))
    (let ((num (str.substr svx 0 idx)))
      (and (not (= num "")) (str.in.re num POSINT)))))
(define-fun C3 () Bool
  (let ((svx (sval x)) (idx (str.indexof (sval x) "/" 0)))
    (let ((den (str.substr svx (+ idx 1) (- (str.len svx) (+ idx 1)))))
      (and (not (= den "")) (str.in.re den POSINT)))))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 8: satisfied_assert_0;assert_1;assert_2, violated_assert_3
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True, 'assert_3': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2'], 'violated_contracts': ['assert_3'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'x': '4/'}
    Solution 2:
      test_case: {'x': '2/'}
    Solution 3:
      test_case: {'x': '6/'}
    Solution 4:
      test_case: {'x': '3/'}
    Solution 5:
      test_case: {'x': '7/'}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun DIGIT () (RegEx String) (re.range "0" "9"))
(define-fun POSINT () (RegEx String) (re.++ (re.range "1" "9") (re.* DIGIT)))

; === Inputs ===
(declare-const x Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal x))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal x))
(define-fun C1 () Bool
  (let ((svx (sval x)) (idx (str.indexof (sval x) "/" 0)))
    (and (>= idx 0) (= (str.indexof svx "/" (+ idx 1)) -1))))
(define-fun C2 () Bool
  (let ((svx (sval x)) (idx (str.indexof (sval x) "/" 0)))
    (let ((num (str.substr svx 0 idx)))
      (and (not (= num "")) (str.in.re num POSINT)))))
(define-fun C3 () Bool
  (let ((svx (sval x)) (idx (str.indexof (sval x) "/" 0)))
    (let ((den (str.substr svx (+ idx 1) (- (str.len svx) (+ idx 1)))))
      (and (not (= den "")) (str.in.re den POSINT)))))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 9: satisfied_assert_3, violated_assert_0;assert_1;assert_2
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False, 'assert_3': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_3'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun DIGIT () (RegEx String) (re.range "0" "9"))
(define-fun POSINT () (RegEx String) (re.++ (re.range "1" "9") (re.* DIGIT)))

; === Inputs ===
(declare-const x Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal x))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal x))
(define-fun C1 () Bool
  (let ((svx (sval x)) (idx (str.indexof (sval x) "/" 0)))
    (and (>= idx 0) (= (str.indexof svx "/" (+ idx 1)) -1))))
(define-fun C2 () Bool
  (let ((svx (sval x)) (idx (str.indexof (sval x) "/" 0)))
    (let ((num (str.substr svx 0 idx)))
      (and (not (= num "")) (str.in.re num POSINT)))))
(define-fun C3 () Bool
  (let ((svx (sval x)) (idx (str.indexof (sval x) "/" 0)))
    (let ((den (str.substr svx (+ idx 1) (- (str.len svx) (+ idx 1)))))
      (and (not (= den "")) (str.in.re den POSINT)))))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 10: satisfied_assert_0;assert_3, violated_assert_1;assert_2
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False, 'assert_3': True}
  Satisfiable: True
  Solution Count: 1
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_3'], 'violated_contracts': ['assert_1', 'assert_2'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'x': '4'}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun DIGIT () (RegEx String) (re.range "0" "9"))
(define-fun POSINT () (RegEx String) (re.++ (re.range "1" "9") (re.* DIGIT)))

; === Inputs ===
(declare-const x Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal x))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal x))
(define-fun C1 () Bool
  (let ((svx (sval x)) (idx (str.indexof (sval x) "/" 0)))
    (and (>= idx 0) (= (str.indexof svx "/" (+ idx 1)) -1))))
(define-fun C2 () Bool
  (let ((svx (sval x)) (idx (str.indexof (sval x) "/" 0)))
    (let ((num (str.substr svx 0 idx)))
      (and (not (= num "")) (str.in.re num POSINT)))))
(define-fun C3 () Bool
  (let ((svx (sval x)) (idx (str.indexof (sval x) "/" 0)))
    (let ((den (str.substr svx (+ idx 1) (- (str.len svx) (+ idx 1)))))
      (and (not (= den "")) (str.in.re den POSINT)))))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 11: satisfied_assert_1;assert_3, violated_assert_0;assert_2
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False, 'assert_3': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_3'], 'violated_contracts': ['assert_0', 'assert_2'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun DIGIT () (RegEx String) (re.range "0" "9"))
(define-fun POSINT () (RegEx String) (re.++ (re.range "1" "9") (re.* DIGIT)))

; === Inputs ===
(declare-const x Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal x))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal x))
(define-fun C1 () Bool
  (let ((svx (sval x)) (idx (str.indexof (sval x) "/" 0)))
    (and (>= idx 0) (= (str.indexof svx "/" (+ idx 1)) -1))))
(define-fun C2 () Bool
  (let ((svx (sval x)) (idx (str.indexof (sval x) "/" 0)))
    (let ((num (str.substr svx 0 idx)))
      (and (not (= num "")) (str.in.re num POSINT)))))
(define-fun C3 () Bool
  (let ((svx (sval x)) (idx (str.indexof (sval x) "/" 0)))
    (let ((den (str.substr svx (+ idx 1) (- (str.len svx) (+ idx 1)))))
      (and (not (= den "")) (str.in.re den POSINT)))))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 12: satisfied_assert_0;assert_1;assert_3, violated_assert_2
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False, 'assert_3': True}
  Satisfiable: True
  Solution Count: 1
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_3'], 'violated_contracts': ['assert_2'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'x': '/4'}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun DIGIT () (RegEx String) (re.range "0" "9"))
(define-fun POSINT () (RegEx String) (re.++ (re.range "1" "9") (re.* DIGIT)))

; === Inputs ===
(declare-const x Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal x))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal x))
(define-fun C1 () Bool
  (let ((svx (sval x)) (idx (str.indexof (sval x) "/" 0)))
    (and (>= idx 0) (= (str.indexof svx "/" (+ idx 1)) -1))))
(define-fun C2 () Bool
  (let ((svx (sval x)) (idx (str.indexof (sval x) "/" 0)))
    (let ((num (str.substr svx 0 idx)))
      (and (not (= num "")) (str.in.re num POSINT)))))
(define-fun C3 () Bool
  (let ((svx (sval x)) (idx (str.indexof (sval x) "/" 0)))
    (let ((den (str.substr svx (+ idx 1) (- (str.len svx) (+ idx 1)))))
      (and (not (= den "")) (str.in.re den POSINT)))))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 13: satisfied_assert_2;assert_3, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True, 'assert_3': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_2', 'assert_3'], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun DIGIT () (RegEx String) (re.range "0" "9"))
(define-fun POSINT () (RegEx String) (re.++ (re.range "1" "9") (re.* DIGIT)))

; === Inputs ===
(declare-const x Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal x))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal x))
(define-fun C1 () Bool
  (let ((svx (sval x)) (idx (str.indexof (sval x) "/" 0)))
    (and (>= idx 0) (= (str.indexof svx "/" (+ idx 1)) -1))))
(define-fun C2 () Bool
  (let ((svx (sval x)) (idx (str.indexof (sval x) "/" 0)))
    (let ((num (str.substr svx 0 idx)))
      (and (not (= num "")) (str.in.re num POSINT)))))
(define-fun C3 () Bool
  (let ((svx (sval x)) (idx (str.indexof (sval x) "/" 0)))
    (let ((den (str.substr svx (+ idx 1) (- (str.len svx) (+ idx 1)))))
      (and (not (= den "")) (str.in.re den POSINT)))))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 14: satisfied_assert_0;assert_2;assert_3, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True, 'assert_3': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2', 'assert_3'], 'violated_contracts': ['assert_1'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun DIGIT () (RegEx String) (re.range "0" "9"))
(define-fun POSINT () (RegEx String) (re.++ (re.range "1" "9") (re.* DIGIT)))

; === Inputs ===
(declare-const x Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal x))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal x))
(define-fun C1 () Bool
  (let ((svx (sval x)) (idx (str.indexof (sval x) "/" 0)))
    (and (>= idx 0) (= (str.indexof svx "/" (+ idx 1)) -1))))
(define-fun C2 () Bool
  (let ((svx (sval x)) (idx (str.indexof (sval x) "/" 0)))
    (let ((num (str.substr svx 0 idx)))
      (and (not (= num "")) (str.in.re num POSINT)))))
(define-fun C3 () Bool
  (let ((svx (sval x)) (idx (str.indexof (sval x) "/" 0)))
    (let ((den (str.substr svx (+ idx 1) (- (str.len svx) (+ idx 1)))))
      (and (not (= den "")) (str.in.re den POSINT)))))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 15: satisfied_assert_1;assert_2;assert_3, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True, 'assert_3': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2', 'assert_3'], 'violated_contracts': ['assert_0'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun DIGIT () (RegEx String) (re.range "0" "9"))
(define-fun POSINT () (RegEx String) (re.++ (re.range "1" "9") (re.* DIGIT)))

; === Inputs ===
(declare-const x Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal x))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal x))
(define-fun C1 () Bool
  (let ((svx (sval x)) (idx (str.indexof (sval x) "/" 0)))
    (and (>= idx 0) (= (str.indexof svx "/" (+ idx 1)) -1))))
(define-fun C2 () Bool
  (let ((svx (sval x)) (idx (str.indexof (sval x) "/" 0)))
    (let ((num (str.substr svx 0 idx)))
      (and (not (= num "")) (str.in.re num POSINT)))))
(define-fun C3 () Bool
  (let ((svx (sval x)) (idx (str.indexof (sval x) "/" 0)))
    (let ((den (str.substr svx (+ idx 1) (- (str.len svx) (+ idx 1)))))
      (and (not (= den "")) (str.in.re den POSINT)))))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 16: satisfied_assert_0;assert_1;assert_2;assert_3, violated_
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True, 'assert_3': True}
  Satisfiable: True
  Solution Count: 1
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_3'], 'violated_contracts': [], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'x': '8/8'}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun DIGIT () (RegEx String) (re.range "0" "9"))
(define-fun POSINT () (RegEx String) (re.++ (re.range "1" "9") (re.* DIGIT)))

; === Inputs ===
(declare-const x Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal x))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal x))
(define-fun C1 () Bool
  (let ((svx (sval x)) (idx (str.indexof (sval x) "/" 0)))
    (and (>= idx 0) (= (str.indexof svx "/" (+ idx 1)) -1))))
(define-fun C2 () Bool
  (let ((svx (sval x)) (idx (str.indexof (sval x) "/" 0)))
    (let ((num (str.substr svx 0 idx)))
      (and (not (= num "")) (str.in.re num POSINT)))))
(define-fun C3 () Bool
  (let ((svx (sval x)) (idx (str.indexof (sval x) "/" 0)))
    (let ((den (str.substr svx (+ idx 1) (- (str.len svx) (+ idx 1)))))
      (and (not (= den "")) (str.in.re den POSINT)))))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)
(assert C3)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/145 ===
  Test Case 1: satisfied_, violated_assert_0
  Combination: {'assert_0': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0'], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'nums': [2.0]}
    Solution 2:
      test_case: {'nums': [3.0]}
    Solution 3:
      test_case: {'nums': [4.0]}
    Solution 4:
      test_case: {'nums': [5.0]}
    Solution 5:
      test_case: {'nums': [6.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))
(define-fun-rec list_all_int ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (is-IntVal (head v))
                 (list_all_int (tail v)))
            false)))

; === Inputs ===
(declare-const nums Value)

; === BASIC STRUCTURE ===
(assert (IsList nums))

; === Contract predicates ===
(define-fun C0 () Bool (list_all_int nums))

; === COMBINATION ===
(assert (not C0))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_
  Combination: {'assert_0': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': [], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'nums': []}
    Solution 2:
      test_case: {'nums': [2]}
    Solution 3:
      test_case: {'nums': [3]}
    Solution 4:
      test_case: {'nums': [4]}
    Solution 5:
      test_case: {'nums': [5]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))
(define-fun-rec list_all_int ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (and (is-IntVal (head v))
                 (list_all_int (tail v)))
            false)))

; === Inputs ===
(declare-const nums Value)

; === BASIC STRUCTURE ===
(assert (IsList nums))

; === Contract predicates ===
(define-fun C0 () Bool (list_all_int nums))

; === COMBINATION ===
(assert C0)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/146 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (let ((tailVal (tail l)))
              (IsList tailVal))
            false)))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (let ((headVal (head l))
                  (tailVal (tail l)))
              (and (is-IntVal headVal)
                   (list_all_int tailVal)))
            false)))

; === Inputs ===
(declare-const nums Value)

; === BASIC STRUCTURE ===
(assert (IsList nums))

; === Contract predicates ===
(define-fun C0 () Bool
  (IsList nums))
(define-fun C1 () Bool
  (list_all_int nums))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'nums': [2.0]}
    Solution 2:
      test_case: {'nums': [3.0]}
    Solution 3:
      test_case: {'nums': [4.0]}
    Solution 4:
      test_case: {'nums': [5.0]}
    Solution 5:
      test_case: {'nums': [6.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (let ((tailVal (tail l)))
              (IsList tailVal))
            false)))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (let ((headVal (head l))
                  (tailVal (tail l)))
              (and (is-IntVal headVal)
                   (list_all_int tailVal)))
            false)))

; === Inputs ===
(declare-const nums Value)

; === BASIC STRUCTURE ===
(assert (IsList nums))

; === Contract predicates ===
(define-fun C0 () Bool
  (IsList nums))
(define-fun C1 () Bool
  (list_all_int nums))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (let ((tailVal (tail l)))
              (IsList tailVal))
            false)))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (let ((headVal (head l))
                  (tailVal (tail l)))
              (and (is-IntVal headVal)
                   (list_all_int tailVal)))
            false)))

; === Inputs ===
(declare-const nums Value)

; === BASIC STRUCTURE ===
(assert (IsList nums))

; === Contract predicates ===
(define-fun C0 () Bool
  (IsList nums))
(define-fun C1 () Bool
  (list_all_int nums))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'nums': []}
    Solution 2:
      test_case: {'nums': [2]}
    Solution 3:
      test_case: {'nums': [3]}
    Solution 4:
      test_case: {'nums': [4]}
    Solution 5:
      test_case: {'nums': [5]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (let ((tailVal (tail l)))
              (IsList tailVal))
            false)))

(define-fun-rec list_all_int ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (let ((headVal (head l))
                  (tailVal (tail l)))
              (and (is-IntVal headVal)
                   (list_all_int tailVal)))
            false)))

; === Inputs ===
(declare-const nums Value)

; === BASIC STRUCTURE ===
(assert (IsList nums))

; === Contract predicates ===
(define-fun C0 () Bool
  (IsList nums))
(define-fun C1 () Bool
  (list_all_int nums))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/147 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===
(assert (is-IntVal n))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))
(define-fun C1 () Bool (> (SafeI n) 0))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'n': 0}
    Solution 2:
      test_case: {'n': -7719}
    Solution 3:
      test_case: {'n': -10156}
    Solution 4:
      test_case: {'n': -21953}
    Solution 5:
      test_case: {'n': -54238}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===
(assert (is-IntVal n))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))
(define-fun C1 () Bool (> (SafeI n) 0))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===
(assert (is-IntVal n))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))
(define-fun C1 () Bool (> (SafeI n) 0))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'n': 1}
    Solution 2:
      test_case: {'n': 7720}
    Solution 3:
      test_case: {'n': 10157}
    Solution 4:
      test_case: {'n': 21954}
    Solution 5:
      test_case: {'n': 54239}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const n Value)

; === BASIC STRUCTURE ===
(assert (is-IntVal n))

; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))
(define-fun C1 () Bool (> (SafeI n) 0))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/148 ===
  Test Case 1: satisfied_, violated_assert_0
  Combination: {'assert_0': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0'], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'planet2': 2.0, 'planet1': 3.0}
    Solution 2:
      test_case: {'planet2': 5.0, 'planet1': 4.0}
    Solution 3:
      test_case: {'planet2': 7.0, 'planet1': 6.0}
    Solution 4:
      test_case: {'planet2': 8.0, 'planet1': 9.0}
    Solution 5:
      test_case: {'planet2': 10.0, 'planet1': 11.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeStr ((v Value)) String (ite (is-StrVal v) (sval v) ""))

; === Inputs ===
(declare-const planet1 Value)
(declare-const planet2 Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (is-StrVal planet1) (is-StrVal planet2)))

; === COMBINATION ===
(assert (not C0))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_
  Combination: {'assert_0': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': [], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'planet2': '!0!', 'planet1': '!0!'}
    Solution 2:
      test_case: {'planet2': '0', 'planet1': '!'}
    Solution 3:
      test_case: {'planet2': '0!', 'planet1': '0!'}
    Solution 4:
      test_case: {'planet2': '!', 'planet1': 'A'}
    Solution 5:
      test_case: {'planet2': '', 'planet1': 'B'}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeStr ((v Value)) String (ite (is-StrVal v) (sval v) ""))

; === Inputs ===
(declare-const planet1 Value)
(declare-const planet2 Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (is-StrVal planet1) (is-StrVal planet2)))

; === COMBINATION ===
(assert C0)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/149 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (or
    (is-Nil l)
    (and (is-Cons l)
         (IsList (tail l)))))

(define-fun-rec list_all_str ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (let ((hd (head l))
                  (tl (tail l)))
              (and (is-StrVal hd)
                   (list_all_str tl)))
            false)))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (IsList lst))

; === Contract predicates ===
(define-fun C0 () Bool (IsList lst))
(define-fun C1 () Bool (list_all_str lst))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'lst': [2.0]}
    Solution 2:
      test_case: {'lst': [3.0]}
    Solution 3:
      test_case: {'lst': [4.0]}
    Solution 4:
      test_case: {'lst': [5.0]}
    Solution 5:
      test_case: {'lst': [6.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (or
    (is-Nil l)
    (and (is-Cons l)
         (IsList (tail l)))))

(define-fun-rec list_all_str ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (let ((hd (head l))
                  (tl (tail l)))
              (and (is-StrVal hd)
                   (list_all_str tl)))
            false)))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (IsList lst))

; === Contract predicates ===
(define-fun C0 () Bool (IsList lst))
(define-fun C1 () Bool (list_all_str lst))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (or
    (is-Nil l)
    (and (is-Cons l)
         (IsList (tail l)))))

(define-fun-rec list_all_str ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (let ((hd (head l))
                  (tl (tail l)))
              (and (is-StrVal hd)
                   (list_all_str tl)))
            false)))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (IsList lst))

; === Contract predicates ===
(define-fun C0 () Bool (IsList lst))
(define-fun C1 () Bool (list_all_str lst))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'lst': []}
    Solution 2:
      test_case: {'lst': ['!0!']}
    Solution 3:
      test_case: {'lst': ['!']}
    Solution 4:
      test_case: {'lst': ['0']}
    Solution 5:
      test_case: {'lst': ['0!']}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (or
    (is-Nil l)
    (and (is-Cons l)
         (IsList (tail l)))))

(define-fun-rec list_all_str ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (let ((hd (head l))
                  (tl (tail l)))
              (and (is-StrVal hd)
                   (list_all_str tl)))
            false)))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===
(assert (IsList lst))

; === Contract predicates ===
(define-fun C0 () Bool (IsList lst))
(define-fun C1 () Bool (list_all_str lst))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/150 ===
  Test Case 1: satisfied_, violated_assert_0
  Combination: {'assert_0': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0'], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'n': 2.0}
    Solution 2:
      test_case: {'n': 3.0}
    Solution 3:
      test_case: {'n': 4.0}
    Solution 4:
      test_case: {'n': 5.0}
    Solution 5:
      test_case: {'n': 6.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const n Value)
(declare-const x Value)
(declare-const y Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))

; === COMBINATION ===
(assert (not C0))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_
  Combination: {'assert_0': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': [], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'n': 2}
    Solution 2:
      test_case: {'n': 3}
    Solution 3:
      test_case: {'n': 4}
    Solution 4:
      test_case: {'n': 5}
    Solution 5:
      test_case: {'n': 6}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const n Value)
(declare-const x Value)
(declare-const y Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal n))

; === COMBINATION ===
(assert C0)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/151 ===
  Test Case 1: satisfied_, violated_assert_0
  Combination: {'assert_0': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0'], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'lst': 2.0}
    Solution 2:
      test_case: {'lst': 3.0}
    Solution 3:
      test_case: {'lst': 4.0}
    Solution 4:
      test_case: {'lst': 5.0}
    Solution 5:
      test_case: {'lst': 6.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (IsList (tail v))
      false)))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (IsList lst))

; === COMBINATION ===
(assert (not C0))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_
  Combination: {'assert_0': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': [], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'lst': []}
    Solution 2:
      test_case: {'lst': [2.0]}
    Solution 3:
      test_case: {'lst': [3.0]}
    Solution 4:
      test_case: {'lst': [4.0]}
    Solution 5:
      test_case: {'lst': [5.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v) true
    (ite (is-Cons v)
      (IsList (tail v))
      false)))

; === Inputs ===
(declare-const lst Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (IsList lst))

; === COMBINATION ===
(assert C0)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/152 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1;assert_2;assert_3
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False, 'assert_3': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_3'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool (or (is-Nil v) (and (is-Cons v) (IsList (tail v)))))
(define-fun-rec ListAllInt ((v Value)) Bool (or (is-Nil v) (and (is-Cons v) (is-IntVal (head v)) (ListAllInt (tail v)))))
(define-fun-rec Length ((v Value)) Int (ite (is-Nil v) 0 (ite (is-Cons v) (+ 1 (Length (tail v))) 0)))

; === Inputs ===
(declare-const game Value)
(declare-const guess Value)

; === BASIC STRUCTURE ===
(assert (and (IsList game) (IsList guess)))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList game) (IsList guess)))
(define-fun C1 () Bool (ListAllInt game))
(define-fun C2 () Bool (ListAllInt guess))
(define-fun C3 () Bool (= (Length game) (Length guess)))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1;assert_2;assert_3
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False, 'assert_3': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1', 'assert_2', 'assert_3'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'guess': [5.0, 3.0], 'game': [2.0]}
    Solution 2:
      test_case: {'game': [8.0], 'guess': [7.0, 6.0]}
    Solution 3:
      test_case: {'game': [10.0], 'guess': [9.0, 4.0]}
    Solution 4:
      test_case: {'game': [11.0], 'guess': [13.0, 12.0]}
    Solution 5:
      test_case: {'game': [14.0], 'guess': [16.0, 15.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool (or (is-Nil v) (and (is-Cons v) (IsList (tail v)))))
(define-fun-rec ListAllInt ((v Value)) Bool (or (is-Nil v) (and (is-Cons v) (is-IntVal (head v)) (ListAllInt (tail v)))))
(define-fun-rec Length ((v Value)) Int (ite (is-Nil v) 0 (ite (is-Cons v) (+ 1 (Length (tail v))) 0)))

; === Inputs ===
(declare-const game Value)
(declare-const guess Value)

; === BASIC STRUCTURE ===
(assert (and (IsList game) (IsList guess)))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList game) (IsList guess)))
(define-fun C1 () Bool (ListAllInt game))
(define-fun C2 () Bool (ListAllInt guess))
(define-fun C3 () Bool (= (Length game) (Length guess)))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0;assert_2;assert_3
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False, 'assert_3': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0', 'assert_2', 'assert_3'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool (or (is-Nil v) (and (is-Cons v) (IsList (tail v)))))
(define-fun-rec ListAllInt ((v Value)) Bool (or (is-Nil v) (and (is-Cons v) (is-IntVal (head v)) (ListAllInt (tail v)))))
(define-fun-rec Length ((v Value)) Int (ite (is-Nil v) 0 (ite (is-Cons v) (+ 1 (Length (tail v))) 0)))

; === Inputs ===
(declare-const game Value)
(declare-const guess Value)

; === BASIC STRUCTURE ===
(assert (and (IsList game) (IsList guess)))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList game) (IsList guess)))
(define-fun C1 () Bool (ListAllInt game))
(define-fun C2 () Bool (ListAllInt guess))
(define-fun C3 () Bool (= (Length game) (Length guess)))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_assert_2;assert_3
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False, 'assert_3': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': ['assert_2', 'assert_3'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'guess': [2.0], 'game': []}
    Solution 2:
      test_case: {'game': [], 'guess': [3.0]}
    Solution 3:
      test_case: {'game': [], 'guess': [4.0]}
    Solution 4:
      test_case: {'game': [], 'guess': [5.0]}
    Solution 5:
      test_case: {'game': [], 'guess': [7.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool (or (is-Nil v) (and (is-Cons v) (IsList (tail v)))))
(define-fun-rec ListAllInt ((v Value)) Bool (or (is-Nil v) (and (is-Cons v) (is-IntVal (head v)) (ListAllInt (tail v)))))
(define-fun-rec Length ((v Value)) Int (ite (is-Nil v) 0 (ite (is-Cons v) (+ 1 (Length (tail v))) 0)))

; === Inputs ===
(declare-const game Value)
(declare-const guess Value)

; === BASIC STRUCTURE ===
(assert (and (IsList game) (IsList guess)))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList game) (IsList guess)))
(define-fun C1 () Bool (ListAllInt game))
(define-fun C2 () Bool (ListAllInt guess))
(define-fun C3 () Bool (= (Length game) (Length guess)))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 5: satisfied_assert_2, violated_assert_0;assert_1;assert_3
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True, 'assert_3': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_2'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_3'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool (or (is-Nil v) (and (is-Cons v) (IsList (tail v)))))
(define-fun-rec ListAllInt ((v Value)) Bool (or (is-Nil v) (and (is-Cons v) (is-IntVal (head v)) (ListAllInt (tail v)))))
(define-fun-rec Length ((v Value)) Int (ite (is-Nil v) 0 (ite (is-Cons v) (+ 1 (Length (tail v))) 0)))

; === Inputs ===
(declare-const game Value)
(declare-const guess Value)

; === BASIC STRUCTURE ===
(assert (and (IsList game) (IsList guess)))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList game) (IsList guess)))
(define-fun C1 () Bool (ListAllInt game))
(define-fun C2 () Bool (ListAllInt guess))
(define-fun C3 () Bool (= (Length game) (Length guess)))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 6: satisfied_assert_0;assert_2, violated_assert_1;assert_3
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True, 'assert_3': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2'], 'violated_contracts': ['assert_1', 'assert_3'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'guess': [], 'game': [3.0]}
    Solution 2:
      test_case: {'game': [4.0], 'guess': []}
    Solution 3:
      test_case: {'game': [5.0], 'guess': []}
    Solution 4:
      test_case: {'game': [6.0], 'guess': []}
    Solution 5:
      test_case: {'game': [7.0], 'guess': []}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool (or (is-Nil v) (and (is-Cons v) (IsList (tail v)))))
(define-fun-rec ListAllInt ((v Value)) Bool (or (is-Nil v) (and (is-Cons v) (is-IntVal (head v)) (ListAllInt (tail v)))))
(define-fun-rec Length ((v Value)) Int (ite (is-Nil v) 0 (ite (is-Cons v) (+ 1 (Length (tail v))) 0)))

; === Inputs ===
(declare-const game Value)
(declare-const guess Value)

; === BASIC STRUCTURE ===
(assert (and (IsList game) (IsList guess)))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList game) (IsList guess)))
(define-fun C1 () Bool (ListAllInt game))
(define-fun C2 () Bool (ListAllInt guess))
(define-fun C3 () Bool (= (Length game) (Length guess)))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 7: satisfied_assert_1;assert_2, violated_assert_0;assert_3
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True, 'assert_3': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2'], 'violated_contracts': ['assert_0', 'assert_3'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool (or (is-Nil v) (and (is-Cons v) (IsList (tail v)))))
(define-fun-rec ListAllInt ((v Value)) Bool (or (is-Nil v) (and (is-Cons v) (is-IntVal (head v)) (ListAllInt (tail v)))))
(define-fun-rec Length ((v Value)) Int (ite (is-Nil v) 0 (ite (is-Cons v) (+ 1 (Length (tail v))) 0)))

; === Inputs ===
(declare-const game Value)
(declare-const guess Value)

; === BASIC STRUCTURE ===
(assert (and (IsList game) (IsList guess)))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList game) (IsList guess)))
(define-fun C1 () Bool (ListAllInt game))
(define-fun C2 () Bool (ListAllInt guess))
(define-fun C3 () Bool (= (Length game) (Length guess)))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 8: satisfied_assert_0;assert_1;assert_2, violated_assert_3
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True, 'assert_3': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2'], 'violated_contracts': ['assert_3'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'guess': [], 'game': [2]}
    Solution 2:
      test_case: {'game': [3], 'guess': []}
    Solution 3:
      test_case: {'game': [4], 'guess': []}
    Solution 4:
      test_case: {'game': [5], 'guess': []}
    Solution 5:
      test_case: {'game': [6], 'guess': []}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool (or (is-Nil v) (and (is-Cons v) (IsList (tail v)))))
(define-fun-rec ListAllInt ((v Value)) Bool (or (is-Nil v) (and (is-Cons v) (is-IntVal (head v)) (ListAllInt (tail v)))))
(define-fun-rec Length ((v Value)) Int (ite (is-Nil v) 0 (ite (is-Cons v) (+ 1 (Length (tail v))) 0)))

; === Inputs ===
(declare-const game Value)
(declare-const guess Value)

; === BASIC STRUCTURE ===
(assert (and (IsList game) (IsList guess)))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList game) (IsList guess)))
(define-fun C1 () Bool (ListAllInt game))
(define-fun C2 () Bool (ListAllInt guess))
(define-fun C3 () Bool (= (Length game) (Length guess)))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 9: satisfied_assert_3, violated_assert_0;assert_1;assert_2
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False, 'assert_3': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_3'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool (or (is-Nil v) (and (is-Cons v) (IsList (tail v)))))
(define-fun-rec ListAllInt ((v Value)) Bool (or (is-Nil v) (and (is-Cons v) (is-IntVal (head v)) (ListAllInt (tail v)))))
(define-fun-rec Length ((v Value)) Int (ite (is-Nil v) 0 (ite (is-Cons v) (+ 1 (Length (tail v))) 0)))

; === Inputs ===
(declare-const game Value)
(declare-const guess Value)

; === BASIC STRUCTURE ===
(assert (and (IsList game) (IsList guess)))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList game) (IsList guess)))
(define-fun C1 () Bool (ListAllInt game))
(define-fun C2 () Bool (ListAllInt guess))
(define-fun C3 () Bool (= (Length game) (Length guess)))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 10: satisfied_assert_0;assert_3, violated_assert_1;assert_2
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False, 'assert_3': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_3'], 'violated_contracts': ['assert_1', 'assert_2'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'guess': [2.0], 'game': [3.0]}
    Solution 2:
      test_case: {'game': [6.0], 'guess': [4.0]}
    Solution 3:
      test_case: {'game': [5.0], 'guess': [7.0]}
    Solution 4:
      test_case: {'game': [8.0], 'guess': [9.0]}
    Solution 5:
      test_case: {'game': [11.0], 'guess': [10.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool (or (is-Nil v) (and (is-Cons v) (IsList (tail v)))))
(define-fun-rec ListAllInt ((v Value)) Bool (or (is-Nil v) (and (is-Cons v) (is-IntVal (head v)) (ListAllInt (tail v)))))
(define-fun-rec Length ((v Value)) Int (ite (is-Nil v) 0 (ite (is-Cons v) (+ 1 (Length (tail v))) 0)))

; === Inputs ===
(declare-const game Value)
(declare-const guess Value)

; === BASIC STRUCTURE ===
(assert (and (IsList game) (IsList guess)))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList game) (IsList guess)))
(define-fun C1 () Bool (ListAllInt game))
(define-fun C2 () Bool (ListAllInt guess))
(define-fun C3 () Bool (= (Length game) (Length guess)))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 11: satisfied_assert_1;assert_3, violated_assert_0;assert_2
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False, 'assert_3': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_3'], 'violated_contracts': ['assert_0', 'assert_2'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool (or (is-Nil v) (and (is-Cons v) (IsList (tail v)))))
(define-fun-rec ListAllInt ((v Value)) Bool (or (is-Nil v) (and (is-Cons v) (is-IntVal (head v)) (ListAllInt (tail v)))))
(define-fun-rec Length ((v Value)) Int (ite (is-Nil v) 0 (ite (is-Cons v) (+ 1 (Length (tail v))) 0)))

; === Inputs ===
(declare-const game Value)
(declare-const guess Value)

; === BASIC STRUCTURE ===
(assert (and (IsList game) (IsList guess)))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList game) (IsList guess)))
(define-fun C1 () Bool (ListAllInt game))
(define-fun C2 () Bool (ListAllInt guess))
(define-fun C3 () Bool (= (Length game) (Length guess)))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 12: satisfied_assert_0;assert_1;assert_3, violated_assert_2
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False, 'assert_3': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_3'], 'violated_contracts': ['assert_2'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'guess': [3.0], 'game': [2]}
    Solution 2:
      test_case: {'game': [3], 'guess': [4.0]}
    Solution 3:
      test_case: {'game': [4], 'guess': [5.0]}
    Solution 4:
      test_case: {'game': [5], 'guess': [6.0]}
    Solution 5:
      test_case: {'game': [6], 'guess': [7.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool (or (is-Nil v) (and (is-Cons v) (IsList (tail v)))))
(define-fun-rec ListAllInt ((v Value)) Bool (or (is-Nil v) (and (is-Cons v) (is-IntVal (head v)) (ListAllInt (tail v)))))
(define-fun-rec Length ((v Value)) Int (ite (is-Nil v) 0 (ite (is-Cons v) (+ 1 (Length (tail v))) 0)))

; === Inputs ===
(declare-const game Value)
(declare-const guess Value)

; === BASIC STRUCTURE ===
(assert (and (IsList game) (IsList guess)))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList game) (IsList guess)))
(define-fun C1 () Bool (ListAllInt game))
(define-fun C2 () Bool (ListAllInt guess))
(define-fun C3 () Bool (= (Length game) (Length guess)))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 13: satisfied_assert_2;assert_3, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True, 'assert_3': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_2', 'assert_3'], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool (or (is-Nil v) (and (is-Cons v) (IsList (tail v)))))
(define-fun-rec ListAllInt ((v Value)) Bool (or (is-Nil v) (and (is-Cons v) (is-IntVal (head v)) (ListAllInt (tail v)))))
(define-fun-rec Length ((v Value)) Int (ite (is-Nil v) 0 (ite (is-Cons v) (+ 1 (Length (tail v))) 0)))

; === Inputs ===
(declare-const game Value)
(declare-const guess Value)

; === BASIC STRUCTURE ===
(assert (and (IsList game) (IsList guess)))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList game) (IsList guess)))
(define-fun C1 () Bool (ListAllInt game))
(define-fun C2 () Bool (ListAllInt guess))
(define-fun C3 () Bool (= (Length game) (Length guess)))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 14: satisfied_assert_0;assert_2;assert_3, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True, 'assert_3': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2', 'assert_3'], 'violated_contracts': ['assert_1'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'guess': [7], 'game': [2.0]}
    Solution 2:
      test_case: {'game': [5.0], 'guess': [2]}
    Solution 3:
      test_case: {'game': [4.0], 'guess': [3]}
    Solution 4:
      test_case: {'game': [6.0], 'guess': [4]}
    Solution 5:
      test_case: {'game': [7.0], 'guess': [5]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool (or (is-Nil v) (and (is-Cons v) (IsList (tail v)))))
(define-fun-rec ListAllInt ((v Value)) Bool (or (is-Nil v) (and (is-Cons v) (is-IntVal (head v)) (ListAllInt (tail v)))))
(define-fun-rec Length ((v Value)) Int (ite (is-Nil v) 0 (ite (is-Cons v) (+ 1 (Length (tail v))) 0)))

; === Inputs ===
(declare-const game Value)
(declare-const guess Value)

; === BASIC STRUCTURE ===
(assert (and (IsList game) (IsList guess)))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList game) (IsList guess)))
(define-fun C1 () Bool (ListAllInt game))
(define-fun C2 () Bool (ListAllInt guess))
(define-fun C3 () Bool (= (Length game) (Length guess)))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 15: satisfied_assert_1;assert_2;assert_3, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True, 'assert_3': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2', 'assert_3'], 'violated_contracts': ['assert_0'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool (or (is-Nil v) (and (is-Cons v) (IsList (tail v)))))
(define-fun-rec ListAllInt ((v Value)) Bool (or (is-Nil v) (and (is-Cons v) (is-IntVal (head v)) (ListAllInt (tail v)))))
(define-fun-rec Length ((v Value)) Int (ite (is-Nil v) 0 (ite (is-Cons v) (+ 1 (Length (tail v))) 0)))

; === Inputs ===
(declare-const game Value)
(declare-const guess Value)

; === BASIC STRUCTURE ===
(assert (and (IsList game) (IsList guess)))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList game) (IsList guess)))
(define-fun C1 () Bool (ListAllInt game))
(define-fun C2 () Bool (ListAllInt guess))
(define-fun C3 () Bool (= (Length game) (Length guess)))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 16: satisfied_assert_0;assert_1;assert_2;assert_3, violated_
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True, 'assert_3': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_3'], 'violated_contracts': [], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'guess': [], 'game': []}
    Solution 2:
      test_case: {'game': [3], 'guess': [2]}
    Solution 3:
      test_case: {'game': [5], 'guess': [4]}
    Solution 4:
      test_case: {'game': [7], 'guess': [6]}
    Solution 5:
      test_case: {'game': [9], 'guess': [8]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool (or (is-Nil v) (and (is-Cons v) (IsList (tail v)))))
(define-fun-rec ListAllInt ((v Value)) Bool (or (is-Nil v) (and (is-Cons v) (is-IntVal (head v)) (ListAllInt (tail v)))))
(define-fun-rec Length ((v Value)) Int (ite (is-Nil v) 0 (ite (is-Cons v) (+ 1 (Length (tail v))) 0)))

; === Inputs ===
(declare-const game Value)
(declare-const guess Value)

; === BASIC STRUCTURE ===
(assert (and (IsList game) (IsList guess)))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList game) (IsList guess)))
(define-fun C1 () Bool (ListAllInt game))
(define-fun C2 () Bool (ListAllInt guess))
(define-fun C3 () Bool (= (Length game) (Length guess)))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)
(assert C3)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/153 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1;assert_2;assert_3
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False, 'assert_3': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_3'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'class_name': 2.0, 'extensions': 3.0}
    Solution 2:
      test_case: {'extensions': 4.0, 'class_name': 5.0}
    Solution 3:
      test_case: {'extensions': 6.0, 'class_name': 7.0}
    Solution 4:
      test_case: {'extensions': 8.0, 'class_name': 9.0}
    Solution 5:
      test_case: {'class_name': 11.0, 'extensions': 10.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_str ((lst Value)) Bool
  (ite (is-Nil lst)
       true
       (ite (is-Cons lst)
            (and (is-StrVal (head lst))
                 (list_all_str (tail lst)))
            false)))

; === Inputs ===
(declare-const class_name Value)
(declare-const extensions Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal class_name))
(define-fun C1 () Bool (IsList extensions))
(define-fun C2 () Bool (list_all_str extensions))
(define-fun C3 () Bool (is-Cons extensions))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1;assert_2;assert_3
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False, 'assert_3': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1', 'assert_2', 'assert_3'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'class_name': '!0!', 'extensions': 2.0}
    Solution 2:
      test_case: {'extensions': 3.0, 'class_name': '!'}
    Solution 3:
      test_case: {'extensions': 4.0, 'class_name': '0'}
    Solution 4:
      test_case: {'extensions': 5.0, 'class_name': '0!'}
    Solution 5:
      test_case: {'extensions': 6.0, 'class_name': ''}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_str ((lst Value)) Bool
  (ite (is-Nil lst)
       true
       (ite (is-Cons lst)
            (and (is-StrVal (head lst))
                 (list_all_str (tail lst)))
            false)))

; === Inputs ===
(declare-const class_name Value)
(declare-const extensions Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal class_name))
(define-fun C1 () Bool (IsList extensions))
(define-fun C2 () Bool (list_all_str extensions))
(define-fun C3 () Bool (is-Cons extensions))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0;assert_2;assert_3
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False, 'assert_3': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0', 'assert_2', 'assert_3'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_str ((lst Value)) Bool
  (ite (is-Nil lst)
       true
       (ite (is-Cons lst)
            (and (is-StrVal (head lst))
                 (list_all_str (tail lst)))
            false)))

; === Inputs ===
(declare-const class_name Value)
(declare-const extensions Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal class_name))
(define-fun C1 () Bool (IsList extensions))
(define-fun C2 () Bool (list_all_str extensions))
(define-fun C3 () Bool (is-Cons extensions))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_assert_2;assert_3
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False, 'assert_3': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': ['assert_2', 'assert_3'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_str ((lst Value)) Bool
  (ite (is-Nil lst)
       true
       (ite (is-Cons lst)
            (and (is-StrVal (head lst))
                 (list_all_str (tail lst)))
            false)))

; === Inputs ===
(declare-const class_name Value)
(declare-const extensions Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal class_name))
(define-fun C1 () Bool (IsList extensions))
(define-fun C2 () Bool (list_all_str extensions))
(define-fun C3 () Bool (is-Cons extensions))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 5: satisfied_assert_2, violated_assert_0;assert_1;assert_3
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True, 'assert_3': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_2'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_3'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_str ((lst Value)) Bool
  (ite (is-Nil lst)
       true
       (ite (is-Cons lst)
            (and (is-StrVal (head lst))
                 (list_all_str (tail lst)))
            false)))

; === Inputs ===
(declare-const class_name Value)
(declare-const extensions Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal class_name))
(define-fun C1 () Bool (IsList extensions))
(define-fun C2 () Bool (list_all_str extensions))
(define-fun C3 () Bool (is-Cons extensions))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 6: satisfied_assert_0;assert_2, violated_assert_1;assert_3
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True, 'assert_3': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2'], 'violated_contracts': ['assert_1', 'assert_3'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_str ((lst Value)) Bool
  (ite (is-Nil lst)
       true
       (ite (is-Cons lst)
            (and (is-StrVal (head lst))
                 (list_all_str (tail lst)))
            false)))

; === Inputs ===
(declare-const class_name Value)
(declare-const extensions Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal class_name))
(define-fun C1 () Bool (IsList extensions))
(define-fun C2 () Bool (list_all_str extensions))
(define-fun C3 () Bool (is-Cons extensions))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 7: satisfied_assert_1;assert_2, violated_assert_0;assert_3
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True, 'assert_3': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2'], 'violated_contracts': ['assert_0', 'assert_3'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'class_name': 2.0, 'extensions': []}
    Solution 2:
      test_case: {'extensions': [], 'class_name': 3.0}
    Solution 3:
      test_case: {'class_name': 4.0, 'extensions': []}
    Solution 4:
      test_case: {'extensions': [], 'class_name': 5.0}
    Solution 5:
      test_case: {'extensions': [], 'class_name': 6.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_str ((lst Value)) Bool
  (ite (is-Nil lst)
       true
       (ite (is-Cons lst)
            (and (is-StrVal (head lst))
                 (list_all_str (tail lst)))
            false)))

; === Inputs ===
(declare-const class_name Value)
(declare-const extensions Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal class_name))
(define-fun C1 () Bool (IsList extensions))
(define-fun C2 () Bool (list_all_str extensions))
(define-fun C3 () Bool (is-Cons extensions))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 8: satisfied_assert_0;assert_1;assert_2, violated_assert_3
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True, 'assert_3': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2'], 'violated_contracts': ['assert_3'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'class_name': '!0!', 'extensions': []}
    Solution 2:
      test_case: {'extensions': [], 'class_name': '!'}
    Solution 3:
      test_case: {'extensions': [], 'class_name': '0'}
    Solution 4:
      test_case: {'class_name': '0!', 'extensions': []}
    Solution 5:
      test_case: {'extensions': [], 'class_name': ''}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_str ((lst Value)) Bool
  (ite (is-Nil lst)
       true
       (ite (is-Cons lst)
            (and (is-StrVal (head lst))
                 (list_all_str (tail lst)))
            false)))

; === Inputs ===
(declare-const class_name Value)
(declare-const extensions Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal class_name))
(define-fun C1 () Bool (IsList extensions))
(define-fun C2 () Bool (list_all_str extensions))
(define-fun C3 () Bool (is-Cons extensions))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 9: satisfied_assert_3, violated_assert_0;assert_1;assert_2
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False, 'assert_3': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_3'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'class_name': 4.0, 'extensions': [2.0, 3.0]}
    Solution 2:
      test_case: {'extensions': [6.0, 7.0], 'class_name': 5.0}
    Solution 3:
      test_case: {'extensions': [9.0, 10.0], 'class_name': 8.0}
    Solution 4:
      test_case: {'extensions': [12.0, 13.0], 'class_name': 11.0}
    Solution 5:
      test_case: {'extensions': [15.0, 16.0], 'class_name': 14.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_str ((lst Value)) Bool
  (ite (is-Nil lst)
       true
       (ite (is-Cons lst)
            (and (is-StrVal (head lst))
                 (list_all_str (tail lst)))
            false)))

; === Inputs ===
(declare-const class_name Value)
(declare-const extensions Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal class_name))
(define-fun C1 () Bool (IsList extensions))
(define-fun C2 () Bool (list_all_str extensions))
(define-fun C3 () Bool (is-Cons extensions))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 10: satisfied_assert_0;assert_3, violated_assert_1;assert_2
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False, 'assert_3': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_3'], 'violated_contracts': ['assert_1', 'assert_2'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'class_name': '!0!', 'extensions': [3.0, 2.0]}
    Solution 2:
      test_case: {'extensions': [4.0, 5.0], 'class_name': '!'}
    Solution 3:
      test_case: {'extensions': [6.0, 7.0], 'class_name': '0'}
    Solution 4:
      test_case: {'extensions': [8.0, 9.0], 'class_name': '0!'}
    Solution 5:
      test_case: {'extensions': [11.0, 10.0], 'class_name': 'A'}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_str ((lst Value)) Bool
  (ite (is-Nil lst)
       true
       (ite (is-Cons lst)
            (and (is-StrVal (head lst))
                 (list_all_str (tail lst)))
            false)))

; === Inputs ===
(declare-const class_name Value)
(declare-const extensions Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal class_name))
(define-fun C1 () Bool (IsList extensions))
(define-fun C2 () Bool (list_all_str extensions))
(define-fun C3 () Bool (is-Cons extensions))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 11: satisfied_assert_1;assert_3, violated_assert_0;assert_2
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False, 'assert_3': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_3'], 'violated_contracts': ['assert_0', 'assert_2'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'class_name': 2.0, 'extensions': [3.0]}
    Solution 2:
      test_case: {'extensions': [5.0], 'class_name': 4.0}
    Solution 3:
      test_case: {'extensions': [7.0], 'class_name': 6.0}
    Solution 4:
      test_case: {'extensions': [8.0], 'class_name': 9.0}
    Solution 5:
      test_case: {'extensions': [10.0], 'class_name': 11.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_str ((lst Value)) Bool
  (ite (is-Nil lst)
       true
       (ite (is-Cons lst)
            (and (is-StrVal (head lst))
                 (list_all_str (tail lst)))
            false)))

; === Inputs ===
(declare-const class_name Value)
(declare-const extensions Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal class_name))
(define-fun C1 () Bool (IsList extensions))
(define-fun C2 () Bool (list_all_str extensions))
(define-fun C3 () Bool (is-Cons extensions))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 12: satisfied_assert_0;assert_1;assert_3, violated_assert_2
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False, 'assert_3': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_3'], 'violated_contracts': ['assert_2'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'class_name': '!0!', 'extensions': [2.0]}
    Solution 2:
      test_case: {'extensions': [3.0], 'class_name': '!'}
    Solution 3:
      test_case: {'extensions': [4.0], 'class_name': '0'}
    Solution 4:
      test_case: {'extensions': [5.0], 'class_name': '0!'}
    Solution 5:
      test_case: {'extensions': [6.0], 'class_name': ''}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_str ((lst Value)) Bool
  (ite (is-Nil lst)
       true
       (ite (is-Cons lst)
            (and (is-StrVal (head lst))
                 (list_all_str (tail lst)))
            false)))

; === Inputs ===
(declare-const class_name Value)
(declare-const extensions Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal class_name))
(define-fun C1 () Bool (IsList extensions))
(define-fun C2 () Bool (list_all_str extensions))
(define-fun C3 () Bool (is-Cons extensions))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 13: satisfied_assert_2;assert_3, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True, 'assert_3': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_2', 'assert_3'], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_str ((lst Value)) Bool
  (ite (is-Nil lst)
       true
       (ite (is-Cons lst)
            (and (is-StrVal (head lst))
                 (list_all_str (tail lst)))
            false)))

; === Inputs ===
(declare-const class_name Value)
(declare-const extensions Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal class_name))
(define-fun C1 () Bool (IsList extensions))
(define-fun C2 () Bool (list_all_str extensions))
(define-fun C3 () Bool (is-Cons extensions))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 14: satisfied_assert_0;assert_2;assert_3, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True, 'assert_3': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2', 'assert_3'], 'violated_contracts': ['assert_1'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_str ((lst Value)) Bool
  (ite (is-Nil lst)
       true
       (ite (is-Cons lst)
            (and (is-StrVal (head lst))
                 (list_all_str (tail lst)))
            false)))

; === Inputs ===
(declare-const class_name Value)
(declare-const extensions Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal class_name))
(define-fun C1 () Bool (IsList extensions))
(define-fun C2 () Bool (list_all_str extensions))
(define-fun C3 () Bool (is-Cons extensions))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 15: satisfied_assert_1;assert_2;assert_3, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True, 'assert_3': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2', 'assert_3'], 'violated_contracts': ['assert_0'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'class_name': 2.0, 'extensions': ['!0!']}
    Solution 2:
      test_case: {'extensions': ['!'], 'class_name': 3.0}
    Solution 3:
      test_case: {'extensions': ['0'], 'class_name': 4.0}
    Solution 4:
      test_case: {'extensions': ['0!'], 'class_name': 5.0}
    Solution 5:
      test_case: {'extensions': ['A'], 'class_name': 6.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_str ((lst Value)) Bool
  (ite (is-Nil lst)
       true
       (ite (is-Cons lst)
            (and (is-StrVal (head lst))
                 (list_all_str (tail lst)))
            false)))

; === Inputs ===
(declare-const class_name Value)
(declare-const extensions Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal class_name))
(define-fun C1 () Bool (IsList extensions))
(define-fun C2 () Bool (list_all_str extensions))
(define-fun C3 () Bool (is-Cons extensions))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 16: satisfied_assert_0;assert_1;assert_2;assert_3, violated_
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True, 'assert_3': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_3'], 'violated_contracts': [], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'class_name': '!0!', 'extensions': ['!0!']}
    Solution 2:
      test_case: {'extensions': ['0'], 'class_name': '!'}
    Solution 3:
      test_case: {'extensions': ['0!'], 'class_name': '0!'}
    Solution 4:
      test_case: {'extensions': ['!'], 'class_name': '0'}
    Solution 5:
      test_case: {'extensions': [''], 'class_name': 'A'}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((v Value)) Bool
  (ite (is-Nil v)
       true
       (ite (is-Cons v)
            (IsList (tail v))
            false)))

(define-fun-rec list_all_str ((lst Value)) Bool
  (ite (is-Nil lst)
       true
       (ite (is-Cons lst)
            (and (is-StrVal (head lst))
                 (list_all_str (tail lst)))
            false)))

; === Inputs ===
(declare-const class_name Value)
(declare-const extensions Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal class_name))
(define-fun C1 () Bool (IsList extensions))
(define-fun C2 () Bool (list_all_str extensions))
(define-fun C3 () Bool (is-Cons extensions))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)
(assert C3)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/154 ===
  Test Case 1: satisfied_, violated_assert_0
  Combination: {'assert_0': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0'], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'b': 2.0, 'a': 3.0}
    Solution 2:
      test_case: {'b': 5.0, 'a': 4.0}
    Solution 3:
      test_case: {'b': 7.0, 'a': 6.0}
    Solution 4:
      test_case: {'b': 8.0, 'a': 9.0}
    Solution 5:
      test_case: {'b': 10.0, 'a': 11.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const a Value)
(declare-const b Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (is-StrVal a) (is-StrVal b)))

; === COMBINATION ===
(assert (not C0))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_
  Combination: {'assert_0': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': [], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'b': '!0!', 'a': '!0!'}
    Solution 2:
      test_case: {'b': '0', 'a': '!'}
    Solution 3:
      test_case: {'b': '0!', 'a': '0!'}
    Solution 4:
      test_case: {'b': '!', 'a': ''}
    Solution 5:
      test_case: {'b': 'A', 'a': ''}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const a Value)
(declare-const b Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (is-StrVal a) (is-StrVal b)))

; === COMBINATION ===
(assert C0)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/155 ===
  Test Case 1: satisfied_, violated_assert_0
  Combination: {'assert_0': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0'], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'num': 2.0}
    Solution 2:
      test_case: {'num': 3.0}
    Solution 3:
      test_case: {'num': 4.0}
    Solution 4:
      test_case: {'num': 5.0}
    Solution 5:
      test_case: {'num': 6.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const num Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal num))

; === COMBINATION ===
(assert (not C0))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_
  Combination: {'assert_0': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': [], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'num': 2}
    Solution 2:
      test_case: {'num': 3}
    Solution 3:
      test_case: {'num': 4}
    Solution 4:
      test_case: {'num': 5}
    Solution 5:
      test_case: {'num': 6}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const num Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-IntVal num))

; === COMBINATION ===
(assert C0)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/156 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'number': 2.0}
    Solution 2:
      test_case: {'number': 3.0}
    Solution 3:
      test_case: {'number': 4.0}
    Solution 4:
      test_case: {'number': 5.0}
    Solution 5:
      test_case: {'number': 6.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun safe-ival ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const number Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool
  (is-IntVal number))
(define-fun C1 () Bool
  (and (<= 1 (safe-ival number))
       (<= (safe-ival number) 1000)))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'number': 1001}
    Solution 2:
      test_case: {'number': 0}
    Solution 3:
      test_case: {'number': -2437}
    Solution 4:
      test_case: {'number': -10802}
    Solution 5:
      test_case: {'number': -41414}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun safe-ival ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const number Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool
  (is-IntVal number))
(define-fun C1 () Bool
  (and (<= 1 (safe-ival number))
       (<= (safe-ival number) 1000)))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun safe-ival ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const number Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool
  (is-IntVal number))
(define-fun C1 () Bool
  (and (<= 1 (safe-ival number))
       (<= (safe-ival number) 1000)))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'number': 1}
    Solution 2:
      test_case: {'number': 720}
    Solution 3:
      test_case: {'number': 438}
    Solution 4:
      test_case: {'number': 798}
    Solution 5:
      test_case: {'number': 286}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun safe-ival ((v Value)) Int
  (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const number Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool
  (is-IntVal number))
(define-fun C1 () Bool
  (and (<= 1 (safe-ival number))
       (<= (safe-ival number) 1000)))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/157 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'b': '!0!', 'c': 0, 'a': 0}
    Solution 2:
      test_case: {'c': -1, 'b': 0, 'a': '!'}
    Solution 3:
      test_case: {'c': -28101, 'b': 5853, 'a': '0'}
    Solution 4:
      test_case: {'c': -28101, 'b': 21774, 'a': '0!'}
    Solution 5:
      test_case: {'c': -28101, 'b': 21774, 'a': '!0!'}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun getNum ((v Value)) Real (ite (is-IntVal v) (to_real (ival v)) (fval v)))
(define-fun square ((x Real)) Real (* x x))

; === Inputs ===
(declare-const a Value)
(declare-const b Value)
(declare-const c Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (or (is-IntVal a) (is-FloatVal a)) (or (is-IntVal b) (is-FloatVal b)) (or (is-IntVal c) (is-FloatVal c))))
(define-fun C1 () Bool (let ((na (getNum a)) (nb (getNum b)) (nc (getNum c))) (and (> na 0.0) (> nb 0.0) (> nc 0.0))))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'b': 0, 'c': 0, 'a': 0}
    Solution 2:
      test_case: {'c': 28100, 'b': 1, 'a': -1}
    Solution 3:
      test_case: {'c': 28100, 'b': -26286, 'a': -1}
    Solution 4:
      test_case: {'c': 28100, 'b': -26286, 'a': -2}
    Solution 5:
      test_case: {'c': 30546, 'b': -26286, 'a': -2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun getNum ((v Value)) Real (ite (is-IntVal v) (to_real (ival v)) (fval v)))
(define-fun square ((x Real)) Real (* x x))

; === Inputs ===
(declare-const a Value)
(declare-const b Value)
(declare-const c Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (or (is-IntVal a) (is-FloatVal a)) (or (is-IntVal b) (is-FloatVal b)) (or (is-IntVal c) (is-FloatVal c))))
(define-fun C1 () Bool (let ((na (getNum a)) (nb (getNum b)) (nc (getNum c))) (and (> na 0.0) (> nb 0.0) (> nc 0.0))))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'b': '!0!', 'c': 282, 'a': 1}
    Solution 2:
      test_case: {'c': 20538, 'b': 282, 'a': '!'}
    Solution 3:
      test_case: {'c': 41514, 'b': '0', 'a': '0!'}
    Solution 4:
      test_case: {'c': 41514, 'b': '!', 'a': '!0!'}
    Solution 5:
      test_case: {'c': 41514, 'b': False, 'a': '0'}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun getNum ((v Value)) Real (ite (is-IntVal v) (to_real (ival v)) (fval v)))
(define-fun square ((x Real)) Real (* x x))

; === Inputs ===
(declare-const a Value)
(declare-const b Value)
(declare-const c Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (or (is-IntVal a) (is-FloatVal a)) (or (is-IntVal b) (is-FloatVal b)) (or (is-IntVal c) (is-FloatVal c))))
(define-fun C1 () Bool (let ((na (getNum a)) (nb (getNum b)) (nc (getNum c))) (and (> na 0.0) (> nb 0.0) (> nc 0.0))))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'b': 20977, 'c': 31892, 'a': 1}
    Solution 2:
      test_case: {'c': 31892, 'b': 20976, 'a': 1}
    Solution 3:
      test_case: {'c': 31892, 'b': 18588, 'a': 1.5}
    Solution 4:
      test_case: {'c': 31891, 'b': 18588, 'a': 1.25}
    Solution 5:
      test_case: {'c': 31893, 'b': 18588, 'a': 1.125}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun getNum ((v Value)) Real (ite (is-IntVal v) (to_real (ival v)) (fval v)))
(define-fun square ((x Real)) Real (* x x))

; === Inputs ===
(declare-const a Value)
(declare-const b Value)
(declare-const c Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (or (is-IntVal a) (is-FloatVal a)) (or (is-IntVal b) (is-FloatVal b)) (or (is-IntVal c) (is-FloatVal c))))
(define-fun C1 () Bool (let ((na (getNum a)) (nb (getNum b)) (nc (getNum c))) (and (> na 0.0) (> nb 0.0) (> nc 0.0))))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/158 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1;assert_2
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2'], 'total_contracts': 3}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (IsList (tail l))
            false)))

(define-fun-rec list_all_str ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (and (is-StrVal (head l))
                 (list_all_str (tail l)))
            false)))

(define-fun-rec list_length ((l Value)) Int
  (ite (is-Nil l)
       0
       (ite (is-Cons l)
            (+ 1 (list_length (tail l)))
            0)))

; === Inputs ===
(declare-const words Value)

; === BASIC STRUCTURE ===
(assert (IsList words))

; === Contract predicates ===
(define-fun C0 () Bool (IsList words))
(define-fun C1 () Bool (list_all_str words))
(define-fun C2 () Bool (> (list_length words) 0))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1;assert_2
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1', 'assert_2'], 'total_contracts': 3}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (IsList (tail l))
            false)))

(define-fun-rec list_all_str ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (and (is-StrVal (head l))
                 (list_all_str (tail l)))
            false)))

(define-fun-rec list_length ((l Value)) Int
  (ite (is-Nil l)
       0
       (ite (is-Cons l)
            (+ 1 (list_length (tail l)))
            0)))

; === Inputs ===
(declare-const words Value)

; === BASIC STRUCTURE ===
(assert (IsList words))

; === Contract predicates ===
(define-fun C0 () Bool (IsList words))
(define-fun C1 () Bool (list_all_str words))
(define-fun C2 () Bool (> (list_length words) 0))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0;assert_2
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0', 'assert_2'], 'total_contracts': 3}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (IsList (tail l))
            false)))

(define-fun-rec list_all_str ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (and (is-StrVal (head l))
                 (list_all_str (tail l)))
            false)))

(define-fun-rec list_length ((l Value)) Int
  (ite (is-Nil l)
       0
       (ite (is-Cons l)
            (+ 1 (list_length (tail l)))
            0)))

; === Inputs ===
(declare-const words Value)

; === BASIC STRUCTURE ===
(assert (IsList words))

; === Contract predicates ===
(define-fun C0 () Bool (IsList words))
(define-fun C1 () Bool (list_all_str words))
(define-fun C2 () Bool (> (list_length words) 0))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_assert_2
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False}
  Satisfiable: True
  Solution Count: 1
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': ['assert_2'], 'total_contracts': 3}
  Solutions:
    Solution 1:
      test_case: {'words': []}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (IsList (tail l))
            false)))

(define-fun-rec list_all_str ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (and (is-StrVal (head l))
                 (list_all_str (tail l)))
            false)))

(define-fun-rec list_length ((l Value)) Int
  (ite (is-Nil l)
       0
       (ite (is-Cons l)
            (+ 1 (list_length (tail l)))
            0)))

; === Inputs ===
(declare-const words Value)

; === BASIC STRUCTURE ===
(assert (IsList words))

; === Contract predicates ===
(define-fun C0 () Bool (IsList words))
(define-fun C1 () Bool (list_all_str words))
(define-fun C2 () Bool (> (list_length words) 0))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))

(check-sat)
(get-model)

------------------------------
  Test Case 5: satisfied_assert_2, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_2'], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 3}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (IsList (tail l))
            false)))

(define-fun-rec list_all_str ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (and (is-StrVal (head l))
                 (list_all_str (tail l)))
            false)))

(define-fun-rec list_length ((l Value)) Int
  (ite (is-Nil l)
       0
       (ite (is-Cons l)
            (+ 1 (list_length (tail l)))
            0)))

; === Inputs ===
(declare-const words Value)

; === BASIC STRUCTURE ===
(assert (IsList words))

; === Contract predicates ===
(define-fun C0 () Bool (IsList words))
(define-fun C1 () Bool (list_all_str words))
(define-fun C2 () Bool (> (list_length words) 0))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)

(check-sat)
(get-model)

------------------------------
  Test Case 6: satisfied_assert_0;assert_2, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2'], 'violated_contracts': ['assert_1'], 'total_contracts': 3}
  Solutions:
    Solution 1:
      test_case: {'words': [2.0]}
    Solution 2:
      test_case: {'words': [3.0]}
    Solution 3:
      test_case: {'words': [4.0]}
    Solution 4:
      test_case: {'words': [5.0]}
    Solution 5:
      test_case: {'words': [6.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (IsList (tail l))
            false)))

(define-fun-rec list_all_str ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (and (is-StrVal (head l))
                 (list_all_str (tail l)))
            false)))

(define-fun-rec list_length ((l Value)) Int
  (ite (is-Nil l)
       0
       (ite (is-Cons l)
            (+ 1 (list_length (tail l)))
            0)))

; === Inputs ===
(declare-const words Value)

; === BASIC STRUCTURE ===
(assert (IsList words))

; === Contract predicates ===
(define-fun C0 () Bool (IsList words))
(define-fun C1 () Bool (list_all_str words))
(define-fun C2 () Bool (> (list_length words) 0))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)

(check-sat)
(get-model)

------------------------------
  Test Case 7: satisfied_assert_1;assert_2, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2'], 'violated_contracts': ['assert_0'], 'total_contracts': 3}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (IsList (tail l))
            false)))

(define-fun-rec list_all_str ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (and (is-StrVal (head l))
                 (list_all_str (tail l)))
            false)))

(define-fun-rec list_length ((l Value)) Int
  (ite (is-Nil l)
       0
       (ite (is-Cons l)
            (+ 1 (list_length (tail l)))
            0)))

; === Inputs ===
(declare-const words Value)

; === BASIC STRUCTURE ===
(assert (IsList words))

; === Contract predicates ===
(define-fun C0 () Bool (IsList words))
(define-fun C1 () Bool (list_all_str words))
(define-fun C2 () Bool (> (list_length words) 0))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)

(check-sat)
(get-model)

------------------------------
  Test Case 8: satisfied_assert_0;assert_1;assert_2, violated_
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2'], 'violated_contracts': [], 'total_contracts': 3}
  Solutions:
    Solution 1:
      test_case: {'words': ['!0!']}
    Solution 2:
      test_case: {'words': ['!']}
    Solution 3:
      test_case: {'words': ['0']}
    Solution 4:
      test_case: {'words': ['0!']}
    Solution 5:
      test_case: {'words': ['']}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (IsList (tail l))
            false)))

(define-fun-rec list_all_str ((l Value)) Bool
  (ite (is-Nil l)
       true
       (ite (is-Cons l)
            (and (is-StrVal (head l))
                 (list_all_str (tail l)))
            false)))

(define-fun-rec list_length ((l Value)) Int
  (ite (is-Nil l)
       0
       (ite (is-Cons l)
            (+ 1 (list_length (tail l)))
            0)))

; === Inputs ===
(declare-const words Value)

; === BASIC STRUCTURE ===
(assert (IsList words))

; === Contract predicates ===
(define-fun C0 () Bool (IsList words))
(define-fun C1 () Bool (list_all_str words))
(define-fun C2 () Bool (> (list_length words) 0))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/159 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1;assert_2;assert_3
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False, 'assert_3': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_3'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'need': 4.0, 'remaining': 3.0, 'number': 2.0}
    Solution 2:
      test_case: {'need': 5.0, 'number': 6.0, 'remaining': 7.0}
    Solution 3:
      test_case: {'need': 9.0, 'number': 8.0, 'remaining': 10.0}
    Solution 4:
      test_case: {'need': 12.0, 'number': 13.0, 'remaining': 11.0}
    Solution 5:
      test_case: {'need': 14.0, 'number': 16.0, 'remaining': 15.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const number Value)
(declare-const need Value)
(declare-const remaining Value)

; === BASIC STRUCTURE ===
(assert true)

; === Contract predicates ===
(define-fun C0 () Bool (and (is-IntVal number) (is-IntVal need) (is-IntVal remaining)))
(define-fun C1 () Bool (ite (is-IntVal number) (and (<= 0 (ival number)) (<= (ival number) 1000)) false))
(define-fun C2 () Bool (ite (is-IntVal need) (and (<= 0 (ival need)) (<= (ival need) 1000)) false))
(define-fun C3 () Bool (ite (is-IntVal remaining) (and (<= 0 (ival remaining)) (<= (ival remaining) 1000)) false))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1;assert_2;assert_3
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False, 'assert_3': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1', 'assert_2', 'assert_3'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'need': 9856, 'remaining': -1, 'number': 1001}
    Solution 2:
      test_case: {'need': 12798, 'number': -1, 'remaining': 9856}
    Solution 3:
      test_case: {'need': 12798, 'number': -1, 'remaining': 15709}
    Solution 4:
      test_case: {'need': 12798, 'number': -1, 'remaining': 31630}
    Solution 5:
      test_case: {'need': 12798, 'number': -1, 'remaining': 52606}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const number Value)
(declare-const need Value)
(declare-const remaining Value)

; === BASIC STRUCTURE ===
(assert true)

; === Contract predicates ===
(define-fun C0 () Bool (and (is-IntVal number) (is-IntVal need) (is-IntVal remaining)))
(define-fun C1 () Bool (ite (is-IntVal number) (and (<= 0 (ival number)) (<= (ival number) 1000)) false))
(define-fun C2 () Bool (ite (is-IntVal need) (and (<= 0 (ival need)) (<= (ival need) 1000)) false))
(define-fun C3 () Bool (ite (is-IntVal remaining) (and (<= 0 (ival remaining)) (<= (ival remaining) 1000)) false))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0;assert_2;assert_3
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False, 'assert_3': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0', 'assert_2', 'assert_3'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'need': 2.0, 'remaining': 3.0, 'number': 0}
    Solution 2:
      test_case: {'need': 5.0, 'number': 435, 'remaining': 4.0}
    Solution 3:
      test_case: {'need': 6.0, 'number': 435, 'remaining': 7.0}
    Solution 4:
      test_case: {'need': 8.0, 'number': 435, 'remaining': 9.0}
    Solution 5:
      test_case: {'need': 10.0, 'number': 435, 'remaining': 11.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const number Value)
(declare-const need Value)
(declare-const remaining Value)

; === BASIC STRUCTURE ===
(assert true)

; === Contract predicates ===
(define-fun C0 () Bool (and (is-IntVal number) (is-IntVal need) (is-IntVal remaining)))
(define-fun C1 () Bool (ite (is-IntVal number) (and (<= 0 (ival number)) (<= (ival number) 1000)) false))
(define-fun C2 () Bool (ite (is-IntVal need) (and (<= 0 (ival need)) (<= (ival need) 1000)) false))
(define-fun C3 () Bool (ite (is-IntVal remaining) (and (<= 0 (ival remaining)) (<= (ival remaining) 1000)) false))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_assert_2;assert_3
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False, 'assert_3': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': ['assert_2', 'assert_3'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'need': 1001, 'remaining': 3438, 'number': 0}
    Solution 2:
      test_case: {'need': 1001, 'number': 435, 'remaining': -1}
    Solution 3:
      test_case: {'need': 1001, 'number': 435, 'remaining': -32286}
    Solution 4:
      test_case: {'need': 29101, 'number': 435, 'remaining': -32286}
    Solution 5:
      test_case: {'need': 45022, 'number': 435, 'remaining': -32286}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const number Value)
(declare-const need Value)
(declare-const remaining Value)

; === BASIC STRUCTURE ===
(assert true)

; === Contract predicates ===
(define-fun C0 () Bool (and (is-IntVal number) (is-IntVal need) (is-IntVal remaining)))
(define-fun C1 () Bool (ite (is-IntVal number) (and (<= 0 (ival number)) (<= (ival number) 1000)) false))
(define-fun C2 () Bool (ite (is-IntVal need) (and (<= 0 (ival need)) (<= (ival need) 1000)) false))
(define-fun C3 () Bool (ite (is-IntVal remaining) (and (<= 0 (ival remaining)) (<= (ival remaining) 1000)) false))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 5: satisfied_assert_2, violated_assert_0;assert_1;assert_3
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True, 'assert_3': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_2'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_3'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'need': 0, 'remaining': 3.0, 'number': 2.0}
    Solution 2:
      test_case: {'need': 435, 'number': 5.0, 'remaining': 4.0}
    Solution 3:
      test_case: {'need': 435, 'number': 6.0, 'remaining': 7.0}
    Solution 4:
      test_case: {'need': 435, 'number': 8.0, 'remaining': 9.0}
    Solution 5:
      test_case: {'need': 435, 'number': 10.0, 'remaining': 11.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const number Value)
(declare-const need Value)
(declare-const remaining Value)

; === BASIC STRUCTURE ===
(assert true)

; === Contract predicates ===
(define-fun C0 () Bool (and (is-IntVal number) (is-IntVal need) (is-IntVal remaining)))
(define-fun C1 () Bool (ite (is-IntVal number) (and (<= 0 (ival number)) (<= (ival number) 1000)) false))
(define-fun C2 () Bool (ite (is-IntVal need) (and (<= 0 (ival need)) (<= (ival need) 1000)) false))
(define-fun C3 () Bool (ite (is-IntVal remaining) (and (<= 0 (ival remaining)) (<= (ival remaining) 1000)) false))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 6: satisfied_assert_0;assert_2, violated_assert_1;assert_3
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True, 'assert_3': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2'], 'violated_contracts': ['assert_1', 'assert_3'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'need': 0, 'remaining': 3438, 'number': 1001}
    Solution 2:
      test_case: {'need': 435, 'number': -1, 'remaining': 1001}
    Solution 3:
      test_case: {'need': 435, 'number': -1, 'remaining': 33286}
    Solution 4:
      test_case: {'need': 435, 'number': -1, 'remaining': 61386}
    Solution 5:
      test_case: {'need': 435, 'number': -1, 'remaining': 77307}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const number Value)
(declare-const need Value)
(declare-const remaining Value)

; === BASIC STRUCTURE ===
(assert true)

; === Contract predicates ===
(define-fun C0 () Bool (and (is-IntVal number) (is-IntVal need) (is-IntVal remaining)))
(define-fun C1 () Bool (ite (is-IntVal number) (and (<= 0 (ival number)) (<= (ival number) 1000)) false))
(define-fun C2 () Bool (ite (is-IntVal need) (and (<= 0 (ival need)) (<= (ival need) 1000)) false))
(define-fun C3 () Bool (ite (is-IntVal remaining) (and (<= 0 (ival remaining)) (<= (ival remaining) 1000)) false))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 7: satisfied_assert_1;assert_2, violated_assert_0;assert_3
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True, 'assert_3': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2'], 'violated_contracts': ['assert_0', 'assert_3'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'need': 712, 'remaining': 2.0, 'number': 0}
    Solution 2:
      test_case: {'need': 217, 'number': 712, 'remaining': 3.0}
    Solution 3:
      test_case: {'need': 217, 'number': 847, 'remaining': 4.0}
    Solution 4:
      test_case: {'need': 217, 'number': 847, 'remaining': 5.0}
    Solution 5:
      test_case: {'need': 217, 'number': 847, 'remaining': 6.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const number Value)
(declare-const need Value)
(declare-const remaining Value)

; === BASIC STRUCTURE ===
(assert true)

; === Contract predicates ===
(define-fun C0 () Bool (and (is-IntVal number) (is-IntVal need) (is-IntVal remaining)))
(define-fun C1 () Bool (ite (is-IntVal number) (and (<= 0 (ival number)) (<= (ival number) 1000)) false))
(define-fun C2 () Bool (ite (is-IntVal need) (and (<= 0 (ival need)) (<= (ival need) 1000)) false))
(define-fun C3 () Bool (ite (is-IntVal remaining) (and (<= 0 (ival remaining)) (<= (ival remaining) 1000)) false))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 8: satisfied_assert_0;assert_1;assert_2, violated_assert_3
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True, 'assert_3': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2'], 'violated_contracts': ['assert_3'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'need': 217, 'remaining': -1, 'number': 0}
    Solution 2:
      test_case: {'need': 435, 'number': 217, 'remaining': 1001}
    Solution 3:
      test_case: {'need': 435, 'number': 217, 'remaining': 33286}
    Solution 4:
      test_case: {'need': 435, 'number': 217, 'remaining': 39139}
    Solution 5:
      test_case: {'need': 435, 'number': 281, 'remaining': 59676}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const number Value)
(declare-const need Value)
(declare-const remaining Value)

; === BASIC STRUCTURE ===
(assert true)

; === Contract predicates ===
(define-fun C0 () Bool (and (is-IntVal number) (is-IntVal need) (is-IntVal remaining)))
(define-fun C1 () Bool (ite (is-IntVal number) (and (<= 0 (ival number)) (<= (ival number) 1000)) false))
(define-fun C2 () Bool (ite (is-IntVal need) (and (<= 0 (ival need)) (<= (ival need) 1000)) false))
(define-fun C3 () Bool (ite (is-IntVal remaining) (and (<= 0 (ival remaining)) (<= (ival remaining) 1000)) false))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)
(assert (not C3))

(check-sat)
(get-model)

------------------------------
  Test Case 9: satisfied_assert_3, violated_assert_0;assert_1;assert_2
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False, 'assert_3': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_3'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'need': 2.0, 'remaining': 0, 'number': 3.0}
    Solution 2:
      test_case: {'need': 4.0, 'number': 5.0, 'remaining': 435}
    Solution 3:
      test_case: {'need': 7.0, 'number': 6.0, 'remaining': 357}
    Solution 4:
      test_case: {'need': 8.0, 'number': 9.0, 'remaining': 440}
    Solution 5:
      test_case: {'need': 11.0, 'number': 10.0, 'remaining': 72}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const number Value)
(declare-const need Value)
(declare-const remaining Value)

; === BASIC STRUCTURE ===
(assert true)

; === Contract predicates ===
(define-fun C0 () Bool (and (is-IntVal number) (is-IntVal need) (is-IntVal remaining)))
(define-fun C1 () Bool (ite (is-IntVal number) (and (<= 0 (ival number)) (<= (ival number) 1000)) false))
(define-fun C2 () Bool (ite (is-IntVal need) (and (<= 0 (ival need)) (<= (ival need) 1000)) false))
(define-fun C3 () Bool (ite (is-IntVal remaining) (and (<= 0 (ival remaining)) (<= (ival remaining) 1000)) false))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 10: satisfied_assert_0;assert_3, violated_assert_1;assert_2
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False, 'assert_3': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_3'], 'violated_contracts': ['assert_1', 'assert_2'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'need': 1001, 'remaining': 0, 'number': -1}
    Solution 2:
      test_case: {'need': -2438, 'number': -1, 'remaining': 847}
    Solution 3:
      test_case: {'need': -2438, 'number': -1, 'remaining': 440}
    Solution 4:
      test_case: {'need': -2438, 'number': -1, 'remaining': 141}
    Solution 5:
      test_case: {'need': -2438, 'number': -8946, 'remaining': 141}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const number Value)
(declare-const need Value)
(declare-const remaining Value)

; === BASIC STRUCTURE ===
(assert true)

; === Contract predicates ===
(define-fun C0 () Bool (and (is-IntVal number) (is-IntVal need) (is-IntVal remaining)))
(define-fun C1 () Bool (ite (is-IntVal number) (and (<= 0 (ival number)) (<= (ival number) 1000)) false))
(define-fun C2 () Bool (ite (is-IntVal need) (and (<= 0 (ival need)) (<= (ival need) 1000)) false))
(define-fun C3 () Bool (ite (is-IntVal remaining) (and (<= 0 (ival remaining)) (<= (ival remaining) 1000)) false))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 11: satisfied_assert_1;assert_3, violated_assert_0;assert_2
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False, 'assert_3': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_3'], 'violated_contracts': ['assert_0', 'assert_2'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'need': 2.0, 'remaining': 712, 'number': 0}
    Solution 2:
      test_case: {'need': 3.0, 'number': 712, 'remaining': 217}
    Solution 3:
      test_case: {'need': 4.0, 'number': 712, 'remaining': 847}
    Solution 4:
      test_case: {'need': 5.0, 'number': 357, 'remaining': 253}
    Solution 5:
      test_case: {'need': 6.0, 'number': 357, 'remaining': 582}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const number Value)
(declare-const need Value)
(declare-const remaining Value)

; === BASIC STRUCTURE ===
(assert true)

; === Contract predicates ===
(define-fun C0 () Bool (and (is-IntVal number) (is-IntVal need) (is-IntVal remaining)))
(define-fun C1 () Bool (ite (is-IntVal number) (and (<= 0 (ival number)) (<= (ival number) 1000)) false))
(define-fun C2 () Bool (ite (is-IntVal need) (and (<= 0 (ival need)) (<= (ival need) 1000)) false))
(define-fun C3 () Bool (ite (is-IntVal remaining) (and (<= 0 (ival remaining)) (<= (ival remaining) 1000)) false))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 12: satisfied_assert_0;assert_1;assert_3, violated_assert_2
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False, 'assert_3': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_3'], 'violated_contracts': ['assert_2'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'need': -1, 'remaining': 217, 'number': 0}
    Solution 2:
      test_case: {'need': 1001, 'number': 217, 'remaining': 435}
    Solution 3:
      test_case: {'need': 1001, 'number': 217, 'remaining': 357}
    Solution 4:
      test_case: {'need': 1001, 'number': 217, 'remaining': 582}
    Solution 5:
      test_case: {'need': 1001, 'number': 141, 'remaining': 281}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const number Value)
(declare-const need Value)
(declare-const remaining Value)

; === BASIC STRUCTURE ===
(assert true)

; === Contract predicates ===
(define-fun C0 () Bool (and (is-IntVal number) (is-IntVal need) (is-IntVal remaining)))
(define-fun C1 () Bool (ite (is-IntVal number) (and (<= 0 (ival number)) (<= (ival number) 1000)) false))
(define-fun C2 () Bool (ite (is-IntVal need) (and (<= 0 (ival need)) (<= (ival need) 1000)) false))
(define-fun C3 () Bool (ite (is-IntVal remaining) (and (<= 0 (ival remaining)) (<= (ival remaining) 1000)) false))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 13: satisfied_assert_2;assert_3, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True, 'assert_3': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_2', 'assert_3'], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'need': 0, 'remaining': 712, 'number': 2.0}
    Solution 2:
      test_case: {'need': 712, 'number': 3.0, 'remaining': 217}
    Solution 3:
      test_case: {'need': 712, 'number': 4.0, 'remaining': 847}
    Solution 4:
      test_case: {'need': 712, 'number': 5.0, 'remaining': 357}
    Solution 5:
      test_case: {'need': 440, 'number': 6.0, 'remaining': 582}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const number Value)
(declare-const need Value)
(declare-const remaining Value)

; === BASIC STRUCTURE ===
(assert true)

; === Contract predicates ===
(define-fun C0 () Bool (and (is-IntVal number) (is-IntVal need) (is-IntVal remaining)))
(define-fun C1 () Bool (ite (is-IntVal number) (and (<= 0 (ival number)) (<= (ival number) 1000)) false))
(define-fun C2 () Bool (ite (is-IntVal need) (and (<= 0 (ival need)) (<= (ival need) 1000)) false))
(define-fun C3 () Bool (ite (is-IntVal remaining) (and (<= 0 (ival remaining)) (<= (ival remaining) 1000)) false))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 14: satisfied_assert_0;assert_2;assert_3, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True, 'assert_3': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2', 'assert_3'], 'violated_contracts': ['assert_1'], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'need': 0, 'remaining': 217, 'number': -1}
    Solution 2:
      test_case: {'need': 217, 'number': 1001, 'remaining': 435}
    Solution 3:
      test_case: {'need': 217, 'number': 1001, 'remaining': 357}
    Solution 4:
      test_case: {'need': 217, 'number': 1001, 'remaining': 582}
    Solution 5:
      test_case: {'need': 141, 'number': 1001, 'remaining': 281}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const number Value)
(declare-const need Value)
(declare-const remaining Value)

; === BASIC STRUCTURE ===
(assert true)

; === Contract predicates ===
(define-fun C0 () Bool (and (is-IntVal number) (is-IntVal need) (is-IntVal remaining)))
(define-fun C1 () Bool (ite (is-IntVal number) (and (<= 0 (ival number)) (<= (ival number) 1000)) false))
(define-fun C2 () Bool (ite (is-IntVal need) (and (<= 0 (ival need)) (<= (ival need) 1000)) false))
(define-fun C3 () Bool (ite (is-IntVal remaining) (and (<= 0 (ival remaining)) (<= (ival remaining) 1000)) false))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 15: satisfied_assert_1;assert_2;assert_3, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True, 'assert_3': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2', 'assert_3'], 'violated_contracts': ['assert_0'], 'total_contracts': 4}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const number Value)
(declare-const need Value)
(declare-const remaining Value)

; === BASIC STRUCTURE ===
(assert true)

; === Contract predicates ===
(define-fun C0 () Bool (and (is-IntVal number) (is-IntVal need) (is-IntVal remaining)))
(define-fun C1 () Bool (ite (is-IntVal number) (and (<= 0 (ival number)) (<= (ival number) 1000)) false))
(define-fun C2 () Bool (ite (is-IntVal need) (and (<= 0 (ival need)) (<= (ival need) 1000)) false))
(define-fun C3 () Bool (ite (is-IntVal remaining) (and (<= 0 (ival remaining)) (<= (ival remaining) 1000)) false))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)
(assert C3)

(check-sat)
(get-model)

------------------------------
  Test Case 16: satisfied_assert_0;assert_1;assert_2;assert_3, violated_
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True, 'assert_3': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_3'], 'violated_contracts': [], 'total_contracts': 4}
  Solutions:
    Solution 1:
      test_case: {'need': 712, 'remaining': 217, 'number': 0}
    Solution 2:
      test_case: {'need': 217, 'number': 712, 'remaining': 435}
    Solution 3:
      test_case: {'need': 217, 'number': 712, 'remaining': 253}
    Solution 4:
      test_case: {'need': 582, 'number': 712, 'remaining': 848}
    Solution 5:
      test_case: {'need': 582, 'number': 141, 'remaining': 281}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))

; === Inputs ===
(declare-const number Value)
(declare-const need Value)
(declare-const remaining Value)

; === BASIC STRUCTURE ===
(assert true)

; === Contract predicates ===
(define-fun C0 () Bool (and (is-IntVal number) (is-IntVal need) (is-IntVal remaining)))
(define-fun C1 () Bool (ite (is-IntVal number) (and (<= 0 (ival number)) (<= (ival number) 1000)) false))
(define-fun C2 () Bool (ite (is-IntVal need) (and (<= 0 (ival need)) (<= (ival need) 1000)) false))
(define-fun C3 () Bool (ite (is-IntVal remaining) (and (<= 0 (ival remaining)) (<= (ival remaining) 1000)) false))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)
(assert C3)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/160 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1;assert_2;assert_3;assert_4;assert_5
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False, 'assert_3': False, 'assert_4': False, 'assert_5': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_3', 'assert_4', 'assert_5'], 'total_contracts': 6}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (or (is-Nil lst)
      (and (is-Cons lst)
           (let ((tailVal (tail lst)))
             (IsList tailVal)))))

(define-fun-rec ListLength ((lst Value)) Int
  (ite (is-Nil lst) 0
       (ite (is-Cons lst)
            (+ 1 (ListLength (tail lst)))
            0)))

(define-fun-rec ListAllIntNonNeg ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-IntVal headVal)
                        (>= (ival headVal) 0)))
                 (ListAllIntNonNeg (tail lst)))
            true
            false)))

(define-fun-rec ListAllOp ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-StrVal headVal)
                        (or (= (sval headVal) "+")
                            (= (sval headVal) "-")
                            (= (sval headVal) "*")
                            (= (sval headVal) "//")
                            (= (sval headVal) "**"))))
                 (ListAllOp (tail lst)))
            true
            false)))

(define-fun-rec SafeDivs ((ops Value) (opnds Value)) Bool
  (ite (is-Cons ops)
       (let ((opHead (head ops))
             (opsTail (tail ops))
             (opndsTail (tail opnds)))
         (let ((nextOpnd (ite (is-Cons opndsTail)
                              (head opndsTail)
                              opndsTail)))
           (and (ite (is-StrVal opHead)
                     (ite (= (sval opHead) "//")
                          (not (and (is-IntVal nextOpnd)
                                    (= (ival nextOpnd) 0)))
                          true)
                     true)
                (SafeDivs opsTail opndsTail))))
       true))

; === Inputs ===
(declare-const operator Value)
(declare-const operand Value)

; === BASIC STRUCTURE ===
(assert (IsList operator))
(assert (IsList operand))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList operator) (IsList operand)))
(define-fun C1 () Bool (>= (ListLength operator) 1))
(define-fun C2 () Bool (= (ListLength operand) (+ (ListLength operator) 1)))
(define-fun C3 () Bool (ListAllIntNonNeg operand))
(define-fun C4 () Bool (ListAllOp operator))
(define-fun C5 () Bool (SafeDivs operator operand))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))
(assert (not C3))
(assert (not C4))
(assert (not C5))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1;assert_2;assert_3;assert_4;assert_5
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False, 'assert_3': False, 'assert_4': False, 'assert_5': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1', 'assert_2', 'assert_3', 'assert_4', 'assert_5'], 'total_contracts': 6}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (or (is-Nil lst)
      (and (is-Cons lst)
           (let ((tailVal (tail lst)))
             (IsList tailVal)))))

(define-fun-rec ListLength ((lst Value)) Int
  (ite (is-Nil lst) 0
       (ite (is-Cons lst)
            (+ 1 (ListLength (tail lst)))
            0)))

(define-fun-rec ListAllIntNonNeg ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-IntVal headVal)
                        (>= (ival headVal) 0)))
                 (ListAllIntNonNeg (tail lst)))
            true
            false)))

(define-fun-rec ListAllOp ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-StrVal headVal)
                        (or (= (sval headVal) "+")
                            (= (sval headVal) "-")
                            (= (sval headVal) "*")
                            (= (sval headVal) "//")
                            (= (sval headVal) "**"))))
                 (ListAllOp (tail lst)))
            true
            false)))

(define-fun-rec SafeDivs ((ops Value) (opnds Value)) Bool
  (ite (is-Cons ops)
       (let ((opHead (head ops))
             (opsTail (tail ops))
             (opndsTail (tail opnds)))
         (let ((nextOpnd (ite (is-Cons opndsTail)
                              (head opndsTail)
                              opndsTail)))
           (and (ite (is-StrVal opHead)
                     (ite (= (sval opHead) "//")
                          (not (and (is-IntVal nextOpnd)
                                    (= (ival nextOpnd) 0)))
                          true)
                     true)
                (SafeDivs opsTail opndsTail))))
       true))

; === Inputs ===
(declare-const operator Value)
(declare-const operand Value)

; === BASIC STRUCTURE ===
(assert (IsList operator))
(assert (IsList operand))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList operator) (IsList operand)))
(define-fun C1 () Bool (>= (ListLength operator) 1))
(define-fun C2 () Bool (= (ListLength operand) (+ (ListLength operator) 1)))
(define-fun C3 () Bool (ListAllIntNonNeg operand))
(define-fun C4 () Bool (ListAllOp operator))
(define-fun C5 () Bool (SafeDivs operator operand))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))
(assert (not C3))
(assert (not C4))
(assert (not C5))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0;assert_2;assert_3;assert_4;assert_5
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False, 'assert_3': False, 'assert_4': False, 'assert_5': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0', 'assert_2', 'assert_3', 'assert_4', 'assert_5'], 'total_contracts': 6}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (or (is-Nil lst)
      (and (is-Cons lst)
           (let ((tailVal (tail lst)))
             (IsList tailVal)))))

(define-fun-rec ListLength ((lst Value)) Int
  (ite (is-Nil lst) 0
       (ite (is-Cons lst)
            (+ 1 (ListLength (tail lst)))
            0)))

(define-fun-rec ListAllIntNonNeg ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-IntVal headVal)
                        (>= (ival headVal) 0)))
                 (ListAllIntNonNeg (tail lst)))
            true
            false)))

(define-fun-rec ListAllOp ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-StrVal headVal)
                        (or (= (sval headVal) "+")
                            (= (sval headVal) "-")
                            (= (sval headVal) "*")
                            (= (sval headVal) "//")
                            (= (sval headVal) "**"))))
                 (ListAllOp (tail lst)))
            true
            false)))

(define-fun-rec SafeDivs ((ops Value) (opnds Value)) Bool
  (ite (is-Cons ops)
       (let ((opHead (head ops))
             (opsTail (tail ops))
             (opndsTail (tail opnds)))
         (let ((nextOpnd (ite (is-Cons opndsTail)
                              (head opndsTail)
                              opndsTail)))
           (and (ite (is-StrVal opHead)
                     (ite (= (sval opHead) "//")
                          (not (and (is-IntVal nextOpnd)
                                    (= (ival nextOpnd) 0)))
                          true)
                     true)
                (SafeDivs opsTail opndsTail))))
       true))

; === Inputs ===
(declare-const operator Value)
(declare-const operand Value)

; === BASIC STRUCTURE ===
(assert (IsList operator))
(assert (IsList operand))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList operator) (IsList operand)))
(define-fun C1 () Bool (>= (ListLength operator) 1))
(define-fun C2 () Bool (= (ListLength operand) (+ (ListLength operator) 1)))
(define-fun C3 () Bool (ListAllIntNonNeg operand))
(define-fun C4 () Bool (ListAllOp operator))
(define-fun C5 () Bool (SafeDivs operator operand))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))
(assert (not C3))
(assert (not C4))
(assert (not C5))

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_assert_2;assert_3;assert_4;assert_5
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False, 'assert_3': False, 'assert_4': False, 'assert_5': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': ['assert_2', 'assert_3', 'assert_4', 'assert_5'], 'total_contracts': 6}
  Solutions:
    Solution 1:
      test_case: {'operator': [2.0, '//'], 'operand': [3.0]}
    Solution 2:
      test_case: {'operand': [4.0], 'operator': [5.0, '//']}
    Solution 3:
      test_case: {'operand': [6.0], 'operator': [8.0, '//']}
    Solution 4:
      test_case: {'operator': [7.0, '//'], 'operand': [10.0]}
    Solution 5:
      test_case: {'operand': [12.0], 'operator': [9.0, '//']}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (or (is-Nil lst)
      (and (is-Cons lst)
           (let ((tailVal (tail lst)))
             (IsList tailVal)))))

(define-fun-rec ListLength ((lst Value)) Int
  (ite (is-Nil lst) 0
       (ite (is-Cons lst)
            (+ 1 (ListLength (tail lst)))
            0)))

(define-fun-rec ListAllIntNonNeg ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-IntVal headVal)
                        (>= (ival headVal) 0)))
                 (ListAllIntNonNeg (tail lst)))
            true
            false)))

(define-fun-rec ListAllOp ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-StrVal headVal)
                        (or (= (sval headVal) "+")
                            (= (sval headVal) "-")
                            (= (sval headVal) "*")
                            (= (sval headVal) "//")
                            (= (sval headVal) "**"))))
                 (ListAllOp (tail lst)))
            true
            false)))

(define-fun-rec SafeDivs ((ops Value) (opnds Value)) Bool
  (ite (is-Cons ops)
       (let ((opHead (head ops))
             (opsTail (tail ops))
             (opndsTail (tail opnds)))
         (let ((nextOpnd (ite (is-Cons opndsTail)
                              (head opndsTail)
                              opndsTail)))
           (and (ite (is-StrVal opHead)
                     (ite (= (sval opHead) "//")
                          (not (and (is-IntVal nextOpnd)
                                    (= (ival nextOpnd) 0)))
                          true)
                     true)
                (SafeDivs opsTail opndsTail))))
       true))

; === Inputs ===
(declare-const operator Value)
(declare-const operand Value)

; === BASIC STRUCTURE ===
(assert (IsList operator))
(assert (IsList operand))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList operator) (IsList operand)))
(define-fun C1 () Bool (>= (ListLength operator) 1))
(define-fun C2 () Bool (= (ListLength operand) (+ (ListLength operator) 1)))
(define-fun C3 () Bool (ListAllIntNonNeg operand))
(define-fun C4 () Bool (ListAllOp operator))
(define-fun C5 () Bool (SafeDivs operator operand))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))
(assert (not C3))
(assert (not C4))
(assert (not C5))

(check-sat)
(get-model)

------------------------------
  Test Case 5: satisfied_assert_2, violated_assert_0;assert_1;assert_3;assert_4;assert_5
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True, 'assert_3': False, 'assert_4': False, 'assert_5': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_2'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_3', 'assert_4', 'assert_5'], 'total_contracts': 6}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (or (is-Nil lst)
      (and (is-Cons lst)
           (let ((tailVal (tail lst)))
             (IsList tailVal)))))

(define-fun-rec ListLength ((lst Value)) Int
  (ite (is-Nil lst) 0
       (ite (is-Cons lst)
            (+ 1 (ListLength (tail lst)))
            0)))

(define-fun-rec ListAllIntNonNeg ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-IntVal headVal)
                        (>= (ival headVal) 0)))
                 (ListAllIntNonNeg (tail lst)))
            true
            false)))

(define-fun-rec ListAllOp ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-StrVal headVal)
                        (or (= (sval headVal) "+")
                            (= (sval headVal) "-")
                            (= (sval headVal) "*")
                            (= (sval headVal) "//")
                            (= (sval headVal) "**"))))
                 (ListAllOp (tail lst)))
            true
            false)))

(define-fun-rec SafeDivs ((ops Value) (opnds Value)) Bool
  (ite (is-Cons ops)
       (let ((opHead (head ops))
             (opsTail (tail ops))
             (opndsTail (tail opnds)))
         (let ((nextOpnd (ite (is-Cons opndsTail)
                              (head opndsTail)
                              opndsTail)))
           (and (ite (is-StrVal opHead)
                     (ite (= (sval opHead) "//")
                          (not (and (is-IntVal nextOpnd)
                                    (= (ival nextOpnd) 0)))
                          true)
                     true)
                (SafeDivs opsTail opndsTail))))
       true))

; === Inputs ===
(declare-const operator Value)
(declare-const operand Value)

; === BASIC STRUCTURE ===
(assert (IsList operator))
(assert (IsList operand))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList operator) (IsList operand)))
(define-fun C1 () Bool (>= (ListLength operator) 1))
(define-fun C2 () Bool (= (ListLength operand) (+ (ListLength operator) 1)))
(define-fun C3 () Bool (ListAllIntNonNeg operand))
(define-fun C4 () Bool (ListAllOp operator))
(define-fun C5 () Bool (SafeDivs operator operand))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)
(assert (not C3))
(assert (not C4))
(assert (not C5))

(check-sat)
(get-model)

------------------------------
  Test Case 6: satisfied_assert_0;assert_2, violated_assert_1;assert_3;assert_4;assert_5
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True, 'assert_3': False, 'assert_4': False, 'assert_5': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2'], 'violated_contracts': ['assert_1', 'assert_3', 'assert_4', 'assert_5'], 'total_contracts': 6}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (or (is-Nil lst)
      (and (is-Cons lst)
           (let ((tailVal (tail lst)))
             (IsList tailVal)))))

(define-fun-rec ListLength ((lst Value)) Int
  (ite (is-Nil lst) 0
       (ite (is-Cons lst)
            (+ 1 (ListLength (tail lst)))
            0)))

(define-fun-rec ListAllIntNonNeg ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-IntVal headVal)
                        (>= (ival headVal) 0)))
                 (ListAllIntNonNeg (tail lst)))
            true
            false)))

(define-fun-rec ListAllOp ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-StrVal headVal)
                        (or (= (sval headVal) "+")
                            (= (sval headVal) "-")
                            (= (sval headVal) "*")
                            (= (sval headVal) "//")
                            (= (sval headVal) "**"))))
                 (ListAllOp (tail lst)))
            true
            false)))

(define-fun-rec SafeDivs ((ops Value) (opnds Value)) Bool
  (ite (is-Cons ops)
       (let ((opHead (head ops))
             (opsTail (tail ops))
             (opndsTail (tail opnds)))
         (let ((nextOpnd (ite (is-Cons opndsTail)
                              (head opndsTail)
                              opndsTail)))
           (and (ite (is-StrVal opHead)
                     (ite (= (sval opHead) "//")
                          (not (and (is-IntVal nextOpnd)
                                    (= (ival nextOpnd) 0)))
                          true)
                     true)
                (SafeDivs opsTail opndsTail))))
       true))

; === Inputs ===
(declare-const operator Value)
(declare-const operand Value)

; === BASIC STRUCTURE ===
(assert (IsList operator))
(assert (IsList operand))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList operator) (IsList operand)))
(define-fun C1 () Bool (>= (ListLength operator) 1))
(define-fun C2 () Bool (= (ListLength operand) (+ (ListLength operator) 1)))
(define-fun C3 () Bool (ListAllIntNonNeg operand))
(define-fun C4 () Bool (ListAllOp operator))
(define-fun C5 () Bool (SafeDivs operator operand))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)
(assert (not C3))
(assert (not C4))
(assert (not C5))

(check-sat)
(get-model)

------------------------------
  Test Case 7: satisfied_assert_1;assert_2, violated_assert_0;assert_3;assert_4;assert_5
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True, 'assert_3': False, 'assert_4': False, 'assert_5': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2'], 'violated_contracts': ['assert_0', 'assert_3', 'assert_4', 'assert_5'], 'total_contracts': 6}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (or (is-Nil lst)
      (and (is-Cons lst)
           (let ((tailVal (tail lst)))
             (IsList tailVal)))))

(define-fun-rec ListLength ((lst Value)) Int
  (ite (is-Nil lst) 0
       (ite (is-Cons lst)
            (+ 1 (ListLength (tail lst)))
            0)))

(define-fun-rec ListAllIntNonNeg ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-IntVal headVal)
                        (>= (ival headVal) 0)))
                 (ListAllIntNonNeg (tail lst)))
            true
            false)))

(define-fun-rec ListAllOp ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-StrVal headVal)
                        (or (= (sval headVal) "+")
                            (= (sval headVal) "-")
                            (= (sval headVal) "*")
                            (= (sval headVal) "//")
                            (= (sval headVal) "**"))))
                 (ListAllOp (tail lst)))
            true
            false)))

(define-fun-rec SafeDivs ((ops Value) (opnds Value)) Bool
  (ite (is-Cons ops)
       (let ((opHead (head ops))
             (opsTail (tail ops))
             (opndsTail (tail opnds)))
         (let ((nextOpnd (ite (is-Cons opndsTail)
                              (head opndsTail)
                              opndsTail)))
           (and (ite (is-StrVal opHead)
                     (ite (= (sval opHead) "//")
                          (not (and (is-IntVal nextOpnd)
                                    (= (ival nextOpnd) 0)))
                          true)
                     true)
                (SafeDivs opsTail opndsTail))))
       true))

; === Inputs ===
(declare-const operator Value)
(declare-const operand Value)

; === BASIC STRUCTURE ===
(assert (IsList operator))
(assert (IsList operand))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList operator) (IsList operand)))
(define-fun C1 () Bool (>= (ListLength operator) 1))
(define-fun C2 () Bool (= (ListLength operand) (+ (ListLength operator) 1)))
(define-fun C3 () Bool (ListAllIntNonNeg operand))
(define-fun C4 () Bool (ListAllOp operator))
(define-fun C5 () Bool (SafeDivs operator operand))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)
(assert (not C3))
(assert (not C4))
(assert (not C5))

(check-sat)
(get-model)

------------------------------
  Test Case 8: satisfied_assert_0;assert_1;assert_2, violated_assert_3;assert_4;assert_5
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True, 'assert_3': False, 'assert_4': False, 'assert_5': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2'], 'violated_contracts': ['assert_3', 'assert_4', 'assert_5'], 'total_contracts': 6}
  Solutions:
    Solution 1:
      test_case: {'operator': ['//', 3.0], 'operand': [2.0, 0, 4.0]}
    Solution 2:
      test_case: {'operand': [7.0, 0, 5.0], 'operator': ['//', 6.0]}
    Solution 3:
      test_case: {'operand': [10.0, 0, 8.0], 'operator': ['//', 9.0]}
    Solution 4:
      test_case: {'operand': [13.0, 0, 11.0], 'operator': ['//', 12.0]}
    Solution 5:
      test_case: {'operand': [16.0, 0, 14.0], 'operator': ['//', 15.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (or (is-Nil lst)
      (and (is-Cons lst)
           (let ((tailVal (tail lst)))
             (IsList tailVal)))))

(define-fun-rec ListLength ((lst Value)) Int
  (ite (is-Nil lst) 0
       (ite (is-Cons lst)
            (+ 1 (ListLength (tail lst)))
            0)))

(define-fun-rec ListAllIntNonNeg ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-IntVal headVal)
                        (>= (ival headVal) 0)))
                 (ListAllIntNonNeg (tail lst)))
            true
            false)))

(define-fun-rec ListAllOp ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-StrVal headVal)
                        (or (= (sval headVal) "+")
                            (= (sval headVal) "-")
                            (= (sval headVal) "*")
                            (= (sval headVal) "//")
                            (= (sval headVal) "**"))))
                 (ListAllOp (tail lst)))
            true
            false)))

(define-fun-rec SafeDivs ((ops Value) (opnds Value)) Bool
  (ite (is-Cons ops)
       (let ((opHead (head ops))
             (opsTail (tail ops))
             (opndsTail (tail opnds)))
         (let ((nextOpnd (ite (is-Cons opndsTail)
                              (head opndsTail)
                              opndsTail)))
           (and (ite (is-StrVal opHead)
                     (ite (= (sval opHead) "//")
                          (not (and (is-IntVal nextOpnd)
                                    (= (ival nextOpnd) 0)))
                          true)
                     true)
                (SafeDivs opsTail opndsTail))))
       true))

; === Inputs ===
(declare-const operator Value)
(declare-const operand Value)

; === BASIC STRUCTURE ===
(assert (IsList operator))
(assert (IsList operand))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList operator) (IsList operand)))
(define-fun C1 () Bool (>= (ListLength operator) 1))
(define-fun C2 () Bool (= (ListLength operand) (+ (ListLength operator) 1)))
(define-fun C3 () Bool (ListAllIntNonNeg operand))
(define-fun C4 () Bool (ListAllOp operator))
(define-fun C5 () Bool (SafeDivs operator operand))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)
(assert (not C3))
(assert (not C4))
(assert (not C5))

(check-sat)
(get-model)

------------------------------
  Test Case 9: satisfied_assert_3, violated_assert_0;assert_1;assert_2;assert_4;assert_5
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False, 'assert_3': True, 'assert_4': False, 'assert_5': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_3'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_4', 'assert_5'], 'total_contracts': 6}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (or (is-Nil lst)
      (and (is-Cons lst)
           (let ((tailVal (tail lst)))
             (IsList tailVal)))))

(define-fun-rec ListLength ((lst Value)) Int
  (ite (is-Nil lst) 0
       (ite (is-Cons lst)
            (+ 1 (ListLength (tail lst)))
            0)))

(define-fun-rec ListAllIntNonNeg ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-IntVal headVal)
                        (>= (ival headVal) 0)))
                 (ListAllIntNonNeg (tail lst)))
            true
            false)))

(define-fun-rec ListAllOp ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-StrVal headVal)
                        (or (= (sval headVal) "+")
                            (= (sval headVal) "-")
                            (= (sval headVal) "*")
                            (= (sval headVal) "//")
                            (= (sval headVal) "**"))))
                 (ListAllOp (tail lst)))
            true
            false)))

(define-fun-rec SafeDivs ((ops Value) (opnds Value)) Bool
  (ite (is-Cons ops)
       (let ((opHead (head ops))
             (opsTail (tail ops))
             (opndsTail (tail opnds)))
         (let ((nextOpnd (ite (is-Cons opndsTail)
                              (head opndsTail)
                              opndsTail)))
           (and (ite (is-StrVal opHead)
                     (ite (= (sval opHead) "//")
                          (not (and (is-IntVal nextOpnd)
                                    (= (ival nextOpnd) 0)))
                          true)
                     true)
                (SafeDivs opsTail opndsTail))))
       true))

; === Inputs ===
(declare-const operator Value)
(declare-const operand Value)

; === BASIC STRUCTURE ===
(assert (IsList operator))
(assert (IsList operand))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList operator) (IsList operand)))
(define-fun C1 () Bool (>= (ListLength operator) 1))
(define-fun C2 () Bool (= (ListLength operand) (+ (ListLength operator) 1)))
(define-fun C3 () Bool (ListAllIntNonNeg operand))
(define-fun C4 () Bool (ListAllOp operator))
(define-fun C5 () Bool (SafeDivs operator operand))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))
(assert C3)
(assert (not C4))
(assert (not C5))

(check-sat)
(get-model)

------------------------------
  Test Case 10: satisfied_assert_0;assert_3, violated_assert_1;assert_2;assert_4;assert_5
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False, 'assert_3': True, 'assert_4': False, 'assert_5': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_3'], 'violated_contracts': ['assert_1', 'assert_2', 'assert_4', 'assert_5'], 'total_contracts': 6}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (or (is-Nil lst)
      (and (is-Cons lst)
           (let ((tailVal (tail lst)))
             (IsList tailVal)))))

(define-fun-rec ListLength ((lst Value)) Int
  (ite (is-Nil lst) 0
       (ite (is-Cons lst)
            (+ 1 (ListLength (tail lst)))
            0)))

(define-fun-rec ListAllIntNonNeg ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-IntVal headVal)
                        (>= (ival headVal) 0)))
                 (ListAllIntNonNeg (tail lst)))
            true
            false)))

(define-fun-rec ListAllOp ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-StrVal headVal)
                        (or (= (sval headVal) "+")
                            (= (sval headVal) "-")
                            (= (sval headVal) "*")
                            (= (sval headVal) "//")
                            (= (sval headVal) "**"))))
                 (ListAllOp (tail lst)))
            true
            false)))

(define-fun-rec SafeDivs ((ops Value) (opnds Value)) Bool
  (ite (is-Cons ops)
       (let ((opHead (head ops))
             (opsTail (tail ops))
             (opndsTail (tail opnds)))
         (let ((nextOpnd (ite (is-Cons opndsTail)
                              (head opndsTail)
                              opndsTail)))
           (and (ite (is-StrVal opHead)
                     (ite (= (sval opHead) "//")
                          (not (and (is-IntVal nextOpnd)
                                    (= (ival nextOpnd) 0)))
                          true)
                     true)
                (SafeDivs opsTail opndsTail))))
       true))

; === Inputs ===
(declare-const operator Value)
(declare-const operand Value)

; === BASIC STRUCTURE ===
(assert (IsList operator))
(assert (IsList operand))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList operator) (IsList operand)))
(define-fun C1 () Bool (>= (ListLength operator) 1))
(define-fun C2 () Bool (= (ListLength operand) (+ (ListLength operator) 1)))
(define-fun C3 () Bool (ListAllIntNonNeg operand))
(define-fun C4 () Bool (ListAllOp operator))
(define-fun C5 () Bool (SafeDivs operator operand))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))
(assert C3)
(assert (not C4))
(assert (not C5))

(check-sat)
(get-model)

------------------------------
  Test Case 11: satisfied_assert_1;assert_3, violated_assert_0;assert_2;assert_4;assert_5
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False, 'assert_3': True, 'assert_4': False, 'assert_5': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_3'], 'violated_contracts': ['assert_0', 'assert_2', 'assert_4', 'assert_5'], 'total_contracts': 6}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (or (is-Nil lst)
      (and (is-Cons lst)
           (let ((tailVal (tail lst)))
             (IsList tailVal)))))

(define-fun-rec ListLength ((lst Value)) Int
  (ite (is-Nil lst) 0
       (ite (is-Cons lst)
            (+ 1 (ListLength (tail lst)))
            0)))

(define-fun-rec ListAllIntNonNeg ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-IntVal headVal)
                        (>= (ival headVal) 0)))
                 (ListAllIntNonNeg (tail lst)))
            true
            false)))

(define-fun-rec ListAllOp ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-StrVal headVal)
                        (or (= (sval headVal) "+")
                            (= (sval headVal) "-")
                            (= (sval headVal) "*")
                            (= (sval headVal) "//")
                            (= (sval headVal) "**"))))
                 (ListAllOp (tail lst)))
            true
            false)))

(define-fun-rec SafeDivs ((ops Value) (opnds Value)) Bool
  (ite (is-Cons ops)
       (let ((opHead (head ops))
             (opsTail (tail ops))
             (opndsTail (tail opnds)))
         (let ((nextOpnd (ite (is-Cons opndsTail)
                              (head opndsTail)
                              opndsTail)))
           (and (ite (is-StrVal opHead)
                     (ite (= (sval opHead) "//")
                          (not (and (is-IntVal nextOpnd)
                                    (= (ival nextOpnd) 0)))
                          true)
                     true)
                (SafeDivs opsTail opndsTail))))
       true))

; === Inputs ===
(declare-const operator Value)
(declare-const operand Value)

; === BASIC STRUCTURE ===
(assert (IsList operator))
(assert (IsList operand))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList operator) (IsList operand)))
(define-fun C1 () Bool (>= (ListLength operator) 1))
(define-fun C2 () Bool (= (ListLength operand) (+ (ListLength operator) 1)))
(define-fun C3 () Bool (ListAllIntNonNeg operand))
(define-fun C4 () Bool (ListAllOp operator))
(define-fun C5 () Bool (SafeDivs operator operand))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))
(assert C3)
(assert (not C4))
(assert (not C5))

(check-sat)
(get-model)

------------------------------
  Test Case 12: satisfied_assert_0;assert_1;assert_3, violated_assert_2;assert_4;assert_5
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False, 'assert_3': True, 'assert_4': False, 'assert_5': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_3'], 'violated_contracts': ['assert_2', 'assert_4', 'assert_5'], 'total_contracts': 6}
  Solutions:
    Solution 1:
      test_case: {'operator': [4.0, '//'], 'operand': []}
    Solution 2:
      test_case: {'operand': [], 'operator': [3.0, '//']}
    Solution 3:
      test_case: {'operand': [], 'operator': [5.0, '//']}
    Solution 4:
      test_case: {'operand': [], 'operator': [2.0, '//']}
    Solution 5:
      test_case: {'operand': [], 'operator': [6.0, '//']}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (or (is-Nil lst)
      (and (is-Cons lst)
           (let ((tailVal (tail lst)))
             (IsList tailVal)))))

(define-fun-rec ListLength ((lst Value)) Int
  (ite (is-Nil lst) 0
       (ite (is-Cons lst)
            (+ 1 (ListLength (tail lst)))
            0)))

(define-fun-rec ListAllIntNonNeg ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-IntVal headVal)
                        (>= (ival headVal) 0)))
                 (ListAllIntNonNeg (tail lst)))
            true
            false)))

(define-fun-rec ListAllOp ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-StrVal headVal)
                        (or (= (sval headVal) "+")
                            (= (sval headVal) "-")
                            (= (sval headVal) "*")
                            (= (sval headVal) "//")
                            (= (sval headVal) "**"))))
                 (ListAllOp (tail lst)))
            true
            false)))

(define-fun-rec SafeDivs ((ops Value) (opnds Value)) Bool
  (ite (is-Cons ops)
       (let ((opHead (head ops))
             (opsTail (tail ops))
             (opndsTail (tail opnds)))
         (let ((nextOpnd (ite (is-Cons opndsTail)
                              (head opndsTail)
                              opndsTail)))
           (and (ite (is-StrVal opHead)
                     (ite (= (sval opHead) "//")
                          (not (and (is-IntVal nextOpnd)
                                    (= (ival nextOpnd) 0)))
                          true)
                     true)
                (SafeDivs opsTail opndsTail))))
       true))

; === Inputs ===
(declare-const operator Value)
(declare-const operand Value)

; === BASIC STRUCTURE ===
(assert (IsList operator))
(assert (IsList operand))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList operator) (IsList operand)))
(define-fun C1 () Bool (>= (ListLength operator) 1))
(define-fun C2 () Bool (= (ListLength operand) (+ (ListLength operator) 1)))
(define-fun C3 () Bool (ListAllIntNonNeg operand))
(define-fun C4 () Bool (ListAllOp operator))
(define-fun C5 () Bool (SafeDivs operator operand))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))
(assert C3)
(assert (not C4))
(assert (not C5))

(check-sat)
(get-model)

------------------------------
  Test Case 13: satisfied_assert_2;assert_3, violated_assert_0;assert_1;assert_4;assert_5
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True, 'assert_3': True, 'assert_4': False, 'assert_5': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_2', 'assert_3'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_4', 'assert_5'], 'total_contracts': 6}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (or (is-Nil lst)
      (and (is-Cons lst)
           (let ((tailVal (tail lst)))
             (IsList tailVal)))))

(define-fun-rec ListLength ((lst Value)) Int
  (ite (is-Nil lst) 0
       (ite (is-Cons lst)
            (+ 1 (ListLength (tail lst)))
            0)))

(define-fun-rec ListAllIntNonNeg ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-IntVal headVal)
                        (>= (ival headVal) 0)))
                 (ListAllIntNonNeg (tail lst)))
            true
            false)))

(define-fun-rec ListAllOp ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-StrVal headVal)
                        (or (= (sval headVal) "+")
                            (= (sval headVal) "-")
                            (= (sval headVal) "*")
                            (= (sval headVal) "//")
                            (= (sval headVal) "**"))))
                 (ListAllOp (tail lst)))
            true
            false)))

(define-fun-rec SafeDivs ((ops Value) (opnds Value)) Bool
  (ite (is-Cons ops)
       (let ((opHead (head ops))
             (opsTail (tail ops))
             (opndsTail (tail opnds)))
         (let ((nextOpnd (ite (is-Cons opndsTail)
                              (head opndsTail)
                              opndsTail)))
           (and (ite (is-StrVal opHead)
                     (ite (= (sval opHead) "//")
                          (not (and (is-IntVal nextOpnd)
                                    (= (ival nextOpnd) 0)))
                          true)
                     true)
                (SafeDivs opsTail opndsTail))))
       true))

; === Inputs ===
(declare-const operator Value)
(declare-const operand Value)

; === BASIC STRUCTURE ===
(assert (IsList operator))
(assert (IsList operand))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList operator) (IsList operand)))
(define-fun C1 () Bool (>= (ListLength operator) 1))
(define-fun C2 () Bool (= (ListLength operand) (+ (ListLength operator) 1)))
(define-fun C3 () Bool (ListAllIntNonNeg operand))
(define-fun C4 () Bool (ListAllOp operator))
(define-fun C5 () Bool (SafeDivs operator operand))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)
(assert C3)
(assert (not C4))
(assert (not C5))

(check-sat)
(get-model)

------------------------------
  Test Case 14: satisfied_assert_0;assert_2;assert_3, violated_assert_1;assert_4;assert_5
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True, 'assert_3': True, 'assert_4': False, 'assert_5': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2', 'assert_3'], 'violated_contracts': ['assert_1', 'assert_4', 'assert_5'], 'total_contracts': 6}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (or (is-Nil lst)
      (and (is-Cons lst)
           (let ((tailVal (tail lst)))
             (IsList tailVal)))))

(define-fun-rec ListLength ((lst Value)) Int
  (ite (is-Nil lst) 0
       (ite (is-Cons lst)
            (+ 1 (ListLength (tail lst)))
            0)))

(define-fun-rec ListAllIntNonNeg ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-IntVal headVal)
                        (>= (ival headVal) 0)))
                 (ListAllIntNonNeg (tail lst)))
            true
            false)))

(define-fun-rec ListAllOp ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-StrVal headVal)
                        (or (= (sval headVal) "+")
                            (= (sval headVal) "-")
                            (= (sval headVal) "*")
                            (= (sval headVal) "//")
                            (= (sval headVal) "**"))))
                 (ListAllOp (tail lst)))
            true
            false)))

(define-fun-rec SafeDivs ((ops Value) (opnds Value)) Bool
  (ite (is-Cons ops)
       (let ((opHead (head ops))
             (opsTail (tail ops))
             (opndsTail (tail opnds)))
         (let ((nextOpnd (ite (is-Cons opndsTail)
                              (head opndsTail)
                              opndsTail)))
           (and (ite (is-StrVal opHead)
                     (ite (= (sval opHead) "//")
                          (not (and (is-IntVal nextOpnd)
                                    (= (ival nextOpnd) 0)))
                          true)
                     true)
                (SafeDivs opsTail opndsTail))))
       true))

; === Inputs ===
(declare-const operator Value)
(declare-const operand Value)

; === BASIC STRUCTURE ===
(assert (IsList operator))
(assert (IsList operand))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList operator) (IsList operand)))
(define-fun C1 () Bool (>= (ListLength operator) 1))
(define-fun C2 () Bool (= (ListLength operand) (+ (ListLength operator) 1)))
(define-fun C3 () Bool (ListAllIntNonNeg operand))
(define-fun C4 () Bool (ListAllOp operator))
(define-fun C5 () Bool (SafeDivs operator operand))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)
(assert C3)
(assert (not C4))
(assert (not C5))

(check-sat)
(get-model)

------------------------------
  Test Case 15: satisfied_assert_1;assert_2;assert_3, violated_assert_0;assert_4;assert_5
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True, 'assert_3': True, 'assert_4': False, 'assert_5': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2', 'assert_3'], 'violated_contracts': ['assert_0', 'assert_4', 'assert_5'], 'total_contracts': 6}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (or (is-Nil lst)
      (and (is-Cons lst)
           (let ((tailVal (tail lst)))
             (IsList tailVal)))))

(define-fun-rec ListLength ((lst Value)) Int
  (ite (is-Nil lst) 0
       (ite (is-Cons lst)
            (+ 1 (ListLength (tail lst)))
            0)))

(define-fun-rec ListAllIntNonNeg ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-IntVal headVal)
                        (>= (ival headVal) 0)))
                 (ListAllIntNonNeg (tail lst)))
            true
            false)))

(define-fun-rec ListAllOp ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-StrVal headVal)
                        (or (= (sval headVal) "+")
                            (= (sval headVal) "-")
                            (= (sval headVal) "*")
                            (= (sval headVal) "//")
                            (= (sval headVal) "**"))))
                 (ListAllOp (tail lst)))
            true
            false)))

(define-fun-rec SafeDivs ((ops Value) (opnds Value)) Bool
  (ite (is-Cons ops)
       (let ((opHead (head ops))
             (opsTail (tail ops))
             (opndsTail (tail opnds)))
         (let ((nextOpnd (ite (is-Cons opndsTail)
                              (head opndsTail)
                              opndsTail)))
           (and (ite (is-StrVal opHead)
                     (ite (= (sval opHead) "//")
                          (not (and (is-IntVal nextOpnd)
                                    (= (ival nextOpnd) 0)))
                          true)
                     true)
                (SafeDivs opsTail opndsTail))))
       true))

; === Inputs ===
(declare-const operator Value)
(declare-const operand Value)

; === BASIC STRUCTURE ===
(assert (IsList operator))
(assert (IsList operand))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList operator) (IsList operand)))
(define-fun C1 () Bool (>= (ListLength operator) 1))
(define-fun C2 () Bool (= (ListLength operand) (+ (ListLength operator) 1)))
(define-fun C3 () Bool (ListAllIntNonNeg operand))
(define-fun C4 () Bool (ListAllOp operator))
(define-fun C5 () Bool (SafeDivs operator operand))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)
(assert C3)
(assert (not C4))
(assert (not C5))

(check-sat)
(get-model)

------------------------------
  Test Case 16: satisfied_assert_0;assert_1;assert_2;assert_3, violated_assert_4;assert_5
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True, 'assert_3': True, 'assert_4': False, 'assert_5': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_3'], 'violated_contracts': ['assert_4', 'assert_5'], 'total_contracts': 6}
  Solutions:
    Solution 1:
      test_case: {'operator': ['//', 2.0], 'operand': [2240, 0, 867]}
    Solution 2:
      test_case: {'operand': [2240, 0, 9725], 'operator': ['//', 3.0]}
    Solution 3:
      test_case: {'operand': [20127, 0, 31597], 'operator': ['//', 4.0]}
    Solution 4:
      test_case: {'operand': [44515, 0, 11649], 'operator': ['//', 5.0]}
    Solution 5:
      test_case: {'operand': [68852, 0, 27856], 'operator': ['//', 6.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (or (is-Nil lst)
      (and (is-Cons lst)
           (let ((tailVal (tail lst)))
             (IsList tailVal)))))

(define-fun-rec ListLength ((lst Value)) Int
  (ite (is-Nil lst) 0
       (ite (is-Cons lst)
            (+ 1 (ListLength (tail lst)))
            0)))

(define-fun-rec ListAllIntNonNeg ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-IntVal headVal)
                        (>= (ival headVal) 0)))
                 (ListAllIntNonNeg (tail lst)))
            true
            false)))

(define-fun-rec ListAllOp ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-StrVal headVal)
                        (or (= (sval headVal) "+")
                            (= (sval headVal) "-")
                            (= (sval headVal) "*")
                            (= (sval headVal) "//")
                            (= (sval headVal) "**"))))
                 (ListAllOp (tail lst)))
            true
            false)))

(define-fun-rec SafeDivs ((ops Value) (opnds Value)) Bool
  (ite (is-Cons ops)
       (let ((opHead (head ops))
             (opsTail (tail ops))
             (opndsTail (tail opnds)))
         (let ((nextOpnd (ite (is-Cons opndsTail)
                              (head opndsTail)
                              opndsTail)))
           (and (ite (is-StrVal opHead)
                     (ite (= (sval opHead) "//")
                          (not (and (is-IntVal nextOpnd)
                                    (= (ival nextOpnd) 0)))
                          true)
                     true)
                (SafeDivs opsTail opndsTail))))
       true))

; === Inputs ===
(declare-const operator Value)
(declare-const operand Value)

; === BASIC STRUCTURE ===
(assert (IsList operator))
(assert (IsList operand))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList operator) (IsList operand)))
(define-fun C1 () Bool (>= (ListLength operator) 1))
(define-fun C2 () Bool (= (ListLength operand) (+ (ListLength operator) 1)))
(define-fun C3 () Bool (ListAllIntNonNeg operand))
(define-fun C4 () Bool (ListAllOp operator))
(define-fun C5 () Bool (SafeDivs operator operand))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)
(assert C3)
(assert (not C4))
(assert (not C5))

(check-sat)
(get-model)

------------------------------
  Test Case 17: satisfied_assert_4, violated_assert_0;assert_1;assert_2;assert_3;assert_5
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False, 'assert_3': False, 'assert_4': True, 'assert_5': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_4'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_3', 'assert_5'], 'total_contracts': 6}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (or (is-Nil lst)
      (and (is-Cons lst)
           (let ((tailVal (tail lst)))
             (IsList tailVal)))))

(define-fun-rec ListLength ((lst Value)) Int
  (ite (is-Nil lst) 0
       (ite (is-Cons lst)
            (+ 1 (ListLength (tail lst)))
            0)))

(define-fun-rec ListAllIntNonNeg ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-IntVal headVal)
                        (>= (ival headVal) 0)))
                 (ListAllIntNonNeg (tail lst)))
            true
            false)))

(define-fun-rec ListAllOp ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-StrVal headVal)
                        (or (= (sval headVal) "+")
                            (= (sval headVal) "-")
                            (= (sval headVal) "*")
                            (= (sval headVal) "//")
                            (= (sval headVal) "**"))))
                 (ListAllOp (tail lst)))
            true
            false)))

(define-fun-rec SafeDivs ((ops Value) (opnds Value)) Bool
  (ite (is-Cons ops)
       (let ((opHead (head ops))
             (opsTail (tail ops))
             (opndsTail (tail opnds)))
         (let ((nextOpnd (ite (is-Cons opndsTail)
                              (head opndsTail)
                              opndsTail)))
           (and (ite (is-StrVal opHead)
                     (ite (= (sval opHead) "//")
                          (not (and (is-IntVal nextOpnd)
                                    (= (ival nextOpnd) 0)))
                          true)
                     true)
                (SafeDivs opsTail opndsTail))))
       true))

; === Inputs ===
(declare-const operator Value)
(declare-const operand Value)

; === BASIC STRUCTURE ===
(assert (IsList operator))
(assert (IsList operand))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList operator) (IsList operand)))
(define-fun C1 () Bool (>= (ListLength operator) 1))
(define-fun C2 () Bool (= (ListLength operand) (+ (ListLength operator) 1)))
(define-fun C3 () Bool (ListAllIntNonNeg operand))
(define-fun C4 () Bool (ListAllOp operator))
(define-fun C5 () Bool (SafeDivs operator operand))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))
(assert (not C3))
(assert C4)
(assert (not C5))

(check-sat)
(get-model)

------------------------------
  Test Case 18: satisfied_assert_0;assert_4, violated_assert_1;assert_2;assert_3;assert_5
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False, 'assert_3': False, 'assert_4': True, 'assert_5': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_4'], 'violated_contracts': ['assert_1', 'assert_2', 'assert_3', 'assert_5'], 'total_contracts': 6}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (or (is-Nil lst)
      (and (is-Cons lst)
           (let ((tailVal (tail lst)))
             (IsList tailVal)))))

(define-fun-rec ListLength ((lst Value)) Int
  (ite (is-Nil lst) 0
       (ite (is-Cons lst)
            (+ 1 (ListLength (tail lst)))
            0)))

(define-fun-rec ListAllIntNonNeg ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-IntVal headVal)
                        (>= (ival headVal) 0)))
                 (ListAllIntNonNeg (tail lst)))
            true
            false)))

(define-fun-rec ListAllOp ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-StrVal headVal)
                        (or (= (sval headVal) "+")
                            (= (sval headVal) "-")
                            (= (sval headVal) "*")
                            (= (sval headVal) "//")
                            (= (sval headVal) "**"))))
                 (ListAllOp (tail lst)))
            true
            false)))

(define-fun-rec SafeDivs ((ops Value) (opnds Value)) Bool
  (ite (is-Cons ops)
       (let ((opHead (head ops))
             (opsTail (tail ops))
             (opndsTail (tail opnds)))
         (let ((nextOpnd (ite (is-Cons opndsTail)
                              (head opndsTail)
                              opndsTail)))
           (and (ite (is-StrVal opHead)
                     (ite (= (sval opHead) "//")
                          (not (and (is-IntVal nextOpnd)
                                    (= (ival nextOpnd) 0)))
                          true)
                     true)
                (SafeDivs opsTail opndsTail))))
       true))

; === Inputs ===
(declare-const operator Value)
(declare-const operand Value)

; === BASIC STRUCTURE ===
(assert (IsList operator))
(assert (IsList operand))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList operator) (IsList operand)))
(define-fun C1 () Bool (>= (ListLength operator) 1))
(define-fun C2 () Bool (= (ListLength operand) (+ (ListLength operator) 1)))
(define-fun C3 () Bool (ListAllIntNonNeg operand))
(define-fun C4 () Bool (ListAllOp operator))
(define-fun C5 () Bool (SafeDivs operator operand))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))
(assert (not C3))
(assert C4)
(assert (not C5))

(check-sat)
(get-model)

------------------------------
  Test Case 19: satisfied_assert_1;assert_4, violated_assert_0;assert_2;assert_3;assert_5
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False, 'assert_3': False, 'assert_4': True, 'assert_5': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_4'], 'violated_contracts': ['assert_0', 'assert_2', 'assert_3', 'assert_5'], 'total_contracts': 6}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (or (is-Nil lst)
      (and (is-Cons lst)
           (let ((tailVal (tail lst)))
             (IsList tailVal)))))

(define-fun-rec ListLength ((lst Value)) Int
  (ite (is-Nil lst) 0
       (ite (is-Cons lst)
            (+ 1 (ListLength (tail lst)))
            0)))

(define-fun-rec ListAllIntNonNeg ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-IntVal headVal)
                        (>= (ival headVal) 0)))
                 (ListAllIntNonNeg (tail lst)))
            true
            false)))

(define-fun-rec ListAllOp ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-StrVal headVal)
                        (or (= (sval headVal) "+")
                            (= (sval headVal) "-")
                            (= (sval headVal) "*")
                            (= (sval headVal) "//")
                            (= (sval headVal) "**"))))
                 (ListAllOp (tail lst)))
            true
            false)))

(define-fun-rec SafeDivs ((ops Value) (opnds Value)) Bool
  (ite (is-Cons ops)
       (let ((opHead (head ops))
             (opsTail (tail ops))
             (opndsTail (tail opnds)))
         (let ((nextOpnd (ite (is-Cons opndsTail)
                              (head opndsTail)
                              opndsTail)))
           (and (ite (is-StrVal opHead)
                     (ite (= (sval opHead) "//")
                          (not (and (is-IntVal nextOpnd)
                                    (= (ival nextOpnd) 0)))
                          true)
                     true)
                (SafeDivs opsTail opndsTail))))
       true))

; === Inputs ===
(declare-const operator Value)
(declare-const operand Value)

; === BASIC STRUCTURE ===
(assert (IsList operator))
(assert (IsList operand))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList operator) (IsList operand)))
(define-fun C1 () Bool (>= (ListLength operator) 1))
(define-fun C2 () Bool (= (ListLength operand) (+ (ListLength operator) 1)))
(define-fun C3 () Bool (ListAllIntNonNeg operand))
(define-fun C4 () Bool (ListAllOp operator))
(define-fun C5 () Bool (SafeDivs operator operand))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))
(assert (not C3))
(assert C4)
(assert (not C5))

(check-sat)
(get-model)

------------------------------
  Test Case 20: satisfied_assert_0;assert_1;assert_4, violated_assert_2;assert_3;assert_5
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False, 'assert_3': False, 'assert_4': True, 'assert_5': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_4'], 'violated_contracts': ['assert_2', 'assert_3', 'assert_5'], 'total_contracts': 6}
  Solutions:
    Solution 1:
      test_case: {'operator': ['//', '//'], 'operand': [3.0]}
    Solution 2:
      test_case: {'operand': [2.0], 'operator': ['*', '//']}
    Solution 3:
      test_case: {'operand': [4.0], 'operator': ['*', '//']}
    Solution 4:
      test_case: {'operand': [5.0], 'operator': ['*', '//']}
    Solution 5:
      test_case: {'operand': [6.0], 'operator': ['*', '//']}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (or (is-Nil lst)
      (and (is-Cons lst)
           (let ((tailVal (tail lst)))
             (IsList tailVal)))))

(define-fun-rec ListLength ((lst Value)) Int
  (ite (is-Nil lst) 0
       (ite (is-Cons lst)
            (+ 1 (ListLength (tail lst)))
            0)))

(define-fun-rec ListAllIntNonNeg ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-IntVal headVal)
                        (>= (ival headVal) 0)))
                 (ListAllIntNonNeg (tail lst)))
            true
            false)))

(define-fun-rec ListAllOp ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-StrVal headVal)
                        (or (= (sval headVal) "+")
                            (= (sval headVal) "-")
                            (= (sval headVal) "*")
                            (= (sval headVal) "//")
                            (= (sval headVal) "**"))))
                 (ListAllOp (tail lst)))
            true
            false)))

(define-fun-rec SafeDivs ((ops Value) (opnds Value)) Bool
  (ite (is-Cons ops)
       (let ((opHead (head ops))
             (opsTail (tail ops))
             (opndsTail (tail opnds)))
         (let ((nextOpnd (ite (is-Cons opndsTail)
                              (head opndsTail)
                              opndsTail)))
           (and (ite (is-StrVal opHead)
                     (ite (= (sval opHead) "//")
                          (not (and (is-IntVal nextOpnd)
                                    (= (ival nextOpnd) 0)))
                          true)
                     true)
                (SafeDivs opsTail opndsTail))))
       true))

; === Inputs ===
(declare-const operator Value)
(declare-const operand Value)

; === BASIC STRUCTURE ===
(assert (IsList operator))
(assert (IsList operand))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList operator) (IsList operand)))
(define-fun C1 () Bool (>= (ListLength operator) 1))
(define-fun C2 () Bool (= (ListLength operand) (+ (ListLength operator) 1)))
(define-fun C3 () Bool (ListAllIntNonNeg operand))
(define-fun C4 () Bool (ListAllOp operator))
(define-fun C5 () Bool (SafeDivs operator operand))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))
(assert (not C3))
(assert C4)
(assert (not C5))

(check-sat)
(get-model)

------------------------------
  Test Case 21: satisfied_assert_2;assert_4, violated_assert_0;assert_1;assert_3;assert_5
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True, 'assert_3': False, 'assert_4': True, 'assert_5': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_2', 'assert_4'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_3', 'assert_5'], 'total_contracts': 6}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (or (is-Nil lst)
      (and (is-Cons lst)
           (let ((tailVal (tail lst)))
             (IsList tailVal)))))

(define-fun-rec ListLength ((lst Value)) Int
  (ite (is-Nil lst) 0
       (ite (is-Cons lst)
            (+ 1 (ListLength (tail lst)))
            0)))

(define-fun-rec ListAllIntNonNeg ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-IntVal headVal)
                        (>= (ival headVal) 0)))
                 (ListAllIntNonNeg (tail lst)))
            true
            false)))

(define-fun-rec ListAllOp ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-StrVal headVal)
                        (or (= (sval headVal) "+")
                            (= (sval headVal) "-")
                            (= (sval headVal) "*")
                            (= (sval headVal) "//")
                            (= (sval headVal) "**"))))
                 (ListAllOp (tail lst)))
            true
            false)))

(define-fun-rec SafeDivs ((ops Value) (opnds Value)) Bool
  (ite (is-Cons ops)
       (let ((opHead (head ops))
             (opsTail (tail ops))
             (opndsTail (tail opnds)))
         (let ((nextOpnd (ite (is-Cons opndsTail)
                              (head opndsTail)
                              opndsTail)))
           (and (ite (is-StrVal opHead)
                     (ite (= (sval opHead) "//")
                          (not (and (is-IntVal nextOpnd)
                                    (= (ival nextOpnd) 0)))
                          true)
                     true)
                (SafeDivs opsTail opndsTail))))
       true))

; === Inputs ===
(declare-const operator Value)
(declare-const operand Value)

; === BASIC STRUCTURE ===
(assert (IsList operator))
(assert (IsList operand))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList operator) (IsList operand)))
(define-fun C1 () Bool (>= (ListLength operator) 1))
(define-fun C2 () Bool (= (ListLength operand) (+ (ListLength operator) 1)))
(define-fun C3 () Bool (ListAllIntNonNeg operand))
(define-fun C4 () Bool (ListAllOp operator))
(define-fun C5 () Bool (SafeDivs operator operand))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)
(assert (not C3))
(assert C4)
(assert (not C5))

(check-sat)
(get-model)

------------------------------
  Test Case 22: satisfied_assert_0;assert_2;assert_4, violated_assert_1;assert_3;assert_5
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True, 'assert_3': False, 'assert_4': True, 'assert_5': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2', 'assert_4'], 'violated_contracts': ['assert_1', 'assert_3', 'assert_5'], 'total_contracts': 6}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (or (is-Nil lst)
      (and (is-Cons lst)
           (let ((tailVal (tail lst)))
             (IsList tailVal)))))

(define-fun-rec ListLength ((lst Value)) Int
  (ite (is-Nil lst) 0
       (ite (is-Cons lst)
            (+ 1 (ListLength (tail lst)))
            0)))

(define-fun-rec ListAllIntNonNeg ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-IntVal headVal)
                        (>= (ival headVal) 0)))
                 (ListAllIntNonNeg (tail lst)))
            true
            false)))

(define-fun-rec ListAllOp ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-StrVal headVal)
                        (or (= (sval headVal) "+")
                            (= (sval headVal) "-")
                            (= (sval headVal) "*")
                            (= (sval headVal) "//")
                            (= (sval headVal) "**"))))
                 (ListAllOp (tail lst)))
            true
            false)))

(define-fun-rec SafeDivs ((ops Value) (opnds Value)) Bool
  (ite (is-Cons ops)
       (let ((opHead (head ops))
             (opsTail (tail ops))
             (opndsTail (tail opnds)))
         (let ((nextOpnd (ite (is-Cons opndsTail)
                              (head opndsTail)
                              opndsTail)))
           (and (ite (is-StrVal opHead)
                     (ite (= (sval opHead) "//")
                          (not (and (is-IntVal nextOpnd)
                                    (= (ival nextOpnd) 0)))
                          true)
                     true)
                (SafeDivs opsTail opndsTail))))
       true))

; === Inputs ===
(declare-const operator Value)
(declare-const operand Value)

; === BASIC STRUCTURE ===
(assert (IsList operator))
(assert (IsList operand))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList operator) (IsList operand)))
(define-fun C1 () Bool (>= (ListLength operator) 1))
(define-fun C2 () Bool (= (ListLength operand) (+ (ListLength operator) 1)))
(define-fun C3 () Bool (ListAllIntNonNeg operand))
(define-fun C4 () Bool (ListAllOp operator))
(define-fun C5 () Bool (SafeDivs operator operand))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)
(assert (not C3))
(assert C4)
(assert (not C5))

(check-sat)
(get-model)

------------------------------
  Test Case 23: satisfied_assert_1;assert_2;assert_4, violated_assert_0;assert_3;assert_5
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True, 'assert_3': False, 'assert_4': True, 'assert_5': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2', 'assert_4'], 'violated_contracts': ['assert_0', 'assert_3', 'assert_5'], 'total_contracts': 6}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (or (is-Nil lst)
      (and (is-Cons lst)
           (let ((tailVal (tail lst)))
             (IsList tailVal)))))

(define-fun-rec ListLength ((lst Value)) Int
  (ite (is-Nil lst) 0
       (ite (is-Cons lst)
            (+ 1 (ListLength (tail lst)))
            0)))

(define-fun-rec ListAllIntNonNeg ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-IntVal headVal)
                        (>= (ival headVal) 0)))
                 (ListAllIntNonNeg (tail lst)))
            true
            false)))

(define-fun-rec ListAllOp ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-StrVal headVal)
                        (or (= (sval headVal) "+")
                            (= (sval headVal) "-")
                            (= (sval headVal) "*")
                            (= (sval headVal) "//")
                            (= (sval headVal) "**"))))
                 (ListAllOp (tail lst)))
            true
            false)))

(define-fun-rec SafeDivs ((ops Value) (opnds Value)) Bool
  (ite (is-Cons ops)
       (let ((opHead (head ops))
             (opsTail (tail ops))
             (opndsTail (tail opnds)))
         (let ((nextOpnd (ite (is-Cons opndsTail)
                              (head opndsTail)
                              opndsTail)))
           (and (ite (is-StrVal opHead)
                     (ite (= (sval opHead) "//")
                          (not (and (is-IntVal nextOpnd)
                                    (= (ival nextOpnd) 0)))
                          true)
                     true)
                (SafeDivs opsTail opndsTail))))
       true))

; === Inputs ===
(declare-const operator Value)
(declare-const operand Value)

; === BASIC STRUCTURE ===
(assert (IsList operator))
(assert (IsList operand))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList operator) (IsList operand)))
(define-fun C1 () Bool (>= (ListLength operator) 1))
(define-fun C2 () Bool (= (ListLength operand) (+ (ListLength operator) 1)))
(define-fun C3 () Bool (ListAllIntNonNeg operand))
(define-fun C4 () Bool (ListAllOp operator))
(define-fun C5 () Bool (SafeDivs operator operand))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)
(assert (not C3))
(assert C4)
(assert (not C5))

(check-sat)
(get-model)

------------------------------
  Test Case 24: satisfied_assert_0;assert_1;assert_2;assert_4, violated_assert_3;assert_5
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True, 'assert_3': False, 'assert_4': True, 'assert_5': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_4'], 'violated_contracts': ['assert_3', 'assert_5'], 'total_contracts': 6}
  Solutions:
    Solution 1:
      test_case: {'operator': ['//'], 'operand': [2.0, 0]}
    Solution 2:
      test_case: {'operand': [3.0, 0], 'operator': ['//']}
    Solution 3:
      test_case: {'operator': ['//'], 'operand': [4.0, 0]}
    Solution 4:
      test_case: {'operand': [5.0, 0], 'operator': ['//']}
    Solution 5:
      test_case: {'operator': ['//'], 'operand': [6.0, 0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (or (is-Nil lst)
      (and (is-Cons lst)
           (let ((tailVal (tail lst)))
             (IsList tailVal)))))

(define-fun-rec ListLength ((lst Value)) Int
  (ite (is-Nil lst) 0
       (ite (is-Cons lst)
            (+ 1 (ListLength (tail lst)))
            0)))

(define-fun-rec ListAllIntNonNeg ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-IntVal headVal)
                        (>= (ival headVal) 0)))
                 (ListAllIntNonNeg (tail lst)))
            true
            false)))

(define-fun-rec ListAllOp ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-StrVal headVal)
                        (or (= (sval headVal) "+")
                            (= (sval headVal) "-")
                            (= (sval headVal) "*")
                            (= (sval headVal) "//")
                            (= (sval headVal) "**"))))
                 (ListAllOp (tail lst)))
            true
            false)))

(define-fun-rec SafeDivs ((ops Value) (opnds Value)) Bool
  (ite (is-Cons ops)
       (let ((opHead (head ops))
             (opsTail (tail ops))
             (opndsTail (tail opnds)))
         (let ((nextOpnd (ite (is-Cons opndsTail)
                              (head opndsTail)
                              opndsTail)))
           (and (ite (is-StrVal opHead)
                     (ite (= (sval opHead) "//")
                          (not (and (is-IntVal nextOpnd)
                                    (= (ival nextOpnd) 0)))
                          true)
                     true)
                (SafeDivs opsTail opndsTail))))
       true))

; === Inputs ===
(declare-const operator Value)
(declare-const operand Value)

; === BASIC STRUCTURE ===
(assert (IsList operator))
(assert (IsList operand))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList operator) (IsList operand)))
(define-fun C1 () Bool (>= (ListLength operator) 1))
(define-fun C2 () Bool (= (ListLength operand) (+ (ListLength operator) 1)))
(define-fun C3 () Bool (ListAllIntNonNeg operand))
(define-fun C4 () Bool (ListAllOp operator))
(define-fun C5 () Bool (SafeDivs operator operand))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)
(assert (not C3))
(assert C4)
(assert (not C5))

(check-sat)
(get-model)

------------------------------
  Test Case 25: satisfied_assert_3;assert_4, violated_assert_0;assert_1;assert_2;assert_5
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False, 'assert_3': True, 'assert_4': True, 'assert_5': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_3', 'assert_4'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_5'], 'total_contracts': 6}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (or (is-Nil lst)
      (and (is-Cons lst)
           (let ((tailVal (tail lst)))
             (IsList tailVal)))))

(define-fun-rec ListLength ((lst Value)) Int
  (ite (is-Nil lst) 0
       (ite (is-Cons lst)
            (+ 1 (ListLength (tail lst)))
            0)))

(define-fun-rec ListAllIntNonNeg ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-IntVal headVal)
                        (>= (ival headVal) 0)))
                 (ListAllIntNonNeg (tail lst)))
            true
            false)))

(define-fun-rec ListAllOp ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-StrVal headVal)
                        (or (= (sval headVal) "+")
                            (= (sval headVal) "-")
                            (= (sval headVal) "*")
                            (= (sval headVal) "//")
                            (= (sval headVal) "**"))))
                 (ListAllOp (tail lst)))
            true
            false)))

(define-fun-rec SafeDivs ((ops Value) (opnds Value)) Bool
  (ite (is-Cons ops)
       (let ((opHead (head ops))
             (opsTail (tail ops))
             (opndsTail (tail opnds)))
         (let ((nextOpnd (ite (is-Cons opndsTail)
                              (head opndsTail)
                              opndsTail)))
           (and (ite (is-StrVal opHead)
                     (ite (= (sval opHead) "//")
                          (not (and (is-IntVal nextOpnd)
                                    (= (ival nextOpnd) 0)))
                          true)
                     true)
                (SafeDivs opsTail opndsTail))))
       true))

; === Inputs ===
(declare-const operator Value)
(declare-const operand Value)

; === BASIC STRUCTURE ===
(assert (IsList operator))
(assert (IsList operand))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList operator) (IsList operand)))
(define-fun C1 () Bool (>= (ListLength operator) 1))
(define-fun C2 () Bool (= (ListLength operand) (+ (ListLength operator) 1)))
(define-fun C3 () Bool (ListAllIntNonNeg operand))
(define-fun C4 () Bool (ListAllOp operator))
(define-fun C5 () Bool (SafeDivs operator operand))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))
(assert C3)
(assert C4)
(assert (not C5))

(check-sat)
(get-model)

------------------------------
  Test Case 26: satisfied_assert_0;assert_3;assert_4, violated_assert_1;assert_2;assert_5
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False, 'assert_3': True, 'assert_4': True, 'assert_5': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_3', 'assert_4'], 'violated_contracts': ['assert_1', 'assert_2', 'assert_5'], 'total_contracts': 6}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (or (is-Nil lst)
      (and (is-Cons lst)
           (let ((tailVal (tail lst)))
             (IsList tailVal)))))

(define-fun-rec ListLength ((lst Value)) Int
  (ite (is-Nil lst) 0
       (ite (is-Cons lst)
            (+ 1 (ListLength (tail lst)))
            0)))

(define-fun-rec ListAllIntNonNeg ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-IntVal headVal)
                        (>= (ival headVal) 0)))
                 (ListAllIntNonNeg (tail lst)))
            true
            false)))

(define-fun-rec ListAllOp ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-StrVal headVal)
                        (or (= (sval headVal) "+")
                            (= (sval headVal) "-")
                            (= (sval headVal) "*")
                            (= (sval headVal) "//")
                            (= (sval headVal) "**"))))
                 (ListAllOp (tail lst)))
            true
            false)))

(define-fun-rec SafeDivs ((ops Value) (opnds Value)) Bool
  (ite (is-Cons ops)
       (let ((opHead (head ops))
             (opsTail (tail ops))
             (opndsTail (tail opnds)))
         (let ((nextOpnd (ite (is-Cons opndsTail)
                              (head opndsTail)
                              opndsTail)))
           (and (ite (is-StrVal opHead)
                     (ite (= (sval opHead) "//")
                          (not (and (is-IntVal nextOpnd)
                                    (= (ival nextOpnd) 0)))
                          true)
                     true)
                (SafeDivs opsTail opndsTail))))
       true))

; === Inputs ===
(declare-const operator Value)
(declare-const operand Value)

; === BASIC STRUCTURE ===
(assert (IsList operator))
(assert (IsList operand))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList operator) (IsList operand)))
(define-fun C1 () Bool (>= (ListLength operator) 1))
(define-fun C2 () Bool (= (ListLength operand) (+ (ListLength operator) 1)))
(define-fun C3 () Bool (ListAllIntNonNeg operand))
(define-fun C4 () Bool (ListAllOp operator))
(define-fun C5 () Bool (SafeDivs operator operand))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))
(assert C3)
(assert C4)
(assert (not C5))

(check-sat)
(get-model)

------------------------------
  Test Case 27: satisfied_assert_1;assert_3;assert_4, violated_assert_0;assert_2;assert_5
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False, 'assert_3': True, 'assert_4': True, 'assert_5': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_3', 'assert_4'], 'violated_contracts': ['assert_0', 'assert_2', 'assert_5'], 'total_contracts': 6}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (or (is-Nil lst)
      (and (is-Cons lst)
           (let ((tailVal (tail lst)))
             (IsList tailVal)))))

(define-fun-rec ListLength ((lst Value)) Int
  (ite (is-Nil lst) 0
       (ite (is-Cons lst)
            (+ 1 (ListLength (tail lst)))
            0)))

(define-fun-rec ListAllIntNonNeg ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-IntVal headVal)
                        (>= (ival headVal) 0)))
                 (ListAllIntNonNeg (tail lst)))
            true
            false)))

(define-fun-rec ListAllOp ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-StrVal headVal)
                        (or (= (sval headVal) "+")
                            (= (sval headVal) "-")
                            (= (sval headVal) "*")
                            (= (sval headVal) "//")
                            (= (sval headVal) "**"))))
                 (ListAllOp (tail lst)))
            true
            false)))

(define-fun-rec SafeDivs ((ops Value) (opnds Value)) Bool
  (ite (is-Cons ops)
       (let ((opHead (head ops))
             (opsTail (tail ops))
             (opndsTail (tail opnds)))
         (let ((nextOpnd (ite (is-Cons opndsTail)
                              (head opndsTail)
                              opndsTail)))
           (and (ite (is-StrVal opHead)
                     (ite (= (sval opHead) "//")
                          (not (and (is-IntVal nextOpnd)
                                    (= (ival nextOpnd) 0)))
                          true)
                     true)
                (SafeDivs opsTail opndsTail))))
       true))

; === Inputs ===
(declare-const operator Value)
(declare-const operand Value)

; === BASIC STRUCTURE ===
(assert (IsList operator))
(assert (IsList operand))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList operator) (IsList operand)))
(define-fun C1 () Bool (>= (ListLength operator) 1))
(define-fun C2 () Bool (= (ListLength operand) (+ (ListLength operator) 1)))
(define-fun C3 () Bool (ListAllIntNonNeg operand))
(define-fun C4 () Bool (ListAllOp operator))
(define-fun C5 () Bool (SafeDivs operator operand))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))
(assert C3)
(assert C4)
(assert (not C5))

(check-sat)
(get-model)

------------------------------
  Test Case 28: satisfied_assert_0;assert_1;assert_3;assert_4, violated_assert_2;assert_5
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False, 'assert_3': True, 'assert_4': True, 'assert_5': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_3', 'assert_4'], 'violated_contracts': ['assert_2', 'assert_5'], 'total_contracts': 6}
  Solutions:
    Solution 1:
      test_case: {'operator': ['//'], 'operand': []}
    Solution 2:
      test_case: {'operand': [18457], 'operator': ['//', '//']}
    Solution 3:
      test_case: {'operator': ['//', '//'], 'operand': [18587]}
    Solution 4:
      test_case: {'operand': [6878], 'operator': ['//', '//']}
    Solution 5:
      test_case: {'operand': [17066], 'operator': ['//', '//']}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (or (is-Nil lst)
      (and (is-Cons lst)
           (let ((tailVal (tail lst)))
             (IsList tailVal)))))

(define-fun-rec ListLength ((lst Value)) Int
  (ite (is-Nil lst) 0
       (ite (is-Cons lst)
            (+ 1 (ListLength (tail lst)))
            0)))

(define-fun-rec ListAllIntNonNeg ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-IntVal headVal)
                        (>= (ival headVal) 0)))
                 (ListAllIntNonNeg (tail lst)))
            true
            false)))

(define-fun-rec ListAllOp ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-StrVal headVal)
                        (or (= (sval headVal) "+")
                            (= (sval headVal) "-")
                            (= (sval headVal) "*")
                            (= (sval headVal) "//")
                            (= (sval headVal) "**"))))
                 (ListAllOp (tail lst)))
            true
            false)))

(define-fun-rec SafeDivs ((ops Value) (opnds Value)) Bool
  (ite (is-Cons ops)
       (let ((opHead (head ops))
             (opsTail (tail ops))
             (opndsTail (tail opnds)))
         (let ((nextOpnd (ite (is-Cons opndsTail)
                              (head opndsTail)
                              opndsTail)))
           (and (ite (is-StrVal opHead)
                     (ite (= (sval opHead) "//")
                          (not (and (is-IntVal nextOpnd)
                                    (= (ival nextOpnd) 0)))
                          true)
                     true)
                (SafeDivs opsTail opndsTail))))
       true))

; === Inputs ===
(declare-const operator Value)
(declare-const operand Value)

; === BASIC STRUCTURE ===
(assert (IsList operator))
(assert (IsList operand))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList operator) (IsList operand)))
(define-fun C1 () Bool (>= (ListLength operator) 1))
(define-fun C2 () Bool (= (ListLength operand) (+ (ListLength operator) 1)))
(define-fun C3 () Bool (ListAllIntNonNeg operand))
(define-fun C4 () Bool (ListAllOp operator))
(define-fun C5 () Bool (SafeDivs operator operand))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))
(assert C3)
(assert C4)
(assert (not C5))

(check-sat)
(get-model)

------------------------------
  Test Case 29: satisfied_assert_2;assert_3;assert_4, violated_assert_0;assert_1;assert_5
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True, 'assert_3': True, 'assert_4': True, 'assert_5': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_2', 'assert_3', 'assert_4'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_5'], 'total_contracts': 6}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (or (is-Nil lst)
      (and (is-Cons lst)
           (let ((tailVal (tail lst)))
             (IsList tailVal)))))

(define-fun-rec ListLength ((lst Value)) Int
  (ite (is-Nil lst) 0
       (ite (is-Cons lst)
            (+ 1 (ListLength (tail lst)))
            0)))

(define-fun-rec ListAllIntNonNeg ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-IntVal headVal)
                        (>= (ival headVal) 0)))
                 (ListAllIntNonNeg (tail lst)))
            true
            false)))

(define-fun-rec ListAllOp ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-StrVal headVal)
                        (or (= (sval headVal) "+")
                            (= (sval headVal) "-")
                            (= (sval headVal) "*")
                            (= (sval headVal) "//")
                            (= (sval headVal) "**"))))
                 (ListAllOp (tail lst)))
            true
            false)))

(define-fun-rec SafeDivs ((ops Value) (opnds Value)) Bool
  (ite (is-Cons ops)
       (let ((opHead (head ops))
             (opsTail (tail ops))
             (opndsTail (tail opnds)))
         (let ((nextOpnd (ite (is-Cons opndsTail)
                              (head opndsTail)
                              opndsTail)))
           (and (ite (is-StrVal opHead)
                     (ite (= (sval opHead) "//")
                          (not (and (is-IntVal nextOpnd)
                                    (= (ival nextOpnd) 0)))
                          true)
                     true)
                (SafeDivs opsTail opndsTail))))
       true))

; === Inputs ===
(declare-const operator Value)
(declare-const operand Value)

; === BASIC STRUCTURE ===
(assert (IsList operator))
(assert (IsList operand))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList operator) (IsList operand)))
(define-fun C1 () Bool (>= (ListLength operator) 1))
(define-fun C2 () Bool (= (ListLength operand) (+ (ListLength operator) 1)))
(define-fun C3 () Bool (ListAllIntNonNeg operand))
(define-fun C4 () Bool (ListAllOp operator))
(define-fun C5 () Bool (SafeDivs operator operand))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)
(assert C3)
(assert C4)
(assert (not C5))

(check-sat)
(get-model)

------------------------------
  Test Case 30: satisfied_assert_0;assert_2;assert_3;assert_4, violated_assert_1;assert_5
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True, 'assert_3': True, 'assert_4': True, 'assert_5': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2', 'assert_3', 'assert_4'], 'violated_contracts': ['assert_1', 'assert_5'], 'total_contracts': 6}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (or (is-Nil lst)
      (and (is-Cons lst)
           (let ((tailVal (tail lst)))
             (IsList tailVal)))))

(define-fun-rec ListLength ((lst Value)) Int
  (ite (is-Nil lst) 0
       (ite (is-Cons lst)
            (+ 1 (ListLength (tail lst)))
            0)))

(define-fun-rec ListAllIntNonNeg ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-IntVal headVal)
                        (>= (ival headVal) 0)))
                 (ListAllIntNonNeg (tail lst)))
            true
            false)))

(define-fun-rec ListAllOp ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-StrVal headVal)
                        (or (= (sval headVal) "+")
                            (= (sval headVal) "-")
                            (= (sval headVal) "*")
                            (= (sval headVal) "//")
                            (= (sval headVal) "**"))))
                 (ListAllOp (tail lst)))
            true
            false)))

(define-fun-rec SafeDivs ((ops Value) (opnds Value)) Bool
  (ite (is-Cons ops)
       (let ((opHead (head ops))
             (opsTail (tail ops))
             (opndsTail (tail opnds)))
         (let ((nextOpnd (ite (is-Cons opndsTail)
                              (head opndsTail)
                              opndsTail)))
           (and (ite (is-StrVal opHead)
                     (ite (= (sval opHead) "//")
                          (not (and (is-IntVal nextOpnd)
                                    (= (ival nextOpnd) 0)))
                          true)
                     true)
                (SafeDivs opsTail opndsTail))))
       true))

; === Inputs ===
(declare-const operator Value)
(declare-const operand Value)

; === BASIC STRUCTURE ===
(assert (IsList operator))
(assert (IsList operand))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList operator) (IsList operand)))
(define-fun C1 () Bool (>= (ListLength operator) 1))
(define-fun C2 () Bool (= (ListLength operand) (+ (ListLength operator) 1)))
(define-fun C3 () Bool (ListAllIntNonNeg operand))
(define-fun C4 () Bool (ListAllOp operator))
(define-fun C5 () Bool (SafeDivs operator operand))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)
(assert C3)
(assert C4)
(assert (not C5))

(check-sat)
(get-model)

------------------------------
  Test Case 31: satisfied_assert_1;assert_2;assert_3;assert_4, violated_assert_0;assert_5
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True, 'assert_3': True, 'assert_4': True, 'assert_5': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2', 'assert_3', 'assert_4'], 'violated_contracts': ['assert_0', 'assert_5'], 'total_contracts': 6}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (or (is-Nil lst)
      (and (is-Cons lst)
           (let ((tailVal (tail lst)))
             (IsList tailVal)))))

(define-fun-rec ListLength ((lst Value)) Int
  (ite (is-Nil lst) 0
       (ite (is-Cons lst)
            (+ 1 (ListLength (tail lst)))
            0)))

(define-fun-rec ListAllIntNonNeg ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-IntVal headVal)
                        (>= (ival headVal) 0)))
                 (ListAllIntNonNeg (tail lst)))
            true
            false)))

(define-fun-rec ListAllOp ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-StrVal headVal)
                        (or (= (sval headVal) "+")
                            (= (sval headVal) "-")
                            (= (sval headVal) "*")
                            (= (sval headVal) "//")
                            (= (sval headVal) "**"))))
                 (ListAllOp (tail lst)))
            true
            false)))

(define-fun-rec SafeDivs ((ops Value) (opnds Value)) Bool
  (ite (is-Cons ops)
       (let ((opHead (head ops))
             (opsTail (tail ops))
             (opndsTail (tail opnds)))
         (let ((nextOpnd (ite (is-Cons opndsTail)
                              (head opndsTail)
                              opndsTail)))
           (and (ite (is-StrVal opHead)
                     (ite (= (sval opHead) "//")
                          (not (and (is-IntVal nextOpnd)
                                    (= (ival nextOpnd) 0)))
                          true)
                     true)
                (SafeDivs opsTail opndsTail))))
       true))

; === Inputs ===
(declare-const operator Value)
(declare-const operand Value)

; === BASIC STRUCTURE ===
(assert (IsList operator))
(assert (IsList operand))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList operator) (IsList operand)))
(define-fun C1 () Bool (>= (ListLength operator) 1))
(define-fun C2 () Bool (= (ListLength operand) (+ (ListLength operator) 1)))
(define-fun C3 () Bool (ListAllIntNonNeg operand))
(define-fun C4 () Bool (ListAllOp operator))
(define-fun C5 () Bool (SafeDivs operator operand))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)
(assert C3)
(assert C4)
(assert (not C5))

(check-sat)
(get-model)

------------------------------
  Test Case 32: satisfied_assert_0;assert_1;assert_2;assert_3;assert_4, violated_assert_5
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True, 'assert_3': True, 'assert_4': True, 'assert_5': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_3', 'assert_4'], 'violated_contracts': ['assert_5'], 'total_contracts': 6}
  Solutions:
    Solution 1:
      test_case: {'operator': ['//'], 'operand': [5853, 0]}
    Solution 2:
      test_case: {'operand': [5854, 0], 'operator': ['//']}
    Solution 3:
      test_case: {'operand': [5852, 0], 'operator': ['//']}
    Solution 4:
      test_case: {'operand': [2494, 0], 'operator': ['//']}
    Solution 5:
      test_case: {'operand': [3013, 0], 'operator': ['//']}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (or (is-Nil lst)
      (and (is-Cons lst)
           (let ((tailVal (tail lst)))
             (IsList tailVal)))))

(define-fun-rec ListLength ((lst Value)) Int
  (ite (is-Nil lst) 0
       (ite (is-Cons lst)
            (+ 1 (ListLength (tail lst)))
            0)))

(define-fun-rec ListAllIntNonNeg ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-IntVal headVal)
                        (>= (ival headVal) 0)))
                 (ListAllIntNonNeg (tail lst)))
            true
            false)))

(define-fun-rec ListAllOp ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-StrVal headVal)
                        (or (= (sval headVal) "+")
                            (= (sval headVal) "-")
                            (= (sval headVal) "*")
                            (= (sval headVal) "//")
                            (= (sval headVal) "**"))))
                 (ListAllOp (tail lst)))
            true
            false)))

(define-fun-rec SafeDivs ((ops Value) (opnds Value)) Bool
  (ite (is-Cons ops)
       (let ((opHead (head ops))
             (opsTail (tail ops))
             (opndsTail (tail opnds)))
         (let ((nextOpnd (ite (is-Cons opndsTail)
                              (head opndsTail)
                              opndsTail)))
           (and (ite (is-StrVal opHead)
                     (ite (= (sval opHead) "//")
                          (not (and (is-IntVal nextOpnd)
                                    (= (ival nextOpnd) 0)))
                          true)
                     true)
                (SafeDivs opsTail opndsTail))))
       true))

; === Inputs ===
(declare-const operator Value)
(declare-const operand Value)

; === BASIC STRUCTURE ===
(assert (IsList operator))
(assert (IsList operand))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList operator) (IsList operand)))
(define-fun C1 () Bool (>= (ListLength operator) 1))
(define-fun C2 () Bool (= (ListLength operand) (+ (ListLength operator) 1)))
(define-fun C3 () Bool (ListAllIntNonNeg operand))
(define-fun C4 () Bool (ListAllOp operator))
(define-fun C5 () Bool (SafeDivs operator operand))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)
(assert C3)
(assert C4)
(assert (not C5))

(check-sat)
(get-model)

------------------------------
  Test Case 33: satisfied_assert_5, violated_assert_0;assert_1;assert_2;assert_3;assert_4
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False, 'assert_3': False, 'assert_4': False, 'assert_5': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_5'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_3', 'assert_4'], 'total_contracts': 6}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (or (is-Nil lst)
      (and (is-Cons lst)
           (let ((tailVal (tail lst)))
             (IsList tailVal)))))

(define-fun-rec ListLength ((lst Value)) Int
  (ite (is-Nil lst) 0
       (ite (is-Cons lst)
            (+ 1 (ListLength (tail lst)))
            0)))

(define-fun-rec ListAllIntNonNeg ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-IntVal headVal)
                        (>= (ival headVal) 0)))
                 (ListAllIntNonNeg (tail lst)))
            true
            false)))

(define-fun-rec ListAllOp ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-StrVal headVal)
                        (or (= (sval headVal) "+")
                            (= (sval headVal) "-")
                            (= (sval headVal) "*")
                            (= (sval headVal) "//")
                            (= (sval headVal) "**"))))
                 (ListAllOp (tail lst)))
            true
            false)))

(define-fun-rec SafeDivs ((ops Value) (opnds Value)) Bool
  (ite (is-Cons ops)
       (let ((opHead (head ops))
             (opsTail (tail ops))
             (opndsTail (tail opnds)))
         (let ((nextOpnd (ite (is-Cons opndsTail)
                              (head opndsTail)
                              opndsTail)))
           (and (ite (is-StrVal opHead)
                     (ite (= (sval opHead) "//")
                          (not (and (is-IntVal nextOpnd)
                                    (= (ival nextOpnd) 0)))
                          true)
                     true)
                (SafeDivs opsTail opndsTail))))
       true))

; === Inputs ===
(declare-const operator Value)
(declare-const operand Value)

; === BASIC STRUCTURE ===
(assert (IsList operator))
(assert (IsList operand))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList operator) (IsList operand)))
(define-fun C1 () Bool (>= (ListLength operator) 1))
(define-fun C2 () Bool (= (ListLength operand) (+ (ListLength operator) 1)))
(define-fun C3 () Bool (ListAllIntNonNeg operand))
(define-fun C4 () Bool (ListAllOp operator))
(define-fun C5 () Bool (SafeDivs operator operand))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))
(assert (not C3))
(assert (not C4))
(assert C5)

(check-sat)
(get-model)

------------------------------
  Test Case 34: satisfied_assert_0;assert_5, violated_assert_1;assert_2;assert_3;assert_4
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False, 'assert_3': False, 'assert_4': False, 'assert_5': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_5'], 'violated_contracts': ['assert_1', 'assert_2', 'assert_3', 'assert_4'], 'total_contracts': 6}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (or (is-Nil lst)
      (and (is-Cons lst)
           (let ((tailVal (tail lst)))
             (IsList tailVal)))))

(define-fun-rec ListLength ((lst Value)) Int
  (ite (is-Nil lst) 0
       (ite (is-Cons lst)
            (+ 1 (ListLength (tail lst)))
            0)))

(define-fun-rec ListAllIntNonNeg ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-IntVal headVal)
                        (>= (ival headVal) 0)))
                 (ListAllIntNonNeg (tail lst)))
            true
            false)))

(define-fun-rec ListAllOp ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-StrVal headVal)
                        (or (= (sval headVal) "+")
                            (= (sval headVal) "-")
                            (= (sval headVal) "*")
                            (= (sval headVal) "//")
                            (= (sval headVal) "**"))))
                 (ListAllOp (tail lst)))
            true
            false)))

(define-fun-rec SafeDivs ((ops Value) (opnds Value)) Bool
  (ite (is-Cons ops)
       (let ((opHead (head ops))
             (opsTail (tail ops))
             (opndsTail (tail opnds)))
         (let ((nextOpnd (ite (is-Cons opndsTail)
                              (head opndsTail)
                              opndsTail)))
           (and (ite (is-StrVal opHead)
                     (ite (= (sval opHead) "//")
                          (not (and (is-IntVal nextOpnd)
                                    (= (ival nextOpnd) 0)))
                          true)
                     true)
                (SafeDivs opsTail opndsTail))))
       true))

; === Inputs ===
(declare-const operator Value)
(declare-const operand Value)

; === BASIC STRUCTURE ===
(assert (IsList operator))
(assert (IsList operand))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList operator) (IsList operand)))
(define-fun C1 () Bool (>= (ListLength operator) 1))
(define-fun C2 () Bool (= (ListLength operand) (+ (ListLength operator) 1)))
(define-fun C3 () Bool (ListAllIntNonNeg operand))
(define-fun C4 () Bool (ListAllOp operator))
(define-fun C5 () Bool (SafeDivs operator operand))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))
(assert (not C3))
(assert (not C4))
(assert C5)

(check-sat)
(get-model)

------------------------------
  Test Case 35: satisfied_assert_1;assert_5, violated_assert_0;assert_2;assert_3;assert_4
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False, 'assert_3': False, 'assert_4': False, 'assert_5': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_5'], 'violated_contracts': ['assert_0', 'assert_2', 'assert_3', 'assert_4'], 'total_contracts': 6}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (or (is-Nil lst)
      (and (is-Cons lst)
           (let ((tailVal (tail lst)))
             (IsList tailVal)))))

(define-fun-rec ListLength ((lst Value)) Int
  (ite (is-Nil lst) 0
       (ite (is-Cons lst)
            (+ 1 (ListLength (tail lst)))
            0)))

(define-fun-rec ListAllIntNonNeg ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-IntVal headVal)
                        (>= (ival headVal) 0)))
                 (ListAllIntNonNeg (tail lst)))
            true
            false)))

(define-fun-rec ListAllOp ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-StrVal headVal)
                        (or (= (sval headVal) "+")
                            (= (sval headVal) "-")
                            (= (sval headVal) "*")
                            (= (sval headVal) "//")
                            (= (sval headVal) "**"))))
                 (ListAllOp (tail lst)))
            true
            false)))

(define-fun-rec SafeDivs ((ops Value) (opnds Value)) Bool
  (ite (is-Cons ops)
       (let ((opHead (head ops))
             (opsTail (tail ops))
             (opndsTail (tail opnds)))
         (let ((nextOpnd (ite (is-Cons opndsTail)
                              (head opndsTail)
                              opndsTail)))
           (and (ite (is-StrVal opHead)
                     (ite (= (sval opHead) "//")
                          (not (and (is-IntVal nextOpnd)
                                    (= (ival nextOpnd) 0)))
                          true)
                     true)
                (SafeDivs opsTail opndsTail))))
       true))

; === Inputs ===
(declare-const operator Value)
(declare-const operand Value)

; === BASIC STRUCTURE ===
(assert (IsList operator))
(assert (IsList operand))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList operator) (IsList operand)))
(define-fun C1 () Bool (>= (ListLength operator) 1))
(define-fun C2 () Bool (= (ListLength operand) (+ (ListLength operator) 1)))
(define-fun C3 () Bool (ListAllIntNonNeg operand))
(define-fun C4 () Bool (ListAllOp operator))
(define-fun C5 () Bool (SafeDivs operator operand))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))
(assert (not C3))
(assert (not C4))
(assert C5)

(check-sat)
(get-model)

------------------------------
  Test Case 36: satisfied_assert_0;assert_1;assert_5, violated_assert_2;assert_3;assert_4
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False, 'assert_3': False, 'assert_4': False, 'assert_5': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_5'], 'violated_contracts': ['assert_2', 'assert_3', 'assert_4'], 'total_contracts': 6}
  Solutions:
    Solution 1:
      test_case: {'operator': [3.0], 'operand': [2.0]}
    Solution 2:
      test_case: {'operand': [4.0], 'operator': [5.0]}
    Solution 3:
      test_case: {'operand': [7.0], 'operator': [6.0]}
    Solution 4:
      test_case: {'operand': [9.0], 'operator': [8.0]}
    Solution 5:
      test_case: {'operand': [11.0], 'operator': [10.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (or (is-Nil lst)
      (and (is-Cons lst)
           (let ((tailVal (tail lst)))
             (IsList tailVal)))))

(define-fun-rec ListLength ((lst Value)) Int
  (ite (is-Nil lst) 0
       (ite (is-Cons lst)
            (+ 1 (ListLength (tail lst)))
            0)))

(define-fun-rec ListAllIntNonNeg ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-IntVal headVal)
                        (>= (ival headVal) 0)))
                 (ListAllIntNonNeg (tail lst)))
            true
            false)))

(define-fun-rec ListAllOp ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-StrVal headVal)
                        (or (= (sval headVal) "+")
                            (= (sval headVal) "-")
                            (= (sval headVal) "*")
                            (= (sval headVal) "//")
                            (= (sval headVal) "**"))))
                 (ListAllOp (tail lst)))
            true
            false)))

(define-fun-rec SafeDivs ((ops Value) (opnds Value)) Bool
  (ite (is-Cons ops)
       (let ((opHead (head ops))
             (opsTail (tail ops))
             (opndsTail (tail opnds)))
         (let ((nextOpnd (ite (is-Cons opndsTail)
                              (head opndsTail)
                              opndsTail)))
           (and (ite (is-StrVal opHead)
                     (ite (= (sval opHead) "//")
                          (not (and (is-IntVal nextOpnd)
                                    (= (ival nextOpnd) 0)))
                          true)
                     true)
                (SafeDivs opsTail opndsTail))))
       true))

; === Inputs ===
(declare-const operator Value)
(declare-const operand Value)

; === BASIC STRUCTURE ===
(assert (IsList operator))
(assert (IsList operand))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList operator) (IsList operand)))
(define-fun C1 () Bool (>= (ListLength operator) 1))
(define-fun C2 () Bool (= (ListLength operand) (+ (ListLength operator) 1)))
(define-fun C3 () Bool (ListAllIntNonNeg operand))
(define-fun C4 () Bool (ListAllOp operator))
(define-fun C5 () Bool (SafeDivs operator operand))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))
(assert (not C3))
(assert (not C4))
(assert C5)

(check-sat)
(get-model)

------------------------------
  Test Case 37: satisfied_assert_2;assert_5, violated_assert_0;assert_1;assert_3;assert_4
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True, 'assert_3': False, 'assert_4': False, 'assert_5': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_2', 'assert_5'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_3', 'assert_4'], 'total_contracts': 6}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (or (is-Nil lst)
      (and (is-Cons lst)
           (let ((tailVal (tail lst)))
             (IsList tailVal)))))

(define-fun-rec ListLength ((lst Value)) Int
  (ite (is-Nil lst) 0
       (ite (is-Cons lst)
            (+ 1 (ListLength (tail lst)))
            0)))

(define-fun-rec ListAllIntNonNeg ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-IntVal headVal)
                        (>= (ival headVal) 0)))
                 (ListAllIntNonNeg (tail lst)))
            true
            false)))

(define-fun-rec ListAllOp ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-StrVal headVal)
                        (or (= (sval headVal) "+")
                            (= (sval headVal) "-")
                            (= (sval headVal) "*")
                            (= (sval headVal) "//")
                            (= (sval headVal) "**"))))
                 (ListAllOp (tail lst)))
            true
            false)))

(define-fun-rec SafeDivs ((ops Value) (opnds Value)) Bool
  (ite (is-Cons ops)
       (let ((opHead (head ops))
             (opsTail (tail ops))
             (opndsTail (tail opnds)))
         (let ((nextOpnd (ite (is-Cons opndsTail)
                              (head opndsTail)
                              opndsTail)))
           (and (ite (is-StrVal opHead)
                     (ite (= (sval opHead) "//")
                          (not (and (is-IntVal nextOpnd)
                                    (= (ival nextOpnd) 0)))
                          true)
                     true)
                (SafeDivs opsTail opndsTail))))
       true))

; === Inputs ===
(declare-const operator Value)
(declare-const operand Value)

; === BASIC STRUCTURE ===
(assert (IsList operator))
(assert (IsList operand))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList operator) (IsList operand)))
(define-fun C1 () Bool (>= (ListLength operator) 1))
(define-fun C2 () Bool (= (ListLength operand) (+ (ListLength operator) 1)))
(define-fun C3 () Bool (ListAllIntNonNeg operand))
(define-fun C4 () Bool (ListAllOp operator))
(define-fun C5 () Bool (SafeDivs operator operand))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)
(assert (not C3))
(assert (not C4))
(assert C5)

(check-sat)
(get-model)

------------------------------
  Test Case 38: satisfied_assert_0;assert_2;assert_5, violated_assert_1;assert_3;assert_4
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True, 'assert_3': False, 'assert_4': False, 'assert_5': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2', 'assert_5'], 'violated_contracts': ['assert_1', 'assert_3', 'assert_4'], 'total_contracts': 6}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (or (is-Nil lst)
      (and (is-Cons lst)
           (let ((tailVal (tail lst)))
             (IsList tailVal)))))

(define-fun-rec ListLength ((lst Value)) Int
  (ite (is-Nil lst) 0
       (ite (is-Cons lst)
            (+ 1 (ListLength (tail lst)))
            0)))

(define-fun-rec ListAllIntNonNeg ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-IntVal headVal)
                        (>= (ival headVal) 0)))
                 (ListAllIntNonNeg (tail lst)))
            true
            false)))

(define-fun-rec ListAllOp ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-StrVal headVal)
                        (or (= (sval headVal) "+")
                            (= (sval headVal) "-")
                            (= (sval headVal) "*")
                            (= (sval headVal) "//")
                            (= (sval headVal) "**"))))
                 (ListAllOp (tail lst)))
            true
            false)))

(define-fun-rec SafeDivs ((ops Value) (opnds Value)) Bool
  (ite (is-Cons ops)
       (let ((opHead (head ops))
             (opsTail (tail ops))
             (opndsTail (tail opnds)))
         (let ((nextOpnd (ite (is-Cons opndsTail)
                              (head opndsTail)
                              opndsTail)))
           (and (ite (is-StrVal opHead)
                     (ite (= (sval opHead) "//")
                          (not (and (is-IntVal nextOpnd)
                                    (= (ival nextOpnd) 0)))
                          true)
                     true)
                (SafeDivs opsTail opndsTail))))
       true))

; === Inputs ===
(declare-const operator Value)
(declare-const operand Value)

; === BASIC STRUCTURE ===
(assert (IsList operator))
(assert (IsList operand))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList operator) (IsList operand)))
(define-fun C1 () Bool (>= (ListLength operator) 1))
(define-fun C2 () Bool (= (ListLength operand) (+ (ListLength operator) 1)))
(define-fun C3 () Bool (ListAllIntNonNeg operand))
(define-fun C4 () Bool (ListAllOp operator))
(define-fun C5 () Bool (SafeDivs operator operand))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)
(assert (not C3))
(assert (not C4))
(assert C5)

(check-sat)
(get-model)

------------------------------
  Test Case 39: satisfied_assert_1;assert_2;assert_5, violated_assert_0;assert_3;assert_4
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True, 'assert_3': False, 'assert_4': False, 'assert_5': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2', 'assert_5'], 'violated_contracts': ['assert_0', 'assert_3', 'assert_4'], 'total_contracts': 6}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (or (is-Nil lst)
      (and (is-Cons lst)
           (let ((tailVal (tail lst)))
             (IsList tailVal)))))

(define-fun-rec ListLength ((lst Value)) Int
  (ite (is-Nil lst) 0
       (ite (is-Cons lst)
            (+ 1 (ListLength (tail lst)))
            0)))

(define-fun-rec ListAllIntNonNeg ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-IntVal headVal)
                        (>= (ival headVal) 0)))
                 (ListAllIntNonNeg (tail lst)))
            true
            false)))

(define-fun-rec ListAllOp ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-StrVal headVal)
                        (or (= (sval headVal) "+")
                            (= (sval headVal) "-")
                            (= (sval headVal) "*")
                            (= (sval headVal) "//")
                            (= (sval headVal) "**"))))
                 (ListAllOp (tail lst)))
            true
            false)))

(define-fun-rec SafeDivs ((ops Value) (opnds Value)) Bool
  (ite (is-Cons ops)
       (let ((opHead (head ops))
             (opsTail (tail ops))
             (opndsTail (tail opnds)))
         (let ((nextOpnd (ite (is-Cons opndsTail)
                              (head opndsTail)
                              opndsTail)))
           (and (ite (is-StrVal opHead)
                     (ite (= (sval opHead) "//")
                          (not (and (is-IntVal nextOpnd)
                                    (= (ival nextOpnd) 0)))
                          true)
                     true)
                (SafeDivs opsTail opndsTail))))
       true))

; === Inputs ===
(declare-const operator Value)
(declare-const operand Value)

; === BASIC STRUCTURE ===
(assert (IsList operator))
(assert (IsList operand))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList operator) (IsList operand)))
(define-fun C1 () Bool (>= (ListLength operator) 1))
(define-fun C2 () Bool (= (ListLength operand) (+ (ListLength operator) 1)))
(define-fun C3 () Bool (ListAllIntNonNeg operand))
(define-fun C4 () Bool (ListAllOp operator))
(define-fun C5 () Bool (SafeDivs operator operand))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)
(assert (not C3))
(assert (not C4))
(assert C5)

(check-sat)
(get-model)

------------------------------
  Test Case 40: satisfied_assert_0;assert_1;assert_2;assert_5, violated_assert_3;assert_4
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True, 'assert_3': False, 'assert_4': False, 'assert_5': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_5'], 'violated_contracts': ['assert_3', 'assert_4'], 'total_contracts': 6}
  Solutions:
    Solution 1:
      test_case: {'operator': [3.0], 'operand': [4.0, 2.0]}
    Solution 2:
      test_case: {'operand': [7.0, 6.0], 'operator': [5.0]}
    Solution 3:
      test_case: {'operand': [8.0, 10.0], 'operator': [9.0]}
    Solution 4:
      test_case: {'operand': [11.0, 12.0], 'operator': [13.0]}
    Solution 5:
      test_case: {'operand': [16.0, 14.0], 'operator': [15.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (or (is-Nil lst)
      (and (is-Cons lst)
           (let ((tailVal (tail lst)))
             (IsList tailVal)))))

(define-fun-rec ListLength ((lst Value)) Int
  (ite (is-Nil lst) 0
       (ite (is-Cons lst)
            (+ 1 (ListLength (tail lst)))
            0)))

(define-fun-rec ListAllIntNonNeg ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-IntVal headVal)
                        (>= (ival headVal) 0)))
                 (ListAllIntNonNeg (tail lst)))
            true
            false)))

(define-fun-rec ListAllOp ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-StrVal headVal)
                        (or (= (sval headVal) "+")
                            (= (sval headVal) "-")
                            (= (sval headVal) "*")
                            (= (sval headVal) "//")
                            (= (sval headVal) "**"))))
                 (ListAllOp (tail lst)))
            true
            false)))

(define-fun-rec SafeDivs ((ops Value) (opnds Value)) Bool
  (ite (is-Cons ops)
       (let ((opHead (head ops))
             (opsTail (tail ops))
             (opndsTail (tail opnds)))
         (let ((nextOpnd (ite (is-Cons opndsTail)
                              (head opndsTail)
                              opndsTail)))
           (and (ite (is-StrVal opHead)
                     (ite (= (sval opHead) "//")
                          (not (and (is-IntVal nextOpnd)
                                    (= (ival nextOpnd) 0)))
                          true)
                     true)
                (SafeDivs opsTail opndsTail))))
       true))

; === Inputs ===
(declare-const operator Value)
(declare-const operand Value)

; === BASIC STRUCTURE ===
(assert (IsList operator))
(assert (IsList operand))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList operator) (IsList operand)))
(define-fun C1 () Bool (>= (ListLength operator) 1))
(define-fun C2 () Bool (= (ListLength operand) (+ (ListLength operator) 1)))
(define-fun C3 () Bool (ListAllIntNonNeg operand))
(define-fun C4 () Bool (ListAllOp operator))
(define-fun C5 () Bool (SafeDivs operator operand))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)
(assert (not C3))
(assert (not C4))
(assert C5)

(check-sat)
(get-model)

------------------------------
  Test Case 41: satisfied_assert_3;assert_5, violated_assert_0;assert_1;assert_2;assert_4
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False, 'assert_3': True, 'assert_4': False, 'assert_5': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_3', 'assert_5'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_4'], 'total_contracts': 6}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (or (is-Nil lst)
      (and (is-Cons lst)
           (let ((tailVal (tail lst)))
             (IsList tailVal)))))

(define-fun-rec ListLength ((lst Value)) Int
  (ite (is-Nil lst) 0
       (ite (is-Cons lst)
            (+ 1 (ListLength (tail lst)))
            0)))

(define-fun-rec ListAllIntNonNeg ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-IntVal headVal)
                        (>= (ival headVal) 0)))
                 (ListAllIntNonNeg (tail lst)))
            true
            false)))

(define-fun-rec ListAllOp ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-StrVal headVal)
                        (or (= (sval headVal) "+")
                            (= (sval headVal) "-")
                            (= (sval headVal) "*")
                            (= (sval headVal) "//")
                            (= (sval headVal) "**"))))
                 (ListAllOp (tail lst)))
            true
            false)))

(define-fun-rec SafeDivs ((ops Value) (opnds Value)) Bool
  (ite (is-Cons ops)
       (let ((opHead (head ops))
             (opsTail (tail ops))
             (opndsTail (tail opnds)))
         (let ((nextOpnd (ite (is-Cons opndsTail)
                              (head opndsTail)
                              opndsTail)))
           (and (ite (is-StrVal opHead)
                     (ite (= (sval opHead) "//")
                          (not (and (is-IntVal nextOpnd)
                                    (= (ival nextOpnd) 0)))
                          true)
                     true)
                (SafeDivs opsTail opndsTail))))
       true))

; === Inputs ===
(declare-const operator Value)
(declare-const operand Value)

; === BASIC STRUCTURE ===
(assert (IsList operator))
(assert (IsList operand))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList operator) (IsList operand)))
(define-fun C1 () Bool (>= (ListLength operator) 1))
(define-fun C2 () Bool (= (ListLength operand) (+ (ListLength operator) 1)))
(define-fun C3 () Bool (ListAllIntNonNeg operand))
(define-fun C4 () Bool (ListAllOp operator))
(define-fun C5 () Bool (SafeDivs operator operand))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))
(assert C3)
(assert (not C4))
(assert C5)

(check-sat)
(get-model)

------------------------------
  Test Case 42: satisfied_assert_0;assert_3;assert_5, violated_assert_1;assert_2;assert_4
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False, 'assert_3': True, 'assert_4': False, 'assert_5': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_3', 'assert_5'], 'violated_contracts': ['assert_1', 'assert_2', 'assert_4'], 'total_contracts': 6}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (or (is-Nil lst)
      (and (is-Cons lst)
           (let ((tailVal (tail lst)))
             (IsList tailVal)))))

(define-fun-rec ListLength ((lst Value)) Int
  (ite (is-Nil lst) 0
       (ite (is-Cons lst)
            (+ 1 (ListLength (tail lst)))
            0)))

(define-fun-rec ListAllIntNonNeg ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-IntVal headVal)
                        (>= (ival headVal) 0)))
                 (ListAllIntNonNeg (tail lst)))
            true
            false)))

(define-fun-rec ListAllOp ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-StrVal headVal)
                        (or (= (sval headVal) "+")
                            (= (sval headVal) "-")
                            (= (sval headVal) "*")
                            (= (sval headVal) "//")
                            (= (sval headVal) "**"))))
                 (ListAllOp (tail lst)))
            true
            false)))

(define-fun-rec SafeDivs ((ops Value) (opnds Value)) Bool
  (ite (is-Cons ops)
       (let ((opHead (head ops))
             (opsTail (tail ops))
             (opndsTail (tail opnds)))
         (let ((nextOpnd (ite (is-Cons opndsTail)
                              (head opndsTail)
                              opndsTail)))
           (and (ite (is-StrVal opHead)
                     (ite (= (sval opHead) "//")
                          (not (and (is-IntVal nextOpnd)
                                    (= (ival nextOpnd) 0)))
                          true)
                     true)
                (SafeDivs opsTail opndsTail))))
       true))

; === Inputs ===
(declare-const operator Value)
(declare-const operand Value)

; === BASIC STRUCTURE ===
(assert (IsList operator))
(assert (IsList operand))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList operator) (IsList operand)))
(define-fun C1 () Bool (>= (ListLength operator) 1))
(define-fun C2 () Bool (= (ListLength operand) (+ (ListLength operator) 1)))
(define-fun C3 () Bool (ListAllIntNonNeg operand))
(define-fun C4 () Bool (ListAllOp operator))
(define-fun C5 () Bool (SafeDivs operator operand))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))
(assert C3)
(assert (not C4))
(assert C5)

(check-sat)
(get-model)

------------------------------
  Test Case 43: satisfied_assert_1;assert_3;assert_5, violated_assert_0;assert_2;assert_4
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False, 'assert_3': True, 'assert_4': False, 'assert_5': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_3', 'assert_5'], 'violated_contracts': ['assert_0', 'assert_2', 'assert_4'], 'total_contracts': 6}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (or (is-Nil lst)
      (and (is-Cons lst)
           (let ((tailVal (tail lst)))
             (IsList tailVal)))))

(define-fun-rec ListLength ((lst Value)) Int
  (ite (is-Nil lst) 0
       (ite (is-Cons lst)
            (+ 1 (ListLength (tail lst)))
            0)))

(define-fun-rec ListAllIntNonNeg ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-IntVal headVal)
                        (>= (ival headVal) 0)))
                 (ListAllIntNonNeg (tail lst)))
            true
            false)))

(define-fun-rec ListAllOp ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-StrVal headVal)
                        (or (= (sval headVal) "+")
                            (= (sval headVal) "-")
                            (= (sval headVal) "*")
                            (= (sval headVal) "//")
                            (= (sval headVal) "**"))))
                 (ListAllOp (tail lst)))
            true
            false)))

(define-fun-rec SafeDivs ((ops Value) (opnds Value)) Bool
  (ite (is-Cons ops)
       (let ((opHead (head ops))
             (opsTail (tail ops))
             (opndsTail (tail opnds)))
         (let ((nextOpnd (ite (is-Cons opndsTail)
                              (head opndsTail)
                              opndsTail)))
           (and (ite (is-StrVal opHead)
                     (ite (= (sval opHead) "//")
                          (not (and (is-IntVal nextOpnd)
                                    (= (ival nextOpnd) 0)))
                          true)
                     true)
                (SafeDivs opsTail opndsTail))))
       true))

; === Inputs ===
(declare-const operator Value)
(declare-const operand Value)

; === BASIC STRUCTURE ===
(assert (IsList operator))
(assert (IsList operand))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList operator) (IsList operand)))
(define-fun C1 () Bool (>= (ListLength operator) 1))
(define-fun C2 () Bool (= (ListLength operand) (+ (ListLength operator) 1)))
(define-fun C3 () Bool (ListAllIntNonNeg operand))
(define-fun C4 () Bool (ListAllOp operator))
(define-fun C5 () Bool (SafeDivs operator operand))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))
(assert C3)
(assert (not C4))
(assert C5)

(check-sat)
(get-model)

------------------------------
  Test Case 44: satisfied_assert_0;assert_1;assert_3;assert_5, violated_assert_2;assert_4
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False, 'assert_3': True, 'assert_4': False, 'assert_5': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_3', 'assert_5'], 'violated_contracts': ['assert_2', 'assert_4'], 'total_contracts': 6}
  Solutions:
    Solution 1:
      test_case: {'operator': [2.0], 'operand': []}
    Solution 2:
      test_case: {'operand': [], 'operator': [3.0]}
    Solution 3:
      test_case: {'operand': [], 'operator': [5.0]}
    Solution 4:
      test_case: {'operator': [7.0], 'operand': []}
    Solution 5:
      test_case: {'operand': [], 'operator': [6.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (or (is-Nil lst)
      (and (is-Cons lst)
           (let ((tailVal (tail lst)))
             (IsList tailVal)))))

(define-fun-rec ListLength ((lst Value)) Int
  (ite (is-Nil lst) 0
       (ite (is-Cons lst)
            (+ 1 (ListLength (tail lst)))
            0)))

(define-fun-rec ListAllIntNonNeg ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-IntVal headVal)
                        (>= (ival headVal) 0)))
                 (ListAllIntNonNeg (tail lst)))
            true
            false)))

(define-fun-rec ListAllOp ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-StrVal headVal)
                        (or (= (sval headVal) "+")
                            (= (sval headVal) "-")
                            (= (sval headVal) "*")
                            (= (sval headVal) "//")
                            (= (sval headVal) "**"))))
                 (ListAllOp (tail lst)))
            true
            false)))

(define-fun-rec SafeDivs ((ops Value) (opnds Value)) Bool
  (ite (is-Cons ops)
       (let ((opHead (head ops))
             (opsTail (tail ops))
             (opndsTail (tail opnds)))
         (let ((nextOpnd (ite (is-Cons opndsTail)
                              (head opndsTail)
                              opndsTail)))
           (and (ite (is-StrVal opHead)
                     (ite (= (sval opHead) "//")
                          (not (and (is-IntVal nextOpnd)
                                    (= (ival nextOpnd) 0)))
                          true)
                     true)
                (SafeDivs opsTail opndsTail))))
       true))

; === Inputs ===
(declare-const operator Value)
(declare-const operand Value)

; === BASIC STRUCTURE ===
(assert (IsList operator))
(assert (IsList operand))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList operator) (IsList operand)))
(define-fun C1 () Bool (>= (ListLength operator) 1))
(define-fun C2 () Bool (= (ListLength operand) (+ (ListLength operator) 1)))
(define-fun C3 () Bool (ListAllIntNonNeg operand))
(define-fun C4 () Bool (ListAllOp operator))
(define-fun C5 () Bool (SafeDivs operator operand))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))
(assert C3)
(assert (not C4))
(assert C5)

(check-sat)
(get-model)

------------------------------
  Test Case 45: satisfied_assert_2;assert_3;assert_5, violated_assert_0;assert_1;assert_4
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True, 'assert_3': True, 'assert_4': False, 'assert_5': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_2', 'assert_3', 'assert_5'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_4'], 'total_contracts': 6}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (or (is-Nil lst)
      (and (is-Cons lst)
           (let ((tailVal (tail lst)))
             (IsList tailVal)))))

(define-fun-rec ListLength ((lst Value)) Int
  (ite (is-Nil lst) 0
       (ite (is-Cons lst)
            (+ 1 (ListLength (tail lst)))
            0)))

(define-fun-rec ListAllIntNonNeg ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-IntVal headVal)
                        (>= (ival headVal) 0)))
                 (ListAllIntNonNeg (tail lst)))
            true
            false)))

(define-fun-rec ListAllOp ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-StrVal headVal)
                        (or (= (sval headVal) "+")
                            (= (sval headVal) "-")
                            (= (sval headVal) "*")
                            (= (sval headVal) "//")
                            (= (sval headVal) "**"))))
                 (ListAllOp (tail lst)))
            true
            false)))

(define-fun-rec SafeDivs ((ops Value) (opnds Value)) Bool
  (ite (is-Cons ops)
       (let ((opHead (head ops))
             (opsTail (tail ops))
             (opndsTail (tail opnds)))
         (let ((nextOpnd (ite (is-Cons opndsTail)
                              (head opndsTail)
                              opndsTail)))
           (and (ite (is-StrVal opHead)
                     (ite (= (sval opHead) "//")
                          (not (and (is-IntVal nextOpnd)
                                    (= (ival nextOpnd) 0)))
                          true)
                     true)
                (SafeDivs opsTail opndsTail))))
       true))

; === Inputs ===
(declare-const operator Value)
(declare-const operand Value)

; === BASIC STRUCTURE ===
(assert (IsList operator))
(assert (IsList operand))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList operator) (IsList operand)))
(define-fun C1 () Bool (>= (ListLength operator) 1))
(define-fun C2 () Bool (= (ListLength operand) (+ (ListLength operator) 1)))
(define-fun C3 () Bool (ListAllIntNonNeg operand))
(define-fun C4 () Bool (ListAllOp operator))
(define-fun C5 () Bool (SafeDivs operator operand))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)
(assert C3)
(assert (not C4))
(assert C5)

(check-sat)
(get-model)

------------------------------
  Test Case 46: satisfied_assert_0;assert_2;assert_3;assert_5, violated_assert_1;assert_4
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True, 'assert_3': True, 'assert_4': False, 'assert_5': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2', 'assert_3', 'assert_5'], 'violated_contracts': ['assert_1', 'assert_4'], 'total_contracts': 6}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (or (is-Nil lst)
      (and (is-Cons lst)
           (let ((tailVal (tail lst)))
             (IsList tailVal)))))

(define-fun-rec ListLength ((lst Value)) Int
  (ite (is-Nil lst) 0
       (ite (is-Cons lst)
            (+ 1 (ListLength (tail lst)))
            0)))

(define-fun-rec ListAllIntNonNeg ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-IntVal headVal)
                        (>= (ival headVal) 0)))
                 (ListAllIntNonNeg (tail lst)))
            true
            false)))

(define-fun-rec ListAllOp ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-StrVal headVal)
                        (or (= (sval headVal) "+")
                            (= (sval headVal) "-")
                            (= (sval headVal) "*")
                            (= (sval headVal) "//")
                            (= (sval headVal) "**"))))
                 (ListAllOp (tail lst)))
            true
            false)))

(define-fun-rec SafeDivs ((ops Value) (opnds Value)) Bool
  (ite (is-Cons ops)
       (let ((opHead (head ops))
             (opsTail (tail ops))
             (opndsTail (tail opnds)))
         (let ((nextOpnd (ite (is-Cons opndsTail)
                              (head opndsTail)
                              opndsTail)))
           (and (ite (is-StrVal opHead)
                     (ite (= (sval opHead) "//")
                          (not (and (is-IntVal nextOpnd)
                                    (= (ival nextOpnd) 0)))
                          true)
                     true)
                (SafeDivs opsTail opndsTail))))
       true))

; === Inputs ===
(declare-const operator Value)
(declare-const operand Value)

; === BASIC STRUCTURE ===
(assert (IsList operator))
(assert (IsList operand))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList operator) (IsList operand)))
(define-fun C1 () Bool (>= (ListLength operator) 1))
(define-fun C2 () Bool (= (ListLength operand) (+ (ListLength operator) 1)))
(define-fun C3 () Bool (ListAllIntNonNeg operand))
(define-fun C4 () Bool (ListAllOp operator))
(define-fun C5 () Bool (SafeDivs operator operand))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)
(assert C3)
(assert (not C4))
(assert C5)

(check-sat)
(get-model)

------------------------------
  Test Case 47: satisfied_assert_1;assert_2;assert_3;assert_5, violated_assert_0;assert_4
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True, 'assert_3': True, 'assert_4': False, 'assert_5': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2', 'assert_3', 'assert_5'], 'violated_contracts': ['assert_0', 'assert_4'], 'total_contracts': 6}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (or (is-Nil lst)
      (and (is-Cons lst)
           (let ((tailVal (tail lst)))
             (IsList tailVal)))))

(define-fun-rec ListLength ((lst Value)) Int
  (ite (is-Nil lst) 0
       (ite (is-Cons lst)
            (+ 1 (ListLength (tail lst)))
            0)))

(define-fun-rec ListAllIntNonNeg ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-IntVal headVal)
                        (>= (ival headVal) 0)))
                 (ListAllIntNonNeg (tail lst)))
            true
            false)))

(define-fun-rec ListAllOp ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-StrVal headVal)
                        (or (= (sval headVal) "+")
                            (= (sval headVal) "-")
                            (= (sval headVal) "*")
                            (= (sval headVal) "//")
                            (= (sval headVal) "**"))))
                 (ListAllOp (tail lst)))
            true
            false)))

(define-fun-rec SafeDivs ((ops Value) (opnds Value)) Bool
  (ite (is-Cons ops)
       (let ((opHead (head ops))
             (opsTail (tail ops))
             (opndsTail (tail opnds)))
         (let ((nextOpnd (ite (is-Cons opndsTail)
                              (head opndsTail)
                              opndsTail)))
           (and (ite (is-StrVal opHead)
                     (ite (= (sval opHead) "//")
                          (not (and (is-IntVal nextOpnd)
                                    (= (ival nextOpnd) 0)))
                          true)
                     true)
                (SafeDivs opsTail opndsTail))))
       true))

; === Inputs ===
(declare-const operator Value)
(declare-const operand Value)

; === BASIC STRUCTURE ===
(assert (IsList operator))
(assert (IsList operand))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList operator) (IsList operand)))
(define-fun C1 () Bool (>= (ListLength operator) 1))
(define-fun C2 () Bool (= (ListLength operand) (+ (ListLength operator) 1)))
(define-fun C3 () Bool (ListAllIntNonNeg operand))
(define-fun C4 () Bool (ListAllOp operator))
(define-fun C5 () Bool (SafeDivs operator operand))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)
(assert C3)
(assert (not C4))
(assert C5)

(check-sat)
(get-model)

------------------------------
  Test Case 48: satisfied_assert_0;assert_1;assert_2;assert_3;assert_5, violated_assert_4
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True, 'assert_3': True, 'assert_4': False, 'assert_5': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_3', 'assert_5'], 'violated_contracts': ['assert_4'], 'total_contracts': 6}
  Solutions:
    Solution 1:
      test_case: {'operator': [2.0], 'operand': [0, 1]}
    Solution 2:
      test_case: {'operand': [1142, 282], 'operator': [3.0]}
    Solution 3:
      test_case: {'operand': [30023, 2522], 'operator': [4.0]}
    Solution 4:
      test_case: {'operand': [30863, 21109], 'operator': [5.0]}
    Solution 5:
      test_case: {'operand': [60396, 27987], 'operator': [6.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (or (is-Nil lst)
      (and (is-Cons lst)
           (let ((tailVal (tail lst)))
             (IsList tailVal)))))

(define-fun-rec ListLength ((lst Value)) Int
  (ite (is-Nil lst) 0
       (ite (is-Cons lst)
            (+ 1 (ListLength (tail lst)))
            0)))

(define-fun-rec ListAllIntNonNeg ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-IntVal headVal)
                        (>= (ival headVal) 0)))
                 (ListAllIntNonNeg (tail lst)))
            true
            false)))

(define-fun-rec ListAllOp ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-StrVal headVal)
                        (or (= (sval headVal) "+")
                            (= (sval headVal) "-")
                            (= (sval headVal) "*")
                            (= (sval headVal) "//")
                            (= (sval headVal) "**"))))
                 (ListAllOp (tail lst)))
            true
            false)))

(define-fun-rec SafeDivs ((ops Value) (opnds Value)) Bool
  (ite (is-Cons ops)
       (let ((opHead (head ops))
             (opsTail (tail ops))
             (opndsTail (tail opnds)))
         (let ((nextOpnd (ite (is-Cons opndsTail)
                              (head opndsTail)
                              opndsTail)))
           (and (ite (is-StrVal opHead)
                     (ite (= (sval opHead) "//")
                          (not (and (is-IntVal nextOpnd)
                                    (= (ival nextOpnd) 0)))
                          true)
                     true)
                (SafeDivs opsTail opndsTail))))
       true))

; === Inputs ===
(declare-const operator Value)
(declare-const operand Value)

; === BASIC STRUCTURE ===
(assert (IsList operator))
(assert (IsList operand))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList operator) (IsList operand)))
(define-fun C1 () Bool (>= (ListLength operator) 1))
(define-fun C2 () Bool (= (ListLength operand) (+ (ListLength operator) 1)))
(define-fun C3 () Bool (ListAllIntNonNeg operand))
(define-fun C4 () Bool (ListAllOp operator))
(define-fun C5 () Bool (SafeDivs operator operand))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)
(assert C3)
(assert (not C4))
(assert C5)

(check-sat)
(get-model)

------------------------------
  Test Case 49: satisfied_assert_4;assert_5, violated_assert_0;assert_1;assert_2;assert_3
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False, 'assert_3': False, 'assert_4': True, 'assert_5': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_4', 'assert_5'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_3'], 'total_contracts': 6}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (or (is-Nil lst)
      (and (is-Cons lst)
           (let ((tailVal (tail lst)))
             (IsList tailVal)))))

(define-fun-rec ListLength ((lst Value)) Int
  (ite (is-Nil lst) 0
       (ite (is-Cons lst)
            (+ 1 (ListLength (tail lst)))
            0)))

(define-fun-rec ListAllIntNonNeg ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-IntVal headVal)
                        (>= (ival headVal) 0)))
                 (ListAllIntNonNeg (tail lst)))
            true
            false)))

(define-fun-rec ListAllOp ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-StrVal headVal)
                        (or (= (sval headVal) "+")
                            (= (sval headVal) "-")
                            (= (sval headVal) "*")
                            (= (sval headVal) "//")
                            (= (sval headVal) "**"))))
                 (ListAllOp (tail lst)))
            true
            false)))

(define-fun-rec SafeDivs ((ops Value) (opnds Value)) Bool
  (ite (is-Cons ops)
       (let ((opHead (head ops))
             (opsTail (tail ops))
             (opndsTail (tail opnds)))
         (let ((nextOpnd (ite (is-Cons opndsTail)
                              (head opndsTail)
                              opndsTail)))
           (and (ite (is-StrVal opHead)
                     (ite (= (sval opHead) "//")
                          (not (and (is-IntVal nextOpnd)
                                    (= (ival nextOpnd) 0)))
                          true)
                     true)
                (SafeDivs opsTail opndsTail))))
       true))

; === Inputs ===
(declare-const operator Value)
(declare-const operand Value)

; === BASIC STRUCTURE ===
(assert (IsList operator))
(assert (IsList operand))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList operator) (IsList operand)))
(define-fun C1 () Bool (>= (ListLength operator) 1))
(define-fun C2 () Bool (= (ListLength operand) (+ (ListLength operator) 1)))
(define-fun C3 () Bool (ListAllIntNonNeg operand))
(define-fun C4 () Bool (ListAllOp operator))
(define-fun C5 () Bool (SafeDivs operator operand))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))
(assert (not C3))
(assert C4)
(assert C5)

(check-sat)
(get-model)

------------------------------
  Test Case 50: satisfied_assert_0;assert_4;assert_5, violated_assert_1;assert_2;assert_3
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False, 'assert_3': False, 'assert_4': True, 'assert_5': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_4', 'assert_5'], 'violated_contracts': ['assert_1', 'assert_2', 'assert_3'], 'total_contracts': 6}
  Solutions:
    Solution 1:
      test_case: {'operator': [], 'operand': [3.0, 4.0]}
    Solution 2:
      test_case: {'operator': [], 'operand': [2.0, 5.0]}
    Solution 3:
      test_case: {'operand': [6.0, 7.0], 'operator': []}
    Solution 4:
      test_case: {'operator': [], 'operand': [9.0, 8.0]}
    Solution 5:
      test_case: {'operand': [11.0, 10.0], 'operator': []}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (or (is-Nil lst)
      (and (is-Cons lst)
           (let ((tailVal (tail lst)))
             (IsList tailVal)))))

(define-fun-rec ListLength ((lst Value)) Int
  (ite (is-Nil lst) 0
       (ite (is-Cons lst)
            (+ 1 (ListLength (tail lst)))
            0)))

(define-fun-rec ListAllIntNonNeg ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-IntVal headVal)
                        (>= (ival headVal) 0)))
                 (ListAllIntNonNeg (tail lst)))
            true
            false)))

(define-fun-rec ListAllOp ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-StrVal headVal)
                        (or (= (sval headVal) "+")
                            (= (sval headVal) "-")
                            (= (sval headVal) "*")
                            (= (sval headVal) "//")
                            (= (sval headVal) "**"))))
                 (ListAllOp (tail lst)))
            true
            false)))

(define-fun-rec SafeDivs ((ops Value) (opnds Value)) Bool
  (ite (is-Cons ops)
       (let ((opHead (head ops))
             (opsTail (tail ops))
             (opndsTail (tail opnds)))
         (let ((nextOpnd (ite (is-Cons opndsTail)
                              (head opndsTail)
                              opndsTail)))
           (and (ite (is-StrVal opHead)
                     (ite (= (sval opHead) "//")
                          (not (and (is-IntVal nextOpnd)
                                    (= (ival nextOpnd) 0)))
                          true)
                     true)
                (SafeDivs opsTail opndsTail))))
       true))

; === Inputs ===
(declare-const operator Value)
(declare-const operand Value)

; === BASIC STRUCTURE ===
(assert (IsList operator))
(assert (IsList operand))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList operator) (IsList operand)))
(define-fun C1 () Bool (>= (ListLength operator) 1))
(define-fun C2 () Bool (= (ListLength operand) (+ (ListLength operator) 1)))
(define-fun C3 () Bool (ListAllIntNonNeg operand))
(define-fun C4 () Bool (ListAllOp operator))
(define-fun C5 () Bool (SafeDivs operator operand))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))
(assert (not C3))
(assert C4)
(assert C5)

(check-sat)
(get-model)

------------------------------
  Test Case 51: satisfied_assert_1;assert_4;assert_5, violated_assert_0;assert_2;assert_3
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False, 'assert_3': False, 'assert_4': True, 'assert_5': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_4', 'assert_5'], 'violated_contracts': ['assert_0', 'assert_2', 'assert_3'], 'total_contracts': 6}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (or (is-Nil lst)
      (and (is-Cons lst)
           (let ((tailVal (tail lst)))
             (IsList tailVal)))))

(define-fun-rec ListLength ((lst Value)) Int
  (ite (is-Nil lst) 0
       (ite (is-Cons lst)
            (+ 1 (ListLength (tail lst)))
            0)))

(define-fun-rec ListAllIntNonNeg ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-IntVal headVal)
                        (>= (ival headVal) 0)))
                 (ListAllIntNonNeg (tail lst)))
            true
            false)))

(define-fun-rec ListAllOp ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-StrVal headVal)
                        (or (= (sval headVal) "+")
                            (= (sval headVal) "-")
                            (= (sval headVal) "*")
                            (= (sval headVal) "//")
                            (= (sval headVal) "**"))))
                 (ListAllOp (tail lst)))
            true
            false)))

(define-fun-rec SafeDivs ((ops Value) (opnds Value)) Bool
  (ite (is-Cons ops)
       (let ((opHead (head ops))
             (opsTail (tail ops))
             (opndsTail (tail opnds)))
         (let ((nextOpnd (ite (is-Cons opndsTail)
                              (head opndsTail)
                              opndsTail)))
           (and (ite (is-StrVal opHead)
                     (ite (= (sval opHead) "//")
                          (not (and (is-IntVal nextOpnd)
                                    (= (ival nextOpnd) 0)))
                          true)
                     true)
                (SafeDivs opsTail opndsTail))))
       true))

; === Inputs ===
(declare-const operator Value)
(declare-const operand Value)

; === BASIC STRUCTURE ===
(assert (IsList operator))
(assert (IsList operand))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList operator) (IsList operand)))
(define-fun C1 () Bool (>= (ListLength operator) 1))
(define-fun C2 () Bool (= (ListLength operand) (+ (ListLength operator) 1)))
(define-fun C3 () Bool (ListAllIntNonNeg operand))
(define-fun C4 () Bool (ListAllOp operator))
(define-fun C5 () Bool (SafeDivs operator operand))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))
(assert (not C3))
(assert C4)
(assert C5)

(check-sat)
(get-model)

------------------------------
  Test Case 52: satisfied_assert_0;assert_1;assert_4;assert_5, violated_assert_2;assert_3
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False, 'assert_3': False, 'assert_4': True, 'assert_5': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_4', 'assert_5'], 'violated_contracts': ['assert_2', 'assert_3'], 'total_contracts': 6}
  Solutions:
    Solution 1:
      test_case: {'operator': ['**'], 'operand': [2.0]}
    Solution 2:
      test_case: {'operand': [3.0], 'operator': ['**']}
    Solution 3:
      test_case: {'operand': [4.0], 'operator': ['**']}
    Solution 4:
      test_case: {'operator': ['**'], 'operand': [5.0]}
    Solution 5:
      test_case: {'operand': [6.0], 'operator': ['**']}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (or (is-Nil lst)
      (and (is-Cons lst)
           (let ((tailVal (tail lst)))
             (IsList tailVal)))))

(define-fun-rec ListLength ((lst Value)) Int
  (ite (is-Nil lst) 0
       (ite (is-Cons lst)
            (+ 1 (ListLength (tail lst)))
            0)))

(define-fun-rec ListAllIntNonNeg ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-IntVal headVal)
                        (>= (ival headVal) 0)))
                 (ListAllIntNonNeg (tail lst)))
            true
            false)))

(define-fun-rec ListAllOp ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-StrVal headVal)
                        (or (= (sval headVal) "+")
                            (= (sval headVal) "-")
                            (= (sval headVal) "*")
                            (= (sval headVal) "//")
                            (= (sval headVal) "**"))))
                 (ListAllOp (tail lst)))
            true
            false)))

(define-fun-rec SafeDivs ((ops Value) (opnds Value)) Bool
  (ite (is-Cons ops)
       (let ((opHead (head ops))
             (opsTail (tail ops))
             (opndsTail (tail opnds)))
         (let ((nextOpnd (ite (is-Cons opndsTail)
                              (head opndsTail)
                              opndsTail)))
           (and (ite (is-StrVal opHead)
                     (ite (= (sval opHead) "//")
                          (not (and (is-IntVal nextOpnd)
                                    (= (ival nextOpnd) 0)))
                          true)
                     true)
                (SafeDivs opsTail opndsTail))))
       true))

; === Inputs ===
(declare-const operator Value)
(declare-const operand Value)

; === BASIC STRUCTURE ===
(assert (IsList operator))
(assert (IsList operand))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList operator) (IsList operand)))
(define-fun C1 () Bool (>= (ListLength operator) 1))
(define-fun C2 () Bool (= (ListLength operand) (+ (ListLength operator) 1)))
(define-fun C3 () Bool (ListAllIntNonNeg operand))
(define-fun C4 () Bool (ListAllOp operator))
(define-fun C5 () Bool (SafeDivs operator operand))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))
(assert (not C3))
(assert C4)
(assert C5)

(check-sat)
(get-model)

------------------------------
  Test Case 53: satisfied_assert_2;assert_4;assert_5, violated_assert_0;assert_1;assert_3
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True, 'assert_3': False, 'assert_4': True, 'assert_5': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_2', 'assert_4', 'assert_5'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_3'], 'total_contracts': 6}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (or (is-Nil lst)
      (and (is-Cons lst)
           (let ((tailVal (tail lst)))
             (IsList tailVal)))))

(define-fun-rec ListLength ((lst Value)) Int
  (ite (is-Nil lst) 0
       (ite (is-Cons lst)
            (+ 1 (ListLength (tail lst)))
            0)))

(define-fun-rec ListAllIntNonNeg ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-IntVal headVal)
                        (>= (ival headVal) 0)))
                 (ListAllIntNonNeg (tail lst)))
            true
            false)))

(define-fun-rec ListAllOp ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-StrVal headVal)
                        (or (= (sval headVal) "+")
                            (= (sval headVal) "-")
                            (= (sval headVal) "*")
                            (= (sval headVal) "//")
                            (= (sval headVal) "**"))))
                 (ListAllOp (tail lst)))
            true
            false)))

(define-fun-rec SafeDivs ((ops Value) (opnds Value)) Bool
  (ite (is-Cons ops)
       (let ((opHead (head ops))
             (opsTail (tail ops))
             (opndsTail (tail opnds)))
         (let ((nextOpnd (ite (is-Cons opndsTail)
                              (head opndsTail)
                              opndsTail)))
           (and (ite (is-StrVal opHead)
                     (ite (= (sval opHead) "//")
                          (not (and (is-IntVal nextOpnd)
                                    (= (ival nextOpnd) 0)))
                          true)
                     true)
                (SafeDivs opsTail opndsTail))))
       true))

; === Inputs ===
(declare-const operator Value)
(declare-const operand Value)

; === BASIC STRUCTURE ===
(assert (IsList operator))
(assert (IsList operand))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList operator) (IsList operand)))
(define-fun C1 () Bool (>= (ListLength operator) 1))
(define-fun C2 () Bool (= (ListLength operand) (+ (ListLength operator) 1)))
(define-fun C3 () Bool (ListAllIntNonNeg operand))
(define-fun C4 () Bool (ListAllOp operator))
(define-fun C5 () Bool (SafeDivs operator operand))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)
(assert (not C3))
(assert C4)
(assert C5)

(check-sat)
(get-model)

------------------------------
  Test Case 54: satisfied_assert_0;assert_2;assert_4;assert_5, violated_assert_1;assert_3
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True, 'assert_3': False, 'assert_4': True, 'assert_5': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2', 'assert_4', 'assert_5'], 'violated_contracts': ['assert_1', 'assert_3'], 'total_contracts': 6}
  Solutions:
    Solution 1:
      test_case: {'operator': [], 'operand': [2.0]}
    Solution 2:
      test_case: {'operand': [3.0], 'operator': []}
    Solution 3:
      test_case: {'operator': [], 'operand': [4.0]}
    Solution 4:
      test_case: {'operand': [5.0], 'operator': []}
    Solution 5:
      test_case: {'operator': [], 'operand': [6.0]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (or (is-Nil lst)
      (and (is-Cons lst)
           (let ((tailVal (tail lst)))
             (IsList tailVal)))))

(define-fun-rec ListLength ((lst Value)) Int
  (ite (is-Nil lst) 0
       (ite (is-Cons lst)
            (+ 1 (ListLength (tail lst)))
            0)))

(define-fun-rec ListAllIntNonNeg ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-IntVal headVal)
                        (>= (ival headVal) 0)))
                 (ListAllIntNonNeg (tail lst)))
            true
            false)))

(define-fun-rec ListAllOp ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-StrVal headVal)
                        (or (= (sval headVal) "+")
                            (= (sval headVal) "-")
                            (= (sval headVal) "*")
                            (= (sval headVal) "//")
                            (= (sval headVal) "**"))))
                 (ListAllOp (tail lst)))
            true
            false)))

(define-fun-rec SafeDivs ((ops Value) (opnds Value)) Bool
  (ite (is-Cons ops)
       (let ((opHead (head ops))
             (opsTail (tail ops))
             (opndsTail (tail opnds)))
         (let ((nextOpnd (ite (is-Cons opndsTail)
                              (head opndsTail)
                              opndsTail)))
           (and (ite (is-StrVal opHead)
                     (ite (= (sval opHead) "//")
                          (not (and (is-IntVal nextOpnd)
                                    (= (ival nextOpnd) 0)))
                          true)
                     true)
                (SafeDivs opsTail opndsTail))))
       true))

; === Inputs ===
(declare-const operator Value)
(declare-const operand Value)

; === BASIC STRUCTURE ===
(assert (IsList operator))
(assert (IsList operand))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList operator) (IsList operand)))
(define-fun C1 () Bool (>= (ListLength operator) 1))
(define-fun C2 () Bool (= (ListLength operand) (+ (ListLength operator) 1)))
(define-fun C3 () Bool (ListAllIntNonNeg operand))
(define-fun C4 () Bool (ListAllOp operator))
(define-fun C5 () Bool (SafeDivs operator operand))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)
(assert (not C3))
(assert C4)
(assert C5)

(check-sat)
(get-model)

------------------------------
  Test Case 55: satisfied_assert_1;assert_2;assert_4;assert_5, violated_assert_0;assert_3
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True, 'assert_3': False, 'assert_4': True, 'assert_5': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2', 'assert_4', 'assert_5'], 'violated_contracts': ['assert_0', 'assert_3'], 'total_contracts': 6}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (or (is-Nil lst)
      (and (is-Cons lst)
           (let ((tailVal (tail lst)))
             (IsList tailVal)))))

(define-fun-rec ListLength ((lst Value)) Int
  (ite (is-Nil lst) 0
       (ite (is-Cons lst)
            (+ 1 (ListLength (tail lst)))
            0)))

(define-fun-rec ListAllIntNonNeg ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-IntVal headVal)
                        (>= (ival headVal) 0)))
                 (ListAllIntNonNeg (tail lst)))
            true
            false)))

(define-fun-rec ListAllOp ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-StrVal headVal)
                        (or (= (sval headVal) "+")
                            (= (sval headVal) "-")
                            (= (sval headVal) "*")
                            (= (sval headVal) "//")
                            (= (sval headVal) "**"))))
                 (ListAllOp (tail lst)))
            true
            false)))

(define-fun-rec SafeDivs ((ops Value) (opnds Value)) Bool
  (ite (is-Cons ops)
       (let ((opHead (head ops))
             (opsTail (tail ops))
             (opndsTail (tail opnds)))
         (let ((nextOpnd (ite (is-Cons opndsTail)
                              (head opndsTail)
                              opndsTail)))
           (and (ite (is-StrVal opHead)
                     (ite (= (sval opHead) "//")
                          (not (and (is-IntVal nextOpnd)
                                    (= (ival nextOpnd) 0)))
                          true)
                     true)
                (SafeDivs opsTail opndsTail))))
       true))

; === Inputs ===
(declare-const operator Value)
(declare-const operand Value)

; === BASIC STRUCTURE ===
(assert (IsList operator))
(assert (IsList operand))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList operator) (IsList operand)))
(define-fun C1 () Bool (>= (ListLength operator) 1))
(define-fun C2 () Bool (= (ListLength operand) (+ (ListLength operator) 1)))
(define-fun C3 () Bool (ListAllIntNonNeg operand))
(define-fun C4 () Bool (ListAllOp operator))
(define-fun C5 () Bool (SafeDivs operator operand))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)
(assert (not C3))
(assert C4)
(assert C5)

(check-sat)
(get-model)

------------------------------
  Test Case 56: satisfied_assert_0;assert_1;assert_2;assert_4;assert_5, violated_assert_3
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True, 'assert_3': False, 'assert_4': True, 'assert_5': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_4', 'assert_5'], 'violated_contracts': ['assert_3'], 'total_contracts': 6}
  Solutions:
    Solution 1:
      test_case: {'operator': ['-'], 'operand': [3.0, 2.0]}
    Solution 2:
      test_case: {'operand': [5.0, 4.0], 'operator': ['-']}
    Solution 3:
      test_case: {'operand': [6.0, 7.0], 'operator': ['-']}
    Solution 4:
      test_case: {'operand': [8.0, 9.0], 'operator': ['-']}
    Solution 5:
      test_case: {'operand': [11.0, 10.0], 'operator': ['-']}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (or (is-Nil lst)
      (and (is-Cons lst)
           (let ((tailVal (tail lst)))
             (IsList tailVal)))))

(define-fun-rec ListLength ((lst Value)) Int
  (ite (is-Nil lst) 0
       (ite (is-Cons lst)
            (+ 1 (ListLength (tail lst)))
            0)))

(define-fun-rec ListAllIntNonNeg ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-IntVal headVal)
                        (>= (ival headVal) 0)))
                 (ListAllIntNonNeg (tail lst)))
            true
            false)))

(define-fun-rec ListAllOp ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-StrVal headVal)
                        (or (= (sval headVal) "+")
                            (= (sval headVal) "-")
                            (= (sval headVal) "*")
                            (= (sval headVal) "//")
                            (= (sval headVal) "**"))))
                 (ListAllOp (tail lst)))
            true
            false)))

(define-fun-rec SafeDivs ((ops Value) (opnds Value)) Bool
  (ite (is-Cons ops)
       (let ((opHead (head ops))
             (opsTail (tail ops))
             (opndsTail (tail opnds)))
         (let ((nextOpnd (ite (is-Cons opndsTail)
                              (head opndsTail)
                              opndsTail)))
           (and (ite (is-StrVal opHead)
                     (ite (= (sval opHead) "//")
                          (not (and (is-IntVal nextOpnd)
                                    (= (ival nextOpnd) 0)))
                          true)
                     true)
                (SafeDivs opsTail opndsTail))))
       true))

; === Inputs ===
(declare-const operator Value)
(declare-const operand Value)

; === BASIC STRUCTURE ===
(assert (IsList operator))
(assert (IsList operand))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList operator) (IsList operand)))
(define-fun C1 () Bool (>= (ListLength operator) 1))
(define-fun C2 () Bool (= (ListLength operand) (+ (ListLength operator) 1)))
(define-fun C3 () Bool (ListAllIntNonNeg operand))
(define-fun C4 () Bool (ListAllOp operator))
(define-fun C5 () Bool (SafeDivs operator operand))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)
(assert (not C3))
(assert C4)
(assert C5)

(check-sat)
(get-model)

------------------------------
  Test Case 57: satisfied_assert_3;assert_4;assert_5, violated_assert_0;assert_1;assert_2
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': False, 'assert_3': True, 'assert_4': True, 'assert_5': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_3', 'assert_4', 'assert_5'], 'violated_contracts': ['assert_0', 'assert_1', 'assert_2'], 'total_contracts': 6}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (or (is-Nil lst)
      (and (is-Cons lst)
           (let ((tailVal (tail lst)))
             (IsList tailVal)))))

(define-fun-rec ListLength ((lst Value)) Int
  (ite (is-Nil lst) 0
       (ite (is-Cons lst)
            (+ 1 (ListLength (tail lst)))
            0)))

(define-fun-rec ListAllIntNonNeg ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-IntVal headVal)
                        (>= (ival headVal) 0)))
                 (ListAllIntNonNeg (tail lst)))
            true
            false)))

(define-fun-rec ListAllOp ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-StrVal headVal)
                        (or (= (sval headVal) "+")
                            (= (sval headVal) "-")
                            (= (sval headVal) "*")
                            (= (sval headVal) "//")
                            (= (sval headVal) "**"))))
                 (ListAllOp (tail lst)))
            true
            false)))

(define-fun-rec SafeDivs ((ops Value) (opnds Value)) Bool
  (ite (is-Cons ops)
       (let ((opHead (head ops))
             (opsTail (tail ops))
             (opndsTail (tail opnds)))
         (let ((nextOpnd (ite (is-Cons opndsTail)
                              (head opndsTail)
                              opndsTail)))
           (and (ite (is-StrVal opHead)
                     (ite (= (sval opHead) "//")
                          (not (and (is-IntVal nextOpnd)
                                    (= (ival nextOpnd) 0)))
                          true)
                     true)
                (SafeDivs opsTail opndsTail))))
       true))

; === Inputs ===
(declare-const operator Value)
(declare-const operand Value)

; === BASIC STRUCTURE ===
(assert (IsList operator))
(assert (IsList operand))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList operator) (IsList operand)))
(define-fun C1 () Bool (>= (ListLength operator) 1))
(define-fun C2 () Bool (= (ListLength operand) (+ (ListLength operator) 1)))
(define-fun C3 () Bool (ListAllIntNonNeg operand))
(define-fun C4 () Bool (ListAllOp operator))
(define-fun C5 () Bool (SafeDivs operator operand))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert (not C2))
(assert C3)
(assert C4)
(assert C5)

(check-sat)
(get-model)

------------------------------
  Test Case 58: satisfied_assert_0;assert_3;assert_4;assert_5, violated_assert_1;assert_2
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': False, 'assert_3': True, 'assert_4': True, 'assert_5': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_3', 'assert_4', 'assert_5'], 'violated_contracts': ['assert_1', 'assert_2'], 'total_contracts': 6}
  Solutions:
    Solution 1:
      test_case: {'operator': [], 'operand': []}
    Solution 2:
      test_case: {'operand': [0, 2240], 'operator': []}
    Solution 3:
      test_case: {'operand': [21237, 23611], 'operator': []}
    Solution 4:
      test_case: {'operand': [20584, 12212], 'operator': []}
    Solution 5:
      test_case: {'operand': [24388, 11649], 'operator': []}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (or (is-Nil lst)
      (and (is-Cons lst)
           (let ((tailVal (tail lst)))
             (IsList tailVal)))))

(define-fun-rec ListLength ((lst Value)) Int
  (ite (is-Nil lst) 0
       (ite (is-Cons lst)
            (+ 1 (ListLength (tail lst)))
            0)))

(define-fun-rec ListAllIntNonNeg ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-IntVal headVal)
                        (>= (ival headVal) 0)))
                 (ListAllIntNonNeg (tail lst)))
            true
            false)))

(define-fun-rec ListAllOp ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-StrVal headVal)
                        (or (= (sval headVal) "+")
                            (= (sval headVal) "-")
                            (= (sval headVal) "*")
                            (= (sval headVal) "//")
                            (= (sval headVal) "**"))))
                 (ListAllOp (tail lst)))
            true
            false)))

(define-fun-rec SafeDivs ((ops Value) (opnds Value)) Bool
  (ite (is-Cons ops)
       (let ((opHead (head ops))
             (opsTail (tail ops))
             (opndsTail (tail opnds)))
         (let ((nextOpnd (ite (is-Cons opndsTail)
                              (head opndsTail)
                              opndsTail)))
           (and (ite (is-StrVal opHead)
                     (ite (= (sval opHead) "//")
                          (not (and (is-IntVal nextOpnd)
                                    (= (ival nextOpnd) 0)))
                          true)
                     true)
                (SafeDivs opsTail opndsTail))))
       true))

; === Inputs ===
(declare-const operator Value)
(declare-const operand Value)

; === BASIC STRUCTURE ===
(assert (IsList operator))
(assert (IsList operand))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList operator) (IsList operand)))
(define-fun C1 () Bool (>= (ListLength operator) 1))
(define-fun C2 () Bool (= (ListLength operand) (+ (ListLength operator) 1)))
(define-fun C3 () Bool (ListAllIntNonNeg operand))
(define-fun C4 () Bool (ListAllOp operator))
(define-fun C5 () Bool (SafeDivs operator operand))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert (not C2))
(assert C3)
(assert C4)
(assert C5)

(check-sat)
(get-model)

------------------------------
  Test Case 59: satisfied_assert_1;assert_3;assert_4;assert_5, violated_assert_0;assert_2
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': False, 'assert_3': True, 'assert_4': True, 'assert_5': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_3', 'assert_4', 'assert_5'], 'violated_contracts': ['assert_0', 'assert_2'], 'total_contracts': 6}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (or (is-Nil lst)
      (and (is-Cons lst)
           (let ((tailVal (tail lst)))
             (IsList tailVal)))))

(define-fun-rec ListLength ((lst Value)) Int
  (ite (is-Nil lst) 0
       (ite (is-Cons lst)
            (+ 1 (ListLength (tail lst)))
            0)))

(define-fun-rec ListAllIntNonNeg ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-IntVal headVal)
                        (>= (ival headVal) 0)))
                 (ListAllIntNonNeg (tail lst)))
            true
            false)))

(define-fun-rec ListAllOp ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-StrVal headVal)
                        (or (= (sval headVal) "+")
                            (= (sval headVal) "-")
                            (= (sval headVal) "*")
                            (= (sval headVal) "//")
                            (= (sval headVal) "**"))))
                 (ListAllOp (tail lst)))
            true
            false)))

(define-fun-rec SafeDivs ((ops Value) (opnds Value)) Bool
  (ite (is-Cons ops)
       (let ((opHead (head ops))
             (opsTail (tail ops))
             (opndsTail (tail opnds)))
         (let ((nextOpnd (ite (is-Cons opndsTail)
                              (head opndsTail)
                              opndsTail)))
           (and (ite (is-StrVal opHead)
                     (ite (= (sval opHead) "//")
                          (not (and (is-IntVal nextOpnd)
                                    (= (ival nextOpnd) 0)))
                          true)
                     true)
                (SafeDivs opsTail opndsTail))))
       true))

; === Inputs ===
(declare-const operator Value)
(declare-const operand Value)

; === BASIC STRUCTURE ===
(assert (IsList operator))
(assert (IsList operand))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList operator) (IsList operand)))
(define-fun C1 () Bool (>= (ListLength operator) 1))
(define-fun C2 () Bool (= (ListLength operand) (+ (ListLength operator) 1)))
(define-fun C3 () Bool (ListAllIntNonNeg operand))
(define-fun C4 () Bool (ListAllOp operator))
(define-fun C5 () Bool (SafeDivs operator operand))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert (not C2))
(assert C3)
(assert C4)
(assert C5)

(check-sat)
(get-model)

------------------------------
  Test Case 60: satisfied_assert_0;assert_1;assert_3;assert_4;assert_5, violated_assert_2
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': False, 'assert_3': True, 'assert_4': True, 'assert_5': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_3', 'assert_4', 'assert_5'], 'violated_contracts': ['assert_2'], 'total_contracts': 6}
  Solutions:
    Solution 1:
      test_case: {'operator': ['+'], 'operand': []}
    Solution 2:
      test_case: {'operand': [], 'operator': ['*']}
    Solution 3:
      test_case: {'operator': ['**'], 'operand': []}
    Solution 4:
      test_case: {'operand': [], 'operator': ['-']}
    Solution 5:
      test_case: {'operator': ['//'], 'operand': []}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (or (is-Nil lst)
      (and (is-Cons lst)
           (let ((tailVal (tail lst)))
             (IsList tailVal)))))

(define-fun-rec ListLength ((lst Value)) Int
  (ite (is-Nil lst) 0
       (ite (is-Cons lst)
            (+ 1 (ListLength (tail lst)))
            0)))

(define-fun-rec ListAllIntNonNeg ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-IntVal headVal)
                        (>= (ival headVal) 0)))
                 (ListAllIntNonNeg (tail lst)))
            true
            false)))

(define-fun-rec ListAllOp ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-StrVal headVal)
                        (or (= (sval headVal) "+")
                            (= (sval headVal) "-")
                            (= (sval headVal) "*")
                            (= (sval headVal) "//")
                            (= (sval headVal) "**"))))
                 (ListAllOp (tail lst)))
            true
            false)))

(define-fun-rec SafeDivs ((ops Value) (opnds Value)) Bool
  (ite (is-Cons ops)
       (let ((opHead (head ops))
             (opsTail (tail ops))
             (opndsTail (tail opnds)))
         (let ((nextOpnd (ite (is-Cons opndsTail)
                              (head opndsTail)
                              opndsTail)))
           (and (ite (is-StrVal opHead)
                     (ite (= (sval opHead) "//")
                          (not (and (is-IntVal nextOpnd)
                                    (= (ival nextOpnd) 0)))
                          true)
                     true)
                (SafeDivs opsTail opndsTail))))
       true))

; === Inputs ===
(declare-const operator Value)
(declare-const operand Value)

; === BASIC STRUCTURE ===
(assert (IsList operator))
(assert (IsList operand))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList operator) (IsList operand)))
(define-fun C1 () Bool (>= (ListLength operator) 1))
(define-fun C2 () Bool (= (ListLength operand) (+ (ListLength operator) 1)))
(define-fun C3 () Bool (ListAllIntNonNeg operand))
(define-fun C4 () Bool (ListAllOp operator))
(define-fun C5 () Bool (SafeDivs operator operand))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert (not C2))
(assert C3)
(assert C4)
(assert C5)

(check-sat)
(get-model)

------------------------------
  Test Case 61: satisfied_assert_2;assert_3;assert_4;assert_5, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False, 'assert_2': True, 'assert_3': True, 'assert_4': True, 'assert_5': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_2', 'assert_3', 'assert_4', 'assert_5'], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 6}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (or (is-Nil lst)
      (and (is-Cons lst)
           (let ((tailVal (tail lst)))
             (IsList tailVal)))))

(define-fun-rec ListLength ((lst Value)) Int
  (ite (is-Nil lst) 0
       (ite (is-Cons lst)
            (+ 1 (ListLength (tail lst)))
            0)))

(define-fun-rec ListAllIntNonNeg ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-IntVal headVal)
                        (>= (ival headVal) 0)))
                 (ListAllIntNonNeg (tail lst)))
            true
            false)))

(define-fun-rec ListAllOp ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-StrVal headVal)
                        (or (= (sval headVal) "+")
                            (= (sval headVal) "-")
                            (= (sval headVal) "*")
                            (= (sval headVal) "//")
                            (= (sval headVal) "**"))))
                 (ListAllOp (tail lst)))
            true
            false)))

(define-fun-rec SafeDivs ((ops Value) (opnds Value)) Bool
  (ite (is-Cons ops)
       (let ((opHead (head ops))
             (opsTail (tail ops))
             (opndsTail (tail opnds)))
         (let ((nextOpnd (ite (is-Cons opndsTail)
                              (head opndsTail)
                              opndsTail)))
           (and (ite (is-StrVal opHead)
                     (ite (= (sval opHead) "//")
                          (not (and (is-IntVal nextOpnd)
                                    (= (ival nextOpnd) 0)))
                          true)
                     true)
                (SafeDivs opsTail opndsTail))))
       true))

; === Inputs ===
(declare-const operator Value)
(declare-const operand Value)

; === BASIC STRUCTURE ===
(assert (IsList operator))
(assert (IsList operand))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList operator) (IsList operand)))
(define-fun C1 () Bool (>= (ListLength operator) 1))
(define-fun C2 () Bool (= (ListLength operand) (+ (ListLength operator) 1)))
(define-fun C3 () Bool (ListAllIntNonNeg operand))
(define-fun C4 () Bool (ListAllOp operator))
(define-fun C5 () Bool (SafeDivs operator operand))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))
(assert C2)
(assert C3)
(assert C4)
(assert C5)

(check-sat)
(get-model)

------------------------------
  Test Case 62: satisfied_assert_0;assert_2;assert_3;assert_4;assert_5, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False, 'assert_2': True, 'assert_3': True, 'assert_4': True, 'assert_5': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_2', 'assert_3', 'assert_4', 'assert_5'], 'violated_contracts': ['assert_1'], 'total_contracts': 6}
  Solutions:
    Solution 1:
      test_case: {'operator': [], 'operand': [0]}
    Solution 2:
      test_case: {'operand': [18457], 'operator': []}
    Solution 3:
      test_case: {'operand': [2446], 'operator': []}
    Solution 4:
      test_case: {'operand': [21237], 'operator': []}
    Solution 5:
      test_case: {'operand': [6878], 'operator': []}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (or (is-Nil lst)
      (and (is-Cons lst)
           (let ((tailVal (tail lst)))
             (IsList tailVal)))))

(define-fun-rec ListLength ((lst Value)) Int
  (ite (is-Nil lst) 0
       (ite (is-Cons lst)
            (+ 1 (ListLength (tail lst)))
            0)))

(define-fun-rec ListAllIntNonNeg ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-IntVal headVal)
                        (>= (ival headVal) 0)))
                 (ListAllIntNonNeg (tail lst)))
            true
            false)))

(define-fun-rec ListAllOp ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-StrVal headVal)
                        (or (= (sval headVal) "+")
                            (= (sval headVal) "-")
                            (= (sval headVal) "*")
                            (= (sval headVal) "//")
                            (= (sval headVal) "**"))))
                 (ListAllOp (tail lst)))
            true
            false)))

(define-fun-rec SafeDivs ((ops Value) (opnds Value)) Bool
  (ite (is-Cons ops)
       (let ((opHead (head ops))
             (opsTail (tail ops))
             (opndsTail (tail opnds)))
         (let ((nextOpnd (ite (is-Cons opndsTail)
                              (head opndsTail)
                              opndsTail)))
           (and (ite (is-StrVal opHead)
                     (ite (= (sval opHead) "//")
                          (not (and (is-IntVal nextOpnd)
                                    (= (ival nextOpnd) 0)))
                          true)
                     true)
                (SafeDivs opsTail opndsTail))))
       true))

; === Inputs ===
(declare-const operator Value)
(declare-const operand Value)

; === BASIC STRUCTURE ===
(assert (IsList operator))
(assert (IsList operand))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList operator) (IsList operand)))
(define-fun C1 () Bool (>= (ListLength operator) 1))
(define-fun C2 () Bool (= (ListLength operand) (+ (ListLength operator) 1)))
(define-fun C3 () Bool (ListAllIntNonNeg operand))
(define-fun C4 () Bool (ListAllOp operator))
(define-fun C5 () Bool (SafeDivs operator operand))

; === COMBINATION ===
(assert C0)
(assert (not C1))
(assert C2)
(assert C3)
(assert C4)
(assert C5)

(check-sat)
(get-model)

------------------------------
  Test Case 63: satisfied_assert_1;assert_2;assert_3;assert_4;assert_5, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True, 'assert_2': True, 'assert_3': True, 'assert_4': True, 'assert_5': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1', 'assert_2', 'assert_3', 'assert_4', 'assert_5'], 'violated_contracts': ['assert_0'], 'total_contracts': 6}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (or (is-Nil lst)
      (and (is-Cons lst)
           (let ((tailVal (tail lst)))
             (IsList tailVal)))))

(define-fun-rec ListLength ((lst Value)) Int
  (ite (is-Nil lst) 0
       (ite (is-Cons lst)
            (+ 1 (ListLength (tail lst)))
            0)))

(define-fun-rec ListAllIntNonNeg ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-IntVal headVal)
                        (>= (ival headVal) 0)))
                 (ListAllIntNonNeg (tail lst)))
            true
            false)))

(define-fun-rec ListAllOp ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-StrVal headVal)
                        (or (= (sval headVal) "+")
                            (= (sval headVal) "-")
                            (= (sval headVal) "*")
                            (= (sval headVal) "//")
                            (= (sval headVal) "**"))))
                 (ListAllOp (tail lst)))
            true
            false)))

(define-fun-rec SafeDivs ((ops Value) (opnds Value)) Bool
  (ite (is-Cons ops)
       (let ((opHead (head ops))
             (opsTail (tail ops))
             (opndsTail (tail opnds)))
         (let ((nextOpnd (ite (is-Cons opndsTail)
                              (head opndsTail)
                              opndsTail)))
           (and (ite (is-StrVal opHead)
                     (ite (= (sval opHead) "//")
                          (not (and (is-IntVal nextOpnd)
                                    (= (ival nextOpnd) 0)))
                          true)
                     true)
                (SafeDivs opsTail opndsTail))))
       true))

; === Inputs ===
(declare-const operator Value)
(declare-const operand Value)

; === BASIC STRUCTURE ===
(assert (IsList operator))
(assert (IsList operand))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList operator) (IsList operand)))
(define-fun C1 () Bool (>= (ListLength operator) 1))
(define-fun C2 () Bool (= (ListLength operand) (+ (ListLength operator) 1)))
(define-fun C3 () Bool (ListAllIntNonNeg operand))
(define-fun C4 () Bool (ListAllOp operator))
(define-fun C5 () Bool (SafeDivs operator operand))

; === COMBINATION ===
(assert (not C0))
(assert C1)
(assert C2)
(assert C3)
(assert C4)
(assert C5)

(check-sat)
(get-model)

------------------------------
  Test Case 64: satisfied_assert_0;assert_1;assert_2;assert_3;assert_4;assert_5, violated_
  Combination: {'assert_0': True, 'assert_1': True, 'assert_2': True, 'assert_3': True, 'assert_4': True, 'assert_5': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1', 'assert_2', 'assert_3', 'assert_4', 'assert_5'], 'violated_contracts': [], 'total_contracts': 6}
  Solutions:
    Solution 1:
      test_case: {'operator': ['*'], 'operand': [0, 1]}
    Solution 2:
      test_case: {'operand': [5853, 28101], 'operator': ['//']}
    Solution 3:
      test_case: {'operator': ['+'], 'operand': [14798, 54386]}
    Solution 4:
      test_case: {'operand': [36453, 80292], 'operator': ['**']}
    Solution 5:
      test_case: {'operator': ['*'], 'operand': [46178, 112570]}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===
(define-fun-rec IsList ((lst Value)) Bool
  (or (is-Nil lst)
      (and (is-Cons lst)
           (let ((tailVal (tail lst)))
             (IsList tailVal)))))

(define-fun-rec ListLength ((lst Value)) Int
  (ite (is-Nil lst) 0
       (ite (is-Cons lst)
            (+ 1 (ListLength (tail lst)))
            0)))

(define-fun-rec ListAllIntNonNeg ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-IntVal headVal)
                        (>= (ival headVal) 0)))
                 (ListAllIntNonNeg (tail lst)))
            true
            false)))

(define-fun-rec ListAllOp ((lst Value)) Bool
  (ite (is-Nil lst) true
       (ite (and (is-Cons lst)
                 (let ((headVal (head lst)))
                   (and (is-StrVal headVal)
                        (or (= (sval headVal) "+")
                            (= (sval headVal) "-")
                            (= (sval headVal) "*")
                            (= (sval headVal) "//")
                            (= (sval headVal) "**"))))
                 (ListAllOp (tail lst)))
            true
            false)))

(define-fun-rec SafeDivs ((ops Value) (opnds Value)) Bool
  (ite (is-Cons ops)
       (let ((opHead (head ops))
             (opsTail (tail ops))
             (opndsTail (tail opnds)))
         (let ((nextOpnd (ite (is-Cons opndsTail)
                              (head opndsTail)
                              opndsTail)))
           (and (ite (is-StrVal opHead)
                     (ite (= (sval opHead) "//")
                          (not (and (is-IntVal nextOpnd)
                                    (= (ival nextOpnd) 0)))
                          true)
                     true)
                (SafeDivs opsTail opndsTail))))
       true))

; === Inputs ===
(declare-const operator Value)
(declare-const operand Value)

; === BASIC STRUCTURE ===
(assert (IsList operator))
(assert (IsList operand))

; === Contract predicates ===
(define-fun C0 () Bool (and (IsList operator) (IsList operand)))
(define-fun C1 () Bool (>= (ListLength operator) 1))
(define-fun C2 () Bool (= (ListLength operand) (+ (ListLength operator) 1)))
(define-fun C3 () Bool (ListAllIntNonNeg operand))
(define-fun C4 () Bool (ListAllOp operator))
(define-fun C5 () Bool (SafeDivs operator operand))

; === COMBINATION ===
(assert C0)
(assert C1)
(assert C2)
(assert C3)
(assert C4)
(assert C5)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/161 ===
  Test Case 1: satisfied_, violated_assert_0
  Combination: {'assert_0': False}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0'], 'total_contracts': 1}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const s Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal s))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal s))

; === COMBINATION ===
(assert (not C0))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_
  Combination: {'assert_0': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': [], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'s': '!0!'}
    Solution 2:
      test_case: {'s': '!'}
    Solution 3:
      test_case: {'s': '0'}
    Solution 4:
      test_case: {'s': '0!'}
    Solution 5:
      test_case: {'s': ''}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const s Value)

; === BASIC STRUCTURE ===
(assert (is-StrVal s))

; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal s))

; === COMBINATION ===
(assert C0)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/162 ===
  Test Case 1: satisfied_, violated_assert_0
  Combination: {'assert_0': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0'], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'text': 2.0}
    Solution 2:
      test_case: {'text': 3.0}
    Solution 3:
      test_case: {'text': 4.0}
    Solution 4:
      test_case: {'text': 5.0}
    Solution 5:
      test_case: {'text': 6.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const text Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal text))

; === COMBINATION ===
(assert (not C0))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_
  Combination: {'assert_0': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': [], 'total_contracts': 1}
  Solutions:
    Solution 1:
      test_case: {'text': '!0!'}
    Solution 2:
      test_case: {'text': '!'}
    Solution 3:
      test_case: {'text': '0'}
    Solution 4:
      test_case: {'text': '0!'}
    Solution 5:
      test_case: {'text': ''}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const text Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (is-StrVal text))

; === COMBINATION ===
(assert C0)

(check-sat)
(get-model)

------------------------------
==================================================

=== Task: HumanEval/163 ===
  Test Case 1: satisfied_, violated_assert_0;assert_1
  Combination: {'assert_0': False, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': [], 'violated_contracts': ['assert_0', 'assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'b': 3.0, 'a': 2.0}
    Solution 2:
      test_case: {'b': 5.0, 'a': 4.0}
    Solution 3:
      test_case: {'b': 7.0, 'a': 6.0}
    Solution 4:
      test_case: {'b': 9.0, 'a': 8.0}
    Solution 5:
      test_case: {'b': 10.0, 'a': 11.0}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const a Value)
(declare-const b Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (is-IntVal a) (is-IntVal b)))
(define-fun C1 () Bool (and (is-IntVal a) (is-IntVal b) (> (ite (is-IntVal a) (ival a) 0) 0) (> (ite (is-IntVal b) (ival b) 0) 0)))

; === COMBINATION ===
(assert (not C0))
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 2: satisfied_assert_0, violated_assert_1
  Combination: {'assert_0': True, 'assert_1': False}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0'], 'violated_contracts': ['assert_1'], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'b': 21238, 'a': 0}
    Solution 2:
      test_case: {'b': 2437, 'a': -21238}
    Solution 3:
      test_case: {'b': 2437, 'a': -29603}
    Solution 4:
      test_case: {'b': 2437, 'a': -60215}
    Solution 5:
      test_case: {'b': 2437, 'a': -61357}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const a Value)
(declare-const b Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (is-IntVal a) (is-IntVal b)))
(define-fun C1 () Bool (and (is-IntVal a) (is-IntVal b) (> (ite (is-IntVal a) (ival a) 0) 0) (> (ite (is-IntVal b) (ival b) 0) 0)))

; === COMBINATION ===
(assert C0)
(assert (not C1))

(check-sat)
(get-model)

------------------------------
  Test Case 3: satisfied_assert_1, violated_assert_0
  Combination: {'assert_0': False, 'assert_1': True}
  Satisfiable: False
  Solution Count: 0
  Metadata: {'satisfied_contracts': ['assert_1'], 'violated_contracts': ['assert_0'], 'total_contracts': 2}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const a Value)
(declare-const b Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (is-IntVal a) (is-IntVal b)))
(define-fun C1 () Bool (and (is-IntVal a) (is-IntVal b) (> (ite (is-IntVal a) (ival a) 0) 0) (> (ite (is-IntVal b) (ival b) 0) 0)))

; === COMBINATION ===
(assert (not C0))
(assert C1)

(check-sat)
(get-model)

------------------------------
  Test Case 4: satisfied_assert_0;assert_1, violated_
  Combination: {'assert_0': True, 'assert_1': True}
  Satisfiable: True
  Solution Count: 5
  Metadata: {'satisfied_contracts': ['assert_0', 'assert_1'], 'violated_contracts': [], 'total_contracts': 2}
  Solutions:
    Solution 1:
      test_case: {'b': 7720, 'a': 1}
    Solution 2:
      test_case: {'b': 21239, 'a': 7720}
    Solution 3:
      test_case: {'b': 21239, 'a': 16575}
    Solution 4:
      test_case: {'b': 21239, 'a': 24940}
    Solution 5:
      test_case: {'b': 31689, 'a': 24940}
  SMT Script:

(set-logic ALL)

; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====
(declare-datatypes ((Value 0)) (
  ((IntVal (ival Int))
   (FloatVal (fval Real))
   (StrVal (sval String))
   (BoolVal (bval Bool))
   (Nil)
   (Cons (head Value) (tail Value)))
))

; === ADD HELPER FUNCTIONS HERE ===


; === Inputs ===
(declare-const a Value)
(declare-const b Value)

; === BASIC STRUCTURE ===


; === Contract predicates ===
(define-fun C0 () Bool (and (is-IntVal a) (is-IntVal b)))
(define-fun C1 () Bool (and (is-IntVal a) (is-IntVal b) (> (ite (is-IntVal a) (ival a) 0) 0) (> (ite (is-IntVal b) (ival b) 0) 0)))

; === COMBINATION ===
(assert C0)
(assert C1)

(check-sat)
(get-model)

------------------------------
==================================================

