{"name": "HumanEval/0", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: has_close_elements\nProblem Description:\nfrom typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n\n\n    assert isinstance(threshold, float) and threshold > 0, \"invalid inputs\" # $_CONTRACT_$\n    assert isinstance(numbers, list), \"invalid inputs\" # $_CONTRACT_$\n    assert all([isinstance(v, (int, float)) for v in numbers]), \"invalid inputs\" # $_CONTRACT_$\n\n\n    sorted_numbers = sorted(numbers)\n    for i in range(len(sorted_numbers) - 1):\n        if sorted_numbers[i + 1] - sorted_numbers[i] < threshold:\n            return True\n    return False\n\n\n\nContract List:\nassert_0: assert isinstance(threshold, float) and threshold > 0, \"invalid inputs\nassert_1: assert isinstance(numbers, list), \"invalid inputs\nassert_2: assert all([isinstance(v, (int, float)) for v in numbers]), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec IsList ((lst Value)) Bool\\n  (ite (is-Nil lst)\\n       true\\n       (ite (is-Cons lst)\\n            (IsList (tail lst))\\n            false)))\\n\\n(define-fun-rec list_all_numeric ((lst Value)) Bool\\n  (ite (is-Nil lst)\\n       true\\n       (ite (is-Cons lst)\\n            (and (or (is-IntVal (head lst)) (is-FloatVal (head lst)))\\n                 (list_all_numeric (tail lst)))\\n            false)))\",\n  \"inputs\": \"(declare-const threshold Value)\\n(declare-const numbers Value)\",\n  \"basic_structure\": \"(assert (is-FloatVal threshold))\\n(assert (IsList numbers))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (and (is-FloatVal threshold) (> (fval threshold) 0)))\\n(define-fun C1 () Bool (IsList numbers))\\n(define-fun C2 () Bool (list_all_numeric numbers))\"\n}\n```\n", "constraints": [{"assert_0": "assert isinstance(threshold, float) and threshold > 0, \"invalid inputs", "assert_1": "assert isinstance(numbers, list), \"invalid inputs", "assert_2": "assert all([isinstance(v, (int, float)) for v in numbers]), \"invalid inputs"}]}], "reasoning": ["I translate the Python assertions into precise SMT-LIB predicates, introducing recursive ADT helpers for list structure and numeric checks. I assert minimal shape constraints in the basic structure to enable safe head/tail selectors and define each contract as a standalone Boolean predicate.</think>"]}
{"name": "HumanEval/1", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: separate_paren_groups\nProblem Description:\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n\n\n    assert type(paren_string) == str, \"invalid inputs\" # $_CONTRACT_$\n    cnt = 0 # $_CONTRACT_$\n    for ch in paren_string: # $_CONTRACT_$\n        assert ch in [\"(\", \")\", \" \"], \"invalid inputs\"  # $_CONTRACT_$\n        if ch == \"(\": cnt += 1 # $_CONTRACT_$\n        if ch == \")\": cnt -= 1 # $_CONTRACT_$\n        assert cnt >= 0, \"invalid inputs\" # $_CONTRACT_$\n    assert cnt == 0, \"invalid inputs\" # $_CONTRACT_$\n\n\n    cnt, group, results = 0, \"\", []\n    for ch in paren_string:\n        if ch == \"(\": cnt += 1\n        if ch == \")\": cnt -= 1\n        if ch != \" \": group += ch\n        if cnt == 0:\n            if group != \"\": results.append(group)\n            group = \"\"\n    return results\n\n\n\nContract List:\nassert_0: assert type(paren_string) == str, \"invalid inputs\nassert_1: assert ch in [\"(\", \")\", \" \"], \"invalid inputs\nassert_2: assert cnt >= 0, \"invalid inputs\nassert_3: assert cnt == 0, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun safe-sval ((v Value)) String\\n  (ite (is-StrVal v) (sval v) \\\"\\\"))\\n\\n(define-fun-rec all_valid_chars ((v Value) (idx Int)) Bool\\n  (ite (< idx (str.len (safe-sval v)))\\n       (let ((ch (str.substr (safe-sval v) idx 1)))\\n         (and (or (= ch \\\"(\\\") (= ch \\\")\\\") (= ch \\\" \\\"))\\n              (all_valid_chars v (+ idx 1))))\\n       true))\\n\\n(define-fun-rec prefix_balanced ((v Value) (idx Int) (cnt Int)) Bool\\n  (ite (< idx (str.len (safe-sval v)))\\n       (let ((ch (str.substr (safe-sval v) idx 1)))\\n         (let ((new_cnt (ite (= ch \\\"(\\\") (+ cnt 1)\\n                              (ite (= ch \\\")\\\") (- cnt 1) cnt))))\\n           (and (>= new_cnt 0)\\n                (prefix_balanced v (+ idx 1) new_cnt))))\\n       true))\\n\\n(define-fun-rec final_count ((v Value) (idx Int) (cnt Int)) Int\\n  (ite (< idx (str.len (safe-sval v)))\\n       (let ((ch (str.substr (safe-sval v) idx 1)))\\n         (final_count v (+ idx 1)\\n                      (ite (= ch \\\"(\\\") (+ cnt 1)\\n                           (ite (= ch \\\")\\\") (- cnt 1) cnt))))\\n       cnt))\",\n  \"inputs\": \"(declare-const paren_string Value)\",\n  \"basic_structure\": \"\",\n  \"contract_defs\": \"(define-fun C0 () Bool (is-StrVal paren_string))\\n(define-fun C1 () Bool (all_valid_chars paren_string 0))\\n(define-fun C2 () Bool (prefix_balanced paren_string 0 0))\\n(define-fun C3 () Bool (= (final_count paren_string 0 0) 0))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(paren_string) == str, \"invalid inputs", "assert_1": "assert ch in [\"(\", \")\", \" \"], \"invalid inputs", "assert_2": "assert cnt >= 0, \"invalid inputs", "assert_3": "assert cnt == 0, \"invalid inputs"}]}], "reasoning": ["I translate each Python assertion into named SMT predicates using a safe extractor for the input string and recursive helpers to walk and validate characters and balances, keeping execution safe under any contracts by using `safe-sval`. The JSON embeds all helpers, inputs, basic structure, and precise contract definitions.</think>"]}
{"name": "HumanEval/2", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: truncate_number\nProblem Description:\n\n\ndef truncate_number(number: float) -> float:\n    \"\"\" Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n\n\n    assert number > 0, \"invalid inputs\" # $_CONTRACT_$\n    assert isinstance(number, float), \"invalid inputs\" # $_CONTRACT_$\n    assert number != float(\"+inf\"), \"invalid inputs\" # $_CONTRACT_$\n\n\n    return number - int(number)\n\n\n\nContract List:\nassert_0: assert number > 0, \"invalid inputs\nassert_1: assert isinstance(number, float), \"invalid inputs\nassert_2: assert number != float(\"+inf\"), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun safe_fval ((v Value)) Real\\n (ite (is-FloatVal v) (fval v) 0.0))\\n(declare-const INF Real)\",\n  \"inputs\": \"(declare-const number Value)\",\n  \"basic_structure\": \"\",\n  \"contract_defs\": \"(define-fun C0 () Bool (> (safe_fval number) 0.0))\\n(define-fun C1 () Bool (is-FloatVal number))\\n(define-fun C2 () Bool (and (is-FloatVal number) (not (= (fval number) INF))))\"\n}\n```\n", "constraints": [{"assert_0": "assert number > 0, \"invalid inputs", "assert_1": "assert isinstance(number, float), \"invalid inputs", "assert_2": "assert number != float(\"+inf\"), \"invalid inputs"}]}], "reasoning": ["I extended the Value ADT with an InfVal constructor to represent Python’s +inf, added a safe_fval helper to guard fval extraction, and translated each Python assertion into a distinct Boolean predicate Ck. This setup cleanly separates basic executability from contract predicates, enabling independent checking of each assertion.</think>"]}
{"name": "HumanEval/3", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: below_zero\nProblem Description:\nfrom typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" You're given a list of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return True. Otherwise it should return False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"\n\n\n    assert type(operations) == list, \"invalid inputs\" # $_CONTRACT_$\n    assert all([isinstance(v, int) for v in operations]), \"invalid inputs\" # $_CONTRACT_$\n\n    account = 0\n    for operation in operations:\n        account += operation\n        if account < 0:\n            return True\n    return False\n\n\n\nContract List:\nassert_0: assert type(operations) == list, \"invalid inputs\nassert_1: assert all([isinstance(v, int) for v in operations]), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec IsList ((v Value)) Bool\\n  (or (is-Nil v)\\n      (and (is-Cons v)\\n           (IsList (tail v)))))\\n\\n(define-fun safe_ival ((v Value)) Int\\n  (ite (is-IntVal v)\\n       (ival v)\\n       0))\\n\\n(define-fun-rec list_all_int ((v Value)) Bool\\n  (or (is-Nil v)\\n      (and (is-Cons v)\\n           (is-IntVal (head v))\\n           (list_all_int (tail v)))))\",\n  \"inputs\": \"(declare-const operations Value)\",\n  \"basic_structure\": \"(assert (IsList operations))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (IsList operations))\\n(define-fun C1 () Bool (list_all_int operations))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(operations) == list, \"invalid inputs", "assert_1": "assert all([isinstance(v, int) for v in operations]), \"invalid inputs"}]}], "reasoning": ["I will model the input list as an SMT ADT and define safe helpers to traverse it without runtime errors. Each Python assert becomes a standalone Bool predicate, with only the list‐shape check in the basic structure to guarantee recursion and selectors are safe.</think>"]}
{"name": "HumanEval/4", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: mean_absolute_deviation\nProblem Description:\nfrom typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n\n\n    assert all(isinstance(x, float) for x in numbers), \"invalid inputs\" # $_CONTRACT_$\n    assert numbers != [], \"invalid inputs\" # $_CONTRACT_$\n\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n\n\n\nContract List:\nassert_0: assert all(isinstance(x, float) for x in numbers), \"invalid inputs\nassert_1: assert numbers != [], \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec IsList ((lst Value)) Bool\\n  (ite (is-Nil lst)\\n       true\\n       (ite (is-Cons lst)\\n            (IsList (tail lst))\\n            false)))\\n\\n(define-fun-rec list_all_float ((lst Value)) Bool\\n  (ite (is-Nil lst)\\n       true\\n       (ite (is-Cons lst)\\n            (and (is-FloatVal (head lst)) (list_all_float (tail lst)))\\n            false)))\",\n  \"inputs\": \"(declare-const numbers Value)\",\n  \"basic_structure\": \"(assert (IsList numbers))\",\n  \"contract_defs\": \"(define-fun C0 () Bool\\n  (list_all_float numbers))\\n(define-fun C1 () Bool\\n  (is-Cons numbers))\"\n}\n```\n", "constraints": [{"assert_0": "assert all(isinstance(x, float) for x in numbers), \"invalid inputs", "assert_1": "assert numbers != [], \"invalid inputs"}]}], "reasoning": ["I translate the Python list-of-floats assertions into precise SMT-LIB predicates by defining recursive helpers for list structure and element-type checking. I assert basic executability constraints separately and then encode each Python assert exactly as named contract predicates. This template can be extended for systematic violation testing.</think>"]}
{"name": "HumanEval/5", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: intersperse\nProblem Description:\nfrom typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\n\n\n    assert all([isinstance(v, int) for v in numbers]), \"invalid inputs\" # $_CONTRACT_$\n    assert isinstance(delimeter, int), \"invalid inputs\" # $_CONTRACT_$\n\n\n    res = []\n    for i in range(len(numbers)):\n        res.append(numbers[i])\n        if i != len(numbers) - 1:\n            res.append(delimeter)\n    return res\n\n\n\nContract List:\nassert_0: assert all([isinstance(v, int) for v in numbers]), \"invalid inputs\nassert_1: assert isinstance(delimeter, int), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec IsList ((v Value)) Bool\\n  (ite (is-Nil v)\\n       true\\n       (ite (is-Cons v)\\n            (let ((h (head v))\\n                  (t (tail v)))\\n              (IsList t))\\n            false)))\\n\\n(define-fun-rec list_all_ints ((v Value)) Bool\\n  (ite (is-Nil v)\\n       true\\n       (ite (is-Cons v)\\n            (let ((h (head v))\\n                  (t (tail v)))\\n              (and (is-IntVal h)\\n                   (list_all_ints t)))\\n            false)))\",\n  \"inputs\": \"(declare-const numbers Value)\\n(declare-const delimeter Value)\",\n  \"basic_structure\": \"(assert (IsList numbers))\",\n  \"contract_defs\": \"(define-fun C0 () Bool\\n  (list_all_ints numbers))\\n(define-fun C1 () Bool\\n  (is-IntVal delimeter))\"\n}\n```\n", "constraints": [{"assert_0": "assert all([isinstance(v, int) for v in numbers]), \"invalid inputs", "assert_1": "assert isinstance(delimeter, int), \"invalid inputs"}]}], "reasoning": ["I translate the Python assertions into SMT predicates by defining a list ADT and checking each element’s constructor, ensuring executability via list structure helpers and modeling each contract as a separate Boolean.</think>"]}
{"name": "HumanEval/6", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: parse_nested_parens\nProblem Description:\nfrom typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n\n    assert type(paren_string) == str, \"invalid inputs\" # $_CONTRACT_$\n    cnt = 0 # $_CONTRACT_$\n    for ch in paren_string: # $_CONTRACT_$\n        assert ch in [\"(\", \")\", \" \"], \"invalid inputs\"  # $_CONTRACT_$\n        if ch == \"(\": cnt += 1 # $_CONTRACT_$\n        if ch == \")\": cnt -= 1 # $_CONTRACT_$\n        assert cnt >= 0, \"invalid inputs\" # $_CONTRACT_$\n    assert cnt == 0, \"invalid inputs\"\n\n    \n    def count_depth(s: str) -> int:\n        max_depth, cnt = 0, 0\n        for ch in s:\n            if ch == \"(\": cnt += 1\n            if ch == \")\": cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    \n    return [count_depth(s) for s in paren_string.split(\" \") if s != \"\"]\n\n\n\nContract List:\nassert_0: assert type(paren_string) == str, \"invalid inputs\nassert_1: assert ch in [\"(\", \")\", \" \"], \"invalid inputs\nassert_2: assert cnt >= 0, \"invalid inputs\nassert_3: assert cnt == 0, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun ValidParenChars ((s String)) Bool\\n  (str.in.re s (re.* (re.union (str.to.re \\\"(\\\") (re.union (str.to.re \\\")\\\") (str.to.re \\\" \\\"))))))\\n\\n(define-fun-rec prefix_ok ((s String) (i Int) (cnt Int)) Bool\\n  (ite (>= i (str.len s))\\n       true\\n       (let ((ch (str.at s i)))\\n         (let ((isL (str.in.re ch (str.to.re \\\"(\\\")))\\n               (isR (str.in.re ch (str.to.re \\\")\\\"))))\\n           (let ((newCnt (ite isL (+ cnt 1) (ite isR (- cnt 1) cnt))))\\n             (and (>= newCnt 0)\\n                  (prefix_ok s (+ i 1) newCnt)))))))\\n\\n(define-fun-rec sum_balance ((s String) (i Int)) Int\\n  (ite (>= i (str.len s))\\n       0\\n       (let ((ch (str.at s i)))\\n         (let ((isL (str.in.re ch (str.to.re \\\"(\\\")))\\n               (isR (str.in.re ch (str.to.re \\\")\\\"))))\\n           (let ((cur (ite isL 1 (ite isR (- 1) 0))))\\n             (+ cur (sum_balance s (+ i 1))))))))\",\n  \"inputs\": \"(declare-const paren_string Value)\",\n  \"basic_structure\": \"\",\n  \"contract_defs\": \"(define-fun C0 () Bool (is-StrVal paren_string))\\n(define-fun C1 () Bool (and (is-StrVal paren_string) (ValidParenChars (sval paren_string))))\\n(define-fun C2 () Bool (and (is-StrVal paren_string) (prefix_ok (sval paren_string) 0 0)))\\n(define-fun C3 () Bool (and (is-StrVal paren_string) (= (sum_balance (sval paren_string) 0) 0)))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(paren_string) == str, \"invalid inputs", "assert_1": "assert ch in [\"(\", \")\", \" \"], \"invalid inputs", "assert_2": "assert cnt >= 0, \"invalid inputs", "assert_3": "assert cnt == 0, \"invalid inputs"}]}], "reasoning": ["I will encode each Python assertion as a separate SMT predicate C0–C3, define recursive helpers to check prefix non‐negativity and total balance, and declare the input and ADT while keeping basic structure minimal.</think>"]}
{"name": "HumanEval/7", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: filter_by_substring\nProblem Description:\nfrom typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n\n\n    assert type(strings) == list, \"invalid inputs\" # $_CONTRACT_$\n    assert all(type(x) == str for x in strings), \"invalid inputs\" # $_CONTRACT_$\n    assert isinstance(substring, str), \"invalid inputs\" # $_CONTRACT_$\n\n    return list(filter(lambda s: substring in s, strings))\n\n\n\nContract List:\nassert_0: assert type(strings) == list, \"invalid inputs\nassert_1: assert all(type(x) == str for x in strings), \"invalid inputs\nassert_2: assert isinstance(substring, str), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec IsList ((v Value)) Bool\\n  (ite (is-Nil v)\\n       true\\n       (ite (is-Cons v)\\n            (IsList (tail v))\\n            false)))\\n\\n(define-fun-rec AllStr ((lst Value)) Bool\\n  (ite (is-Nil lst)\\n       true\\n       (ite (is-Cons lst)\\n            (and (is-StrVal (head lst))\\n                 (AllStr (tail lst)))\\n            false)))\",\n  \"inputs\": \"(declare-const strings Value)\\n(declare-const substring Value)\",\n  \"basic_structure\": \"(assert (IsList strings))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (IsList strings))\\n(define-fun C1 () Bool (AllStr strings))\\n(define-fun C2 () Bool (is-StrVal substring))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(strings) == list, \"invalid inputs", "assert_1": "assert all(type(x) == str for x in strings), \"invalid inputs", "assert_2": "assert isinstance(substring, str), \"invalid inputs"}]}], "reasoning": ["I translate the Python asserts into SMT predicates ensuring list structure and element types, defining recursive helpers for list and string checks while keeping execution constraints minimal.</think>"]}
{"name": "HumanEval/8", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: sum_product\nProblem Description:\nfrom typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n\n\n    assert all([isinstance(v, int) for v in numbers]), \"invalid inputs\" # $_CONTRACT_$\n\n    s, p = 0, 1\n    for number in numbers:\n        s += number\n        p *= number\n    return s, p\n\n\n\nContract List:\nassert_0: assert all([isinstance(v, int) for v in numbers]), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec IsList ((l Value)) Bool\\n  (ite (is-Nil l)\\n       true\\n       (ite (is-Cons l)\\n            (IsList (tail l))\\n            false)))\\n\\n(define-fun-rec list_all_int ((l Value)) Bool\\n  (ite (is-Nil l)\\n       true\\n       (ite (is-Cons l)\\n            (and (is-IntVal (head l))\\n                 (list_all_int (tail l)))\\n            false)))\",\n  \"inputs\": \"(declare-const numbers Value)\",\n  \"basic_structure\": \"(assert (IsList numbers))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (list_all_int numbers))\"\n}\n```\n", "constraints": [{"assert_0": "assert all([isinstance(v, int) for v in numbers]), \"invalid inputs"}]}], "reasoning": ["I model the list structure and the “all ints” contract by defining helper functions IsList and list_all_int using safe recursive patterns. Inputs declare “numbers” as a Value, basic_structure asserts its list shape, and C0 captures the Python all(isinstance) assertion exactly.</think>"]}
{"name": "HumanEval/9", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: rolling_max\nProblem Description:\nfrom typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n\n\n    assert isinstance(numbers, list), \"invalid inputs\" # $_CONTRACT_$\n    assert all([isinstance(v, int) for v in numbers]), \"invalid inputs\" # $_CONTRACT_$\n\n    return [max(numbers[:(i+1)]) for i in range(len(numbers))]\n\n\n\nContract List:\nassert_0: assert isinstance(numbers, list), \"invalid inputs\nassert_1: assert all([isinstance(v, int) for v in numbers]), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec IsList ((v Value)) Bool\\n  (ite (is-Nil v)\\n       true\\n       (ite (is-Cons v)\\n            (IsList (tail v))\\n            false)))\\n\\n(define-fun-rec list_all_int ((v Value)) Bool\\n  (ite (is-Nil v)\\n       true\\n       (ite (is-Cons v)\\n            (and (is-IntVal (head v))\\n                 (list_all_int (tail v)))\\n            false)))\",\n  \"inputs\": \"(declare-const numbers Value)\",\n  \"basic_structure\": \"(assert (IsList numbers))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (IsList numbers))\\n(define-fun C1 () Bool (list_all_int numbers))\"\n}\n```\n", "constraints": [{"assert_0": "assert isinstance(numbers, list), \"invalid inputs", "assert_1": "assert all([isinstance(v, int) for v in numbers]), \"invalid inputs"}]}], "reasoning": ["I will translate the Python list‐and‐int assertions into two precise SMT predicates over our Value ADT, provide recursive helpers to recognize lists and all‐int lists, and ensure the `numbers` input is always a well‐formed list for safe execution.</think>"]}
{"name": "HumanEval/10", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: make_palindrome\nProblem Description:\n\n\ndef is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"\n\n\n    assert type(string) == str, \"invalid inputs\" # $_CONTRACT_$\n\n    if is_palindrome(string):\n        return string\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            return string + string[i-1::-1]\n\n\n\nContract List:\nassert_0: assert type(string) == str, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"\",\n  \"inputs\": \"(declare-const string Value)\",\n  \"basic_structure\": \"(assert (is-StrVal string))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (is-StrVal string))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(string) == str, \"invalid inputs"}]}], "reasoning": ["I translate the Python type assertion into an SMT StrVal tester, enforce that ‘string’ is a StrVal for executability, and define C0 to mirror the assert.</think>"]}
{"name": "HumanEval/11", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: string_xor\nProblem Description:\nfrom typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n\n\n    assert isinstance(a, str) and isinstance(b, str), \"invalid inputs\" # $_CONTRACT_$\n    assert len(a) == len(b), \"invalid inputs\" # $_CONTRACT_$\n    assert set(a).issubset({\"0\", \"1\"}) and set(b).issubset({\"0\", \"1\"}), \"invalid inputs\" # $_CONTRACT_$\n\n\n    return \"\".join(str(int(a[i]) ^ int(b[i])) for i in range(len(a)))\n\n\n\nContract List:\nassert_0: assert isinstance(a, str) and isinstance(b, str), \"invalid inputs\nassert_1: assert len(a) == len(b), \"invalid inputs\nassert_2: assert set(a).issubset({\"0\", \"1\"}) and set(b).issubset({\"0\", \"1\"}), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun Safe_Sval ((x Value)) String\\n  (ite (is-StrVal x) (sval x) \\\"\\\"))\\n(define-fun isBinaryString ((s Value)) Bool\\n  (and (is-StrVal s)\\n       (str.in.re (Safe_Sval s) (re.* (re.union (str.to.re \\\"0\\\") (str.to.re \\\"1\\\"))))))\",\n  \"inputs\": \"(declare-const a Value)\\n(declare-const b Value)\",\n  \"basic_structure\": \"\",\n  \"contract_defs\": \"(define-fun C0 () Bool (and (is-StrVal a) (is-StrVal b)))\\n(define-fun C1 () Bool (= (str.len (Safe_Sval a)) (str.len (Safe_Sval b))))\\n(define-fun C2 () Bool (and (isBinaryString a) (isBinaryString b)))\"\n}\n```\n", "constraints": [{"assert_0": "assert isinstance(a, str) and isinstance(b, str), \"invalid inputs", "assert_1": "assert len(a) == len(b), \"invalid inputs", "assert_2": "assert set(a).issubset({\"0\", \"1\"}) and set(b).issubset({\"0\", \"1\"}), \"invalid inputs"}]}], "reasoning": ["I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.</think>"]}
{"name": "HumanEval/12", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: longest\nProblem Description:\nfrom typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n\n\n    assert type(strings) == list, \"invalid inputs\" # $_CONTRACT_$\n    assert all([isinstance(v, str) for v in strings]), \"invalid inputs\" # $_CONTRACT_$\n\n    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n\n\n\nContract List:\nassert_0: assert type(strings) == list, \"invalid inputs\nassert_1: assert all([isinstance(v, str) for v in strings]), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec IsList ((v Value)) Bool\\n  (ite (is-Nil v) true\\n    (ite (is-Cons v)\\n      (IsList (tail v))\\n      false)))\\n\\n(define-fun-rec AllStr ((v Value)) Bool\\n  (ite (is-Nil v) true\\n    (ite (is-Cons v)\\n      (and (is-StrVal (head v)) (AllStr (tail v)))\\n      false)))\",\n  \"inputs\": \"(declare-const strings Value)\",\n  \"basic_structure\": \"(assert (IsList strings))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (IsList strings))\\n(define-fun C1 () Bool (AllStr strings))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(strings) == list, \"invalid inputs", "assert_1": "assert all([isinstance(v, str) for v in strings]), \"invalid inputs"}]}], "reasoning": ["I translate the Python list-type and element-type assertions into recursive SMT-LIB predicates IsList and AllStr, declare the input, assert basic shape invariants, and then define C0 and C1 to mirror the two Python asserts.</think>"]}
{"name": "HumanEval/13", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: greatest_common_divisor\nProblem Description:\n\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n\n\n    assert type(a) == int and type(b) == int, \"invalid inputs\" # $_CONTRACT_$\n    assert a > 0 and b > 0, \"invalid inputs\" # $_CONTRACT_$\n\n\n    def query_gcd(a: int, b: int) -> int:\n        return a if b == 0 else query_gcd(b, a % b)\n    return query_gcd(a, b)    \n\n\n\nContract List:\nassert_0: assert type(a) == int and type(b) == int, \"invalid inputs\nassert_1: assert a > 0 and b > 0, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun IsInt ((v Value)) Bool (is-IntVal v))\\n(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))\\n(define-fun-rec query_gcd ((x Int) (y Int)) Int\\n  (ite (= y 0)\\n       x\\n       (query_gcd y (mod x y))))\",\n  \"inputs\": \"(declare-const a Value)\\n(declare-const b Value)\",\n  \"basic_structure\": \"\",\n  \"contract_defs\": \"(define-fun C0 () Bool (and (is-IntVal a) (is-IntVal b)))\\n(define-fun C1 () Bool (and (> (SafeI a) 0) (> (SafeI b) 0)))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(a) == int and type(b) == int, \"invalid inputs", "assert_1": "assert a > 0 and b > 0, \"invalid inputs"}]}], "reasoning": ["I will translate the Python assertions into precise SMT-LIB predicates, define a safe integer extractor and the recursive GCD helper for executability, and declare inputs with minimal structure.</think>"]}
{"name": "HumanEval/14", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: all_prefixes\nProblem Description:\nfrom typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"\n\n\n    assert isinstance(string, str), \"invalid inputs\" # $_CONTRACT_$\n\n    return [string[:(i + 1)] for i in range(len(string))]\n\n\n\nContract List:\nassert_0: assert isinstance(string, str), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"\",\n  \"inputs\": \"(declare-const string Value)\",\n  \"basic_structure\": \"(assert (is-StrVal string))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (is-StrVal string))\"\n}\n```\n", "constraints": [{"assert_0": "assert isinstance(string, str), \"invalid inputs"}]}], "reasoning": ["I translate the Python assertion into an SMT predicate requiring the input to be the StrVal constructor, ensure basic executability by constraining the input’s ADT shape, and emit a reusable template.</think>"]}
{"name": "HumanEval/15", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: string_sequence\nProblem Description:\n\n\ndef string_sequence(n: int) -> str:\n    \"\"\" Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n    >>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n    '0 1 2 3 4 5'\n    \"\"\"\n\n\n    assert type(n) == int, \"invalid inputs\" # $_CONTRACT_$\n    assert n >= 0, \"invalid inputs\" # $_CONTRACT_$\n\n\n    return \" \".join(map(str, range(n + 1)))\n\n\n\nContract List:\nassert_0: assert type(n) == int, \"invalid inputs\nassert_1: assert n >= 0, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"\",\n  \"inputs\": \"(declare-const n Value)\",\n  \"basic_structure\": \"\",\n  \"contract_defs\": \"(define-fun C0 () Bool (is-IntVal n))\\n(define-fun C1 () Bool (implies (is-IntVal n) (>= (ival n) 0)))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(n) == int, \"invalid inputs", "assert_1": "assert n >= 0, \"invalid inputs"}]}], "reasoning": ["I model the Python assertions as independent SMT predicates over a Value ADT, using built-in testers and guards to precisely capture type and range checks without affecting executability.</think>"]}
{"name": "HumanEval/16", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: count_distinct_characters\nProblem Description:\n\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n\n\n    assert isinstance(string, str), \"invalid inputs\" # $_CONTRACT_$\n\n    return len(set(string.lower()))\n\n\n\nContract List:\nassert_0: assert isinstance(string, str), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"\",\n  \"inputs\": \"(declare-const string Value)\",\n  \"basic_structure\": \"\",\n  \"contract_defs\": \"(define-fun C0 () Bool (is-StrVal string))\"\n}\n```\n", "constraints": [{"assert_0": "assert isinstance(string, str), \"invalid inputs"}]}], "reasoning": ["I will translate the Python isinstance check into a precise SMT-LIB predicate C0 over our Value ADT and declare the input, leaving helper_functions and basic_structure empty since no additional executability invariants are needed for this single contract.</think>"]}
{"name": "HumanEval/17", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: parse_music\nProblem Description:\nfrom typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n\n\n    assert isinstance(music_string, str), \"invalid inputs\" # $_CONTRACT_$\n    assert music_string == \"\" or all(map(lambda x: x in [\"o\", \"o|\", \".|\"], music_string.split(\" \"))), \"invalid inputs\" # $_CONTRACT_$\n\n\n    def count_beats(note: str) -> int:\n        if note == \"o\": return 4\n        elif note == \"o|\": return 2\n        elif note == \".|\": return 1\n    \n    if music_string == \"\": return []\n    return list(map(count_beats, music_string.split(\" \")))\n\n\n\nContract List:\nassert_0: assert isinstance(music_string, str), \"invalid inputs\nassert_1: assert music_string == \"\" or all(map(lambda x: x in [\"o\", \"o|\", \".|\"], music_string.split(\" \"))), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun SafeS ((v Value)) String\\n  (ite (is-StrVal v) (sval v) \\\"\\\"))\",\n  \"inputs\": \"(declare-const music_string Value)\",\n  \"basic_structure\": \"(assert (is-StrVal music_string))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (is-StrVal music_string))\\n(define-fun C1 () Bool (or (= (SafeS music_string) \\\"\\\") (str.in.re (SafeS music_string) (re.union (str.to.re \\\"\\\") (re.++ (re.union (str.to.re \\\"o\\\") (str.to.re \\\"o|\\\") (str.to.re \\\".|\\\")) (re.* (re.++ (str.to.re \\\" \\\") (re.union (str.to.re \\\"o\\\") (str.to.re \\\"o|\\\") (str.to.re \\\".|\\\")))))))))\"\n}\n```\n", "constraints": [{"assert_0": "assert isinstance(music_string, str), \"invalid inputs", "assert_1": "assert music_string == \"\" or all(map(lambda x: x in [\"o\", \"o|\", \".|\"], music_string.split(\" \"))), \"invalid inputs"}]}], "reasoning": ["I translate the Python assertions into SMT-LIB predicates, modeling the string input type and allowed note tokens via regex membership. A SafeS helper guards extraction of the string field, and C0/C1 capture type and token constraints exactly.</think>"]}
{"name": "HumanEval/18", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: how_many_times\nProblem Description:\n\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n\n\n    assert isinstance(string, str) and isinstance(substring, str), \"invalid inputs\" # $_CONTRACT_$\n    assert substring != \"\", \"invalid inputs\" # $_CONTRACT_$\n\n\n    occurences = 0\n    for i in range(len(string)):\n        if string[i:].startswith(substring):\n            occurences += 1\n    return occurences\n\n\n\nContract List:\nassert_0: assert isinstance(string, str) and isinstance(substring, str), \"invalid inputs\nassert_1: assert substring != \"\", \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"\",\n  \"inputs\": \"(declare-const string Value)\\n(declare-const substring Value)\",\n  \"basic_structure\": \"(assert (is-StrVal string))\\n(assert (is-StrVal substring))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (and (is-StrVal string) (is-StrVal substring)))\\n(define-fun C1 () Bool (ite (is-StrVal substring) (not (= (sval substring) \\\"\\\")) true))\"\n}\n```\n", "constraints": [{"assert_0": "assert isinstance(string, str) and isinstance(substring, str), \"invalid inputs", "assert_1": "assert substring != \"\", \"invalid inputs"}]}], "reasoning": ["I translate each Python assert into a precise SMT predicate, ensure that string values are guarded by is-StrVal, and keep basic_structure only enforcing the Value ADT shape needed for the substring operations.</think>"]}
{"name": "HumanEval/19", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: sort_numbers\nProblem Description:\nfrom typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" Input is a space-delimited string of numberals from 'zero' to 'nine'.\n    Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n    Return the string with numbers sorted from smallest to largest\n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n\n\n    assert isinstance(numbers, str), \"invalid inputs\" # $_CONTRACT_$\n    assert numbers == \"\" or all(map(lambda x: x in [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"], numbers.split(\" \"))), \"invalid inputs\" # $_CONTRACT_$\n\n    \n    to_int = {'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9}\n\n    if numbers == \"\": return \"\"\n    return \" \".join(sorted(numbers.split(\" \"), key=lambda n: to_int[n]))\n\n\n\nContract List:\nassert_0: assert isinstance(numbers, str), \"invalid inputs\nassert_1: assert numbers == \"\" or all(map(lambda x: x in [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"], numbers.split(\" \"))), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun SafeStr ((v Value)) String\\n  (ite (is-StrVal v) (sval v) \\\"\\\"))\",\n  \"inputs\": \"(declare-const numbers Value)\",\n  \"basic_structure\": \"\",\n  \"contract_defs\": \"(define-fun C0 () Bool\\n  (is-StrVal numbers))\\n(define-fun C1 () Bool\\n  (let ((s (SafeStr numbers))\\n        (pattern\\n          (let ((digit (re.union (str.to.re \\\"zero\\\") (str.to.re \\\"one\\\") (str.to.re \\\"two\\\") (str.to.re \\\"three\\\") (str.to.re \\\"four\\\") (str.to.re \\\"five\\\") (str.to.re \\\"six\\\") (str.to.re \\\"seven\\\") (str.to.re \\\"eight\\\") (str.to.re \\\"nine\\\")))\\n                (sep (str.to.re \\\" \\\")))\\n            (re.++ digit (re.* (re.++ sep digit))))))\\n    (or (= s \\\"\\\") (str.in.re s pattern))))\"\n}\n```\n", "constraints": [{"assert_0": "assert isinstance(numbers, str), \"invalid inputs", "assert_1": "assert numbers == \"\" or all(map(lambda x: x in [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"], numbers.split(\" \"))), \"invalid inputs"}]}], "reasoning": ["I translate the Python asserts into two precise SMT predicates over a canonical Value ADT, supplying a SafeStr helper to extract strings safely and a regex-based pattern for valid tokens. No unconditional type restrictions go into BASIC_STRUCTURE so each contract remains independently testable.</think>"]}
{"name": "HumanEval/20", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: find_closest_elements\nProblem Description:\nfrom typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n\n\n    assert all(type(x) in [int, float] for x in numbers), \"invalid inputs\" # $_CONTRACT_$\n    assert len(numbers) >= 2, \"invalid inputs\"  # $_CONTRACT_$\n\n\n    numbers.sort()\n    min_diff = float(\"inf\")\n    min_pair = None\n    for l, r in zip(numbers[:-1], numbers[1:]):\n        diff = r - l\n        if diff < min_diff:\n            min_diff = diff\n            min_pair = (l, r)\n    return min_pair\n\n\n\nContract List:\nassert_0: assert all(type(x) in [int, float] for x in numbers), \"invalid inputs\nassert_1: assert len(numbers) >= 2, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec IsList ((v Value)) Bool\\n  (or (is-Nil v)\\n      (and (is-Cons v)\\n           (IsList (tail v)))))\\n(define-fun-rec list_all_numeric ((v Value)) Bool\\n  (or (is-Nil v)\\n      (and (is-Cons v)\\n           (let ((head (head v)) (tailv (tail v)))\\n             (and (or (is-IntVal head) (is-FloatVal head))\\n                  (list_all_numeric tailv))))))\\n(define-fun-rec list_length ((v Value)) Int\\n  (ite (is-Cons v)\\n       (+ 1 (list_length (tail v)))\\n       0))\",\n  \"inputs\": \"(declare-const numbers Value)\",\n  \"basic_structure\": \"(assert (IsList numbers))\",\n  \"contract_defs\": \"(define-fun C0 () Bool\\n  (list_all_numeric numbers))\\n(define-fun C1 () Bool\\n  (>= (list_length numbers) 2))\"\n}\n```\n", "constraints": [{"assert_0": "assert all(type(x) in [int, float] for x in numbers), \"invalid inputs", "assert_1": "assert len(numbers) >= 2, \"invalid inputs"}]}], "reasoning": ["I translate the Python list and numeric checks into recursive SMT functions (IsList, list_all_numeric, list_length) to ensure safe traversal, then define C0 and C1 to mirror the asserts exactly while requiring basic list structure for executability.</think>"]}
{"name": "HumanEval/21", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: rescale_to_unit\nProblem Description:\nfrom typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n\n\n    assert all(type(x) in [int, float] for x in numbers), \"invalid inputs\" # $_CONTRACT_$\n    assert len(numbers) >= 2, \"invalid inputs\" # $_CONTRACT_$\n    assert max(numbers) > min(numbers), \"invalid inputs\" # $_CONTRACT_$\n\n\n    ma, mi = max(numbers), min(numbers)\n    k = 1 / (ma - mi)\n    return list(map(lambda x: (x - mi) * k, numbers))\n\n\n\nContract List:\nassert_0: assert all(type(x) in [int, float] for x in numbers), \"invalid inputs\nassert_1: assert len(numbers) >= 2, \"invalid inputs\nassert_2: assert max(numbers) > min(numbers), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec IsList ((l Value)) Bool\\n  (or (is-Nil l) (and (is-Cons l) (IsList (tail l)))))\\n\\n(define-fun-rec list_all_numeric ((l Value)) Bool\\n  (or (is-Nil l) (and (is-Cons l) (or (is-IntVal (head l)) (is-FloatVal (head l))) (list_all_numeric (tail l)))))\\n\\n(define-fun safe_num ((v Value)) Real\\n  (ite (is-IntVal v) (to_real (ival v)) (ite (is-FloatVal v) (fval v) 0.0)))\\n\\n(define-fun LenGE2 ((l Value)) Bool\\n  (and (is-Cons l) (is-Cons (tail l))))\\n\\n(define-fun-rec exists_gt_tail ((x Value) (l Value)) Bool\\n  (ite (is-Cons l) (or (> (safe_num x) (safe_num (head l))) (exists_gt_tail x (tail l))) false))\\n\\n(define-fun-rec exists_pair_gt ((l Value)) Bool\\n  (ite (is-Cons l) (or (exists_gt_tail (head l) (tail l)) (exists_pair_gt (tail l))) false))\",\n  \"inputs\": \"(declare-const numbers Value)\",\n  \"basic_structure\": \"(assert (IsList numbers))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (list_all_numeric numbers))\\n(define-fun C1 () Bool (LenGE2 numbers))\\n(define-fun C2 () Bool (and (LenGE2 numbers) (exists_pair_gt numbers)))\"\n}\n```\n", "constraints": [{"assert_0": "assert all(type(x) in [int, float] for x in numbers), \"invalid inputs", "assert_1": "assert len(numbers) >= 2, \"invalid inputs", "assert_2": "assert max(numbers) > min(numbers), \"invalid inputs"}]}], "reasoning": ["I will model the Python assertions as precise SMT-LIB predicates, defining recursive list operations (length, max, min, numeric‐check) under safe guards, and assert the list‐structure invariant separately.</think>"]}
{"name": "HumanEval/22", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: filter_integers\nProblem Description:\nfrom typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\n\n\n    assert type(values) == list, \"invalid inputs\" # $_CONTRACT_$\n\n    return list(filter(lambda x: type(x) == int, values))\n\n\n\nContract List:\nassert_0: assert type(values) == list, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec IsList ((v Value)) Bool\\n  (ite (is-Nil v)\\n       true\\n       (ite (is-Cons v)\\n            (IsList (tail v))\\n            false)))\",\n  \"inputs\": \"(declare-const values Value)\",\n  \"basic_structure\": \"\",\n  \"contract_defs\": \"(define-fun C0 () Bool (IsList values))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(values) == list, \"invalid inputs"}]}], "reasoning": ["I map the Python `assert type(values) == list` to a recursive SMT predicate `IsList` over the ADT (Nil/Cons) and define C0 to require `values` to satisfy `IsList`. No additional executability invariants are needed beyond the contract itself.</think>"]}
{"name": "HumanEval/23", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: strlen\nProblem Description:\n\n\ndef strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"\n\n\n    assert isinstance(string, str), \"invalid inputs\" # $_CONTRACT_$\n\n    return len(string)\n\n\n\nContract List:\nassert_0: assert isinstance(string, str), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"\",\n  \"inputs\": \"(declare-const string Value)\",\n  \"basic_structure\": \"(assert (is-StrVal string))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (is-StrVal string))\"\n}\n```\n", "constraints": [{"assert_0": "assert isinstance(string, str), \"invalid inputs"}]}], "reasoning": ["I translate the Python `isinstance` assertion into an SMT predicate ensuring the input is tagged as a string in our ADT, and include this as both a basic execution constraint and a standalone contract definition. No additional helpers are needed since string typing is directly supported by the ADT.</think>"]}
{"name": "HumanEval/24", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: largest_divisor\nProblem Description:\n\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n\n\n    assert type(n) == int, \"invalid inputs\" # $_CONTRACT_$\n    assert n > 1, \"invalid inputs\" # $_CONTRACT_$\n\n\n    for i in range(2, n):\n        if n % i == 0: return n // i\n    return 1\n\n\n\nContract List:\nassert_0: assert type(n) == int, \"invalid inputs\nassert_1: assert n > 1, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun safe-int ((v Value)) Int (ite (is-IntVal v) (ival v) 0))\",\n  \"inputs\": \"(declare-const n Value)\",\n  \"basic_structure\": \"(assert (is-IntVal n))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (is-IntVal n))\\n(define-fun C1 () Bool (> (safe-int n) 1))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(n) == int, \"invalid inputs", "assert_1": "assert n > 1, \"invalid inputs"}]}], "reasoning": ["I translate Python asserts into SMT predicates C0 and C1 with precise type checking and value extraction via a safe-int helper, while ensuring executability by asserting the input is an IntVal in the basic structure.</think>"]}
{"name": "HumanEval/25", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: factorize\nProblem Description:\nfrom typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n\n\n    assert type(n) == int, \"invalid inputs\" # $_CONTRACT_$\n    assert n >= 2, \"invalid inputs\" # $_CONTRACT_$\n\n    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n //= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n\n\n\nContract List:\nassert_0: assert type(n) == int, \"invalid inputs\nassert_1: assert n >= 2, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))\",\n  \"inputs\": \"(declare-const n Value)\",\n  \"basic_structure\": \"\",\n  \"contract_defs\": \"(define-fun C0 () Bool (is-IntVal n))\\n(define-fun C1 () Bool (and (is-IntVal n) (>= (SafeI n) 2)))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(n) == int, \"invalid inputs", "assert_1": "assert n >= 2, \"invalid inputs"}]}], "reasoning": ["I modeled the input type and range checks as separate predicates using a SafeI helper to guard ival access. Each assertion is captured as a standalone Ck, and all SMT constructs strictly follow the ADT and tester/selector rules.</think>"]}
{"name": "HumanEval/26", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: remove_duplicates\nProblem Description:\nfrom typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n\n\n    assert type(numbers) == list, \"invalid inputs\" # $_CONTRACT_$\n    assert all(type(x) == int for x in numbers), \"invalid inputs\" # $_CONTRACT_$\n\n    num_cnt = dict()\n    for number in numbers:\n        if number not in num_cnt:\n            num_cnt[number] = 0\n        num_cnt[number] += 1\n    return [number for number in numbers if num_cnt[number] == 1]\n\n\n\nContract List:\nassert_0: assert type(numbers) == list, \"invalid inputs\nassert_1: assert all(type(x) == int for x in numbers), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec IsList ((v Value)) Bool\\n  (ite (is-Nil v)\\n       true\\n       (ite (is-Cons v)\\n            (IsList (tail v))\\n            false)))\\n\\n(define-fun-rec list_all_ints ((v Value)) Bool\\n  (ite (is-Nil v)\\n       true\\n       (ite (is-Cons v)\\n            (and (is-IntVal (head v))\\n                 (list_all_ints (tail v)))\\n            false)))\",\n  \"inputs\": \"(declare-const numbers Value)\",\n  \"basic_structure\": \"(assert (IsList numbers))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (IsList numbers))\\n(define-fun C1 () Bool (list_all_ints numbers))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(numbers) == list, \"invalid inputs", "assert_1": "assert all(type(x) == int for x in numbers), \"invalid inputs"}]}], "reasoning": ["I translate the Python `assert` checks into SMT predicates by defining `IsList` and `list_all_ints` as recursive ADT predicates for list structure and element types. I put the minimal shape‐checking in the basic structure and isolate each contract into its own Boolean definition.</think>"]}
{"name": "HumanEval/27", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: flip_case\nProblem Description:\n\n\ndef flip_case(string: str) -> str:\n    \"\"\" For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"\n\n\n    assert type(string) == str, \"invalid inputs\" # $_CONTRACT_$\n\n    return \"\".join(map(lambda x: x.swapcase(), string))\n\n\n\nContract List:\nassert_0: assert type(string) == str, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun SafeS ((v Value)) String (ite (is-StrVal v) (sval v) \\\"\\\"))\",\n  \"inputs\": \"(declare-const string Value)\",\n  \"basic_structure\": \"\",\n  \"contract_defs\": \"(define-fun C0 () Bool (is-StrVal string))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(string) == str, \"invalid inputs"}]}], "reasoning": ["I translate the Python type-check into an SMT predicate requiring the input be a StrVal, add a SafeS helper to guard sval usage, declare the input, and define C0 accordingly.</think>"]}
{"name": "HumanEval/28", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: concatenate\nProblem Description:\nfrom typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\"\n\n\n    assert all(isinstance(s, str) for s in strings), \"invalid inputs\" # $_CONTRACT_$\n    assert isinstance(strings, list), \"invalid inputs\" # $_CONTRACT_$\n\n    return \"\".join(strings)\n\n\n\nContract List:\nassert_0: assert all(isinstance(s, str) for s in strings), \"invalid inputs\nassert_1: assert isinstance(strings, list), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec IsList ((v Value)) Bool\\n  (or\\n    (is-Nil v)\\n    (and (is-Cons v) (IsList (tail v)))\\n  )\\n)\\n\\n(define-fun-rec list_all_str ((v Value)) Bool\\n  (ite (is-Nil v)\\n       true\\n       (ite (is-Cons v)\\n            (and (is-StrVal (head v)) (list_all_str (tail v)))\\n            false\\n       )\\n  )\\n)\",\n  \"inputs\": \"(declare-const strings Value)\",\n  \"basic_structure\": \"\",\n  \"contract_defs\": \"(define-fun C0 () Bool (list_all_str strings))\\n(define-fun C1 () Bool (IsList strings))\"\n}\n```\n", "constraints": [{"assert_0": "assert all(isinstance(s, str) for s in strings), \"invalid inputs", "assert_1": "assert isinstance(strings, list), \"invalid inputs"}]}], "reasoning": ["I translate the Python `assert` checks into two Boolean predicates over a generic `Value` ADT, using recursive definitions for list shape and element‐type checking, while ensuring all selectors are guarded for safety.</think>"]}
{"name": "HumanEval/29", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: filter_by_prefix\nProblem Description:\nfrom typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that start with a given prefix.\n    >>> filter_by_prefix([], 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ['abc', 'array']\n    \"\"\"\n\n\n    assert all(isinstance(s, str) for s in strings), \"invalid inputs\" # $_CONTRACT_$\n    assert isinstance(prefix, str), \"invalid inputs\" # $_CONTRACT_$\n\n    return list(filter(lambda x: x.startswith(prefix), strings))\n\n\n\nContract List:\nassert_0: assert all(isinstance(s, str) for s in strings), \"invalid inputs\nassert_1: assert isinstance(prefix, str), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec IsList ((v Value)) Bool\\n  (ite (is-Nil v)\\n       true\\n       (ite (is-Cons v)\\n            (IsList (tail v))\\n            false)))\\n\\n(define-fun-rec list_all_str ((v Value)) Bool\\n  (ite (is-Nil v)\\n       true\\n       (ite (is-Cons v)\\n            (and (is-StrVal (head v))\\n                 (list_all_str (tail v)))\\n            false)))\",\n  \"inputs\": \"(declare-const strings Value)\\n(declare-const prefix Value)\",\n  \"basic_structure\": \"(assert (IsList strings))\",\n  \"contract_defs\": \"(define-fun C0 () Bool\\n  (list_all_str strings))\\n(define-fun C1 () Bool\\n  (is-StrVal prefix))\\n(define-fun COMBINATION () Bool\\n  (or\\n    (and C0 C1)\\n    (and (not C0) C1)\\n    (and C0 (not C1))\\n    (and (not C0) (not C1))))\"\n}\n```\n", "constraints": [{"assert_0": "assert all(isinstance(s, str) for s in strings), \"invalid inputs", "assert_1": "assert isinstance(prefix, str), \"invalid inputs"}]}], "reasoning": ["I will translate the Python assertions into precise SMT predicates over our ADT, introduce recursive list and string‐type helpers to ensure executability, and define each contract as a named Boolean. Finally, I’ll enumerate all combinations of those contracts in a single COMBINATION definition.</think>"]}
{"name": "HumanEval/30", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: get_positive\nProblem Description:\n\n\ndef get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n\n\n    assert type(l) == list, \"invalid inputs\" # $_CONTRACT_$\n\n    return list(filter(lambda x: x > 0, l))\n\n\n\nContract List:\nassert_0: assert type(l) == list, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec IsList ((v Value)) Bool\\n  (ite (is-Nil v) true\\n    (ite (is-Cons v)\\n         (IsList (tail v))\\n         false)))\\n\\n(define-fun-rec list_all_numeric ((v Value)) Bool\\n  (ite (is-Nil v) true\\n    (ite (is-Cons v)\\n         (let ((hd (head v)) (tl (tail v)))\\n           (and (or (is-IntVal hd) (is-FloatVal hd))\\n                (list_all_numeric tl)))\\n         false)))\",\n  \"inputs\": \"(declare-const l Value)\",\n  \"basic_structure\": \"(assert (IsList l))\\n(assert (list_all_numeric l))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (IsList l))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(l) == list, \"invalid inputs"}]}], "reasoning": ["I define recursive helpers to enforce proper list shape and numeric contents, assert these for execution, and map the Python type(l)==list check into C0.</think>"]}
{"name": "HumanEval/31", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: is_prime\nProblem Description:\n\n\ndef is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n\n\n    assert type(n) == int, \"invalid inputs\" # $_CONTRACT_$\n\n    if n <= 1: return False\n    n_sqrt = 1\n    while n_sqrt ** 2 < n: n_sqrt += 1\n    for i in range(2, min(n_sqrt + 1, n)):\n        if n % i == 0:\n            return False\n    return True\n\n\n\nContract List:\nassert_0: assert type(n) == int, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))\",\n  \"inputs\": \"(declare-const n Value)\",\n  \"basic_structure\": \"\",\n  \"contract_defs\": \"(define-fun C0 () Bool (is-IntVal n))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(n) == int, \"invalid inputs"}]}], "reasoning": ["I translate the Python type assertion into an SMT predicate guarded by a tester, introduce a SafeI extractor for integer values to ensure sound arithmetic operations, and declare the input while keeping the basic structure minimal for executability.</think>"]}
{"name": "HumanEval/32", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: find_zero\nProblem Description:\nimport math\n\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    Evaluates polynomial with coefficients xs at point x.\n    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: list):\n    \"\"\" xs are coefficients of a polynomial.\n    find_zero find x such that poly(x) = 0.\n    find_zero returns only only zero point, even if there are many.\n    Moreover, find_zero only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees\n    a solution.\n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"\n\n\n    assert isinstance(xs, list) and len(xs) > 0 and len(xs) % 2 == 0, \"invalid inputs\" # $_CONTRACT_$\n    assert xs[-1] != 0, \"invalid inputs\" # $_CONTRACT_$\n    assert all(type(x) == int for x in xs), \"invalid inputs\" # $_CONTRACT_$\n    dxs = [xs[i] * i for i in range(1, len(xs))] # $_CONTRACT_$\n    def func(x): # $_CONTRACT_$\n        return poly(xs, x) # $_CONTRACT_$\n    def derivative(x): # $_CONTRACT_$\n        return poly(dxs, x) # $_CONTRACT_$\n    x, tol = 0, 1e-5 # $_CONTRACT_$\n    for _ in range(1000): # $_CONTRACT_$\n        fx = func(x) # $_CONTRACT_$\n        dfx = derivative(x) # $_CONTRACT_$\n        if abs(fx) < tol: break # $_CONTRACT_$\n        x = x - fx / dfx # $_CONTRACT_$\n    assert abs(poly(xs, x)) < tol, \"invalid inputs\" # $_CONTRACT_$\n\n    dxs = [xs[i] * i for i in range(1, len(xs))]\n    def func(x):\n        return poly(xs, x)\n    def derivative(x):\n        return poly(dxs, x)\n    \n    x, tol = 0, 1e-5\n    for _ in range(1000):\n        fx = func(x)\n        dfx = derivative(x)\n        if abs(fx) < tol: break\n        x = x - fx / dfx\n\n    return x\n\n\n\nContract List:\nassert_0: assert isinstance(xs, list) and len(xs) > 0 and len(xs) % 2 == 0, \"invalid inputs\nassert_1: assert xs[-1] != 0, \"invalid inputs\nassert_2: assert all(type(x) == int for x in xs), \"invalid inputs\nassert_3: assert abs(poly(xs, x)) < tol, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec isList ((l Value)) Bool\\n  (ite (is-Nil l)\\n       true\\n       (ite (is-Cons l)\\n            (isList (tail l))\\n            false)))\\n(define-fun-rec length ((l Value)) Int\\n  (ite (is-Nil l)\\n       0\\n       (ite (is-Cons l)\\n            (+ 1 (length (tail l)))\\n            0)))\\n(define-fun-rec lastElem ((l Value)) Value\\n  (ite (and (is-Cons l) (is-Nil (tail l)))\\n       (head l)\\n       (ite (is-Cons l)\\n            (lastElem (tail l))\\n            l)))\\n(define-fun-rec list_all_int ((l Value)) Bool\\n  (ite (is-Nil l)\\n       true\\n       (ite (and (is-Cons l) (is-IntVal (head l)) (list_all_int (tail l)))\\n            true\\n            false)))\\n(define-fun-rec pow ((x Real) (n Int)) Real\\n  (ite (= n 0)\\n       1\\n       (* x (pow x (- n 1)))))\\n(define-fun-rec poly_help ((l Value) (idx Int) (x Real)) Real\\n  (ite (is-Nil l)\\n       0\\n       (let ((h (head l)) (t (tail l)))\\n         (ite (is-IntVal h)\\n              (+ (* (to_real (ival h)) (pow x idx))\\n                 (poly_help t (+ idx 1) x))\\n              (poly_help t (+ idx 1) x)))))\\n(define-fun poly ((l Value) (x Real)) Real\\n  (poly_help l 0 x))\\n(define-fun abs ((r Real)) Real\\n  (ite (< r 0) (- r) r))\\n(declare-fun find_zero ((Value)) Real)\",\n  \"inputs\": \"(declare-const xs Value)\\n\",\n  \"basic_structure\": \"(assert (isList xs))\\n(assert (> (length xs) 0))\",\n  \"contract_defs\": \"(define-fun C0 () Bool\\n  (and (isList xs)\\n       (> (length xs) 0)\\n       (= (mod (length xs) 2) 0)))\\n(define-fun C1 () Bool\\n  (not (= (lastElem xs) (IntVal 0))))\\n(define-fun C2 () Bool\\n  (list_all_int xs))\\n(define-fun C3 () Bool\\n  (< (abs (poly xs (find_zero xs))) (/ 1 100000)))\"\n}\n```\n", "constraints": [{"assert_0": "assert isinstance(xs, list) and len(xs) > 0 and len(xs) % 2 == 0, \"invalid inputs", "assert_1": "assert xs[-1] != 0, \"invalid inputs", "assert_2": "assert all(type(x) == int for x in xs), \"invalid inputs", "assert_3": "assert abs(poly(xs, x)) < tol, \"invalid inputs"}]}], "reasoning": ["I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.</think>"]}
{"name": "HumanEval/33", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: sort_third\nProblem Description:\n\n\ndef sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n\n\n    assert type(l) == list, \"invalid inputs\" # $_CONTRACT_$\n\n    third = [l[i] for i in range(len(l)) if i % 3 == 0]\n    third.sort()\n    return [third[i // 3] if i % 3 == 0 else l[i] for i in range(len(l))]\n\n\n\nContract List:\nassert_0: assert type(l) == list, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec IsList ((v Value)) Bool (ite (is-Nil v) true (ite (is-Cons v) (IsList (tail v)) false)))\",\n  \"inputs\": \"(declare-const l Value)\",\n  \"basic_structure\": \"\",\n  \"contract_defs\": \"(define-fun C0 () Bool (IsList l))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(l) == list, \"invalid inputs"}]}], "reasoning": ["I translate the Python type check into an SMT predicate C0 that uses a recursive IsList helper to ensure l is a well-formed list, declare l as a Value, and keep the basic structure empty so we can test both satisfying and violating C0.</think>"]}
{"name": "HumanEval/34", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: unique\nProblem Description:\n\n\ndef unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n\n\n    assert type(l) == list, \"invalid inputs\" # $_CONTRACT_$\n\n    return sorted(set(l))\n\n\n\nContract List:\nassert_0: assert type(l) == list, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec IsList ((x Value)) Bool\\n  (ite (is-Nil x) true\\n       (ite (is-Cons x)\\n            (IsList (tail x))\\n            false)))\",\n  \"inputs\": \"(declare-const l Value)\",\n  \"basic_structure\": \"(assert (IsList l))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (or (is-Nil l) (is-Cons l)))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(l) == list, \"invalid inputs"}]}], "reasoning": ["I will capture the single Python assertion “type(l) == list” by defining a recursive IsList predicate for executability, then define C0 exactly as “l is Nil or Cons.” This ensures precise SMT modeling of the list‐type check.</think>"]}
{"name": "HumanEval/35", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: max_element\nProblem Description:\n\n\ndef max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n\n\n    assert type(l) == list, \"invalid inputs\" # $_CONTRACT_$\n    assert len(l) != 0, \"invalid inputs\" # $_CONTRACT_$\n    assert all(type(x) in [int, float] for x in l), \"invalid inputs\" # $_CONTRACT_$\n\n    return max(l)\n\n\n\nContract List:\nassert_0: assert type(l) == list, \"invalid inputs\nassert_1: assert len(l) != 0, \"invalid inputs\nassert_2: assert all(type(x) in [int, float] for x in l), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec IsList ((v Value)) Bool\\n  (ite (is-Nil v)\\n       true\\n       (ite (is-Cons v)\\n            (IsList (tail v))\\n            false)))\\n\\n(define-fun-rec length ((v Value)) Int\\n  (ite (is-Nil v)\\n       0\\n       (ite (is-Cons v)\\n            (+ 1 (length (tail v)))\\n            0)))\\n\\n(define-fun-rec list_all_numeric ((v Value)) Bool\\n  (ite (is-Nil v)\\n       true\\n       (ite (is-Cons v)\\n            (let ((h (head v)) (t (tail v)))\\n              (and (or (is-IntVal h) (is-FloatVal h))\\n                   (list_all_numeric t)))\\n            false)))\",\n  \"inputs\": \"(declare-const l Value)\",\n  \"basic_structure\": \"(assert (IsList l))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (IsList l))\\n(define-fun C1 () Bool (not (= (length l) 0)))\\n(define-fun C2 () Bool (list_all_numeric l))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(l) == list, \"invalid inputs", "assert_1": "assert len(l) != 0, \"invalid inputs", "assert_2": "assert all(type(x) in [int, float] for x in l), \"invalid inputs"}]}], "reasoning": ["I translate the Python list‐based contracts into SMT‐LIB by defining precise recursive predicates for list structure, length, and numeric checks. Each assert becomes a named Boolean Ck, with a minimal basic_structure ensuring executability.</think>"]}
{"name": "HumanEval/36", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: fizz_buzz\nProblem Description:\n\n\ndef fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n\n\n    assert type(n) == int and n > 0, \"invalid inputs\" # $_CONTRACT_$\n\n    cnt = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            cnt += len(list(filter(lambda c: c == \"7\", str(i))))\n    return cnt\n\n\n\nContract List:\nassert_0: assert type(n) == int and n > 0, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"\",\n  \"inputs\": \"(declare-const n Value)\",\n  \"basic_structure\": \"\",\n  \"contract_defs\": \"(define-fun C0 () Bool (and (is-IntVal n) (> (ival n) 0)))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(n) == int and n > 0, \"invalid inputs"}]}], "reasoning": ["I will translate the Python “invalid inputs” assertion into a named SMT predicate C0 over the ADT-based Value, declare the input n, keep the basic structure empty (so all checks live in C0), and produce a JSON with no comments.</think>"]}
{"name": "HumanEval/37", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: sort_even\nProblem Description:\n\n\ndef sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n\n\n    assert type(l) == list, \"invalid inputs\" # $_CONTRACT_$\n    assert all(type(x) in [int, float] for x in l), \"invalid inputs\" # $_CONTRACT_$\n\n    even = [l[i] for i in range(len(l)) if i % 2 == 0]\n    even.sort()\n    return [even[i // 2] if i % 2 == 0 else l[i] for i in range(len(l))]\n\n\n\nContract List:\nassert_0: assert type(l) == list, \"invalid inputs\nassert_1: assert all(type(x) in [int, float] for x in l), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec IsList ((v Value)) Bool\\n  (ite (is-Nil v)\\n       true\\n       (ite (is-Cons v)\\n            (IsList (tail v))\\n            false)))\\n\\n(define-fun-rec list_all_numeric ((v Value)) Bool\\n  (ite (is-Nil v)\\n       true\\n       (ite (is-Cons v)\\n            (and (or (is-IntVal (head v)) (is-FloatVal (head v)))\\n                 (list_all_numeric (tail v)))\\n            false)))\",\n  \"inputs\": \"(declare-const l Value)\",\n  \"basic_structure\": \"(assert (IsList l))\",\n  \"contract_defs\": \"(define-fun C0 () Bool\\n  (IsList l))\\n(define-fun C1 () Bool\\n  (list_all_numeric l))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(l) == list, \"invalid inputs", "assert_1": "assert all(type(x) in [int, float] for x in l), \"invalid inputs"}]}], "reasoning": ["I model the list structure and element-type checks as recursive predicates over the ADT to mirror Python’s list and numeric constraints, then define each assertion as a named Boolean over the input. This setup ensures safe selector use and supports combination testing of the contracts.</think>"]}
{"name": "HumanEval/38", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: decode_cyclic\nProblem Description:\n\n\ndef encode_cyclic(s: str):\n    \"\"\"\n    returns encoded string by cycling groups of three characters.\n    \"\"\"\n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\n\ndef decode_cyclic(s: str):\n    \"\"\"\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    \"\"\"\n\n\n    assert isinstance(s, str), \"invalid inputs\" # $_CONTRACT_$\n\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    groups = [(group[2] + group[:2]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\n\n\nContract List:\nassert_0: assert isinstance(s, str), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun SafeS ((v Value)) String (ite (is-StrVal v) (sval v) \\\"\\\"))\",\n  \"inputs\": \"(declare-const s Value)\",\n  \"basic_structure\": \"\",\n  \"contract_defs\": \"(define-fun C0 () Bool (is-StrVal s))\"\n}\n```\n", "constraints": [{"assert_0": "assert isinstance(s, str), \"invalid inputs"}]}], "reasoning": ["I identify that the sole contract enforces that input s is a string. I model s as a Value ADT, define a SafeS helper to extract the string for potential string operations, declare the input, leave basic_structure empty since SafeS guards all string ops, and define C0 precisely as (is-StrVal s).</think>"]}
{"name": "HumanEval/39", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: prime_fib\nProblem Description:\n\n\ndef prime_fib(n: int):\n    \"\"\"\n    prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\n    \"\"\"\n\n\n    assert type(n) == int, \"invalid inputs\" # $_CONTRACT_$\n    assert 1 <= n <= 12, \"invalid inputs\" # $_CONTRACT_$\n\n\n    import random\n    def miller_rabin(n, k=10):\n        \"\"\"Test if n is prime using the Miller-Rabin primality test.\"\"\"\n        if n < 2:\n            return False\n        if n == 2 or n == 3:\n            return True\n        if n % 2 == 0:\n            return False\n\n        r = 0\n        d = n - 1\n        while d % 2 == 0:\n            r += 1\n            d //= 2\n\n        for _ in range(k):\n            a = random.randint(2, n - 2)\n            x = pow(a, d, n)\n            if x == 1 or x == n - 1:\n                continue\n            for _ in range(r - 1):\n                x = pow(x, 2, n)\n                if x == n - 1:\n                    break\n            else:\n                return False\n\n        return True\n\n    c_prime = 0\n    a, b = 0, 1\n    while c_prime < n:\n        a, b = b, a + b\n        if miller_rabin(b):\n            c_prime += 1\n    return b\n\n\n\nContract List:\nassert_0: assert type(n) == int, \"invalid inputs\nassert_1: assert 1 <= n <= 12, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun safe-ival ((v Value)) Int (ite (is-IntVal v) (ival v) 0))\",\n  \"inputs\": \"(declare-const n Value)\",\n  \"basic_structure\": \"\",\n  \"contract_defs\": \"(define-fun C0 () Bool (is-IntVal n))\\n(define-fun C1 () Bool (and (<= 1 (safe-ival n)) (<= (safe-ival n) 12)))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(n) == int, \"invalid inputs", "assert_1": "assert 1 <= n <= 12, \"invalid inputs"}]}], "reasoning": ["I model primitive extraction with a safe-ival helper to guard IntVal access, leave basic_structure empty so we can toggle contracts freely, and define C0/C1 exactly matching the Python asserts.</think>"]}
{"name": "HumanEval/40", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: triples_sum_to_zero\nProblem Description:\n\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"\n    triples_sum_to_zero takes a list of integers as an input.\n    it returns True if there are three distinct elements in the list that\n    sum to zero, and False otherwise.\n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n\n\n    assert type(l) == list, \"invalid inputs\" # $_CONTRACT_$\n\n    for i in range(len(l)):\n        for j in range(len(l)):\n            for k in range(len(l)):\n                if i != j and i != k and j != k and l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n\n\n\nContract List:\nassert_0: assert type(l) == list, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec IsList ((v Value)) Bool\\n  (ite (is-Nil v)\\n       true\\n       (ite (is-Cons v)\\n            (IsList (tail v))\\n            false)))\\n\\n(define-fun-rec list_all_int ((v Value)) Bool\\n  (ite (is-Nil v)\\n       true\\n       (ite (is-Cons v)\\n            (and (is-IntVal (head v))\\n                 (list_all_int (tail v)))\\n            false)))\",\n  \"inputs\": \"(declare-const l Value)\",\n  \"basic_structure\": \"(and (IsList l) (list_all_int l))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (IsList l))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(l) == list, \"invalid inputs"}]}], "reasoning": ["I model the Python `type(l)==list` assertion as an SMT predicate C0 using a recursive `IsList` checker, add `list_all_int` to ensure safe integer operations, and declare the list input. The base template includes the ADT, helper functions, input declaration, basic executability constraints, and the contract predicate.</think>"]}
{"name": "HumanEval/41", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: car_race_collision\nProblem Description:\n\n\ndef car_race_collision(n: int):\n    \"\"\"\n    Imagine a road that's a perfectly straight infinitely long line.\n    n cars are driving left to right;  simultaneously, a different set of n cars\n    are driving right to left.   The two sets of cars start out being very far from\n    each other.  All cars move in the same speed.  Two cars are said to collide\n    when a car that's moving left to right hits a car that's moving right to left.\n    However, the cars are infinitely sturdy and strong; as a result, they continue moving\n    in their trajectory as if they did not collide.\n\n    This function outputs the number of such collisions.\n    \"\"\"\n\n\n    assert type(n) == int, \"invalid inputs\" # $_CONTRACT_$\n    assert n >= 1, \"invalid inputs\" # $_CONTRACT_$\n\n\n    return n ** 2\n\n\n\nContract List:\nassert_0: assert type(n) == int, \"invalid inputs\nassert_1: assert n >= 1, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun SafeI ((v Value)) Int\\n  (ite (is-IntVal v) (ival v) 0))\",\n  \"inputs\": \"(declare-const n Value)\",\n  \"basic_structure\": \"\",\n  \"contract_defs\": \"(define-fun C0 () Bool (is-IntVal n))\\n(define-fun C1 () Bool (>= (SafeI n) 1))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(n) == int, \"invalid inputs", "assert_1": "assert n >= 1, \"invalid inputs"}]}], "reasoning": ["I represent the integer input as a Value ADT, define a safe integer extractor SafeI for runtime safety, and then model each Python assert as a separate Boolean predicate using ADT testers. Inputs and basic execution constraints remain generic, with precise contract predicates C0 and C1 for type and range checks.</think>"]}
{"name": "HumanEval/42", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: incr_list\nProblem Description:\n\n\ndef incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\"\n\n\n    assert type(l) == list, \"invalid inputs\" # $_CONTRACT_$\n\n    return [x + 1 for x in l]\n\n\n\nContract List:\nassert_0: assert type(l) == list, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec IsList ((v Value)) Bool\\n  (ite (is-Nil v)\\n       true\\n       (ite (is-Cons v)\\n            (IsList (tail v))\\n            false)))\\n\\n(define-fun-rec list_all_numeric ((xs Value)) Bool\\n  (ite (is-Nil xs)\\n       true\\n       (ite (is-Cons xs)\\n            (and (or (is-IntVal (head xs))\\n                     (is-FloatVal (head xs)))\\n                 (list_all_numeric (tail xs)))\\n            false)))\",\n  \"inputs\": \"(declare-const l Value)\",\n  \"basic_structure\": \"(assert (IsList l))\\n(assert (list_all_numeric l))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (IsList l))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(l) == list, \"invalid inputs"}]}], "reasoning": ["I will introduce recursive helpers to model list shape and numeric elements, declare the input, assert basic executability invariants, and translate the single Python type‐check into a named predicate C0.</think>"]}
{"name": "HumanEval/43", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: pairs_sum_to_zero\nProblem Description:\n\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero takes a list of integers as an input.\n    it returns True if there are two distinct elements in the list that\n    sum to zero, and False otherwise.\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n\n\n    assert all([isinstance(v, int) for v in l]), \"invalid inputs\" # $_CONTRACT_$\n\n    for i in range(len(l)):\n        for j in range(len(l)):\n            if i != j and l[i] + l[j] == 0:\n                return True\n    return False\n\n\n\nContract List:\nassert_0: assert all([isinstance(v, int) for v in l]), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec IsList ((v Value)) Bool\\n  (ite (is-Nil v)\\n       true\\n       (ite (is-Cons v)\\n            (IsList (tail v))\\n            false)))\\n\\n(define-fun-rec list_all_int ((v Value)) Bool\\n  (ite (is-Nil v)\\n       true\\n       (ite (is-Cons v)\\n            (let ((h (head v)) (t (tail v)))\\n              (ite (is-IntVal h)\\n                   (list_all_int t)\\n                   false))\\n            false)))\",\n  \"inputs\": \"(declare-const l Value)\",\n  \"basic_structure\": \"(assert (IsList l))\",\n  \"contract_defs\": \"(define-fun C0 () Bool\\n  (list_all_int l))\"\n}\n```\n", "constraints": [{"assert_0": "assert all([isinstance(v, int) for v in l]), \"invalid inputs"}]}], "reasoning": ["I define recursive ADT predicates IsList and list_all_int to ensure `l` is a proper list of IntVals, then translate the Python all-instance check into C0.</think>"]}
{"name": "HumanEval/44", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: change_base\nProblem Description:\n\n\ndef change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\"\n\n\n    assert type(x) == int and type(base) == int, \"invalid inputs\" # $_CONTRACT_$\n    assert x >= 0, \"invalid inputs\" # $_CONTRACT_$\n    assert 2 <= base <= 9, \"invalid inputs\" # $_CONTRACT_$\n\n\n    if x == 0: return \"0\"\n    ret = \"\"\n    while x != 0:\n        ret = str(x % base) + ret\n        x //= base\n    return ret\n\n\n\nContract List:\nassert_0: assert type(x) == int and type(base) == int, \"invalid inputs\nassert_1: assert x >= 0, \"invalid inputs\nassert_2: assert 2 <= base <= 9, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"\",\n  \"inputs\": \"(declare-const x Value)\\n(declare-const base Value)\",\n  \"basic_structure\": \"\",\n  \"contract_defs\": \"(define-fun C0 () Bool (and (is-IntVal x) (is-IntVal base)))\\n(define-fun C1 () Bool (and (is-IntVal x) (>= (ival x) 0)))\\n(define-fun C2 () Bool (and (is-IntVal base) (<= 2 (ival base) 9)))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(x) == int and type(base) == int, \"invalid inputs", "assert_1": "assert x >= 0, \"invalid inputs", "assert_2": "assert 2 <= base <= 9, \"invalid inputs"}]}], "reasoning": ["I will translate each Python assertion into a guarded SMT-LIB predicate using the ADT’s testers and selectors, declare the inputs as Value, and leave the basic structure empty since no extra invariants are needed for executability.</think>"]}
{"name": "HumanEval/45", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: triangle_area\nProblem Description:\n\n\ndef triangle_area(a, h):\n    \"\"\"Given length of a side and high return area for a triangle.\n    >>> triangle_area(5, 3)\n    7.5\n    \"\"\"\n\n\n    assert isinstance(a, (int, float)) and isinstance(h, (int, float)), \"invalid inputs\" # $_CONTRACT_$\n    assert a > 0 and h > 0, \"invalid inputs\" # $_CONTRACT_$\n\n\n    return a * h / 2\n\n\n\nContract List:\nassert_0: assert isinstance(a, (int, float)) and isinstance(h, (int, float)), \"invalid inputs\nassert_1: assert a > 0 and h > 0, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun SafeToReal ((v Value)) Real\\n  (ite (is-IntVal v)\\n       (to_real (ival v))\\n       (ite (is-FloatVal v)\\n            (fval v)\\n            0.0)))\",\n  \"inputs\": \"(declare-const a Value)\\n(declare-const h Value)\",\n  \"basic_structure\": \"(assert (or (is-IntVal a) (is-FloatVal a)))\\n(assert (or (is-IntVal h) (is-FloatVal h)))\",\n  \"contract_defs\": \"(define-fun C0 () Bool\\n  (and (or (is-IntVal a) (is-FloatVal a))\\n       (or (is-IntVal h) (is-FloatVal h))))\\n(define-fun C1 () Bool\\n  (and (> (SafeToReal a) 0)\\n       (> (SafeToReal h) 0)))\"\n}\n```\n", "constraints": [{"assert_0": "assert isinstance(a, (int, float)) and isinstance(h, (int, float)), \"invalid inputs", "assert_1": "assert a > 0 and h > 0, \"invalid inputs"}]}], "reasoning": ["I translated the Python asserts into SMT predicates C0 and C1, introduced a SafeToReal helper to extract numerical values, asserted basic type-shape invariants for executability, and declared inputs as Values.</think>"]}
{"name": "HumanEval/46", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: fib4\nProblem Description:\n\n\ndef fib4(n: int):\n    \"\"\"The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n    \"\"\"\n\n\n    assert type(n) == int, \"invalid inputs\" # $_CONTRACT_$\n    assert n >= 0, \"invalid inputs\" # $_CONTRACT_$\n\n    \n    if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    elif n == 3:\n        return 0\n    else:\n        a, b, c, d = 0, 0, 2, 0\n        for i in range(4, n + 1):\n            a, b, c, d = b, c, d, a + b + c + d\n        return d\n\n\n\nContract List:\nassert_0: assert type(n) == int, \"invalid inputs\nassert_1: assert n >= 0, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun SafeI ((v Value)) Int\\n  (ite (is-IntVal v) (ival v) 0))\",\n  \"inputs\": \"(declare-const n Value)\",\n  \"basic_structure\": \"(assert (is-IntVal n))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (is-IntVal n))\\n(define-fun C1 () Bool (>= (SafeI n) 0))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(n) == int, \"invalid inputs", "assert_1": "assert n >= 0, \"invalid inputs"}]}], "reasoning": ["I model the Python asserts as SMT predicates over our canonical Value ADT, introduce a SafeI helper for extracting IntVal, assert basic executability via is-IntVal on input, and define C0/C1 exactly matching the type and non-negativity checks.</think>"]}
{"name": "HumanEval/47", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: median\nProblem Description:\n\n\ndef median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n\n\n    assert len(l) > 0, \"invalid inputs\" # $_CONTRACT_$\n    assert all([isinstance(v, (int, float)) for v in l]), \"invalid inputs\" # $_CONTRACT_$\n\n\n    sorted_l = sorted(l)\n    if len(l) % 2 == 1:\n        return sorted_l[len(l) // 2]\n    else:\n        return (sorted_l[len(l) // 2 - 1] + sorted_l[len(l) // 2]) / 2\n\n\n\nContract List:\nassert_0: assert len(l) > 0, \"invalid inputs\nassert_1: assert all([isinstance(v, (int, float)) for v in l]), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec isList ((v Value)) Bool\\n  (ite (is-Nil v) true\\n    (ite (is-Cons v) (isList (tail v)) false)))\\n\\n(define-fun-rec length ((l Value)) Int\\n  (ite (is-Nil l) 0\\n    (ite (is-Cons l) (+ 1 (length (tail l))) 0)))\\n\\n(define-fun-rec all_numeric ((l Value)) Bool\\n  (ite (is-Nil l) true\\n    (ite (is-Cons l)\\n      (and (or (is-IntVal (head l)) (is-FloatVal (head l)))\\n           (all_numeric (tail l)))\\n      false)))\",\n  \"inputs\": \"(declare-const l Value)\",\n  \"basic_structure\": \"(assert (isList l))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (> (length l) 0))\\n(define-fun C1 () Bool (all_numeric l))\"\n}\n```\n", "constraints": [{"assert_0": "assert len(l) > 0, \"invalid inputs", "assert_1": "assert all([isinstance(v, (int, float)) for v in l]), \"invalid inputs"}]}], "reasoning": ["I introduce recursive SMT definitions for list structure, length, and numeric-element checks to capture Python’s list and all([...]) semantics. Then I declare the input, assert basic list well-formedness, and define each contract predicate C0 and C1 exactly matching the Python asserts.</think>"]}
{"name": "HumanEval/48", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: is_palindrome\nProblem Description:\n\n\ndef is_palindrome(text: str):\n    \"\"\"\n    Checks if given string is a palindrome\n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n\n\n    assert isinstance(text, str), \"invalid inputs\" # $_CONTRACT_$\n\n    return text == text[::-1]\n\n\n\nContract List:\nassert_0: assert isinstance(text, str), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun SafeS ((v Value)) String\\n  (ite (is-StrVal v) (sval v) \\\"\\\"))\\n\\n(define-fun-rec rev ((s String)) String\\n  (ite (= (str.len s) 0) \\\"\\\"\\n    (str.++ (str.substr s (- (str.len s) 1) 1)\\n      (rev (str.substr s 0 (- (str.len s) 1))))))\\n\\n(define-fun is_palindrome_fn ((v Value)) Bool\\n  (= (SafeS v) (rev (SafeS v))))\",\n  \"inputs\": \"(declare-const text Value)\",\n  \"basic_structure\": \"(assert true)\",\n  \"contract_defs\": \"(define-fun C0 () Bool (is-StrVal text))\"\n}\n```\n", "constraints": [{"assert_0": "assert isinstance(text, str), \"invalid inputs"}]}], "reasoning": ["I model the Python assertion as an SMT predicate ensuring the input is a StrVal, provide SafeS and a recursive rev helper to support the palindrome check, and keep basic_structure minimal for executability.</think>"]}
{"name": "HumanEval/49", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: modp\nProblem Description:\n\n\ndef modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n\n\n    assert type(n) == int and type(p) == int, \"invalid inputs\" # $_CONTRACT_$\n    assert n >= 0 and p >= 1, \"invalid inputs\" # $_CONTRACT_$\n\n\n    res, x = 1, 2\n    while n != 0:\n        if n % 2 == 1:\n            res = res * x % p\n        x = x * x % p\n        n //= 2\n    return res % p\n\n\n\nContract List:\nassert_0: assert type(n) == int and type(p) == int, \"invalid inputs\nassert_1: assert n >= 0 and p >= 1, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun SafeIval ((v Value)) Int (ite (is-IntVal v) (ival v) 0))\",\n  \"inputs\": \"(declare-const n Value)\\n(declare-const p Value)\",\n  \"basic_structure\": \"\",\n  \"contract_defs\": \"(define-fun C0 () Bool (and (is-IntVal n) (is-IntVal p)))\\n(define-fun C1 () Bool (and (>= (SafeIval n) 0) (>= (SafeIval p) 1)))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(n) == int and type(p) == int, \"invalid inputs", "assert_1": "assert n >= 0 and p >= 1, \"invalid inputs"}]}], "reasoning": ["I defined a SafeIval helper to guard integer extraction, declared the Value inputs, kept basic_structure empty (no universal invariants beyond extractor safety), and translated each Python assert into a separate SMT predicate: C0 checks types via is-IntVal, C1 enforces non-negativity and positivity using SafeIval.</think>"]}
{"name": "HumanEval/50", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: decode_shift\nProblem Description:\n\n\ndef encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\"\n\n\n    assert s == \"\" or s.islower(), \"invalid inputs\" # $_CONTRACT_$\n\n\n    return \"\".join([chr((ord(ch) - ord(\"a\") - 5 + 26) % 26 + ord(\"a\")) for ch in s])\n\n\n\nContract List:\nassert_0: assert s == \"\" or s.islower(), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec all_lower ((str String) (i Int)) Bool\\n  (ite (= i (str.len str))\\n       true\\n       (and (str.in.re (str.substr str i 1) (str.to.re \\\"[a-z]\\\"))\\n            (all_lower str (+ i 1)))))\\n\\n(define-fun is_lower ((str String)) Bool\\n  (and (> (str.len str) 0)\\n       (all_lower str 0)))\",\n  \"inputs\": \"(declare-const s Value)\",\n  \"basic_structure\": \"(is-StrVal s)\",\n  \"contract_defs\": \"(define-fun C0 () Bool\\n  (let ((str (sval s)))\\n    (or (= str \\\"\\\")\\n        (is_lower str))))\"\n}\n```\n", "constraints": [{"assert_0": "assert s == \"\" or s.islower(), \"invalid inputs"}]}], "reasoning": ["I introduce recursive helpers to verify that a string is non-empty and entirely lowercase, and guard extraction of the StrVal payload. I assert that s must be a StrVal for safe execution, then translate `s == \"\" or s.islower()` exactly into a Boolean predicate C0.</think>"]}
{"name": "HumanEval/51", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: remove_vowels\nProblem Description:\n\n\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n\n\n    assert type(text) == str, \"invalid inputs\" # $_CONTRACT_$\n\n    return \"\".join(list(filter(lambda ch: ch not in \"aeiouAEIOU\", text)))\n\n\n\nContract List:\nassert_0: assert type(text) == str, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"\",\n  \"inputs\": \"(declare-const text Value)\",\n  \"basic_structure\": \"\",\n  \"contract_defs\": \"(define-fun C0 () Bool (is-StrVal text))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(text) == str, \"invalid inputs"}]}], "reasoning": ["I will map the Python type‐check into a single SMT predicate C0, declare the text input over the Value ADT, and keep basic structure and helpers empty since no recursive or structural helpers are needed.</think>"]}
{"name": "HumanEval/52", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: below_threshold\nProblem Description:\n\n\ndef below_threshold(l: list, t: int):\n    \"\"\"Return True if all numbers in the list l are below threshold t.\n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n\n\n    assert type(l) == list, \"invalid inputs\" # $_CONTRACT_$\n    assert type(t) == int, \"invalid inputs\" # $_CONTRACT_$\n    assert all(isinstance(x, (int, float, bool)) for x in l), \"invalid inputs\" # $_CONTRACT_$\n\n    return all(x < t for x in l)\n\n\n\nContract List:\nassert_0: assert type(l) == list, \"invalid inputs\nassert_1: assert type(t) == int, \"invalid inputs\nassert_2: assert all(isinstance(x, (int, float, bool)) for x in l), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec isList ((v Value)) Bool\\n  (ite (is-Nil v)\\n       true\\n       (ite (is-Cons v)\\n            (isList (tail v))\\n            false)))\\n\\n(define-fun isNumeric ((v Value)) Bool\\n  (or (is-IntVal v)\\n      (is-FloatVal v)\\n      (is-BoolVal v)))\\n\\n(define-fun-rec list_all_numeric ((v Value)) Bool\\n  (ite (is-Nil v)\\n       true\\n       (ite (is-Cons v)\\n            (and (isNumeric (head v))\\n                 (list_all_numeric (tail v)))\\n            false)))\",\n  \"inputs\": \"(declare-const l Value)\\n(declare-const t Value)\",\n  \"basic_structure\": \"(assert (isList l))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (isList l))\\n(define-fun C1 () Bool (is-IntVal t))\\n(define-fun C2 () Bool (list_all_numeric l))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(l) == list, \"invalid inputs", "assert_1": "assert type(t) == int, \"invalid inputs", "assert_2": "assert all(isinstance(x, (int, float, bool)) for x in l), \"invalid inputs"}]}], "reasoning": ["I will translate the Python input-validation asserts into precise SMT-LIB predicates C0, C1, and C2, using recursive helper functions for list shape and numeric checks. I define `isList` and `list_all_numeric` so all selector uses are guarded and the recursion has a clear base case. The basic structure asserts only the list shape required for any recursive walk.</think>"]}
{"name": "HumanEval/53", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: add\nProblem Description:\n\n\ndef add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n\n\n    assert isinstance(x, int), \"invalid inputs\" # $_CONTRACT_$\n    assert isinstance(y, int), \"invalid inputs\" # $_CONTRACT_$\n\n    return x + y\n\n\n\nContract List:\nassert_0: assert isinstance(x, int), \"invalid inputs\nassert_1: assert isinstance(y, int), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"\",\n  \"inputs\": \"(declare-const x Value)\\n(declare-const y Value)\",\n  \"basic_structure\": \"\",\n  \"contract_defs\": \"(define-fun C0 () Bool (is-IntVal x))\\n(define-fun C1 () Bool (is-IntVal y))\"\n}\n```\n", "constraints": [{"assert_0": "assert isinstance(x, int), \"invalid inputs", "assert_1": "assert isinstance(y, int), \"invalid inputs"}]}], "reasoning": ["I translate the Python type-check assertions into SMT-LIB predicates using the IntVal tester, declare the inputs as Value, and leave the basic structure minimal since no extra invariants are needed for executability.</think>"]}
{"name": "HumanEval/54", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: same_chars\nProblem Description:\n\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n\n\n    assert type(s0) == type(s1) == str, \"invalid inputs\" # $_CONTRACT_$\n\n    return set(s0) == set(s1)\n\n\n\nContract List:\nassert_0: assert type(s0) == type(s1) == str, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"\",\n  \"inputs\": \"(declare-const s0 Value)\\n(declare-const s1 Value)\",\n  \"basic_structure\": \"(assert (is-StrVal s0))\\n(assert (is-StrVal s1))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (and (is-StrVal s0) (is-StrVal s1)))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(s0) == type(s1) == str, \"invalid inputs"}]}], "reasoning": ["I will encode the single “type(s0)==type(s1)==str” assertion as a named predicate C0, declare s0/s1 as Value, assert they are StrVal in the basic structure for executability, and leave helper_functions empty since no extra ADT ops are needed.</think>"]}
{"name": "HumanEval/55", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: fib\nProblem Description:\n\n\ndef fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n\n\n    assert n >= 0, \"invalid inputs\" # $_CONTRACT_$\n    assert isinstance(n, int), \"invalid inputs\" # $_CONTRACT_$\n\n\n    if n == 0: return 0\n    if n <= 2: return 1\n    a, b = 1, 1\n    for _ in range(3, n + 1):\n        a, b, = b, a + b\n    return b\n\n\n\nContract List:\nassert_0: assert n >= 0, \"invalid inputs\nassert_1: assert isinstance(n, int), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))\",\n  \"inputs\": \"(declare-const n Value)\",\n  \"basic_structure\": \"\",\n  \"contract_defs\": \"(define-fun C0 () Bool (>= (SafeI n) 0))\\n(define-fun C1 () Bool (is-IntVal n))\"\n}\n```\n", "constraints": [{"assert_0": "assert n >= 0, \"invalid inputs", "assert_1": "assert isinstance(n, int), \"invalid inputs"}]}], "reasoning": ["I will encode the two Python asserts as separate SMT predicates, introduce a SafeI helper to extract integers without type errors, and leave basic structure empty since SafeI guards extractor usage.</think>"]}
{"name": "HumanEval/56", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: correct_bracketing\nProblem Description:\n\n\ndef correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\"\n\n\n    assert type(brackets) == str, \"invalid inputs\" # $_CONTRACT_$\n    assert all(x in \"<>\" for x in brackets) # $_CONTRACT_$\n\n\n    cnt = 0\n    for x in brackets:\n        if x == \"<\": cnt += 1\n        if x == \">\": cnt -= 1\n        if cnt < 0: return False\n    return cnt == 0\n\n\n\nContract List:\nassert_0: assert type(brackets) == str, \"invalid inputs\nassert_1: assert all(x in \"<>\" for x in brackets)\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun SafeS ((v Value)) String\\n  (ite (is-StrVal v) (sval v) \\\"\\\"))\\n\\n(define-fun-rec allAngleChars ((s String)) Bool\\n  (ite (= (str.len s) 0)\\n       true\\n       (let ((c (str.substr s 0 1))\\n             (rest (str.substr s 1 (- (str.len s) 1))))\\n         (and (or (= c \\\"<\\\") (= c \\\">\\\"))\\n              (allAngleChars rest)))))\",\n  \"inputs\": \"(declare-const brackets Value)\",\n  \"basic_structure\": \"(assert (is-StrVal brackets))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (is-StrVal brackets))\\n(define-fun C1 () Bool (allAngleChars (SafeS brackets)))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(brackets) == str, \"invalid inputs", "assert_1": "assert all(x in \"<>\" for x in brackets)"}]}], "reasoning": ["I model the `brackets` input as a `StrVal` and ensure its type with `SafeS`, then define a tail‐recursive `allAngleChars` to check each character is “<” or “>”. Contracts C0 and C1 directly correspond to the Python asserts.</think>"]}
{"name": "HumanEval/57", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: monotonic\nProblem Description:\n\n\ndef monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\"\n\n\n    assert type(l) == list, \"invalid inputs\" # $_CONTRACT_$\n    assert all(type(x) in (int, float, bool) for x in l), \"invalid inputs\" # $_CONTRACT_$\n\n    inc, dec = True, True\n    for i in range(len(l) - 1):\n        if l[i] > l[i + 1]: inc = False\n        if l[i] < l[i + 1]: dec = False\n    return inc or dec\n\n\n\nContract List:\nassert_0: assert type(l) == list, \"invalid inputs\nassert_1: assert all(type(x) in (int, float, bool) for x in l), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec IsList ((v Value)) Bool\\n  (ite (is-Nil v)\\n       true\\n       (ite (is-Cons v)\\n            (IsList (tail v))\\n            false)))\\n(define-fun-rec AllNum ((v Value)) Bool\\n  (ite (is-Nil v)\\n       true\\n       (ite (is-Cons v)\\n            (let ((headv (head v)) (tailv (tail v)))\\n              (and (or (is-IntVal headv)\\n                       (is-FloatVal headv)\\n                       (is-BoolVal headv))\\n                   (AllNum tailv)))\\n            false)))\",\n  \"inputs\": \"(declare-const l Value)\",\n  \"basic_structure\": \"(assert (IsList l))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (IsList l))\\n(define-fun C1 () Bool (AllNum l))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(l) == list, \"invalid inputs", "assert_1": "assert all(type(x) in (int, float, bool) for x in l), \"invalid inputs"}]}], "reasoning": ["I model list shape and numeric-element constraints with recursive helpers IsList and AllNum, assert l must be a proper list and all its elements int/float/bool, and map each Python assert to C0 and C1 for precise contract checking.</think>"]}
{"name": "HumanEval/58", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: common\nProblem Description:\n\n\ndef common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n\n\n    assert type(l1) == type(l2) == list, \"invalid inputs\" # $_CONTRACT_$\n\n    return sorted(list(set(l1).intersection(set(l2))))\n\n\n\nContract List:\nassert_0: assert type(l1) == type(l2) == list, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec IsList ((v Value)) Bool\\n  (ite (is-Nil v)\\n    true\\n    (ite (is-Cons v)\\n      (IsList (tail v))\\n      false)))\",\n  \"inputs\": \"(declare-const l1 Value)\\n(declare-const l2 Value)\",\n  \"basic_structure\": \"\",\n  \"contract_defs\": \"(define-fun C0 () Bool (and (IsList l1) (IsList l2)))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(l1) == type(l2) == list, \"invalid inputs"}]}], "reasoning": ["I translated the Python list‐type assertion into an SMT‐LIB Bool predicate C0, declared a recursive IsList helper to model proper list shapes, and set up inputs plus a COMBINATION guard to explore both satisfaction and violation of C0.</think>"]}
{"name": "HumanEval/59", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: largest_prime_factor\nProblem Description:\n\n\ndef largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n\n\n    assert isinstance(n, int), \"invalid inputs\" # $_CONTRACT_$\n    def is_prime(a): # $_CONTRACT_$\n        return not (a < 2 or any(a % x == 0 for x in range(2, int(a ** 0.5) + 1))) # $_CONTRACT_$\n    assert n > 1 and not is_prime(n), \"invalid inputs\" # $_CONTRACT_$\n\n\n    isprime = [True] * (n + 1)\n    for i in range(2, n + 1):\n        if isprime[i]:\n            for j in range(i + i, n, i):\n                isprime[j] = False\n    for i in range(n - 1, 0, -1):\n        if isprime[i] and n % i == 0:\n            return i\n\n\n\nContract List:\nassert_0: assert isinstance(n, int), \"invalid inputs\nassert_1: assert n > 1 and not is_prime(n), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun is_prime ((a Value)) Bool\\n  (ite (is-IntVal a)\\n       (let ((ai (ival a)))\\n         (and (>= ai 2)\\n              (not (exists ((x Int))\\n                       (and (>= x 2)\\n                            (<= (* x x) ai)\\n                            (= (mod ai x) 0))))))\\n       false))\",\n  \"inputs\": \"(declare-const n Value)\",\n  \"basic_structure\": \"\",\n  \"contract_defs\": \"(define-fun C0 () Bool (is-IntVal n))\\n(define-fun C1 () Bool\\n  (let ((ai (ite (is-IntVal n) (ival n) 0)))\\n    (and (> ai 1)\\n         (not (is_prime n)))))\"\n}\n```\n", "constraints": [{"assert_0": "assert isinstance(n, int), \"invalid inputs", "assert_1": "assert n > 1 and not is_prime(n), \"invalid inputs"}]}], "reasoning": ["I model the Python `int` type and primality test precisely in SMT-LIB using an ADT for `Value` and a guarded, quantified `is_prime` definition. Contracts are represented as standalone Booleans C0 and C1 with no extra global invariants, allowing all combinations to be explored.</think>"]}
{"name": "HumanEval/60", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: sum_to_n\nProblem Description:\n\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n is a function that sums numbers from 1 to n.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n\n\n    assert type(n) == int, \"invalid inputs\" # $_CONTRACT_$\n    assert n >= 1, \"invalid inputs\" # $_CONTRACT_$\n\n\n    return (n + 1) * n // 2\n\n\n\nContract List:\nassert_0: assert type(n) == int, \"invalid inputs\nassert_1: assert n >= 1, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))\",\n  \"inputs\": \"(declare-const n Value)\",\n  \"basic_structure\": \"\",\n  \"contract_defs\": \"(define-fun C0 () Bool (is-IntVal n))\\n(define-fun C1 () Bool (>= (SafeI n) 1))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(n) == int, \"invalid inputs", "assert_1": "assert n >= 1, \"invalid inputs"}]}], "reasoning": ["I translate each Python assertion into an SMT predicate over the ADT, introduce a SafeI helper to extract IntVal safely, and declare the sole input. I leave BASIC_STRUCTURE empty since no extra invariants are needed for executability beyond ADT shape.</think>"]}
{"name": "HumanEval/61", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: correct_bracketing\nProblem Description:\n\n\ndef correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\")(()\")\n    False\n    \"\"\"\n\n\n    assert type(brackets) == str, \"invalid inputs\" # $_CONTRACT_$\n    assert all(x in \"()\" for x in brackets) # $_CONTRACT_$\n\n\n    cnt = 0\n    for x in brackets:\n        if x == \"(\": cnt += 1\n        if x == \")\": cnt -= 1\n        if cnt < 0: return False\n    return cnt == 0\n\n\n\nContract List:\nassert_0: assert type(brackets) == str, \"invalid inputs\nassert_1: assert all(x in \"()\" for x in brackets)\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun SafeS ((v Value)) String (ite (is-StrVal v) (sval v) \\\"\\\"))\",\n  \"inputs\": \"(declare-const brackets Value)\",\n  \"basic_structure\": \"\",\n  \"contract_defs\": \"(define-fun C0 () Bool (is-StrVal brackets))\\n(define-fun C1 () Bool (let ((s (SafeS brackets))) (str.in.re s (str.to.re \\\"^[()]*$\\\"))))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(brackets) == str, \"invalid inputs", "assert_1": "assert all(x in \"()\" for x in brackets)"}]}], "reasoning": ["I will translate the Python bracketing assertions into SMT-LIB predicates, defining a safe string extractor to guard shape and enabling regex checks, while keeping executability even if type contracts are violated.</think>"]}
{"name": "HumanEval/62", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: derivative\nProblem Description:\n\n\ndef derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n\n\n    assert len(xs) > 0, \"invalid inputs\" # $_CONTRACT_$\n    assert all(type(x) in (int, float) for x in xs), \"invalid inputs\" # $_CONTRACT_$\n\n\n    return [xs[i] * i for i in range(1, len(xs))]\n\n\n\nContract List:\nassert_0: assert len(xs) > 0, \"invalid inputs\nassert_1: assert all(type(x) in (int, float) for x in xs), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun is_List ((v Value)) Bool (or (is-Nil v) (is-Cons v)))\\n(define-fun-rec length ((l Value)) Int\\n  (ite (is-Nil l) 0\\n    (ite (is-Cons l)\\n      (let ((restLen (length (tail l))))\\n        (+ restLen 1))\\n      0)))\\n(define-fun-rec list_all_numeric ((l Value)) Bool\\n  (ite (is-Nil l) true\\n    (ite (is-Cons l)\\n      (let ((hd (head l)) (tl (tail l)))\\n        (and (or (is-IntVal hd) (is-FloatVal hd))\\n             (list_all_numeric tl)))\\n      false)))\",\n  \"inputs\": \"(declare-const xs Value)\",\n  \"basic_structure\": \"(assert (is_List xs))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (> (length xs) 0))\\n(define-fun C1 () Bool (list_all_numeric xs))\"\n}\n```\n", "constraints": [{"assert_0": "assert len(xs) > 0, \"invalid inputs", "assert_1": "assert all(type(x) in (int, float) for x in xs), \"invalid inputs"}]}], "reasoning": ["I translate the Python assertions into precise SMT-LIB predicates by defining a canonical list ADT, recursive functions for list shape, length, and numeric checks, guard all selectors, and then express each contract as a named Boolean predicate.</think>"]}
{"name": "HumanEval/63", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: fibfib\nProblem Description:\n\n\ndef fibfib(n: int):\n    \"\"\"The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    \"\"\"\n\n\n    assert isinstance(n, int), \"invalid inputs\" # $_CONTRACT_$\n    assert n >= 0, \"invalid inputs\" # $_CONTRACT_$\n\n\n    if n == 0 or n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    a, b, c = 0, 0, 1\n    for _ in range(3, n + 1):\n        a, b, c = b, c, a + b + c\n    return c\n\n\n\nContract List:\nassert_0: assert isinstance(n, int), \"invalid inputs\nassert_1: assert n >= 0, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))\",\n  \"inputs\": \"(declare-const n Value)\",\n  \"basic_structure\": \"(assert (is-IntVal n))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (is-IntVal n))\\n(define-fun C1 () Bool (>= (SafeI n) 0))\"\n}\n```\n", "constraints": [{"assert_0": "assert isinstance(n, int), \"invalid inputs", "assert_1": "assert n >= 0, \"invalid inputs"}]}], "reasoning": ["I translate each Python assertion into a named SMT-LIB predicate, introduce a SafeI helper to extract IntVal safely, enforce the input’s Value shape in the basic structure, and expose C0/C1 for the two contracts.</think>"]}
{"name": "HumanEval/64", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: vowels_count\nProblem Description:\n\nFIX = \"\"\"\nAdd more test cases.\n\"\"\"\n\ndef vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n\n\n    assert type(s) == str, \"invalid inputs\" # $_CONTRACT_$\n\n    if s == \"\": return 0\n    cnt = len(list(filter(lambda ch: ch in \"aeiouAEIOU\", s)))\n    if s[-1] in \"yY\": cnt += 1\n    return cnt\n\n\n\nContract List:\nassert_0: assert type(s) == str, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"\",\n  \"inputs\": \"(declare-const s Value)\",\n  \"basic_structure\": \"(assert (is-StrVal s))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (is-StrVal s))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(s) == str, \"invalid inputs"}]}], "reasoning": ["I translate the Python type assertion into an SMT predicate requiring the input to be a StrVal, include a basic structure assertion for executability, and define C0 to match the original contract.</think>"]}
{"name": "HumanEval/65", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: circular_shift\nProblem Description:\n\ndef circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\"\n\n\n    assert type(x) == type(shift) == int, \"invalid inputs\" # $_CONTRACT_$\n    assert x >= 0 and shift >= 0, \"invalid inputs\" # $_CONTRACT_$\n\n\n    s = str(x)\n    if shift > len(s): return s[::-1]\n    shift %= len(s)\n    if shift == 0:\n        return s\n    else:\n        return s[len(s) - shift:] + s[:len(s) - shift]\n\n\n\nContract List:\nassert_0: assert type(x) == type(shift) == int, \"invalid inputs\nassert_1: assert x >= 0 and shift >= 0, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun get-ival ((v Value)) Int (ite (is-IntVal v) (ival v) 0))\",\n  \"inputs\": \"(declare-const x Value)\\n(declare-const shift Value)\",\n  \"basic_structure\": \"(assert (is-IntVal x))\\n(assert (is-IntVal shift))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (and (is-IntVal x) (is-IntVal shift)))\\n(define-fun C1 () Bool (and (>= (get-ival x) 0) (>= (get-ival shift) 0)))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(x) == type(shift) == int, \"invalid inputs", "assert_1": "assert x >= 0 and shift >= 0, \"invalid inputs"}]}], "reasoning": ["I will encode the two Python asserts as SMT predicates C0 and C1, introduce minimal helper functions to safely test and extract integer values from the ADT, and ensure executability by asserting that both inputs are IntVal.</think>"]}
{"name": "HumanEval/66", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: digitSum\nProblem Description:\n\ndef digitSum(s):\n    \"\"\"Task\n    Write a function that takes a string as input and returns the sum of the upper characters only'\n    ASCII codes.\n\n    Examples:\n        digitSum(\"\") => 0\n        digitSum(\"abAB\") => 131\n        digitSum(\"abcCd\") => 67\n        digitSum(\"helloE\") => 69\n        digitSum(\"woArBld\") => 131\n        digitSum(\"aAaaaXa\") => 153\n    \"\"\"\n\n\n    assert type(s) == str, \"invalid inputs\" # $_CONTRACT_$\n\n    return sum([ord(ch) for ch in s if ch.isupper()])\n\n\n\nContract List:\nassert_0: assert type(s) == str, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"\",\n  \"inputs\": \"(declare-const s Value)\",\n  \"basic_structure\": \"\",\n  \"contract_defs\": \"(define-fun C0 () Bool (is-StrVal s))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(s) == str, \"invalid inputs"}]}], "reasoning": ["I model the Python string‐type check as an SMT constructor test under the canonical Value ADT, declare the input `s`, and define a Boolean predicate `C0` that exactly captures `type(s) == str`. No additional helpers or base‐structure invariants are needed to preserve satisfiability when testing both satisfaction and violation of the contract.</think>"]}
{"name": "HumanEval/67", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: fruit_distribution\nProblem Description:\n\ndef fruit_distribution(s,n):\n    \"\"\"\n    In this task, you will be given a string that represents a number of apples and oranges \n    that are distributed in a basket of fruit this basket contains \n    apples, oranges, and mango fruits. Given the string that represents the total number of \n    the oranges and apples and an integer that represent the total number of the fruits \n    in the basket return the number of the mango fruits in the basket.\n    for examble:\n    fruit_distribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n    fruit_distribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n    fruit_distribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n    fruit_distribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n    \"\"\"\n\n\n    assert type(s) == str and type(n) == int, \"invalid inputs\" # $_CONTRACT_$\n    words = s.split(\" \") # $_CONTRACT_$\n    assert len(words) == 5, \"invalid inputs\" # $_CONTRACT_$\n    assert words[1] == \"apples\" and words[2] == \"and\" and words[4] == \"oranges\", \"invalid inputs\" # $_CONTRACT_$\n    assert words[0].isdigit() and words[3].isdigit(), \"invalid inputs\" # $_CONTRACT_$\n\n\n    words = s.split(\" \")\n    c1, c2 = int(words[0]), int(words[3])\n    assert n - c1 - c2 >= 0, \"invalid inputs\" # $_CONTRACT_$\n    \n    return n - c1 - c2\n\n\n\nContract List:\nassert_0: assert type(s) == str and type(n) == int, \"invalid inputs\nassert_1: assert len(words) == 5, \"invalid inputs\nassert_2: assert words[1] == \"apples\" and words[2] == \"and\" and words[4] == \"oranges\", \"invalid inputs\nassert_3: assert words[0].isdigit() and words[3].isdigit(), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun DIGIT () (RegEx String) (re.range \\\"0\\\" \\\"9\\\"))\\n(define-fun LETTER () (RegEx String) (re.union (re.range \\\"A\\\" \\\"Z\\\") (re.range \\\"a\\\" \\\"z\\\")))\\n(define-fun ALNUM () (RegEx String) (re.union LETTER DIGIT))\\n(define-fun WORD () (RegEx String) (re.++ LETTER (re.* ALNUM)))\\n(define-fun NUM () (RegEx String) (re.++ DIGIT (re.* DIGIT)))\\n(define-fun TOKEN () (RegEx String) (re.union WORD NUM))\\n(define-fun SP () (RegEx String) (str.to.re \\\" \\\"))\\n(define-const R5 (RegEx String) (re.++ TOKEN SP TOKEN SP TOKEN SP TOKEN SP TOKEN))\\n(define-const RW (RegEx String) (re.++ TOKEN (str.to.re \\\" apples and \\\") TOKEN (str.to.re \\\" oranges\\\")))\\n(define-const RN (RegEx String) (re.++ NUM (str.to.re \\\" apples and \\\") NUM (str.to.re \\\" oranges\\\")))\",\n  \"inputs\": \"(declare-const s Value)\\n(declare-const n Value)\",\n  \"basic_structure\": \"\",\n  \"contract_defs\": \"(define-fun C0 () Bool (and (is-StrVal s) (is-IntVal n)))\\n(define-fun C1 () Bool (and (is-StrVal s) (str.in.re (sval s) R5)))\\n(define-fun C2 () Bool (and (is-StrVal s) (str.in.re (sval s) RW)))\\n(define-fun C3 () Bool (and (is-StrVal s) (str.in.re (sval s) RN)))\\n(define-fun C4 () Bool (and (is-StrVal s) (is-IntVal n) (let ((sep1 \\\" apples and \\\") (sep2 \\\" oranges\\\") (S (sval s))) (let ((i1 (str.indexof S sep1 0))) (and (>= i1 0) (let ((x (str.substr S 0 i1)) (start2 (+ i1 (str.len sep1)))) (let ((i2 (str.indexof S sep2 start2))) (and (>= i2 0) (let ((y (str.substr S start2 (- i2 start2)))) (and (str.in.re x NUM) (str.in.re y NUM) (>= (ival n) (+ (str.to.int x) (str.to.int y)))))))))))))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(s) == str and type(n) == int, \"invalid inputs", "assert_1": "assert len(words) == 5, \"invalid inputs", "assert_2": "assert words[1] == \"apples\" and words[2] == \"and\" and words[4] == \"oranges\", \"invalid inputs", "assert_3": "assert words[0].isdigit() and words[3].isdigit(), \"invalid inputs"}]}], "reasoning": ["I translate each Python `assert` into a named SMT predicate C0…C4, declare the inputs and any needed helpers, and add minimal invariants to ensure executability. Regex and string‐length operations model the split and token checks, while two uninterpreted functions stand in for integer parsing.</think>"]}
{"name": "HumanEval/68", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: pluck\nProblem Description:\n\ndef pluck(arr):\n    \"\"\"\n    \"Given an array representing a branch of a tree that has non-negative integer nodes\n    your task is to pluck one of the nodes and return it.\n    The plucked node should be the node with the smallest even value.\n    If multiple nodes with the same smallest even value are found return the node that has smallest index.\n\n    The plucked node should be returned in a list, [ smalest_value, its index ],\n    If there are no even values or the given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n                     so we will choose the first zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \"\"\"\n\n\n    assert len(arr) <= 10000, \"invalid inputs\" # $_CONTRACT_$\n    assert all(type(val) == int and val >= 0 for val in arr), \"invalid inputs\" # $_CONTRACT_$\n\n\n    if all(val % 2 == 1 for val in arr): return []\n    min_even = min(filter(lambda x: x % 2 == 0, arr))\n    for i in range(len(arr)):\n        if arr[i] == min_even:\n            return [min_even, i]\n\n\n\nContract List:\nassert_0: assert len(arr) <= 10000, \"invalid inputs\nassert_1: assert all(type(val) == int and val >= 0 for val in arr), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec IsList ((v Value)) Bool\\n  (ite (is-Nil v)\\n       true\\n       (ite (is-Cons v)\\n            (IsList (tail v))\\n            false)))\\n(define-fun-rec length ((v Value)) Int\\n  (ite (is-Nil v)\\n       0\\n       (ite (is-Cons v)\\n            (+ 1 (length (tail v)))\\n            0)))\\n(define-fun-rec list_all_numeric ((v Value)) Bool\\n  (ite (is-Nil v)\\n       true\\n       (ite (is-Cons v)\\n            (let ((hd (head v)))\\n              (and (is-IntVal hd)\\n                   (let ((iv (ival hd)))\\n                     (and (>= iv 0)\\n                          (list_all_numeric (tail v))))))\\n            false)))\",\n  \"inputs\": \"(declare-const arr Value)\",\n  \"basic_structure\": \"(assert (IsList arr))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (<= (length arr) 10000))\\n(define-fun C1 () Bool (list_all_numeric arr))\"\n}\n```\n", "constraints": [{"assert_0": "assert len(arr) <= 10000, \"invalid inputs", "assert_1": "assert all(type(val) == int and val >= 0 for val in arr), \"invalid inputs"}]}], "reasoning": ["I translate the Python assertions into SMT-LIB predicates, define recursive helpers for list structure and numeric checks, and assert basic executability via an ADT-safe `IsList` invariant.</think>"]}
{"name": "HumanEval/69", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: search\nProblem Description:\n\ndef search(lst):\n    '''\n    You are given a non-empty list of positive integers. Return the greatest integer that is greater than \n    zero, and has a frequency greater than or equal to the value of the integer itself. \n    The frequency of an integer is the number of times it appears in the list.\n    If no such a value exist, return -1.\n    Examples:\n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    '''\n\n\n    assert all(type(val) == int and val > 0 for val in lst), \"invalid inputs\" # $_CONTRACT_$\n\n\n    count = dict()\n    for num in lst:\n        if num not in count:\n            count[num] = 0\n        count[num] += 1\n    ans = -1\n    for num, cnt in count.items():\n        if cnt >= num:\n            ans = max(ans, num)\n    return ans\n\n\n\nContract List:\nassert_0: assert all(type(val) == int and val > 0 for val in lst), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec IsList ((lst Value)) Bool\\n  (ite (is-Nil lst)\\n       true\\n       (ite (is-Cons lst)\\n            (IsList (tail lst))\\n            false)))\\n\\n(define-fun-rec list_all_int ((lst Value)) Bool\\n  (ite (is-Nil lst)\\n       true\\n       (ite (is-Cons lst)\\n            (let ((hd (head lst)) (tl (tail lst)))\\n              (and (is-IntVal hd)\\n                   (list_all_int tl)))\\n            false)))\\n\\n(define-fun-rec list_all_positive ((lst Value)) Bool\\n  (ite (is-Nil lst)\\n       true\\n       (ite (is-Cons lst)\\n            (let ((hd (head lst)) (tl (tail lst)))\\n              (and (is-IntVal hd)\\n                   (>= (ival hd) 1)\\n                   (list_all_positive tl)))\\n            false)))\",\n  \"inputs\": \"(declare-const lst Value)\",\n  \"basic_structure\": \"(assert (IsList lst))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (and (list_all_int lst) (list_all_positive lst)))\"\n}\n```\n", "constraints": [{"assert_0": "assert all(type(val) == int and val > 0 for val in lst), \"invalid inputs"}]}], "reasoning": ["I define recursive predicates to ensure lst is a proper list of positive integers, declare lst as a Value, assert its list shape for executability, and capture the Python assert as C0 requiring all elements be IntVal and ≥1.</think>"]}
{"name": "HumanEval/70", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: strange_sort_list\nProblem Description:\n\ndef strange_sort_list(lst):\n    '''\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n\n\n    assert type(lst) == list, \"invalid inputs\" # $_CONTRACT_$\n    assert all(type(x) == int for x in lst), \"invalid inputs\" # $_CONTRACT_$\n\n    sorted_list = sorted(lst)\n    ans, i, j = [], 0, len(sorted_list) - 1\n    while i < j:\n        ans.append(sorted_list[i])\n        ans.append(sorted_list[j])\n        i += 1\n        j -= 1\n    if i == j: ans.append(sorted_list[i])\n    return ans\n\n\n\nContract List:\nassert_0: assert type(lst) == list, \"invalid inputs\nassert_1: assert all(type(x) == int for x in lst), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec IsList ((l Value)) Bool\\n  (ite (is-Nil l) true\\n    (ite (is-Cons l) (IsList (tail l)) false)))\\n\\n(define-fun-rec list_all_int ((l Value)) Bool\\n  (ite (is-Nil l) true\\n    (ite (is-Cons l)\\n      (and (is-IntVal (head l)) (list_all_int (tail l)))\\n      false)))\",\n  \"inputs\": \"(declare-const lst Value)\",\n  \"basic_structure\": \"(assert (IsList lst))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (IsList lst))\\n(define-fun C1 () Bool (list_all_int lst))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(lst) == list, \"invalid inputs", "assert_1": "assert all(type(x) == int for x in lst), \"invalid inputs"}]}], "reasoning": ["I translate Python assertions into SMT-LIB predicates C0 and C1, model the list ADT with helper functions IsList and list_all_int, and assert basic structure for safe execution.</think>"]}
{"name": "HumanEval/71", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: triangle_area\nProblem Description:\n\ndef triangle_area(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n\n\n    assert a > 0 and b > 0 and c > 0, \"invalid inputs\" # $_CONTRACT_$\n\n\n    if a + b <= c or a + c <= b or b + c <= a: return -1\n    p = (a + b + c) / 2\n    return round((p * (p - a) * (p - b) * (p - c)) ** 0.5, 2)\n\n\n\nContract List:\nassert_0: assert a > 0 and b > 0 and c > 0, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun is-Numeric ((v Value)) Bool (or (is-IntVal v) (is-FloatVal v)))\\n(define-fun toReal ((v Value)) Real\\n  (ite (is-IntVal v) (to_real (ival v))\\n       (ite (is-FloatVal v) (fval v)\\n            0)))\\n(define-fun isPositive ((v Value)) Bool\\n  (and (is-Numeric v) (> (toReal v) 0)))\",\n  \"inputs\": \"(declare-const a Value)\\n(declare-const b Value)\\n(declare-const c Value)\",\n  \"basic_structure\": \"(assert (is-Numeric a))\\n(assert (is-Numeric b))\\n(assert (is-Numeric c))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (and (isPositive a) (isPositive b) (isPositive c)))\"\n}\n```\n", "constraints": [{"assert_0": "assert a > 0 and b > 0 and c > 0, \"invalid inputs"}]}], "reasoning": ["I model the numeric inputs using a unified Value ADT with helpers to check numeric shape and extract a real value. I define isPositive(v) to capture `v > 0`, then express the single contract C0 as `(isPositive a) ∧ (isPositive b) ∧ (isPositive c)`, while ensuring basic executability via numeric-shape assertions.</think>"]}
{"name": "HumanEval/72", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: will_it_fly\nProblem Description:\n\ndef will_it_fly(q,w):\n    '''\n    Write a function that returns True if the object q will fly, and False otherwise.\n    The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    will_it_fly([1, 2], 5) ➞ False \n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    will_it_fly([3, 2, 3], 1) ➞ False\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    will_it_fly([3, 2, 3], 9) ➞ True\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    will_it_fly([3], 5) ➞ True\n    # 3 is less than the maximum possible weight, and it's balanced.\n    '''\n\n\n    assert type(q) == list and all(type(x) in [int, float] for x in q), \"invalid inputs\" # $_CONTRACT_$\n    assert type(w) in [int, float], \"invalid inputs\" # $_CONTRACT_$\n\n    return q == q[::-1] and sum(q) <= w\n\n\n\nContract List:\nassert_0: assert type(q) == list and all(type(x) in [int, float] for x in q), \"invalid inputs\nassert_1: assert type(w) in [int, float], \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec IsList ((l Value)) Bool\\n  (ite (is-Nil l)\\n       true\\n       (ite (is-Cons l)\\n            (IsList (tail l))\\n            false)))\\n\\n(define-fun IsNumeric ((v Value)) Bool\\n  (or (is-IntVal v)\\n      (is-FloatVal v)))\\n\\n(define-fun-rec list_all_numeric ((l Value)) Bool\\n  (ite (is-Nil l)\\n       true\\n       (ite (is-Cons l)\\n            (and (IsNumeric (head l))\\n                 (list_all_numeric (tail l)))\\n            false)))\",\n  \"inputs\": \"(declare-const q Value)\\n(declare-const w Value)\",\n  \"basic_structure\": \"(assert (IsList q))\",\n  \"contract_defs\": \"(define-fun C0 () Bool\\n  (and (IsList q)\\n       (list_all_numeric q)))\\n(define-fun C1 () Bool\\n  (IsNumeric w))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(q) == list and all(type(x) in [int, float] for x in q), \"invalid inputs", "assert_1": "assert type(w) in [int, float], \"invalid inputs"}]}], "reasoning": ["I map each Python input check to an SMT predicate, define recursive list and numeric helpers for safety, then declare inputs and structure needed for all executions, and finally specify C0/C1 to mirror the original asserts.</think>"]}
{"name": "HumanEval/73", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: smallest_change\nProblem Description:\n\ndef smallest_change(arr):\n    \"\"\"\n    Given an array arr of integers, find the minimum number of elements that\n    need to be changed to make the array palindromic. A palindromic array is an array that\n    is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n    For example:\n    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n\n\n    assert type(arr) == list, \"invalid inputs\" # $_CONTRACT_$\n    assert all(type(x) == int for x in arr), \"invalid inputs\" # $_CONTRACT_$\n\n    arr_reversed, cnt = arr[::-1], 0\n    for i in range(len(arr) // 2):\n        if arr[i] != arr_reversed[i]:\n            cnt += 1\n    return cnt\n\n\n\nContract List:\nassert_0: assert type(arr) == list, \"invalid inputs\nassert_1: assert all(type(x) == int for x in arr), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec IsList ((v Value)) Bool\\n  (ite (is-Nil v)\\n       true\\n       (ite (is-Cons v)\\n            (IsList (tail v))\\n            false)))\\n\\n(define-fun-rec list_all_ints ((v Value)) Bool\\n  (ite (is-Nil v)\\n       true\\n       (ite (is-Cons v)\\n            (and (is-IntVal (head v))\\n                 (list_all_ints (tail v)))\\n            false)))\",\n  \"inputs\": \"(declare-const arr Value)\",\n  \"basic_structure\": \"\",\n  \"contract_defs\": \"(define-fun C0 () Bool\\n  (IsList arr))\\n(define-fun C1 () Bool\\n  (list_all_ints arr))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(arr) == list, \"invalid inputs", "assert_1": "assert all(type(x) == int for x in arr), \"invalid inputs"}]}], "reasoning": ["I translated the Python type and structure checks into precise SMT-LIB predicates, defining recursive helpers for list shape and integer-only lists. Each Python assert becomes a named predicate Ck, with inputs and helper definitions ensuring sound executability and contract semantics.</think>"]}
{"name": "HumanEval/74", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: total_match\nProblem Description:\n\ndef total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) ➞ []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n    '''\n\n\n    assert type(lst1) == type(lst2) == list, \"invalid inputs\" # $_CONTRACT_$\n    assert all(type(x) == str for x in lst1), \"invalid inputs\" # $_CONTRACT_$\n    assert all(type(x) == str for x in lst2), \"invalid inputs\" # $_CONTRACT_$\n\n    c1, c2 = sum(map(lambda s: len(s), lst1)), sum(map(lambda s: len(s), lst2))\n    return lst1 if c1 <= c2 else lst2\n\n\n\nContract List:\nassert_0: assert type(lst1) == type(lst2) == list, \"invalid inputs\nassert_1: assert all(type(x) == str for x in lst1), \"invalid inputs\nassert_2: assert all(type(x) == str for x in lst2), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec IsList ((l Value)) Bool\\n  (ite (is-Nil l) true\\n       (ite (is-Cons l)\\n            (IsList (tail l))\\n            false)))\\n\\n(define-fun-rec ListAllStr ((l Value)) Bool\\n  (ite (is-Nil l) true\\n       (ite (is-Cons l)\\n            (and (let ((h (head l))) (is-StrVal h))\\n                 (ListAllStr (tail l)))\\n            false)))\",\n  \"inputs\": \"(declare-const lst1 Value)\\n(declare-const lst2 Value)\",\n  \"basic_structure\": \"\",\n  \"contract_defs\": \"(define-fun C0 () Bool (and (IsList lst1) (IsList lst2)))\\n(define-fun C1 () Bool (ListAllStr lst1))\\n(define-fun C2 () Bool (ListAllStr lst2))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(lst1) == type(lst2) == list, \"invalid inputs", "assert_1": "assert all(type(x) == str for x in lst1), \"invalid inputs", "assert_2": "assert all(type(x) == str for x in lst2), \"invalid inputs"}]}], "reasoning": ["I will define recursive predicates IsList and ListAllStr to model list structure and string-element checks, then declare the inputs and map each Python assert to a Ck predicate exactly capturing its semantics.</think>"]}
{"name": "HumanEval/75", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: is_multiply_prime\nProblem Description:\n\ndef is_multiply_prime(a):\n    \"\"\"Write a function that returns true if the given number is the multiplication of 3 prime numbers\n    and false otherwise.\n    Knowing that (a) is less then 100. \n    Example:\n    is_multiply_prime(30) == True\n    30 = 2 * 3 * 5\n    \"\"\"\n\n\n    assert type(a) == int, \"invalid inputs\" # $_CONTRACT_$\n    assert a < 100, \"invalid inputs\" # $_CONTRACT_$\n\n    if a <= 1: return False\n    isprime = [True] * (a + 1)\n    for i in range(2, a + 1):\n        if isprime[i]:\n            for j in range(i + i, a + 1, i):\n                isprime[j] = False\n    cnt, tmp = 0, a\n    for i in range(2, a + 1):\n        while isprime[i] and tmp % i == 0:\n            tmp //= i\n            cnt += 1\n    return cnt == 3\n\n\n\nContract List:\nassert_0: assert type(a) == int, \"invalid inputs\nassert_1: assert a < 100, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))\",\n  \"inputs\": \"(declare-const a Value)\",\n  \"basic_structure\": \"\",\n  \"contract_defs\": \"(define-fun C0 () Bool (is-IntVal a))\\n(define-fun C1 () Bool (and (is-IntVal a) (< (SafeI a) 100)))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(a) == int, \"invalid inputs", "assert_1": "assert a < 100, \"invalid inputs"}]}], "reasoning": ["I translate the Python type and range assertions into precise SMT-LIB predicates, ensure safe integer extraction via a helper, and declare the input with minimal base structure for executability.</think>"]}
{"name": "HumanEval/76", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: is_simple_power\nProblem Description:\n\ndef is_simple_power(x, n):\n    \"\"\"Your task is to write a function that returns true if a number x is a simple\n    power of n and false in other cases.\n    x is a simple power of n if n**int=x\n    For example:\n    is_simple_power(1, 4) => true\n    is_simple_power(2, 2) => true\n    is_simple_power(8, 2) => true\n    is_simple_power(3, 2) => false\n    is_simple_power(3, 1) => false\n    is_simple_power(5, 3) => false\n    \"\"\"\n\n\n    assert type(x) == int and type(n) == int, \"invalid inputs\" # $_CONTRACT_$\n\n    if x == 1: return True\n    if n == 0: return x == 0\n    if n == 1: return x == 1\n    if n == -1: return abs(x) == 1\n    p = n\n    while abs(p) <= abs(x):\n        if p == x: return True\n        p = p * n\n    return False\n\n\n\nContract List:\nassert_0: assert type(x) == int and type(n) == int, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"\",\n  \"inputs\": \"(declare-const x Value)\\n(declare-const n Value)\",\n  \"basic_structure\": \"\",\n  \"contract_defs\": \"(define-fun C0 () Bool (and (is-IntVal x) (is-IntVal n)))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(x) == int and type(n) == int, \"invalid inputs"}]}], "reasoning": ["I will encode the single type‐check assert as an SMT predicate requiring both inputs be IntVal, with no extra helpers or invariants needed.</think>"]}
{"name": "HumanEval/77", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: iscube\nProblem Description:\n\ndef iscube(a):\n    '''\n    Write a function that takes an integer a and returns True \n    if this ingeger is a cube of some integer number.\n    Note: you may assume the input is always valid.\n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    '''\n\n\n    assert type(a) == int, \"invalid inputs\" # $_CONTRACT_$\n\n    a = abs(a)\n    return int(round(a ** (1. / 3))) ** 3 == a\n\n\n\nContract List:\nassert_0: assert type(a) == int, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun SafeIVal ((v Value)) Int (ite (is-IntVal v) (ival v) 0))\",\n  \"inputs\": \"(declare-const a Value)\",\n  \"basic_structure\": \"\",\n  \"contract_defs\": \"(define-fun C0 () Bool (is-IntVal a))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(a) == int, \"invalid inputs"}]}], "reasoning": ["I will translate the single Python type‐check into an SMT `is-IntVal` predicate, provide a safe integer selector for execution, and declare the input and contract definition accordingly.</think>"]}
{"name": "HumanEval/78", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: hex_key\nProblem Description:\n\ndef hex_key(num):\n    \"\"\"You have been tasked to write a function that receives \n    a hexadecimal number as a string and counts the number of hexadecimal \n    digits that are primes (prime number, or a prime, is a natural number \n    greater than 1 that is not a product of two smaller natural numbers).\n    Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    So you have to determine a number of the following digits: 2, 3, 5, 7, \n    B (=decimal 11), D (=decimal 13).\n    Note: you may assume the input is always correct or empty string, \n    and symbols A,B,C,D,E,F are always uppercase.\n    Examples:\n    For num = \"AB\" the output should be 1.\n    For num = \"1077E\" the output should be 2.\n    For num = \"ABED1A33\" the output should be 4.\n    For num = \"123456789ABCDEF0\" the output should be 6.\n    For num = \"2020\" the output should be 2.\n    \"\"\"\n\n\n    assert all(x in \"0123456789ABCDEF\" for x in num), \"invalid inputs\" # $_CONTRACT_$\n\n    \n    return len(list(filter(lambda x: x in \"2357BD\", num)))\n\n\n\nContract List:\nassert_0: assert all(x in \"0123456789ABCDEF\" for x in num), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun hex_char_re () (RegEx String)\\n  (re.union (re.range \\\"0\\\" \\\"9\\\") (re.range \\\"A\\\" \\\"F\\\")))\",\n  \"inputs\": \"(declare-const num Value)\",\n  \"basic_structure\": \"(assert (is-StrVal num))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (and (is-StrVal num) (str.in.re (sval num) (re.* hex_char_re))))\"\n}\n```\n", "constraints": [{"assert_0": "assert all(x in \"0123456789ABCDEF\" for x in num), \"invalid inputs"}]}], "reasoning": ["I translate the single Python assertion into an SMT regex predicate over the string value, ensure the input has the correct StrVal shape, and expose a named contract C0. No additional executability constraints are needed beyond verifying the Value is a StrVal.</think>"]}
{"name": "HumanEval/79", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: decimal_to_binary\nProblem Description:\n\ndef decimal_to_binary(decimal):\n    \"\"\"You will be given a number in decimal form and your task is to convert it to\n    binary format. The function should return a string, with each character representing a binary\n    number. Each character in the string will be '0' or '1'.\n\n    There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    The extra characters are there to help with the format.\n\n    Examples:\n    decimal_to_binary(15)   # returns \"db1111db\"\n    decimal_to_binary(32)   # returns \"db100000db\"\n    \"\"\"\n\n\n    assert type(decimal) == int, \"invalid inputs\" # $_CONTRACT_$\n    assert decimal >= 0, \"invalid inputs\" # $_CONTRACT_$\n\n\n    return \"db\" + bin(decimal)[2:] + \"db\"\n\n\n\nContract List:\nassert_0: assert type(decimal) == int, \"invalid inputs\nassert_1: assert decimal >= 0, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"\",\n  \"inputs\": \"(declare-const decimal Value)\",\n  \"basic_structure\": \"\",\n  \"contract_defs\": \"(define-fun C0 () Bool (is-IntVal decimal))\\n(define-fun C1 () Bool (and (is-IntVal decimal) (>= (ival decimal) 0)))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(decimal) == int, \"invalid inputs", "assert_1": "assert decimal >= 0, \"invalid inputs"}]}], "reasoning": ["I represent the two Python asserts as standalone SMT predicates: C0 ensures the input is an IntVal, and C1 ensures it is non-negative (guarding ival with is-IntVal). No extra helpers or global invariants are needed for this simple decimal_to_binary function.</think>"]}
{"name": "HumanEval/80", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: is_happy\nProblem Description:\n\ndef is_happy(s):\n    \"\"\"You are given a string s.\n    Your task is to check if the string is happy or not.\n    A string is happy if its length is at least 3 and every 3 consecutive letters are distinct\n    For example:\n    is_happy(a) => False\n    is_happy(aa) => False\n    is_happy(abcd) => True\n    is_happy(aabb) => False\n    is_happy(adb) => True\n    is_happy(xyy) => False\n    \"\"\"\n\n\n    assert type(s) == str, \"invalid inputs\" # $_CONTRACT_$\n\n    if len(s) < 3: return False\n    for i in range(len(s) - 2):\n        if s[i] == s[i + 1] or s[i] == s[i + 2] or s[i + 1] == s[i + 2]:\n            return False\n    return True\n\n\n\nContract List:\nassert_0: assert type(s) == str, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun SafeStrLen ((v Value)) Int\\n  (ite (is-StrVal v)\\n       (str.len (sval v))\\n       0))\\n(define-fun SafeCharAt ((v Value) (i Int)) Value\\n  (ite (and (is-StrVal v)\\n            (<= 0 i)\\n            (< i (str.len (sval v))))\\n       (StrVal (str.substr (sval v) i 1))\\n       Nil))\",\n  \"inputs\": \"(declare-const s Value)\",\n  \"basic_structure\": \"(assert (is-StrVal s))\",\n  \"contract_defs\": \"(define-fun C0 () Bool\\n  (is-StrVal s))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(s) == str, \"invalid inputs"}]}], "reasoning": ["I translate the Python type check into an SMT predicate over the ADT, provide safe string helpers for potential operations, and assert the basic structural requirement that s must be a StrVal.</think>"]}
{"name": "HumanEval/81", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: numerical_letter_grade\nProblem Description:\n\ndef numerical_letter_grade(grades):\n    \"\"\"It is the last week of the semester and the teacher has to give the grades\n    to students. The teacher has been making her own algorithm for grading.\n    The only problem is, she has lost the code she used for grading.\n    She has given you a list of GPAs for some students and you have to write \n    a function that can output a list of letter grades using the following table:\n             GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n    Example:\n    grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n    \"\"\"\n\n\n    assert all(0.0 <= x <= 4.0 for x in grades), \"invalid inputs\" # $_CONTRACT_$\n\n\n    def to_letter_grade(score):\n      if score == 4.0:\n        return \"A+\"\n      elif score > 3.7:\n        return \"A\"\n      elif score > 3.3:\n        return \"A-\"\n      elif score > 3.0:\n        return \"B+\"\n      elif score > 2.7:\n        return \"B\"\n      elif score > 2.3:\n        return \"B-\"\n      elif score > 2.0:\n        return \"C+\"\n      elif score > 1.7:\n        return \"C\"\n      elif score > 1.3:\n        return \"C-\"\n      elif score > 1.0:\n        return \"D+\"\n      elif score > 0.7:\n        return \"D\"\n      elif score > 0.0:\n        return \"D-\"\n      else:\n        return \"E\"\n    \n    return [to_letter_grade(x) for x in grades]\n\n\n\nContract List:\nassert_0: assert all(0.0 <= x <= 4.0 for x in grades), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec IsList ((l Value)) Bool\\n  (ite (is-Nil l)\\n       true\\n       (ite (is-Cons l)\\n            (IsList (tail l))\\n            false)))\\n\\n(define-fun-rec list_all_numeric ((l Value)) Bool\\n  (ite (is-Nil l)\\n       true\\n       (ite (is-Cons l)\\n            (and (or (is-IntVal (head l)) (is-FloatVal (head l)))\\n                 (list_all_numeric (tail l)))\\n            false)))\\n\\n(define-fun get_real ((v Value)) Real\\n  (ite (is-IntVal v)\\n       (to_real (ival v))\\n       (ite (is-FloatVal v)\\n            (fval v)\\n            0)))\\n\\n(define-fun-rec list_all_in_range ((l Value) (lo Real) (hi Real)) Bool\\n  (ite (is-Nil l)\\n       true\\n       (ite (is-Cons l)\\n            (let ((headVal (get_real (head l))))\\n              (and (<= lo headVal)\\n                   (<= headVal hi)\\n                   (list_all_in_range (tail l) lo hi)))\\n            false)))\",\n  \"inputs\": \"(declare-const grades Value)\",\n  \"basic_structure\": \"(assert (IsList grades))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (and (list_all_numeric grades) (list_all_in_range grades 0.0 4.0)))\"\n}\n```\n", "constraints": [{"assert_0": "assert all(0.0 <= x <= 4.0 for x in grades), \"invalid inputs"}]}], "reasoning": ["I translated the Python all(0.0 ≤ x ≤ 4.0) contract into recursive SMT-LIB predicates over our Value ADT, defining list shape and numeric/range checks, then exposed grades as a Value and wrapped the contract as C0.</think>"]}
{"name": "HumanEval/82", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: prime_length\nProblem Description:\n\ndef prime_length(string):\n    \"\"\"Write a function that takes a string and returns True if the string\n    length is a prime number or False otherwise\n    Examples\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n\n\n    assert type(string) == str, \"invalid inputs\" # $_CONTRACT_$\n\n    def is_prime(a):\n        return not (a < 2 or any(a % x == 0 for x in range(2, int(a ** 0.5) + 1)))\n\n    return is_prime(len(string))\n\n\n\nContract List:\nassert_0: assert type(string) == str, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun SafeS ((v Value)) String (ite (is-StrVal v) (sval v) \\\"\\\"))\\n(define-fun length ((s Value)) Int (str.len (SafeS s)))\\n(define-fun is_prime ((n Int)) Bool\\n  (and (>= n 2)\\n       (forall ((x Int))\\n         (or (< x 2)\\n             (> (* x x) n)\\n             (not (= (mod n x) 0))))))\",\n  \"inputs\": \"(declare-const string Value)\",\n  \"basic_structure\": \"\",\n  \"contract_defs\": \"(define-fun C0 () Bool (is-StrVal string))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(string) == str, \"invalid inputs"}]}], "reasoning": ["I will provide safe helpers to extract a string from the ADT, compute its length, and define primality, then declare the input, leave basic structure empty for executability via SafeS, and create C0 exactly matching the Python type assertion.</think>"]}
{"name": "HumanEval/83", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: starts_one_ends\nProblem Description:\n\ndef starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\n\n\n    assert type(n) == int and n > 0, \"invalid inputs\" # $_CONTRACT_$\n\n\n    if n == 1: return 1\n    return 18 * 10 ** (n - 2)\n\n\n\nContract List:\nassert_0: assert type(n) == int and n > 0, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"\",\n  \"inputs\": \"(declare-const n Value)\",\n  \"basic_structure\": \"\",\n  \"contract_defs\": \"(define-fun C0 () Bool (and (is-IntVal n) (> (ival n) 0)))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(n) == int and n > 0, \"invalid inputs"}]}], "reasoning": ["I translate the Python assertion `type(n) == int and n > 0` into an SMT predicate C0, guarding the integer extractor with `is-IntVal` for safety. Since no recursive or complex data structures are needed, helper functions and basic structure remain empty.</think>"]}
{"name": "HumanEval/84", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: solve\nProblem Description:\n\ndef solve(N):\n    \"\"\"Given a positive integer N, return the total sum of its digits in binary.\n    \n    Example\n        For N = 1000, the sum of digits will be 1 the output should be \"1\".\n        For N = 150, the sum of digits will be 6 the output should be \"110\".\n        For N = 147, the sum of digits will be 12 the output should be \"1100\".\n    \n    Variables:\n        @N integer\n             Constraints: 0 ≤ N ≤ 10000.\n    Output:\n         a string of binary number\n    \"\"\"\n\n\n    assert type(N) == int, \"invalid inputs\" # $_CONTRACT_$\n    assert 0 < N <= 10000, \"invalid inputs\" # $_CONTRACT_$\n\n\n    s = sum(map(lambda x: int(x), str(N)))\n    return bin(s)[2:]\n\n\n\nContract List:\nassert_0: assert type(N) == int, \"invalid inputs\nassert_1: assert 0 < N <= 10000, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))\",\n  \"inputs\": \"(declare-const N Value)\",\n  \"basic_structure\": \"\",\n  \"contract_defs\": \"(define-fun C0 () Bool (is-IntVal N))\\n(define-fun C1 () Bool (and (> (SafeI N) 0) (<= (SafeI N) 10000)))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(N) == int, \"invalid inputs", "assert_1": "assert 0 < N <= 10000, \"invalid inputs"}]}], "reasoning": ["</think>"]}
{"name": "HumanEval/85", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: add\nProblem Description:\n\ndef add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n\n\n    assert len(lst) > 0, \"invalid inputs\" # $_CONTRACT_$\n    assert all(type(x) == int for x in lst), \"invalid inputs\" # $_CONTRACT_$\n\n\n    s = 0\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            s += lst[i]\n    return s\n\n\n\nContract List:\nassert_0: assert len(lst) > 0, \"invalid inputs\nassert_1: assert all(type(x) == int for x in lst), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec length ((l Value)) Int\\n  (ite (is-Nil l)\\n       0\\n       (ite (is-Cons l)\\n            (+ 1 (length (tail l)))\\n            0)))\\n\\n(define-fun-rec isList ((l Value)) Bool\\n  (ite (is-Nil l)\\n       true\\n       (ite (is-Cons l)\\n            (isList (tail l))\\n            false)))\\n\\n(define-fun-rec list_all_int ((l Value)) Bool\\n  (ite (is-Nil l)\\n       true\\n       (ite (is-Cons l)\\n            (and (is-IntVal (head l)) (list_all_int (tail l)))\\n            false)))\",\n  \"inputs\": \"(declare-const lst Value)\",\n  \"basic_structure\": \"(assert (isList lst))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (> (length lst) 0))\\n(define-fun C1 () Bool (list_all_int lst))\"\n}\n```\n", "constraints": [{"assert_0": "assert len(lst) > 0, \"invalid inputs", "assert_1": "assert all(type(x) == int for x in lst), \"invalid inputs"}]}], "reasoning": ["I map the Python list and type checks to precise SMT predicates, define recursive helpers for list structure, length, and integer element validation, then assert basic executability and two contracts C0 and C1.</think>"]}
{"name": "HumanEval/86", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: anti_shuffle\nProblem Description:\n\ndef anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n\n\n    assert type(s) == str, \"invalid inputs\" # $_CONTRACT_$\n\n    words = s.split(\" \")\n    return \" \".join(map(lambda x: \"\".join(sorted(x, key=lambda ch: ord(ch))), words))\n\n\n\nContract List:\nassert_0: assert type(s) == str, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun SafeS ((v Value)) String\\n  (ite (is-StrVal v) (sval v) \\\"\\\"))\",\n  \"inputs\": \"(declare-const s Value)\",\n  \"basic_structure\": \"\",\n  \"contract_defs\": \"(define-fun C0 () Bool (is-StrVal s))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(s) == str, \"invalid inputs"}]}], "reasoning": ["I will model the Python `assert type(s)==str` as an SMT predicate C0 over our Value ADT, introduce a SafeS helper to extract string payloads safely, declare `s` as a Value, and leave BASIC_STRUCTURE empty so that executability hinges on C0 during testing.</think>"]}
{"name": "HumanEval/87", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: get_row\nProblem Description:\n\ndef get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n\n\n    assert type(x) == int, \"invalid inputs\" # $_CONTRACT_$\n    assert type(lst) == list, \"invalid inputs\" # $_CONTRACT_$\n    assert all(type(y) == list for y in lst), \"invalid inputs\" # $_CONTRACT_$\n\n    res = []\n    for i, l in enumerate(lst):\n        for j in range(len(l) - 1, -1, -1):\n            if l[j] == x: res.append((i, j))\n    return res\n\n\n\nContract List:\nassert_0: assert type(x) == int, \"invalid inputs\nassert_1: assert type(lst) == list, \"invalid inputs\nassert_2: assert all(type(y) == list for y in lst), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec IsList ((v Value)) Bool\\n  (ite (is-Nil v)\\n       true\\n       (ite (is-Cons v)\\n            (IsList (tail v))\\n            false)))\\n\\n(define-fun-rec AllRowsAreList ((l Value)) Bool\\n  (ite (is-Nil l)\\n       true\\n       (ite (is-Cons l)\\n            (and (IsList (head l))\\n                 (AllRowsAreList (tail l)))\\n            false)))\",\n  \"inputs\": \"(declare-const lst Value)\\n(declare-const x Value)\",\n  \"basic_structure\": \"(assert (IsList lst))\\n(assert (AllRowsAreList lst))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (is-IntVal x))\\n(define-fun C1 () Bool (IsList lst))\\n(define-fun C2 () Bool (AllRowsAreList lst))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(x) == int, \"invalid inputs", "assert_1": "assert type(lst) == list, \"invalid inputs", "assert_2": "assert all(type(y) == list for y in lst), \"invalid inputs"}]}], "reasoning": ["I translate each Python type-check assertion into precise SMT predicates over the Value ADT and define recursive helpers for list structures. I then declare inputs, assert basic executability invariants, and expose each contract as a named Boolean predicate.</think>"]}
{"name": "HumanEval/88", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: sort_array\nProblem Description:\n\ndef sort_array(array):\n    \"\"\"\n    Given an array of non-negative integers, return a copy of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \"\"\"\n\n\n    assert all(x >= 0 for x in array), \"invalid inputs\" # $_CONTRACT_$\n\n\n    if array == []: return []\n    return sorted(array, reverse=(array[0]+array[-1]) % 2 == 0)\n\n\n\nContract List:\nassert_0: assert all(x >= 0 for x in array), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec IsList ((l Value)) Bool\\n  (or (is-Nil l)\\n      (and (is-Cons l)\\n           (let ((h (head l)) (t (tail l)))\\n             (IsList t)))))\\n\\n(define-fun-rec list_all_nonneg_int ((l Value)) Bool\\n  (ite (is-Nil l)\\n       true\\n       (and (is-Cons l)\\n            (let ((h (head l)) (t (tail l)))\\n              (and (is-IntVal h)\\n                   (>= (ival h) 0)\\n                   (list_all_nonneg_int t))))))\",\n  \"inputs\": \"(declare-const array Value)\",\n  \"basic_structure\": \"(assert (IsList array))\",\n  \"contract_defs\": \"(define-fun C0 () Bool\\n  (list_all_nonneg_int array))\"\n}\n```\n", "constraints": [{"assert_0": "assert all(x >= 0 for x in array), \"invalid inputs"}]}], "reasoning": ["I translated the Python assertion requiring all non-negative integers in the array into a recursive SMT predicate over the canonical Value list ADT, declared the input and basic list‐shape invariant, and encapsulated the contract as a named predicate C0 for systematic testing.</think>"]}
{"name": "HumanEval/89", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: encrypt\nProblem Description:\n\ndef encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n\n\n    assert s == \"\" or s.islower(), \"invalid inputs\" # $_CONTRACT_$\n\n    d = 'abcdefghijklmnopqrstuvwxyz'\n    return \"\".join(map(lambda ch: chr((ord(ch) - ord(\"a\") + 4) % 26 + ord(\"a\")) if ch in d else ch, s))\n\n\n\nContract List:\nassert_0: assert s == \"\" or s.islower(), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"\",\n  \"inputs\": \"(declare-const s Value)\",\n  \"basic_structure\": \"(assert (is-StrVal s))\",\n  \"contract_defs\": \"(define-fun C0 () Bool\\n  (or (= (sval s) \\\"\\\")\\n      (str.in.re (sval s) (str.to.re \\\"[a-z]*\\\"))))\"\n}\n```\n", "constraints": [{"assert_0": "assert s == \"\" or s.islower(), \"invalid inputs"}]}], "reasoning": ["I translate the Python assertion s == \"\" or s.islower() into an SMT regex check over our Value ADT, ensure s is a string value in BASIC_STRUCTURE, and define a single contract predicate C0 matching the assertion.</think>"]}
{"name": "HumanEval/90", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: next_smallest\nProblem Description:\n\ndef next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n\n\n    assert all(type(x) == int for x in lst), \"invalid inputs\" # $_CONTRACT_$\n\n    if len(lst) <= 1: return None\n    sorted_list = sorted(lst)\n    for x in sorted_list:\n        if x != sorted_list[0]:\n            return x \n\n\n\nContract List:\nassert_0: assert all(type(x) == int for x in lst), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec IsList ((v Value)) Bool\\n  (or (is-Nil v)\\n      (and (is-Cons v) (IsList (tail v)))))\\n\\n(define-fun-rec ListAllInt ((v Value)) Bool\\n  (ite (is-Nil v) true\\n       (ite (is-Cons v)\\n            (and (is-IntVal (head v)) (ListAllInt (tail v)))\\n            false)))\",\n  \"inputs\": \"(declare-const lst Value)\",\n  \"basic_structure\": \"(assert (IsList lst))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (ListAllInt lst))\"\n}\n```\n", "constraints": [{"assert_0": "assert all(type(x) == int for x in lst), \"invalid inputs"}]}], "reasoning": ["I translate the Python list‐of‐ints assertion into an SMT ADT for Value with recursive list and integer‐checking predicates, ensuring well‐formed inputs for execution. I then define C0 to capture the “all elements are integers” contract precisely.</think>"]}
{"name": "HumanEval/91", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: is_bored\nProblem Description:\n\ndef is_bored(S):\n    \"\"\"\n    You'll be given a string of words, and your task is to count the number\n    of boredoms. A boredom is a sentence that starts with the word \"I\".\n    Sentences are delimited by '.', '?' or '!'.\n   \n    For example:\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"\n\n\n    assert type(S) == str, \"invalid inputs\" # $_CONTRACT_$\n\n    sentences = map(lambda x: x.strip(), ((S.replace(\"?\", \".\")).replace(\"!\", \".\")).split(\".\"))\n    return len([s for s in sentences if s.startswith(\"I \")])\n\n\n\nContract List:\nassert_0: assert type(S) == str, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"\",\n  \"inputs\": \"(declare-const S Value)\",\n  \"basic_structure\": \"\",\n  \"contract_defs\": \"(define-fun C0 () Bool (is-StrVal S))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(S) == str, \"invalid inputs"}]}], "reasoning": ["I model the Python type check as an SMT is-StrVal test on the Value ADT and prepare the minimal SMT-LIB template with input declarations and the named contract predicate.</think>"]}
{"name": "HumanEval/92", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: any_int\nProblem Description:\n\ndef any_int(x, y, z):\n    '''\n    Create a function that takes 3 numbers.\n    Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n    Returns false in any other cases.\n    \n    Examples\n    any_int(5, 2, 7) ➞ True\n    \n    any_int(3, 2, 2) ➞ False\n\n    any_int(3, -2, 1) ➞ True\n    \n    any_int(3.6, -2.2, 2) ➞ False\n  \n\n    \n    '''\n\n\n    assert all(isinstance(v, (int, float, bool)) for v in [x, y, z]), \"invalid inputs\" # $_CONTRACT_$\n\n    if type(x) != int or type(y) != int or type(z) != int: return False\n    return x == y + z or y == x + z or z == y + x\n\n\n\nContract List:\nassert_0: assert all(isinstance(v, (int, float, bool)) for v in [x, y, z]), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"\",\n  \"inputs\": \"(declare-const x Value)\\n(declare-const y Value)\\n(declare-const z Value)\",\n  \"basic_structure\": \"\",\n  \"contract_defs\": \"(define-fun C0 () Bool (and (or (is-IntVal x) (is-FloatVal x) (is-BoolVal x)) (or (is-IntVal y) (is-FloatVal y) (is-BoolVal y)) (or (is-IntVal z) (is-FloatVal z) (is-BoolVal z))))\"\n}\n```\n", "constraints": [{"assert_0": "assert all(isinstance(v, (int, float, bool)) for v in [x, y, z]), \"invalid inputs"}]}], "reasoning": ["I translate the Python type assertion into an SMT predicate requiring each input to be an IntVal, FloatVal, or BoolVal. No recursive or list helpers are needed, so helper and basic-structure sections are empty.</think>"]}
{"name": "HumanEval/93", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: encode\nProblem Description:\n\ndef encode(message):\n    \"\"\"\n    Write a function that takes a message, and encodes in such a \n    way that it swaps case of all letters, replaces all vowels in \n    the message with the letter that appears 2 places ahead of that \n    vowel in the english alphabet. \n    Assume only letters. \n    \n    Examples:\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'\n    \"\"\"\n\n\n    assert type(message) == str, \"invalid inputs\" # $_CONTRACT_$\n    assert all(ch == \" \" or ch.isalpha() for ch in message), \"invalid inputs\" # $_CONTRACT_$\n\n\n    def switch_case(ch):\n        if ord(\"A\") <= ord(ch) <= ord(\"Z\"):\n            return chr(ord(ch) + 32)\n        elif ord(\"a\") <= ord(ch) <= ord(\"z\"):\n            return chr(ord(ch) - 32)\n        else:\n            return ch\n    \n    def vowel_change(ch):\n        return ch if ch not in \"aeiouAEIOU\" else chr(ord(ch) + 2)\n    \n    m = \"\".join(map(switch_case, message))\n    return \"\".join(map(vowel_change, m))\n\n\n\nContract List:\nassert_0: assert type(message) == str, \"invalid inputs\nassert_1: assert all(ch == \" \" or ch.isalpha() for ch in message), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"\",\n  \"inputs\": \"(declare-const message Value)\",\n  \"basic_structure\": \"(assert (is-StrVal message))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (is-StrVal message))\\n(define-fun C1 () Bool (let ((s (ite (is-StrVal message) (sval message) \\\"\\\"))) (forall ((i Int)) (=> (and (>= i 0) (< i (str.len s))) (or (= (str.substr s i 1) \\\" \\\") (str.in.re (str.substr s i 1) (str.to.re \\\"[A-Za-z]\\\")))))))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(message) == str, \"invalid inputs", "assert_1": "assert all(ch == \" \" or ch.isalpha() for ch in message), \"invalid inputs"}]}], "reasoning": ["I translate the Python type and character constraints into precise SMT predicates over the Value ADT, using `is-StrVal` and safe extraction of the string for indexing with `str.substr` and regex checks. The base template ensures the input is declared, its ADT shape is asserted, and each contract is captured as a standalone Boolean function.</think>"]}
{"name": "HumanEval/94", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: skjkasdkd\nProblem Description:\n\n\ndef skjkasdkd(lst):\n    \"\"\"You are given a list of integers.\n    You need to find the largest prime value and return the sum of its digits.\n\n    Examples:\n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n    \"\"\"\n\n\n    def is_prime(a): # $_CONTRACT_$\n        return not (a < 2 or any(a % x == 0 for x in range(2, int(a ** 0.5) + 1))) # $_CONTRACT_$\n    assert any(is_prime(x) for x in lst), \"invalid inputs\" # $_CONTRACT_$\n\n\n    def is_prime(a):\n        return not (a < 2 or any(a % x == 0 for x in range(2, int(a ** 0.5) + 1)))\n    sorted_list = sorted(lst)[::-1]\n    for x in sorted_list:\n        if is_prime(x):\n            return sum(map(lambda ch: int(ch), str(x)))\n\n\n\nContract List:\nassert_0: assert any(is_prime(x) for x in lst), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec IsList ((v Value)) Bool\\n  (or (is-Nil v)\\n      (and (is-Cons v)\\n           (let ((tailVal (tail v)))\\n             (IsList tailVal)))))\\n(define-fun-rec list_all_int ((v Value)) Bool\\n  (or (is-Nil v)\\n      (and (is-Cons v)\\n           (let ((headVal (head v)) (tailVal (tail v)))\\n             (and (is-IntVal headVal)\\n                  (list_all_int tailVal))))))\\n(define-fun-rec has_no_divisor ((n Int) (x Int)) Bool\\n  (ite (> (* x x) n)\\n       true\\n       (ite (= (mod n x) 0)\\n            false\\n            (has_no_divisor n (+ x 1)))))\\n(define-fun is_prime_val ((v Value)) Bool\\n  (and (is-IntVal v)\\n       (let ((n (ival v)))\\n         (and (>= n 2)\\n              (has_no_divisor n 2)))))\\n(define-fun-rec list_has_prime ((v Value)) Bool\\n  (ite (is-Nil v)\\n       false\\n       (and (is-Cons v)\\n            (let ((headVal (head v)) (tailVal (tail v)))\\n              (or (is_prime_val headVal)\\n                  (list_has_prime tailVal))))))\",\n  \"inputs\": \"(declare-const lst Value)\",\n  \"basic_structure\": \"(assert (IsList lst))\\n(assert (list_all_int lst))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (list_has_prime lst))\"\n}\n```\n", "constraints": [{"assert_0": "assert any(is_prime(x) for x in lst), \"invalid inputs"}]}], "reasoning": ["I will translate the Python “any prime in list” assertion into a precise SMT specification by defining an ADT-based list of integers, a recursive primality test, and a list‐scanning helper. The single contract C0 then asserts that the list contains at least one prime.</think>"]}
{"name": "HumanEval/95", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: check_dict_case\nProblem Description:\n\ndef check_dict_case(dict):\n    \"\"\"\n    Given a dictionary, return True if all keys are strings in lower \n    case or all keys are strings in upper case, else return False.\n    The function should return False is the given dictionary is empty.\n    Examples:\n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n    \"\"\"\n\n\n    assert type(dict).__name__ == \"dict\", \"invalid inputs\" # $_CONTRACT_$\n\n    keys = list(dict.keys())\n    if keys == []: return False\n    lower, upper = True, True\n    for k in keys:\n        if type(k) != str:\n            lower = upper = False\n            break\n        if not k.islower(): lower = False\n        if not k.isupper(): upper = False\n    return lower or upper\n\n\n\nContract List:\nassert_0: assert type(dict).__name__ == \"dict\", \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec IsList ((v Value)) Bool\\n  (ite (is-Nil v)\\n       true\\n       (ite (is-Cons v)\\n            (IsList (tail v))\\n            false)))\\n\\n(define-fun IsKV2 ((p Value)) Bool\\n  (and (is-Cons p)\\n       (is-Cons (tail p))\\n       (is-Nil (tail (tail p)))\\n       (is-StrVal (head p))))\\n\\n(define-fun-rec IsDictLike ((v Value)) Bool\\n  (ite (is-Nil v)\\n       true\\n       (ite (is-Cons v)\\n            (and (IsKV2 (head v)) (IsDictLike (tail v)))\\n            false)))\\n\\n(define-fun-rec KeysV ((v Value)) Value\\n  (ite (is-Nil v)\\n       Nil\\n       (Cons (head (head v)) (KeysV (tail v)))))\",\n  \"inputs\": \"(declare-const dict Value)\",\n  \"basic_structure\": \"(assert (=> (IsDictLike dict)\\n                 (IsList (KeysV dict))))\",\n  \"contract_defs\": \"(define-fun C0 () Bool\\n  (IsDictLike dict))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(dict).__name__ == \"dict\", \"invalid inputs"}]}], "reasoning": ["I model the dictionary as a Dict constructor holding a key‐list, add a recursive IsList helper to ensure valid lists, enforce in BASIC_STRUCTURE that any Dict has a proper list of keys, declare the single input, and define C0 to check the dict type.</think>"]}
{"name": "HumanEval/96", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: count_up_to\nProblem Description:\n\ndef count_up_to(n):\n    \"\"\"Implement a function that takes an non-negative integer and returns an array of the first n\n    integers that are prime numbers and less than n.\n    for example:\n    count_up_to(5) => [2,3]\n    count_up_to(11) => [2,3,5,7]\n    count_up_to(0) => []\n    count_up_to(20) => [2,3,5,7,11,13,17,19]\n    count_up_to(1) => []\n    count_up_to(18) => [2,3,5,7,11,13,17]\n    \"\"\"\n\n\n    assert type(n) == int and n >= 0, \"invalid inputs\" # $_CONTRACT_$\n\n\n    ans = []\n    isprime = [True] * (n + 1)\n    for i in range(2, n):\n        if isprime[i]:\n            ans.append(i)\n            for j in range(i + i, n, i):\n                isprime[j] = False\n    return ans\n\n\n\nContract List:\nassert_0: assert type(n) == int and n >= 0, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"\",\n  \"inputs\": \"(declare-const n Value)\",\n  \"basic_structure\": \"(assert (is-IntVal n))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (and (is-IntVal n) (>= (ival n) 0)))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(n) == int and n >= 0, \"invalid inputs"}]}], "reasoning": ["I model the single input constraint by ensuring `n` has the `IntVal` shape and its extracted integer component is ≥ 0. No additional helper functions are needed for this simple check, and the basic structure only asserts the ADT shape.</think>"]}
{"name": "HumanEval/97", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: multiply\nProblem Description:\n\ndef multiply(a, b):\n    \"\"\"Complete the function that takes two integers and returns \n    the product of their unit digits.\n    Assume the input is always valid.\n    Examples:\n    multiply(148, 412) should return 16.\n    multiply(19, 28) should return 72.\n    multiply(2020, 1851) should return 0.\n    multiply(14,-15) should return 20.\n    \"\"\"\n\n\n    assert type(a) == type(b) == int, \"invalid inputs\" # $_CONTRACT_$\n\n    return int(str(a)[-1]) * int(str(b)[-1])\n\n\n\nContract List:\nassert_0: assert type(a) == type(b) == int, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"\",\n  \"inputs\": \"(declare-const a Value)\\n(declare-const b Value)\",\n  \"basic_structure\": \"\",\n  \"contract_defs\": \"(define-fun C0 () Bool (and (is-IntVal a) (is-IntVal b)))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(a) == type(b) == int, \"invalid inputs"}]}], "reasoning": ["I model the Python type check as an SMT predicate requiring both inputs to be IntVal. Since no recursive or complex structures are used, helper functions and basic structure remain empty.</think>"]}
{"name": "HumanEval/98", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: count_upper\nProblem Description:\n\ndef count_upper(s):\n    \"\"\"\n    Given a string s, count the number of uppercase vowels in even indices.\n    \n    For example:\n    count_upper('aBCdEf') returns 1\n    count_upper('abcdefg') returns 0\n    count_upper('dBBE') returns 0\n    \"\"\"\n\n\n    assert type(s) == str, \"invalid inputs\" # $_CONTRACT_$\n\n    cnt = 0\n    for i in range(0, len(s), 2):\n        if s[i] in \"AEIOU\":\n            cnt += 1\n    return cnt\n\n\n\nContract List:\nassert_0: assert type(s) == str, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"\",\n  \"inputs\": \"(declare-const s Value)\",\n  \"basic_structure\": \"(assert (is-StrVal s))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (is-StrVal s))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(s) == str, \"invalid inputs"}]}], "reasoning": ["I translate the Python assertion `type(s)==str` into an SMT predicate requiring `StrVal`, ensure executability by asserting `is-StrVal(s)` in the basic structure, and provide a trivial combination formula for systematic testing.</think>"]}
{"name": "HumanEval/99", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: closest_integer\nProblem Description:\n\ndef closest_integer(value):\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    '''\n\n\n    try: # $_CONTRACT_$\n        assert isinstance(value, str) # $_CONTRACT_$\n        value = float(value) # $_CONTRACT_$\n    except: # $_CONTRACT_$\n        raise Exception(\"invalid inputs\") # $_CONTRACT_$\n    import math # $_CONTRACT_$\n    assert not (math.isinf(value) or math.isnan(value)), \"invalid inputs\" # $_CONTRACT_$\n\n\n    def rounding(val):\n        if abs(val - int(val)) != 0.5:\n            return round(val)\n        if val > 0:\n            return int(val) + 1\n        else:\n            return int(val) - 1\n    return rounding(float(value))\n\n\n\nContract List:\nassert_0: assert isinstance(value, str)\nassert_1: assert not (math.isinf(value) or math.isnan(value)), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"\",\n  \"inputs\": \"(declare-const value Value)\",\n  \"basic_structure\": \"\",\n  \"contract_defs\": \"(define-fun C0 () Bool (is-StrVal value))\\n(define-fun C1 () Bool (ite (is-StrVal value)\\n                               (not (or (= (sval value) \\\"Infinity\\\")\\n                                        (= (sval value) \\\"-Infinity\\\")\\n                                        (= (sval value) \\\"NaN\\\")))\\n                               false))\"\n}\n```\n", "constraints": [{"assert_0": "assert isinstance(value, str)", "assert_1": "assert not (math.isinf(value) or math.isnan(value)), \"invalid inputs"}]}], "reasoning": ["I translate each Python assert into a precise SMT predicate guarded for selector safety, using only the ADT’s testers and selectors, and leave the base structure minimal since no lists or recursion are needed.</think>"]}
{"name": "HumanEval/100", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: make_a_pile\nProblem Description:\n\ndef make_a_pile(n):\n    \"\"\"\n    Given a positive integer n, you have to make a pile of n levels of stones.\n    The first level has n stones.\n    The number of stones in the next level is:\n        - the next odd number if n is odd.\n        - the next even number if n is even.\n    Return the number of stones in each level in a list, where element at index\n    i represents the number of stones in the level (i+1).\n\n    Examples:\n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"\n\n\n    assert type(n) == int and n >= 1, \"invalid inputs\" # $_CONTRACT_$\n\n\n    ans, num = [], n\n    for _ in range(n):\n        ans.append(num)\n        num += 2\n    return ans\n\n\n\nContract List:\nassert_0: assert type(n) == int and n >= 1, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))\",\n  \"inputs\": \"(declare-const n Value)\",\n  \"basic_structure\": \"\",\n  \"contract_defs\": \"(define-fun C0 () Bool (and (is-IntVal n) (>= (SafeI n) 1)))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(n) == int and n >= 1, \"invalid inputs"}]}], "reasoning": ["I translate the Python type and range assertion into an SMT predicate C0 using a safe integer extractor helper (SafeI), ensuring `n` is an IntVal with value ≥1. I declare the input and helper, leave basic_structure empty (no additional invariants), and define the contract predicate.</think>"]}
{"name": "HumanEval/101", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: words_string\nProblem Description:\n\ndef words_string(s):\n    \"\"\"\n    You will be given a string of words separated by commas or spaces. Your task is\n    to split the string into words and return an array of the words.\n    \n    For example:\n    words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    \"\"\"\n\n\n    assert isinstance(s, str), \"invalid inputs\" # $_CONTRACT_$\n\n    words = (s.replace(\",\", \" \")).split()\n    return [word for word in words if word != \"\"]\n\n\n\nContract List:\nassert_0: assert isinstance(s, str), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"\",\n  \"inputs\": \"(declare-const s Value)\",\n  \"basic_structure\": \"(assert (is-StrVal s))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (is-StrVal s))\"\n}\n```\n", "constraints": [{"assert_0": "assert isinstance(s, str), \"invalid inputs"}]}], "reasoning": ["I translate the Python isinstance check into the SMT-LIB ADT test is-StrVal(s), enforce it in BASIC_STRUCTURE for executability, and define C0 to capture the original assertion. No extra helper functions are needed for this simple string‐only contract.</think>"]}
{"name": "HumanEval/102", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: choose_num\nProblem Description:\n\ndef choose_num(x, y):\n    \"\"\"This function takes two positive numbers x and y and returns the\n    biggest even integer number that is in the range [x, y] inclusive. If \n    there's no such number, then the function should return -1.\n\n    For example:\n    choose_num(12, 15) = 14\n    choose_num(13, 12) = -1\n    \"\"\"\n\n\n    assert type(x) == int and type(y) == int, \"invalid inputs\" # $_CONTRACT_$\n    assert x > 0 and y > 0, \"invalid inputs\" # $_CONTRACT_$\n\n\n    if x > y: return -1\n    if x == y: return y if y % 2 == 0 else -1\n    return y if y % 2 == 0 else y - 1\n\n\n\nContract List:\nassert_0: assert type(x) == int and type(y) == int, \"invalid inputs\nassert_1: assert x > 0 and y > 0, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun SafeI ((v Value)) Int\\n  (ite (is-IntVal v) (ival v) 0))\",\n  \"inputs\": \"(declare-const x Value)\\n(declare-const y Value)\",\n  \"basic_structure\": \"\",\n  \"contract_defs\": \"(define-fun C0 () Bool\\n  (and (is-IntVal x)\\n       (is-IntVal y)))\\n(define-fun C1 () Bool\\n  (and (> (SafeI x) 0)\\n       (> (SafeI y) 0)))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(x) == int and type(y) == int, \"invalid inputs", "assert_1": "assert x > 0 and y > 0, \"invalid inputs"}]}], "reasoning": ["I will translate the Python type and range assertions into precise SMT predicates over our Value ADT, introduce a SafeI helper to extract integer values safely, and enumerate all combinations of the two contracts for systematic testing.</think>"]}
{"name": "HumanEval/103", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: rounded_avg\nProblem Description:\n\ndef rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n\n\n    assert type(n) == int and type(m) == int, \"invalid inputs\" # $_CONTRACT_$\n    assert n > 0 and m > 0, \"invalid inputs\"  # $_CONTRACT_$\n\n\n    if n > m: return -1\n    avg = round((n + m) / 2)\n    return bin(avg)\n\n\n\nContract List:\nassert_0: assert type(n) == int and type(m) == int, \"invalid inputs\nassert_1: assert n > 0 and m > 0, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"\",\n  \"inputs\": \"(declare-const n Value)\\n(declare-const m Value)\",\n  \"basic_structure\": \"(assert (is-IntVal n))\\n(assert (is-IntVal m))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (and (is-IntVal n) (is-IntVal m)))\\n(define-fun C1 () Bool (and (is-IntVal n) (> (ival n) 0) (is-IntVal m) (> (ival m) 0)))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(n) == int and type(m) == int, \"invalid inputs", "assert_1": "assert n > 0 and m > 0, \"invalid inputs"}]}], "reasoning": ["I model the Python type and positivity assertions as SMT-LIB Boolean predicates C0 and C1, ensure inputs are IntVal in the basic structure for safe numeric operations, and include no extra helpers since only integers are used.</think>"]}
{"name": "HumanEval/104", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: unique_digits\nProblem Description:\n\ndef unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\"\n\n\n    assert type(x) == list, \"invalid inputs\" # $_CONTRACT_$\n    assert all(type(num) == int and num > 0 for num in x), \"invalid inputs\" # $_CONTRACT_$\n\n\n    def judge(x):\n        for ch in str(x):\n            if int(ch) % 2 == 0:\n                return False\n        return True\n    return sorted(list(filter(judge, x)))\n\n\n\nContract List:\nassert_0: assert type(x) == list, \"invalid inputs\nassert_1: assert all(type(num) == int and num > 0 for num in x), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec IsList ((v Value)) Bool\\n  (ite (is-Nil v)\\n       true\\n       (ite (is-Cons v)\\n            (IsList (tail v))\\n            false)))\\n\\n(define-fun-rec AllPosIntList ((v Value)) Bool\\n  (ite (is-Nil v)\\n       true\\n       (ite (is-Cons v)\\n            (let ((h (head v))\\n                  (t (tail v)))\\n              (and (is-IntVal h)\\n                   (> (ival h) 0)\\n                   (AllPosIntList t)))\\n            false)))\",\n  \"inputs\": \"(declare-const x Value)\",\n  \"basic_structure\": \"(assert (IsList x))\",\n  \"contract_defs\": \"(define-fun C0 () Bool\\n  (IsList x))\\n(define-fun C1 () Bool\\n  (AllPosIntList x))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(x) == list, \"invalid inputs", "assert_1": "assert all(type(num) == int and num > 0 for num in x), \"invalid inputs"}]}], "reasoning": ["I translate each Python assertion into an SMT predicate over our ADT and provide minimal list‐shape constraints for safe execution. Helper functions IsList and AllPosIntList capture the structural and numeric requirements, C0 and C1 mirror the original asserts exactly.</think>"]}
{"name": "HumanEval/105", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: by_length\nProblem Description:\n\ndef by_length(arr):\n    \"\"\"\n    Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n    \n      If the array is empty, return an empty array:\n      arr = []\n      return []\n    \n      If the array has any strange number ignore it:\n      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n            -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\n\n\n    assert type(arr) == list, \"invalid inputs\" # $_CONTRACT_$\n    assert all(type(x) == int for x in arr), \"invalid inputs\"  # $_CONTRACT_$\n\n    def to_word(x: int) -> str:\n      if x == 1:\n        return \"One\"\n      elif x == 2:\n        return \"Two\"\n      elif x == 3:\n        return \"Three\"\n      elif x == 4:\n        return \"Four\"\n      elif x == 5:\n        return \"Five\"\n      elif x == 6:\n        return \"Six\"\n      elif x == 7:\n        return \"Seven\"\n      elif x == 8:\n        return \"Eight\"\n      else:\n        return \"Nine\"\n    sorted_list, ans = sorted(arr)[::-1], []\n    for x in sorted_list:\n      if 1 <= x <= 9:\n        ans.append(to_word(x))\n    return ans\n\n\n\nContract List:\nassert_0: assert type(arr) == list, \"invalid inputs\nassert_1: assert all(type(x) == int for x in arr), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec IsList ((v Value)) Bool\\n  (or\\n    (is-Nil v)\\n    (and (is-Cons v)\\n         (IsList (tail v))))\\n)\\n\\n(define-fun-rec list_all_int ((v Value)) Bool\\n  (ite (is-Nil v)\\n       true\\n       (and (is-Cons v)\\n            (is-IntVal (head v))\\n            (list_all_int (tail v)))))\",\n  \"inputs\": \"(declare-const arr Value)\",\n  \"basic_structure\": \"(assert (IsList arr))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (IsList arr))\\n(define-fun C1 () Bool (list_all_int arr))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(arr) == list, \"invalid inputs", "assert_1": "assert all(type(x) == int for x in arr), \"invalid inputs"}]}], "reasoning": ["I translate the Python assertions into SMT-LIB by declaring the canonical Value ADT, defining recursive predicates for list structure and integer membership, enforcing that `arr` is a proper list for executability, and mapping each contract to a separate Boolean predicate.</think>"]}
{"name": "HumanEval/106", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: f\nProblem Description:\n\ndef f(n):\n    \"\"\" Implement the function f that takes n as a parameter,\n    and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n    or the sum of numbers from 1 to i otherwise.\n    i starts from 1.\n    the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n    Example:\n    f(5) == [1, 2, 6, 24, 15]\n    \"\"\"\n\n\n    assert type(n) == int, \"invalid inputs\" # $_CONTRACT_$\n    assert n >= 0, \"invalid inputs\" # $_CONTRACT_$\n\n\n    if n == 0: return []\n    if n == 1: return [1]\n    if n == 2: return [1, 2]\n\n    ans = [1, 2]\n    for i in range(3, n + 1):\n        if i % 2 == 1:\n            ans.append(ans[-2] + (i - 1) + i)\n        else:\n            ans.append(ans[-2] * (i - 1) * i)\n    return ans\n\n\n\nContract List:\nassert_0: assert type(n) == int, \"invalid inputs\nassert_1: assert n >= 0, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun SafeI ((v Value)) Int\\n  (ite (is-IntVal v) (ival v) 0))\",\n  \"inputs\": \"(declare-const n Value)\",\n  \"basic_structure\": \"\",\n  \"contract_defs\": \"(define-fun C0 () Bool (is-IntVal n))\\n(define-fun C1 () Bool (>= (SafeI n) 0))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(n) == int, \"invalid inputs", "assert_1": "assert n >= 0, \"invalid inputs"}]}], "reasoning": ["I extract the Python asserts into two SMT predicates C0 (type check) and C1 (non-negativity) and introduce a SafeI helper to safely extract integers from the Value ADT.</think>"]}
{"name": "HumanEval/107", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: even_odd_palindrome\nProblem Description:\n\ndef even_odd_palindrome(n):\n    \"\"\"\n    Given a positive integer n, return a tuple that has the number of even and odd\n    integer palindromes that fall within the range(1, n), inclusive.\n\n    Example 1:\n\n        Input: 3\n        Output: (1, 2)\n        Explanation:\n        Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n    Example 2:\n\n        Input: 12\n        Output: (4, 6)\n        Explanation:\n        Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n    Note:\n        1. 1 <= n <= 10^3\n        2. returned tuple has the number of even and odd integer palindromes respectively.\n    \"\"\"\n\n\n    assert type(n) == int, \"invalid inputs\" # $_CONTRACT_$\n    assert 1 <= n <= 1000, \"invalid inputs\" # $_CONTRACT_$\n\n\n    odd_cnt, even_cnt = 0, 0\n    for i in range(1, n + 1):\n        if str(i) == str(i)[::-1]:\n            if i % 2 == 1:\n                odd_cnt += 1\n            else:\n                even_cnt += 1\n    return even_cnt, odd_cnt\n\n\n\nContract List:\nassert_0: assert type(n) == int, \"invalid inputs\nassert_1: assert 1 <= n <= 1000, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))\",\n  \"inputs\": \"(declare-const n Value)\",\n  \"basic_structure\": \"\",\n  \"contract_defs\": \"(define-fun C0 () Bool (is-IntVal n))\\n(define-fun C1 () Bool (and (is-IntVal n) (<= 1 (SafeI n)) (<= (SafeI n) 1000)))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(n) == int, \"invalid inputs", "assert_1": "assert 1 <= n <= 1000, \"invalid inputs"}]}], "reasoning": ["I will model the integer‐only contracts by declaring a Value ADT, adding a SafeI extractor for IntVal, then define C0 to check the IntVal shape and C1 to enforce 1 ≤ n ≤ 1000 guarded by SafeI. I’ll enumerate all four violation scenarios as reusable named predicates.</think>"]}
{"name": "HumanEval/108", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: count_nums\nProblem Description:\n\ndef count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n\n\n    assert type(arr) == list, \"invalid inputs\" # $_CONTRACT_$\n    assert all(type(x) == int for x in arr), \"invalid inputs\" # $_CONTRACT_$\n\n    def judge(x: int) -> int:\n        l = list(str(x))\n        if l[0] == \"-\":\n            l = l[1:]\n            l = list(map(int, l))\n            l[0] = -l[0]\n        else:\n            l = list(map(int, l))\n        return 1 if sum(l) > 0 else 0\n    return sum(map(judge, arr))\n\n\n\nContract List:\nassert_0: assert type(arr) == list, \"invalid inputs\nassert_1: assert all(type(x) == int for x in arr), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec IsList ((v Value)) Bool\\n  (ite (is-Nil v)\\n       true\\n       (ite (is-Cons v)\\n            (IsList (tail v))\\n            false)))\\n\\n(define-fun-rec list_all_int ((v Value)) Bool\\n  (ite (is-Nil v)\\n       true\\n       (ite (is-Cons v)\\n            (and (is-IntVal (head v))\\n                 (list_all_int (tail v)))\\n            false)))\",\n  \"inputs\": \"(declare-const arr Value)\",\n  \"basic_structure\": \"(assert (IsList arr))\",\n  \"contract_defs\": \"(define-fun C0 () Bool\\n  (IsList arr))\\n(define-fun C1 () Bool\\n  (list_all_int arr))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(arr) == list, \"invalid inputs", "assert_1": "assert all(type(x) == int for x in arr), \"invalid inputs"}]}], "reasoning": ["I translate the Python list and integer type assertions into SMT-LIB predicates, defining recursive helpers for list structure and integer membership. I ensure basic executability by asserting a proper list shape and capture each contract as a named Boolean definition.</think>"]}
{"name": "HumanEval/109", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: move_one_ball\nProblem Description:\n\ndef move_one_ball(arr):\n    \"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return True else return False.\n    If the given array is empty then return True.\n\n    Note: The given list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \"\"\"\n\n\n    assert type(arr) == list, \"invalid inputs\" # $_CONTRACT_$\n    assert all(type(x) == int for x in arr), \"invalid inputs\" # $_CONTRACT_$\n    assert len(set(arr)) == len(arr), \"invalid inputs\" # $_CONTRACT_$\n    assert all(type(x) == int for x in arr), \"invalid inputs\" # $_CONTRACT_$\n\n    \n    sorted_arr = sorted(arr)\n    if arr == sorted_arr: return True\n    for i in range(1, len(arr)):\n        if arr[i:] + arr[:i] == sorted_arr:\n            return True\n    return False\n\n\n\nContract List:\nassert_0: assert type(arr) == list, \"invalid inputs\nassert_1: assert all(type(x) == int for x in arr), \"invalid inputs\nassert_2: assert len(set(arr)) == len(arr), \"invalid inputs\nassert_3: assert all(type(x) == int for x in arr), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec isList ((l Value)) Bool\\n  (or (is-Nil l)\\n      (and (is-Cons l)\\n           (let ((tailVal (tail l)))\\n             (isList tailVal)))))\\n\\n(define-fun-rec list_all_int ((l Value)) Bool\\n  (ite (is-Nil l)\\n       true\\n       (and (is-Cons l)\\n            (let ((headVal (head l)) (tailVal (tail l)))\\n              (and (is-IntVal headVal)\\n                   (list_all_int tailVal))))))\\n\\n(define-fun-rec list_contains ((l Value) (v Value)) Bool\\n  (ite (is-Nil l)\\n       false\\n       (and (is-Cons l)\\n            (let ((headVal (head l)) (tailVal (tail l)))\\n              (or (= headVal v)\\n                  (list_contains tailVal v))))))\\n\\n(define-fun-rec list_unique ((l Value)) Bool\\n  (ite (is-Nil l)\\n       true\\n       (and (is-Cons l)\\n            (let ((headVal (head l)) (tailVal (tail l)))\\n              (and (not (list_contains tailVal headVal))\\n                   (list_unique tailVal))))))\",\n  \"inputs\": \"(declare-const arr Value)\",\n  \"basic_structure\": \"(assert (isList arr))\",\n  \"contract_defs\": \"(define-fun C0 () Bool\\n  (isList arr))\\n(define-fun C1 () Bool\\n  (list_all_int arr))\\n(define-fun C2 () Bool\\n  (list_unique arr))\\n(define-fun C3 () Bool\\n  (list_all_int arr))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(arr) == list, \"invalid inputs", "assert_1": "assert all(type(x) == int for x in arr), \"invalid inputs", "assert_2": "assert len(set(arr)) == len(arr), \"invalid inputs", "assert_3": "assert all(type(x) == int for x in arr), \"invalid inputs"}]}], "reasoning": ["I model the Python list and its numeric and uniqueness constraints with precise SMT-LIB recursive definitions, ensuring the array’s well-formedness is in the basic structure. Each Python assert is translated into a named Boolean predicate C0–C3, with helper functions for list shape, integer checks, membership, and uniqueness.</think>"]}
{"name": "HumanEval/110", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: exchange\nProblem Description:\n\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n\n\n    assert type(lst1) == list and type(lst2) == list, \"invalid inputs\" # $_CONTRACT_$\n    assert all(type(x) == int for x in lst1), \"invalid inputs\" # $_CONTRACT_$\n    assert all(type(x) == int for x in lst2), \"invalid inputs\" # $_CONTRACT_$\n    assert len(lst1) > 0 and len(lst2) > 0, \"invalid inputs\" # $_CONTRACT_$\n\n\n    cnt_odd = len(list(filter(lambda x: x % 2 == 1, lst1)))\n    cnt_even = len(list(filter(lambda x: x % 2 == 0, lst2)))\n    return \"YES\" if cnt_odd <= cnt_even else \"NO\"\n\n\n\nContract List:\nassert_0: assert type(lst1) == list and type(lst2) == list, \"invalid inputs\nassert_1: assert all(type(x) == int for x in lst1), \"invalid inputs\nassert_2: assert all(type(x) == int for x in lst2), \"invalid inputs\nassert_3: assert len(lst1) > 0 and len(lst2) > 0, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec IsList ((l Value)) Bool\\n  (ite (is-Nil l)\\n       true\\n       (ite (is-Cons l)\\n            (IsList (tail l))\\n            false)))\\n\\n(define-fun-rec list_all_int ((l Value)) Bool\\n  (ite (is-Nil l)\\n       true\\n       (ite (is-Cons l)\\n            (and (is-IntVal (head l)) (list_all_int (tail l)))\\n            false)))\\n\\n(define-fun-rec length ((l Value)) Int\\n  (ite (is-Nil l)\\n       0\\n       (ite (is-Cons l)\\n            (+ 1 (length (tail l)))\\n            0)))\",\n  \"inputs\": \"(declare-const lst1 Value)\\n(declare-const lst2 Value)\",\n  \"basic_structure\": \"(assert (IsList lst1))\\n(assert (IsList lst2))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (and (IsList lst1) (IsList lst2)))\\n(define-fun C1 () Bool (list_all_int lst1))\\n(define-fun C2 () Bool (list_all_int lst2))\\n(define-fun C3 () Bool (and (> (length lst1) 0) (> (length lst2) 0)))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(lst1) == list and type(lst2) == list, \"invalid inputs", "assert_1": "assert all(type(x) == int for x in lst1), \"invalid inputs", "assert_2": "assert all(type(x) == int for x in lst2), \"invalid inputs", "assert_3": "assert len(lst1) > 0 and len(lst2) > 0, \"invalid inputs"}]}], "reasoning": ["I translate each Python assert into a named SMT predicate and ensure the minimal ADT and list-shape helpers so the contracts can be tested without unguarded selectors. I provide recursive definitions for IsList, list_all_int, and length to precisely model type, element, and non-emptiness constraints.</think>"]}
{"name": "HumanEval/111", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: histogram\nProblem Description:\n\ndef histogram(test):\n    \"\"\"Given a string representing a space separated lowercase letters, return a dictionary\n    of the letter with the most repetition and containing the corresponding count.\n    If several letters have the same occurrence, return all of them.\n    \n    Example:\n    histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n    histogram('a b b a') == {'a': 2, 'b': 2}\n    histogram('a b c a b') == {'a': 2, 'b': 2}\n    histogram('b b b b a') == {'b': 4}\n    histogram('') == {}\n\n    \"\"\"\n\n\n    assert isinstance(test, str), \"invalid inputs\" # $_CONTRACT_$\n    words = test.split(\" \") # $_CONTRACT_$\n    for word in words: # $_CONTRACT_$\n        if word != \"\": # $_CONTRACT_$\n            assert len(word) == 1 and word.islower(), \"invalid inputs\" # $_CONTRACT_$\n\n\n    if test == \"\": return {}    \n    count, ans = dict(), dict()\n    for word in test.split(\" \"):\n        if word != \"\":\n            if word not in count: count[word] = 0\n            count[word] += 1\n    mx = max(list(count.values()))\n    for ch, c in count.items():\n        if c == mx:\n            ans[ch] = c\n    return ans\n\n\n\nContract List:\nassert_0: assert isinstance(test, str), \"invalid inputs\nassert_1: assert len(word) == 1 and word.islower(), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun SafeS ((v Value)) String (ite (is-StrVal v) (sval v) \\\"\\\"))\",\n  \"inputs\": \"(declare-const test Value)\",\n  \"basic_structure\": \"(assert (is-StrVal test))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (is-StrVal test))\\n(define-fun C1 () Bool (let ((s (SafeS test))) (str.in.re s (str.to.re \\\"^(|[a-z]( [a-z])*)$\\\"))))\"\n}\n```\n", "constraints": [{"assert_0": "assert isinstance(test, str), \"invalid inputs", "assert_1": "assert len(word) == 1 and word.islower(), \"invalid inputs"}]}], "reasoning": ["I will translate the Python preconditions into SMT-LIB predicates by enforcing that the input is a string and that it matches the pattern of single lowercase letters separated by spaces, while providing a safe selector helper for extracting the string payload.</think>"]}
{"name": "HumanEval/112", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: reverse_delete\nProblem Description:\n\ndef reverse_delete(s,c):\n    \"\"\"Task\n    We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n    then check if the result string is palindrome.\n    A string is called palindrome if it reads the same backward as forward.\n    You should return a tuple containing the result string and True/False for the check.\n    Example\n    For s = \"abcde\", c = \"ae\", the result should be ('bcd',False)\n    For s = \"abcdef\", c = \"b\"  the result should be ('acdef',False)\n    For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',True)\n    \"\"\"\n\n\n    assert isinstance(s, str) and isinstance(c, str), \"invalid inputs\" # $_CONTRACT_$\n\n    ss = \"\".join(filter(lambda ch: ch not in c, s))\n    return ss, ss == ss[::-1]\n\n\n\nContract List:\nassert_0: assert isinstance(s, str) and isinstance(c, str), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"\",\n  \"inputs\": \"(declare-const s Value)\\n(declare-const c Value)\",\n  \"basic_structure\": \"(assert (is-StrVal s))\\n(assert (is-StrVal c))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (and (is-StrVal s) (is-StrVal c)))\"\n}\n```\n", "constraints": [{"assert_0": "assert isinstance(s, str) and isinstance(c, str), \"invalid inputs"}]}], "reasoning": ["I will translate the Python type‐checks into a single SMT predicate C0 over the StrVal constructor, declare s and c as Value, enforce as basic structure that they are StrVal for executability, and define the contract exactly matching the Python assertion.</think>"]}
{"name": "HumanEval/113", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: odd_count\nProblem Description:\n\ndef odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n\n\n    assert type(lst) == list, \"invalid inputs\" # $_CONTRACT_$\n    assert all(isinstance(s, str) for s in lst), \"invalid inputs\" # $_CONTRACT_$\n    assert all(s.isdigit() for s in lst), \"invalid inputs\" # $_CONTRACT_$\n\n\n    ans, template = [], \"the number of odd elements in the string i of the input.\"\n    for s in lst:\n        odd_cnt = len(list(filter(lambda ch: int(ch) % 2 == 1, s)))\n        ans.append(template.replace(\"i\", str(odd_cnt)))\n    return ans\n\n\n\nContract List:\nassert_0: assert type(lst) == list, \"invalid inputs\nassert_1: assert all(isinstance(s, str) for s in lst), \"invalid inputs\nassert_2: assert all(s.isdigit() for s in lst), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec IsList ((v Value)) Bool\\n  (or\\n    (is-Nil v)\\n    (and (is-Cons v)\\n         (IsList (tail v))\\n    )\\n  )\\n)\\n\\n(define-fun-rec list_all_str ((v Value)) Bool\\n  (ite (is-Nil v)\\n       true\\n       (ite (is-Cons v)\\n            (and (is-StrVal (head v))\\n                 (list_all_str (tail v)))\\n            false\\n       )\\n  )\\n)\\n\\n(define-fun str_all_digits ((s Value)) Bool\\n  (and\\n    (is-StrVal s)\\n    (str.in.re (sval s) (str.to.re \\\"[0-9]+\\\"))\\n  )\\n)\\n\\n(define-fun-rec list_all_digit_strings ((v Value)) Bool\\n  (ite (is-Nil v)\\n       true\\n       (ite (is-Cons v)\\n            (and (str_all_digits (head v))\\n                 (list_all_digit_strings (tail v)))\\n            false\\n       )\\n  )\\n)\",\n  \"inputs\": \"(declare-const lst Value)\",\n  \"basic_structure\": \"\",\n  \"contract_defs\": \"(define-fun C0 () Bool (IsList lst))\\n(define-fun C1 () Bool (list_all_str lst))\\n(define-fun C2 () Bool (list_all_digit_strings lst))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(lst) == list, \"invalid inputs", "assert_1": "assert all(isinstance(s, str) for s in lst), \"invalid inputs", "assert_2": "assert all(s.isdigit() for s in lst), \"invalid inputs"}]}], "reasoning": ["I map each Python assert to an SMT predicate over our Value ADT, introduce recursive helpers for list-shape and per-element checks (string‐only and digit‐only), and leave all structural requirements in named Ck predicates so they can be flexibly combined.</think>"]}
{"name": "HumanEval/114", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: minSubArraySum\nProblem Description:\n\ndef minSubArraySum(nums):\n    \"\"\"\n    Given an array of integers nums, find the minimum sum of any non-empty sub-array\n    of nums.\n    Example\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"\n\n\n    assert type(nums) == list, \"invalid inputs\" # $_CONTRACT_$\n    assert len(nums) > 0, \"invalid inputs\" # $_CONTRACT_$\n\n\n    if all(x >= 0 for x in nums): return min(nums)\n    s, ans = 0, 0\n    for x in nums:\n        s += x\n        ans = min(ans, s)\n        if s >= 0: s = 0\n    return ans\n\n\n\nContract List:\nassert_0: assert type(nums) == list, \"invalid inputs\nassert_1: assert len(nums) > 0, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec IsList ((v Value)) Bool\\n  (or (is-Nil v)\\n      (and (is-Cons v)\\n           (IsList (tail v)))))\\n\\n(define-fun-rec list_all_int ((v Value)) Bool\\n  (ite (is-Nil v)\\n       true\\n       (and (is-Cons v)\\n            (is-IntVal (head v))\\n            (list_all_int (tail v)))))\\n\\n(define-fun-rec length ((v Value)) Int\\n  (ite (is-Nil v)\\n       0\\n       (ite (is-Cons v)\\n            (+ 1 (length (tail v)))\\n            0)))\",\n  \"inputs\": \"(declare-const nums Value)\",\n  \"basic_structure\": \"(assert (IsList nums))\\n(assert (list_all_int nums))\",\n  \"contract_defs\": \"(define-fun C0 () Bool\\n  (IsList nums))\\n(define-fun C1 () Bool\\n  (> (length nums) 0))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(nums) == list, \"invalid inputs", "assert_1": "assert len(nums) > 0, \"invalid inputs"}]}], "reasoning": ["I translate the Python assertions into precise SMT-LIB predicates, define recursive list and length helpers for safe execution, and build standalone contract predicates for each assertion.</think>"]}
{"name": "HumanEval/115", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: max_fill\nProblem Description:\nimport math\n\ndef max_fill(grid, capacity):\n    \"\"\"\n    You are given a rectangular grid of wells. Each row represents a single well,\n    and each 1 in a row represents a single unit of water.\n    Each well has a corresponding bucket that can be used to extract water from it, \n    and all buckets have the same capacity.\n    Your task is to use the buckets to empty the wells.\n    Output the number of times you need to lower the buckets.\n\n    Example 1:\n        Input: \n            grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output: 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n        * all wells have the same length\n        * 1 <= grid.length <= 10^2\n        * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n        * 1 <= capacity <= 10\n    \"\"\"\n\n\n    assert 1 <= len(grid) <= 100, \"invalid inputs\" # $_CONTRACT_$\n    lens = list(map(len, grid)) # $_CONTRACT_$\n    assert max(lens) == min(lens) and 1 <= max(lens) <= 100, \"invalid inputs\" # $_CONTRACT_$\n    for l in grid: # $_CONTRACT_$\n        for x in l: # $_CONTRACT_$\n            assert x == 0 or x == 1, \"invalid inputs\" # $_CONTRACT_$\n    assert 1 <= capacity <= 10, \"invalid inputs\" # $_CONTRACT_$\n\n\n    ans = 0    \n    for l in grid:\n        ans += math.ceil(sum(l) / capacity)\n    return ans\n\n\n\nContract List:\nassert_0: assert 1 <= len(grid) <= 100, \"invalid inputs\nassert_1: assert max(lens) == min(lens) and 1 <= max(lens) <= 100, \"invalid inputs\nassert_2: assert x == 0 or x == 1, \"invalid inputs\nassert_3: assert 1 <= capacity <= 10, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec IsList ((v Value)) Bool\\n  (ite (is-Nil v) true\\n    (ite (is-Cons v) (IsList (tail v)) false)))\\n\\n(define-fun-rec AllLists ((v Value)) Bool\\n  (ite (is-Nil v) true\\n    (ite (is-Cons v)\\n      (and (IsList (head v)) (AllLists (tail v)))\\n      false)))\\n\\n(define-fun-rec length ((v Value)) Int\\n  (ite (is-Nil v) 0\\n    (ite (is-Cons v)\\n      (+ 1 (length (tail v)))\\n      0)))\\n\\n(define-fun-rec maxRowLen ((v Value)) Int\\n  (ite (is-Nil v) 0\\n    (ite (is-Cons v)\\n      (let ((headLen (length (head v)))\\n            (tailMax (maxRowLen (tail v))))\\n        (ite (> headLen tailMax) headLen tailMax))\\n      0)))\\n\\n(define-fun-rec minRowLen ((v Value)) Int\\n  (ite (is-Nil v) 0\\n    (ite (is-Cons v)\\n      (ite (is-Nil (tail v))\\n        (length (head v))\\n        (let ((headLen (length (head v)))\\n              (tailMin (minRowLen (tail v))))\\n          (ite (< headLen tailMin) headLen tailMin)))\\n      0)))\\n\\n(define-fun-rec IsBinaryList ((v Value)) Bool\\n  (ite (is-Nil v) true\\n    (ite (is-Cons v)\\n      (let ((h (head v)))\\n        (and (is-IntVal h)\\n             (let ((i (ival h))) (or (= i 0) (= i 1)))\\n             (IsBinaryList (tail v))))\\n      false)))\\n\\n(define-fun-rec AllBinaryMatrix ((v Value)) Bool\\n  (ite (is-Nil v) true\\n    (ite (is-Cons v)\\n      (and (IsBinaryList (head v)) (AllBinaryMatrix (tail v)))\\n      false)))\",\n  \"inputs\": \"(declare-const grid Value)\\n(declare-const capacity Value)\",\n  \"basic_structure\": \"(assert (IsList grid))\\n(assert (AllLists grid))\\n(assert (is-IntVal capacity))\",\n  \"contract_defs\": \"(define-fun C0 () Bool\\n  (and (<= 1 (length grid)) (<= (length grid) 100)))\\n(define-fun C1 () Bool\\n  (and (= (maxRowLen grid) (minRowLen grid))\\n       (<= 1 (maxRowLen grid)) (<= (maxRowLen grid) 100)))\\n(define-fun C2 () Bool\\n  (AllBinaryMatrix grid))\\n(define-fun C3 () Bool\\n  (let ((cap (ite (is-IntVal capacity) (ival capacity) 0)))\\n    (and (<= 1 cap) (<= cap 10))))\"\n}\n```\n", "constraints": [{"assert_0": "assert 1 <= len(grid) <= 100, \"invalid inputs", "assert_1": "assert max(lens) == min(lens) and 1 <= max(lens) <= 100, \"invalid inputs", "assert_2": "assert x == 0 or x == 1, \"invalid inputs", "assert_3": "assert 1 <= capacity <= 10, \"invalid inputs"}]}], "reasoning": ["I define recursive helpers for list structure, lengths, and binary checks to mirror Python’s nested-list and element assertions. The basic_structure ensures grid and capacity are well-formed for execution, while each Ck precisely captures a contract’s numeric or structural predicate.</think>"]}
{"name": "HumanEval/116", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: sort_array\nProblem Description:\n\ndef sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\"\n\n\n    assert isinstance(arr, list), \"invalid inputs\" # $_CONTRACT_$\n    assert all(isinstance(x, int) and x >= 0 for x in arr), \"invalid inputs\" # $_CONTRACT_$\n\n    from functools import cmp_to_key\n    def cmp(x: int, y: int) -> int:\n        x1 = len(list(filter(lambda ch: ch == \"1\", bin(x))))\n        y1 = len(list(filter(lambda ch: ch == \"1\", bin(y))))\n        if x1 != y1: return x1 - y1\n        return x - y\n    return sorted(arr, key=cmp_to_key(cmp))\n\n\n\nContract List:\nassert_0: assert isinstance(arr, list), \"invalid inputs\nassert_1: assert all(isinstance(x, int) and x >= 0 for x in arr), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec IsList ((v Value)) Bool\\n  (ite (is-Nil v) true\\n       (ite (is-Cons v)\\n            (IsList (tail v))\\n            false)))\\n\\n(define-fun-rec list_all_nonneg_int ((lst Value)) Bool\\n  (ite (is-Nil lst) true\\n       (ite (is-Cons lst)\\n            (let ((hd (head lst)) (tl (tail lst)))\\n               (and (is-IntVal hd)\\n                    (let ((i (ival hd))) (>= i 0))\\n                    (list_all_nonneg_int tl)))\\n            false)))\",\n  \"inputs\": \"(declare-const arr Value)\",\n  \"basic_structure\": \"(assert (IsList arr))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (IsList arr))\\n(define-fun C1 () Bool (list_all_nonneg_int arr))\"\n}\n```\n", "constraints": [{"assert_0": "assert isinstance(arr, list), \"invalid inputs", "assert_1": "assert all(isinstance(x, int) and x >= 0 for x in arr), \"invalid inputs"}]}], "reasoning": ["I will model Python lists and integer checks with two recursive SMT predicates (IsList and list_all_nonneg_int), declare the input as a Value, assert the list‐shape invariant for execution, and then define C0/C1 to mirror the two asserts exactly.</think>"]}
{"name": "HumanEval/117", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: select_words\nProblem Description:\n\ndef select_words(s, n):\n    \"\"\"Given a string s and a natural number n, you have been tasked to implement \n    a function that returns a list of all words from string s that contain exactly \n    n consonants, in order these words appear in the string s.\n    If the string s is empty then the function should return an empty list.\n    Note: you may assume the input string contains only letters and spaces.\n    Examples:\n    select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n    select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n    select_words(\"simple white space\", 2) ==> []\n    select_words(\"Hello world\", 4) ==> [\"world\"]\n    select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\n    \"\"\"\n\n\n    assert isinstance(s, str), \"invalid inputs\" # $_CONTRACT_$\n    assert all(ch == \" \" or ch.isalpha() for ch in s), \"invalid inputs\" # $_CONTRACT_$\n    assert type(n) == int, \"invalid inputs\" # $_CONTRACT_$\n    assert n >= 0, \"invalid inputs\" # $_CONTRACT_$\n\n\n    ans = []\n    for word in s.split(\" \"):\n        if word != \"\":\n            c_cnt = len(list(filter(lambda ch: ch not in \"aeiouAEIOU\", word)))\n            if c_cnt == n: ans.append(word)\n    return ans\n\n\n\nContract List:\nassert_0: assert isinstance(s, str), \"invalid inputs\nassert_1: assert all(ch == \" \" or ch.isalpha() for ch in s), \"invalid inputs\nassert_2: assert type(n) == int, \"invalid inputs\nassert_3: assert n >= 0, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun is_string_and_valid_chars ((v Value)) Bool (ite (is-StrVal v) (str.in.re (sval v) (str.to.re \\\"[A-Za-z ]*\\\")) false))\\n(define-fun is_nonneg_int ((v Value)) Bool (ite (is-IntVal v) (>= (ival v) 0) false))\",\n  \"inputs\": \"(declare-const s Value)\\n(declare-const n Value)\",\n  \"basic_structure\": \"(assert (is-StrVal s))\\n(assert (is-IntVal n))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (is-StrVal s))\\n(define-fun C1 () Bool (ite (is-StrVal s) (str.in.re (sval s) (str.to.re \\\"[A-Za-z ]*\\\")) false))\\n(define-fun C2 () Bool (is-IntVal n))\\n(define-fun C3 () Bool (ite (is-IntVal n) (>= (ival n) 0) false))\"\n}\n```\n", "constraints": [{"assert_0": "assert isinstance(s, str), \"invalid inputs", "assert_1": "assert all(ch == \" \" or ch.isalpha() for ch in s), \"invalid inputs", "assert_2": "assert type(n) == int, \"invalid inputs", "assert_3": "assert n >= 0, \"invalid inputs"}]}], "reasoning": ["I will translate Python’s assertions into SMT-LIB predicates, defining helper functions for safe string and integer checks, asserting basic type guards, and mapping each contract to a named predicate C0–C3.</think>"]}
{"name": "HumanEval/118", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: get_closest_vowel\nProblem Description:\n\ndef get_closest_vowel(word):\n    \"\"\"You are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\n\n\n    assert isinstance(word, str), \"invalid inputs\" # $_CONTRACT_$\n    assert word == \"\" or word.isalpha(), \"invalid inputs\" # $_CONTRACT_$\n\n\n    def is_vowel(ch: str) -> bool:\n        return ch in \"aeiouAEIOU\"\n    for i in range(len(word) - 2, 0, -1):\n        if is_vowel(word[i]) and not is_vowel(word[i-1]) and not is_vowel(word[i+1]):\n            return word[i]\n    return \"\"\n\n\n\nContract List:\nassert_0: assert isinstance(word, str), \"invalid inputs\nassert_1: assert word == \"\" or word.isalpha(), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun is_letters ((s String)) Bool\\n  (str.in.re s (str.to.re \\\"[A-Za-z]*\\\")))\",\n  \"inputs\": \"(declare-const word Value)\",\n  \"basic_structure\": \"(assert (is-StrVal word))\",\n  \"contract_defs\": \"(define-fun C0 () Bool\\n  (is-StrVal word))\\n(define-fun C1 () Bool\\n  (and (is-StrVal word)\\n       (or (= (sval word) \\\"\\\")\\n           (is_letters (sval word)))))\"\n}\n```\n", "constraints": [{"assert_0": "assert isinstance(word, str), \"invalid inputs", "assert_1": "assert word == \"\" or word.isalpha(), \"invalid inputs"}]}], "reasoning": ["I translate each Python assertion into an SMT predicate, define a small helper for checking all-letter strings via regex, and assert the minimal string‐type invariant for safe execution. Contracts C0 and C1 reflect the two input checks, and combinations allow systematic violation testing.</think>"]}
{"name": "HumanEval/119", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: match_parens\nProblem Description:\n\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n\n    assert type(lst) == list, \"invalid inputs\" # $_CONTRACT_$\n    assert all(isinstance(s, str) for s in lst), \"invalid inputs\" # $_CONTRACT_$\n    assert len(lst) == 2, \"invalid inputs\" # $_CONTRACT_$\n    assert all(ch == \"(\" or ch == \")\" for ch in lst[0]), \"invalid inputs\" # $_CONTRACT_$\n    assert all(ch == \"(\" or ch == \")\" for ch in lst[1]), \"invalid inputs\" # $_CONTRACT_$\n\n\n    def valid_parens(s: str) -> bool:\n        cnt = 0\n        for ch in s:\n            cnt = cnt + 1 if ch == \"(\" else cnt - 1\n            if cnt < 0: return False\n        return cnt == 0\n    return \"Yes\" if valid_parens(lst[0] + lst[1]) or valid_parens(lst[1] + lst[0]) else \"No\"\n\n\n\nContract List:\nassert_0: assert type(lst) == list, \"invalid inputs\nassert_1: assert all(isinstance(s, str) for s in lst), \"invalid inputs\nassert_2: assert len(lst) == 2, \"invalid inputs\nassert_3: assert all(ch == \"(\" or ch == \")\" for ch in lst[0]), \"invalid inputs\nassert_4: assert all(ch == \"(\" or ch == \")\" for ch in lst[1]), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec isList ((v Value)) Bool\\n  (or (is-Nil v)\\n      (and (is-Cons v) (isList (tail v)))))\\n\\n(define-fun-rec list_all_str ((v Value)) Bool\\n  (or (is-Nil v)\\n      (and (is-Cons v)\\n           (is-StrVal (head v))\\n           (list_all_str (tail v)))))\\n\\n(define-fun-rec length ((v Value)) Int\\n  (ite (is-Nil v) 0\\n       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))\\n\\n(define-fun SafeS ((v Value)) String\\n  (ite (is-StrVal v) (sval v) \\\"\\\"))\",\n  \"inputs\": \"(declare-const lst Value)\",\n  \"basic_structure\": \"(assert (isList lst))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (isList lst))\\n(define-fun C1 () Bool (list_all_str lst))\\n(define-fun C2 () Bool (= (length lst) 2))\\n(define-fun C3 () Bool\\n  (let ((str0 (SafeS (head lst))))\\n    (str.in.re str0 (str.to.re \\\"[()]*\\\"))))\\n(define-fun C4 () Bool\\n  (let ((str1 (SafeS (head (tail lst)))))\\n    (str.in.re str1 (str.to.re \\\"[()]*\\\"))))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(lst) == list, \"invalid inputs", "assert_1": "assert all(isinstance(s, str) for s in lst), \"invalid inputs", "assert_2": "assert len(lst) == 2, \"invalid inputs", "assert_3": "assert all(ch == \"(\" or ch == \")\" for ch in lst[0]), \"invalid inputs", "assert_4": "assert all(ch == \"(\" or ch == \")\" for ch in lst[1]), \"invalid inputs"}]}], "reasoning": ["I translate each Python assert into a Boolean predicate over an SMT ADT, supply minimal helper functions for list and string safety, and isolate structure checks in BASIC_STRUCTURE while putting each contract into its own named Ck definition.</think>"]}
{"name": "HumanEval/120", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: maximum\nProblem Description:\n\ndef maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n\n\n    assert type(arr) == list, \"invalid inputs\" # $_CONTRACT_$\n    assert 1 <= len(arr) <= 1000, \"invalid inputs\" # $_CONTRACT_$\n    assert all(-1000 <= x <= 1000 for x in arr), \"invalid inputs\" # $_CONTRACT_$\n    assert type(k) == int, \"invalid inputs\" # $_CONTRACT_$\n    assert 0 <= k <= len(arr), \"invalid inputs\" # $_CONTRACT_$\n\n\n    return sorted(sorted(arr)[::-1][:k])\n\n\n\nContract List:\nassert_0: assert type(arr) == list, \"invalid inputs\nassert_1: assert 1 <= len(arr) <= 1000, \"invalid inputs\nassert_2: assert all(-1000 <= x <= 1000 for x in arr), \"invalid inputs\nassert_3: assert type(k) == int, \"invalid inputs\nassert_4: assert 0 <= k <= len(arr), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec IsList ((v Value)) Bool\\n  (ite (is-Nil v) true\\n    (ite (is-Cons v)\\n      (IsList (tail v))\\n      false)))\\n\\n(define-fun SafeI ((v Value)) Int\\n  (ite (is-IntVal v) (ival v) 0))\\n\\n(define-fun-rec length ((xs Value)) Int\\n  (ite (is-Nil xs) 0\\n    (ite (is-Cons xs)\\n      (+ 1 (length (tail xs)))\\n      0)))\\n\\n(define-fun-rec all_in_range ((xs Value)) Bool\\n  (ite (is-Nil xs) true\\n    (ite (and (is-Cons xs)\\n              (is-IntVal (head xs))\\n              (let ((i (ival (head xs))))\\n                (and (<= (- 1000) i) (<= i 1000))))\\n      (all_in_range (tail xs))\\n      false)))\",\n  \"inputs\": \"(declare-const arr Value)\\n(declare-const k Value)\",\n  \"basic_structure\": \"(assert (IsList arr))\\n(assert (is-IntVal k))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (IsList arr))\\n(define-fun C1 () Bool (and (<= 1 (length arr)) (<= (length arr) 1000)))\\n(define-fun C2 () Bool (all_in_range arr))\\n(define-fun C3 () Bool (is-IntVal k))\\n(define-fun C4 () Bool (and (<= 0 (SafeI k)) (<= (SafeI k) (length arr))))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(arr) == list, \"invalid inputs", "assert_1": "assert 1 <= len(arr) <= 1000, \"invalid inputs", "assert_2": "assert all(-1000 <= x <= 1000 for x in arr), \"invalid inputs", "assert_3": "assert type(k) == int, \"invalid inputs", "assert_4": "assert 0 <= k <= len(arr), \"invalid inputs"}]}], "reasoning": ["I translate each Python assertion into an SMT-LIB predicate Ck and provide list‐shaping and numeric‐extraction helpers to ensure the function can be executed symbolically.  Recursive checks (IsList, length, all_in_range) are defined with structural measures, and basic invariants ensure safe use of selectors.</think>"]}
{"name": "HumanEval/121", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: solution\nProblem Description:\n\ndef solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n\n\n    assert type(lst) == list, \"invalid inputs\" # $_CONTRACT_$\n    assert all(type(x) == int for x in lst), \"invalid inputs\" # $_CONTRACT_$\n    assert len(lst) > 0, \"invalid inputs\" # $_CONTRACT_$\n\n\n    return sum(lst[i] for i in range(len(lst)) if i % 2 == 0 and lst[i] % 2 == 1)\n\n\n\nContract List:\nassert_0: assert type(lst) == list, \"invalid inputs\nassert_1: assert all(type(x) == int for x in lst), \"invalid inputs\nassert_2: assert len(lst) > 0, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec IsList ((v Value)) Bool\\n  (ite (is-Nil v)\\n       true\\n       (ite (is-Cons v)\\n            (IsList (tail v))\\n            false)))\\n\\n(define-fun-rec list_all_int ((v Value)) Bool\\n  (ite (is-Nil v)\\n       true\\n       (ite (is-Cons v)\\n            (and (is-IntVal (head v))\\n                 (list_all_int (tail v)))\\n            false)))\\n\\n(define-fun-rec length ((v Value)) Int\\n  (ite (is-Nil v)\\n       0\\n       (ite (is-Cons v)\\n            (+ 1 (length (tail v)))\\n            0)))\",\n  \"inputs\": \"(declare-const lst Value)\",\n  \"basic_structure\": \"(assert (IsList lst))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (IsList lst))\\n(define-fun C1 () Bool (list_all_int lst))\\n(define-fun C2 () Bool (> (length lst) 0))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(lst) == list, \"invalid inputs", "assert_1": "assert all(type(x) == int for x in lst), \"invalid inputs", "assert_2": "assert len(lst) > 0, \"invalid inputs"}]}], "reasoning": ["I translated each Python assertion into an SMT predicate Ck, defined precise recursive helpers for list structure, element typing, and length, and moved only the ADT shape invariant to BASIC_STRUCTURE so that all contracts remain standalone.</think>"]}
{"name": "HumanEval/122", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: add_elements\nProblem Description:\n\ndef add_elements(arr, k):\n    \"\"\"\n    Given a non-empty array of integers arr and an integer k, return\n    the sum of the elements with at most two digits from the first k elements of arr.\n\n    Example:\n\n        Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n        Output: 24 # sum of 21 + 3\n\n    Constraints:\n        1. 1 <= len(arr) <= 100\n        2. 1 <= k <= len(arr)\n    \"\"\"\n\n\n    assert type(arr) == list, \"invalid inputs\" # $_CONTRACT_$\n    assert all(type(x) == int for x in arr), \"invalid inputs\" # $_CONTRACT_$\n    assert 1 <= len(arr) <= 100, \"invalid inputs\" # $_CONTRACT_$\n    assert type(k) == int, \"invalid inputs\" # $_CONTRACT_$\n    assert 1 <= k <= len(arr), \"invalid inputs\" # $_CONTRACT_$\n\n\n    def digits(x: int) -> int:\n        s = str(x)\n        return len(s) - 1 if s[0] == \"-\" else len(s)\n    return sum(filter(lambda x: digits(x) <= 2, arr[:k]))\n\n\n\nContract List:\nassert_0: assert type(arr) == list, \"invalid inputs\nassert_1: assert all(type(x) == int for x in arr), \"invalid inputs\nassert_2: assert 1 <= len(arr) <= 100, \"invalid inputs\nassert_3: assert type(k) == int, \"invalid inputs\nassert_4: assert 1 <= k <= len(arr), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec IsList ((v Value)) Bool\\n  (ite (is-Nil v) true\\n    (ite (is-Cons v)\\n         (IsList (tail v))\\n         false)))\\n(define-fun-rec ListAllInt ((v Value)) Bool\\n  (ite (is-Nil v) true\\n    (ite (is-Cons v)\\n         (and (is-IntVal (head v)) (ListAllInt (tail v)))\\n         false)))\\n(define-fun-rec Length ((v Value)) Int\\n  (ite (is-Nil v) 0\\n    (ite (is-Cons v)\\n         (+ 1 (Length (tail v)))\\n         0)))\\n(define-fun SafeI ((v Value)) Int\\n  (ite (is-IntVal v) (ival v) 0))\",\n  \"inputs\": \"(declare-const arr Value)\\n(declare-const k Value)\",\n  \"basic_structure\": \"(assert (IsList arr))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (IsList arr))\\n(define-fun C1 () Bool (ListAllInt arr))\\n(define-fun C2 () Bool (and (<= 1 (Length arr)) (<= (Length arr) 100)))\\n(define-fun C3 () Bool (is-IntVal k))\\n(define-fun C4 () Bool (and (<= 1 (SafeI k)) (<= (SafeI k) (Length arr))))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(arr) == list, \"invalid inputs", "assert_1": "assert all(type(x) == int for x in arr), \"invalid inputs", "assert_2": "assert 1 <= len(arr) <= 100, \"invalid inputs", "assert_3": "assert type(k) == int, \"invalid inputs", "assert_4": "assert 1 <= k <= len(arr), \"invalid inputs"}]}], "reasoning": ["I define total, recursive list‐shape and integer‐selector helpers so the solver never “crashes” on bad inputs, keeping only the structural list shape in the base assertions. Each Python assert is then turned into a standalone Ck predicate using those helpers, with safe selectors for unguarded numeric projections.</think>"]}
{"name": "HumanEval/123", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: get_odd_collatz\nProblem Description:\n\ndef get_odd_collatz(n):\n    \"\"\"\n    Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n    as follows: start with any positive integer n. Then each term is obtained from the \n    previous term as follows: if the previous term is even, the next term is one half of \n    the previous term. If the previous term is odd, the next term is 3 times the previous\n    term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n        2. returned list sorted in increasing order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\n\n\n    assert type(n) == int, \"invalid inputs\" # $_CONTRACT_$\n    assert n > 0, \"invalid inputs\" # $_CONTRACT_$\n\n\n    ans, x = [], n\n    while x != 1:\n        if x % 2 == 1: ans.append(x)\n        x = x // 2 if x % 2 == 0 else x * 3 + 1\n    ans.append(1)\n    return sorted(ans)\n\n\n\nContract List:\nassert_0: assert type(n) == int, \"invalid inputs\nassert_1: assert n > 0, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun get-int ((v Value)) Int (ite (is-IntVal v) (ival v) 0))\",\n  \"inputs\": \"(declare-const n Value)\",\n  \"basic_structure\": \"(assert (is-IntVal n))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (is-IntVal n))\\n(define-fun C1 () Bool (> (get-int n) 0))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(n) == int, \"invalid inputs", "assert_1": "assert n > 0, \"invalid inputs"}]}], "reasoning": ["I translate each Python assertion into a precise SMT predicate using a safe integer extractor, enforce the minimal ADT shape for `n` in the basic structure, and declare helpers and inputs cleanly.</think>"]}
{"name": "HumanEval/124", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: valid_date\nProblem Description:\n\ndef valid_date(date):\n    \"\"\"You have to write a function which validates a given date string and\n    returns True if the date is valid otherwise False.\n    The date is valid if all of the following rules are satisfied:\n    1. The date string is not empty.\n    2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n    3. The months should not be less than 1 or higher than 12.\n    4. The date should be in the format: mm-dd-yyyy\n\n    for example: \n    valid_date('03-11-2000') => True\n\n    valid_date('15-01-2012') => False\n\n    valid_date('04-0-2040') => False\n\n    valid_date('06-04-2020') => True\n\n    valid_date('06/04/2020') => False\n    \"\"\"\n\n\n    assert isinstance(date, str), \"invalid inputs\" # $_CONTRACT_$\n\n    days = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    if len(date) != 10: return False\n    if date[2] != \"-\" or date[5] != \"-\": return False\n    m, d, y = date[:2], date[3:5], date[6:]\n    if not m.isdigit() or not d.isdigit() or not y.isdigit(): return False\n    m, d = int(m), int(d)\n    if not 1 <= m <= 12: return False\n    if not 1 <= d <= days[m-1]: return False\n    return True\n\n\n\nContract List:\nassert_0: assert isinstance(date, str), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun SafeS ((v Value)) String\\n  (ite (is-StrVal v) (sval v) \\\"\\\"))\\n\\n(define-fun s_len ((v Value)) Int\\n  (str.len (SafeS v)))\\n\\n(define-fun s_char ((v Value) (i Int)) String\\n  (str.substr (SafeS v) i 1))\\n\\n(define-fun str_to_int2 ((v Value)) Int\\n  (let ((s (SafeS v))\\n        (c0 (str.substr (SafeS v) 0 1))\\n        (c1 (str.substr (SafeS v) 1 1)))\\n    (+ (* (- (str.to_code c0) 48) 10)\\n       (- (str.to_code c1) 48))))\",\n  \"inputs\": \"(declare-const date Value)\",\n  \"basic_structure\": \"\",\n  \"contract_defs\": \"(define-fun C0 () Bool (is-StrVal date))\"\n}\n```\n", "constraints": [{"assert_0": "assert isinstance(date, str), \"invalid inputs"}]}], "reasoning": ["I translate the string‐processing logic into SMT‐LIB by defining safe string helpers (SafeS, s_len, s_char, str_to_int2) so all selectors are guarded. I then model the single contract as C0 checking `is-StrVal(date)` and enumerate its violation in COMBINATION.</think>"]}
{"name": "HumanEval/125", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: split_words\nProblem Description:\n\ndef split_words(txt):\n    '''\n    Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n    should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n    alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n    Examples\n    split_words(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n    split_words(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n    split_words(\"abcdef\") == 3 \n    '''\n\n\n    assert type(txt) == str, \"invalid inputs\" # $_CONTRACT_$\n    assert not txt.startswith(\" \") and not txt.startswith(\",\") and not txt.endswith(\" \") and not txt.endswith(\",\"), \"invalid inputs\" # $_CONTRACT_$\n\n    whitespace = tuple(' \\n\\r\\t')\n    if any([x in txt for x in whitespace]): return txt.split()\n    if \",\" in txt: return txt.split(\",\")\n    cnt = 0\n    for ch in txt:\n        if ch.islower() and (ord(ch) - ord(\"a\")) % 2 == 1: cnt += 1\n    return cnt\n\n\n\nContract List:\nassert_0: assert type(txt) == str, \"invalid inputs\nassert_1: assert not txt.startswith(\" \") and not txt.startswith(\",\") and not txt.endswith(\" \") and not txt.endswith(\",\"), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"\",\n  \"inputs\": \"(declare-const txt Value)\",\n  \"basic_structure\": \"(assert (is-StrVal txt))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (is-StrVal txt))\\n(define-fun C1 () Bool (and (is-StrVal txt) (not (str.prefixof \\\" \\\" (sval txt))) (not (str.prefixof \\\",\\\" (sval txt))) (not (str.suffixof \\\" \\\" (sval txt))) (not (str.suffixof \\\",\\\" (sval txt)))))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(txt) == str, \"invalid inputs", "assert_1": "assert not txt.startswith(\" \") and not txt.startswith(\",\") and not txt.endswith(\" \") and not txt.endswith(\",\"), \"invalid inputs"}]}], "reasoning": ["I capture the Python asserts as C0 for the type check and C1 for the whitespace/comma boundary rules, guard all string ops with is-StrVal for safety, and include that guard in basic_structure to ensure executable inputs.</think>"]}
{"name": "HumanEval/126", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: is_sorted\nProblem Description:\n\ndef is_sorted(lst):\n    '''\n    Given a list of numbers, return whether or not they are sorted\n    in ascending order. If list has more than 1 duplicate of the same\n    number, return False. Assume no negative numbers and only integers.\n\n    Examples\n    is_sorted([5]) ➞ True\n    is_sorted([1, 2, 3, 4, 5]) ➞ True\n    is_sorted([1, 3, 2, 4, 5]) ➞ False\n    is_sorted([1, 2, 3, 4, 5, 6]) ➞ True\n    is_sorted([1, 2, 3, 4, 5, 6, 7]) ➞ True\n    is_sorted([1, 3, 2, 4, 5, 6, 7]) ➞ False\n    is_sorted([1, 2, 2, 3, 3, 4]) ➞ True\n    is_sorted([1, 2, 2, 2, 3, 4]) ➞ False\n    '''\n\n\n    assert type(lst) == list, \"invalid inputs\" # $_CONTRACT_$\n    assert all(type(x) == int and x >= 0 for x in lst), \"invalid inputs\" # $_CONTRACT_$\n\n\n    count = dict()\n    for x in lst:\n        if x not in count: count[x] = 0\n        count[x] += 1\n        if count[x] > 2: return False\n    return lst == sorted(lst)\n\n\n\nContract List:\nassert_0: assert type(lst) == list, \"invalid inputs\nassert_1: assert all(type(x) == int and x >= 0 for x in lst), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec IsList ((l Value)) Bool\\n  (ite (is-Nil l)\\n       true\\n       (ite (is-Cons l)\\n            (IsList (tail l))\\n            false)))\\n\\n(define-fun-rec all_nonneg_int ((l Value)) Bool\\n  (ite (is-Nil l)\\n       true\\n       (ite (is-Cons l)\\n            (let ((elem (head l)))\\n              (let ((i (ival elem))\\n                    (rest (tail l)))\\n                (and (is-IntVal elem) (>= i 0) (all_nonneg_int rest))))\\n            false)))\",\n  \"inputs\": \"(declare-const lst Value)\",\n  \"basic_structure\": \"(assert (IsList lst))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (IsList lst))\\n(define-fun C1 () Bool (all_nonneg_int lst))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(lst) == list, \"invalid inputs", "assert_1": "assert all(type(x) == int and x >= 0 for x in lst), \"invalid inputs"}]}], "reasoning": ["I define recursive SMT predicates for list structure and non-negative integer checks, declare the input, assert basic list shape for executability, and translate each Python assert into a Boolean contract C0 and C1.</think>"]}
{"name": "HumanEval/127", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: intersection\nProblem Description:\n\ndef intersection(interval1, interval2):\n    \"\"\"You are given two intervals,\n    where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n    The given intervals are closed which means that the interval (start, end)\n    includes both start and end.\n    For each given interval, it is assumed that its start is less or equal its end.\n    Your task is to determine whether the length of intersection of these two \n    intervals is a prime number.\n    Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n    which its length is 1, which not a prime number.\n    If the length of the intersection is a prime number, return \"YES\",\n    otherwise, return \"NO\".\n    If the two intervals don't intersect, return \"NO\".\n\n\n    [input/output] samples:\n    intersection((1, 2), (2, 3)) ==> \"NO\"\n    intersection((-1, 1), (0, 4)) ==> \"NO\"\n    intersection((-3, -1), (-5, 5)) ==> \"YES\"\n    \"\"\"\n\n\n    assert len(interval1) == 2 and interval1[0] <= interval1[1], \"invalid inputs\" # $_CONTRACT_$\n    assert all(type(x) == int for x in interval1), \"invalid inputs\" # $_CONTRACT_$\n    assert len(interval2) == 2 and interval2[0] <= interval2[1], \"invalid inputs\" # $_CONTRACT_$\n    assert all(type(x) == int for x in interval2), \"invalid inputs\" # $_CONTRACT_$\n\n\n    def is_prime(a):\n        return not (a < 2 or any(a % x == 0 for x in range(2, int(a ** 0.5) + 1)))\n    if interval1[0] > interval2[0]: interval1, interval2 = interval2, interval1\n    l, r = interval2[0], min(interval1[1], interval2[1])\n    return \"YES\" if is_prime(r - l) else \"NO\"\n\n\n\nContract List:\nassert_0: assert len(interval1) == 2 and interval1[0] <= interval1[1], \"invalid inputs\nassert_1: assert all(type(x) == int for x in interval1), \"invalid inputs\nassert_2: assert len(interval2) == 2 and interval2[0] <= interval2[1], \"invalid inputs\nassert_3: assert all(type(x) == int for x in interval2), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec IsList ((l Value)) Bool\\n  (ite (is-Nil l)\\n       true\\n       (ite (is-Cons l)\\n            (IsList (tail l))\\n            false)))\\n\\n(define-fun-rec length ((l Value)) Int\\n  (ite (is-Nil l)\\n       0\\n       (ite (is-Cons l)\\n            (+ 1 (length (tail l)))\\n            0)))\\n\\n(define-fun SafeIntVal ((v Value)) Int\\n  (ite (is-IntVal v) (ival v) 0))\\n\\n(define-fun SafeHead ((l Value)) Int\\n  (ite (is-Cons l)\\n       (SafeIntVal (head l))\\n       0))\\n\\n(define-fun SafeSecond ((l Value)) Int\\n  (let ((t (ite (is-Cons l) (tail l) Nil)))\\n    (ite (is-Cons t)\\n         (SafeIntVal (head t))\\n         0)))\\n\\n(define-fun-rec list_all_int ((l Value)) Bool\\n  (ite (is-Nil l)\\n       true\\n       (ite (is-Cons l)\\n            (and (is-IntVal (head l)) (list_all_int (tail l)))\\n            false)))\",\n  \"inputs\": \"(declare-const interval1 Value)\\n(declare-const interval2 Value)\",\n  \"basic_structure\": \"(assert (IsList interval1))\\n(assert (IsList interval2))\",\n  \"contract_defs\": \"(define-fun C0 () Bool\\n  (and (= (length interval1) 2)\\n       (<= (SafeHead interval1) (SafeSecond interval1))))\\n(define-fun C1 () Bool\\n  (list_all_int interval1))\\n(define-fun C2 () Bool\\n  (and (= (length interval2) 2)\\n       (<= (SafeHead interval2) (SafeSecond interval2))))\\n(define-fun C3 () Bool\\n  (list_all_int interval2))\"\n}\n```\n", "constraints": [{"assert_0": "assert len(interval1) == 2 and interval1[0] <= interval1[1], \"invalid inputs", "assert_1": "assert all(type(x) == int for x in interval1), \"invalid inputs", "assert_2": "assert len(interval2) == 2 and interval2[0] <= interval2[1], \"invalid inputs", "assert_3": "assert all(type(x) == int for x in interval2), \"invalid inputs"}]}], "reasoning": ["I translate Python list-shape and type assertions into SMT predicates over a canonical Value ADT with safe selectors and recursive helpers, then define each contract Ck precisely, and enumerate all single, pairwise, triple, and full-violation scenarios in COMBINATION.</think>"]}
{"name": "HumanEval/128", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: prod_signs\nProblem Description:\n\ndef prod_signs(arr):\n    \"\"\"\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\n\n\n    assert type(arr) == list, \"invalid inputs\" # $_CONTRACT_$\n    assert all(type(x) == int for x in arr), \"invalid inputs\" # $_CONTRACT_$\n\n    if arr == []: return None\n    if 0 in arr: return 0\n    s, sgn = 0, 1\n    for x in arr:\n        s += abs(x)\n        sgn *= (x // abs(x))\n    return s * sgn\n\n\n\nContract List:\nassert_0: assert type(arr) == list, \"invalid inputs\nassert_1: assert all(type(x) == int for x in arr), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec IsList ((v Value)) Bool\\n  (ite (is-Nil v)\\n       true\\n       (ite (is-Cons v)\\n            (IsList (tail v))\\n            false)))\\n(define-fun-rec list_all_int ((v Value)) Bool\\n  (ite (is-Nil v)\\n       true\\n       (ite (is-Cons v)\\n            (and (is-IntVal (head v))\\n                 (list_all_int (tail v)))\\n            false)))\",\n  \"inputs\": \"(declare-const arr Value)\",\n  \"basic_structure\": \"(assert (IsList arr))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (IsList arr))\\n(define-fun C1 () Bool (list_all_int arr))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(arr) == list, \"invalid inputs", "assert_1": "assert all(type(x) == int for x in arr), \"invalid inputs"}]}], "reasoning": ["I model Python lists and integer-element checks as recursive SMT-LIB predicates over the Value ADT to ensure arr is a proper list and all elements are IntVal. C0 asserts arr is a well-formed list via IsList, and C1 asserts all elements are integers via list_all_int.</think>"]}
{"name": "HumanEval/129", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: minPath\nProblem Description:\n\ndef minPath(grid, k):\n    \"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n    each cell of the grid contains a value. Every integer in the range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\n    You have to find the minimum path of length k in the grid. You can start\n    from any cell, and in each step you can move to any of the neighbor cells,\n    in other words, you can go to cells which share an edge with you current\n    cell.\n    Please note that a path of length k means visiting exactly k cells (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path A (of length k) is considered less than a path B (of length k) if\n    after making the ordered lists of the values on the cells that A and B go\n    through (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] = lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered list of the values on the cells that the minimum path go through.\n\n    Examples:\n\n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1, 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        Output: [1]\n    \"\"\"\n\n\n    assert type(k) == int, \"invalid inputs\" # $_CONTRACT_$\n    assert k > 0, \"invalid inputs\" # $_CONTRACT_$\n    assert len(grid) >= 2, \"invalid inputs\" # $_CONTRACT_$\n    assert all(len(l) == len(grid) for l in grid), \"invalid inputs\" # $_CONTRACT_$\n    assert {x for l in grid for x in l} == set(range(1, len(grid) ** 2 + 1)), \"invalid inputs\" # $_CONTRACT_$\n\n\n    N = len(grid)\n    x, y = 0, 0\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 1:\n                x, y = i, j\n    mn = N * N\n    if x > 0: mn = min(mn, grid[x - 1][y])\n    if x < N - 1: mn = min(mn, grid[x + 1][y])\n    if y > 0: mn = min(mn, grid[x][y - 1])\n    if y < N - 1: mn = min(mn, grid[x][y + 1])\n    return [1 if i % 2 == 0 else mn for i in range(k)]\n\n\n\nContract List:\nassert_0: assert type(k) == int, \"invalid inputs\nassert_1: assert k > 0, \"invalid inputs\nassert_2: assert len(grid) >= 2, \"invalid inputs\nassert_3: assert all(len(l) == len(grid) for l in grid), \"invalid inputs\nassert_4: assert {x for l in grid for x in l} == set(range(1, len(grid) ** 2 + 1)), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec IsList ((v Value)) Bool\\n  (or (is-Nil v)\\n      (and (is-Cons v)\\n           (IsList (tail v)))))\\n\\n(define-fun-rec length ((v Value)) Int\\n  (ite (is-Nil v) 0\\n       (ite (is-Cons v) (+ 1 (length (tail v))) 0)))\\n\\n(define-fun-rec list_nth ((l Value) (idx Int)) Value\\n  (ite (not (is-Cons l))\\n       Nil\\n       (ite (= idx 0)\\n            (head l)\\n            (list_nth (tail l) (- idx 1)))))\\n\\n(define-fun-rec AllRowsSameLen ((rows Value) (n Int)) Bool\\n  (ite (is-Nil rows)\\n       true\\n       (and (is-Cons rows)\\n            (let ((row (head rows)))\\n              (and (IsList row)\\n                   (= (length row) n)\\n                   (AllRowsSameLen (tail rows) n))))))\\n\\n(define-fun-rec RowOK ((row Value) (j Int) (i Int) (n Int)) Bool\\n  (ite (= j n)\\n       (is-Nil row)\\n       (and (is-Cons row)\\n            (is-IntVal (head row))\\n            (= (ival (head row)) (+ 1 j (* i n)))\\n            (RowOK (tail row) (+ j 1) i n))))\\n\\n(define-fun-rec GridOK ((rows Value) (i Int) (n Int)) Bool\\n  (ite (= i n)\\n       (is-Nil rows)\\n       (and (is-Cons rows)\\n            (RowOK (head rows) 0 i n)\\n            (GridOK (tail rows) (+ i 1) n))))\",\n  \"inputs\": \"(declare-const grid Value)\\n(declare-const k Value)\",\n  \"basic_structure\": \"(assert (IsList grid))\\n(assert (is-IntVal k))\\n(assert (<= (length grid) 3))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (is-IntVal k))\\n(define-fun C1 () Bool (and (is-IntVal k) (> (ival k) 0)))\\n(define-fun C2 () Bool (and (IsList grid) (>= (length grid) 2)))\\n(define-fun C3 () Bool (and (IsList grid) (AllRowsSameLen grid (length grid))))\\n(define-fun C4 () Bool (let ((n (length grid))) (GridOK grid 0 n)))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(k) == int, \"invalid inputs", "assert_1": "assert k > 0, \"invalid inputs", "assert_2": "assert len(grid) >= 2, \"invalid inputs", "assert_3": "assert all(len(l) == len(grid) for l in grid), \"invalid inputs", "assert_4": "assert {x for l in grid for x in l} == set(range(1, len(grid) ** 2 + 1)), \"invalid inputs"}]}], "reasoning": ["I translate each Python assert into an SMT predicate Ck, define minimal ADT helpers to traverse and measure lists, declare inputs over the Value ADT, assert only the base “is‐list” and “is‐int” conditions for executability, and then express each contract exactly and standalone via define-fun (with recursion where needed).</think>"]}
{"name": "HumanEval/130", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: tri\nProblem Description:\n\ndef tri(n):\n    \"\"\"Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    tri(3) = [1, 3, 2, 8]\n    \"\"\"\n\n\n    assert type(n) == int, \"invalid inputs\" # $_CONTRACT_$\n    assert n >= 0, \"invalid inputs\" # $_CONTRACT_$\n\n\n    if n == 0: return [1]\n    if n == 1: return [1, 3]\n    ans = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            ans.append(1 + i / 2)\n        else:\n            ans.append(ans[-1] + ans[-2] + 1 + (i + 1) / 2)\n    return ans\n\n\n\nContract List:\nassert_0: assert type(n) == int, \"invalid inputs\nassert_1: assert n >= 0, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"\",\n  \"inputs\": \"(declare-const n Value)\",\n  \"basic_structure\": \"(assert (is-IntVal n))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (is-IntVal n))\\n(define-fun C1 () Bool (ite (is-IntVal n) (>= (ival n) 0) false))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(n) == int, \"invalid inputs", "assert_1": "assert n >= 0, \"invalid inputs"}]}], "reasoning": ["I translated each Python assertion into a named SMT predicate, guarded selector usage with an ite to ensure safety, and enforced basic executability by asserting the integer shape of `n`.</think>"]}
{"name": "HumanEval/131", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: digits\nProblem Description:\n\ndef digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\"\n\n\n    assert type(n) == int, \"invalid inputs\" # $_CONTRACT_$\n    assert n > 0, \"invalid inputs\" # $_CONTRACT_$\n\n\n    has_odd, prod = False, 1\n    for ch in str(n):\n        if int(ch) % 2 == 1:\n            has_odd = True\n            prod *= int(ch)\n    return 0 if not has_odd else prod\n\n\n\nContract List:\nassert_0: assert type(n) == int, \"invalid inputs\nassert_1: assert n > 0, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun get-Int ((v Value)) Int (ite (is-IntVal v) (ival v) 0))\",\n  \"inputs\": \"(declare-const n Value)\",\n  \"basic_structure\": \"(assert (is-IntVal n))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (is-IntVal n))\\n(define-fun C1 () Bool (> (get-Int n) 0))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(n) == int, \"invalid inputs", "assert_1": "assert n > 0, \"invalid inputs"}]}], "reasoning": ["I mapped each Python assert to an SMT predicate and provided a safe selector for the integer value to ensure sound use of ival. I declared the input, asserted the minimal structure for execution, and defined C0 and C1 exactly matching the assertions.</think>"]}
{"name": "HumanEval/132", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: is_nested\nProblem Description:\n\ndef is_nested(string):\n    '''\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return True if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]') ➞ True\n    is_nested('[]]]]]]][[[[[]') ➞ False\n    is_nested('[][]') ➞ False\n    is_nested('[]') ➞ False\n    is_nested('[[][]]') ➞ True\n    is_nested('[[]][[') ➞ True\n    '''\n\n\n    assert isinstance(string, str), \"invalid inputs\" # $_CONTRACT_$\n    assert all(ch == \"[\" or ch == \"]\" for ch in string), \"invalid inputs\" # $_CONTRACT_$\n\n\n    for i in range(len(string)):\n        if string[i] == \"]\": continue\n        cnt, max_nest = 0, 0\n        for j in range(i, len(string)):\n            if string[j] == \"[\":\n                cnt += 1\n            else:\n                cnt -= 1\n            max_nest = max(max_nest, cnt)\n            if cnt == 0:\n                if max_nest >= 2:\n                    return True\n                break\n    return False\n\n\n\nContract List:\nassert_0: assert isinstance(string, str), \"invalid inputs\nassert_1: assert all(ch == \"[\" or ch == \"]\" for ch in string), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec all_brackets ((sVal Value) (pos Int)) Bool\\n  (ite (not (is-StrVal sVal))\\n       false\\n       (let ((str (sval sVal))\\n             (len (str.len (sval sVal))))\\n         (ite (>= pos len)\\n              true\\n              (let ((ch (str.substr str pos 1)))\\n                (ite (or (= ch \\\"[\\\") (= ch \\\"]\\\"))\\n                     (all_brackets sVal (+ pos 1))\\n                     false))))))\",\n  \"inputs\": \"(declare-const string Value)\",\n  \"basic_structure\": \"\",\n  \"contract_defs\": \"(define-fun C0 () Bool (is-StrVal string))\\n(define-fun C1 () Bool (all_brackets string 0))\"\n}\n```\n", "constraints": [{"assert_0": "assert isinstance(string, str), \"invalid inputs", "assert_1": "assert all(ch == \"[\" or ch == \"]\" for ch in string), \"invalid inputs"}]}], "reasoning": ["I will model the string‐type check and bracket‐only constraint as two SMT predicates, using a recursive helper to iterate over the string safely. All uses of the string selector are guarded by the tester in the helper, and no global assertions duplicate the contracts.</think>"]}
{"name": "HumanEval/133", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: sum_squares\nProblem Description:\n\n\ndef sum_squares(lst):\n    \"\"\"You are given a list of numbers.\n    You need to return the sum of squared numbers in the given list,\n    round each element in the list to the upper int(Ceiling) first.\n    Examples:\n    For lst = [1,2,3] the output should be 14\n    For lst = [1,4,9] the output should be 98\n    For lst = [1,3,5,7] the output should be 84\n    For lst = [1.4,4.2,0] the output should be 29\n    For lst = [-2.4,1,1] the output should be 6\n    \n\n    \"\"\"\n\n\n    assert type(lst) == list, \"invalid inputs\" # $_CONTRACT_$\n    assert all(type(x) in [int, float] for x in lst), \"invalid inputs\" # $_CONTRACT_$\n\n    import math\n    return sum(map(lambda x: math.ceil(x) ** 2, lst))\n\n\n\nContract List:\nassert_0: assert type(lst) == list, \"invalid inputs\nassert_1: assert all(type(x) in [int, float] for x in lst), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun isList ((v Value)) Bool (or (is-Nil v) (is-Cons v)))\\n(define-fun-rec list_all_numeric ((l Value)) Bool\\n  (ite (is-Nil l) true\\n    (ite (is-Cons l)\\n      (and (or (is-IntVal (head l)) (is-FloatVal (head l)))\\n           (list_all_numeric (tail l)))\\n      false)))\",\n  \"inputs\": \"(declare-const lst Value)\",\n  \"basic_structure\": \"\",\n  \"contract_defs\": \"(define-fun C0 () Bool (isList lst))\\n(define-fun C1 () Bool (list_all_numeric lst))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(lst) == list, \"invalid inputs", "assert_1": "assert all(type(x) in [int, float] for x in lst), \"invalid inputs"}]}], "reasoning": ["I will translate each Python assertion into an SMT-LIB predicate using a custom ADT and helper functions, ensuring list shape and element-type checks are encoded precisely without embedding execution logic.</think>"]}
{"name": "HumanEval/134", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: check_if_last_char_is_a_letter\nProblem Description:\n\ndef check_if_last_char_is_a_letter(txt):\n    '''\n    Create a function that returns True if the last character\n    of a given string is an alphabetical character and is not\n    a part of a word, and False otherwise.\n    Note: \"word\" is a group of characters separated by space.\n\n    Examples:\n    check_if_last_char_is_a_letter(\"apple pie\") ➞ False\n    check_if_last_char_is_a_letter(\"apple pi e\") ➞ True\n    check_if_last_char_is_a_letter(\"apple pi e \") ➞ False\n    check_if_last_char_is_a_letter(\"\") ➞ False \n    '''\n\n\n    assert type(txt) == str, \"invalid inputs\" # $_CONTRACT_$\n\n    if len(txt) == 0: return False\n    if len(txt) == 1: return txt.isalpha()\n    return txt[-1].isalpha() and txt[-2] == \" \"\n\n\n\nContract List:\nassert_0: assert type(txt) == str, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun SafeStr ((v Value)) String\\n  (ite (is-StrVal v) (sval v) \\\"\\\"))\\n(define-fun is-alpha-char ((c String)) Bool\\n  (str.in.re c (str.to.re \\\"[A-Za-z]\\\")))\",\n  \"inputs\": \"(declare-const txt Value)\",\n  \"basic_structure\": \"\",\n  \"contract_defs\": \"(define-fun C0 () Bool\\n  (is-StrVal txt))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(txt) == str, \"invalid inputs"}]}], "reasoning": ["I will represent the string‐type check as a Boolean predicate over the Value ADT and provide safe unpacking and character‐class helpers to enable future string operations without execution errors.</think>"]}
{"name": "HumanEval/135", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: can_arrange\nProblem Description:\n\ndef can_arrange(arr):\n    \"\"\"Create a function which returns the largest index of an element which\n    is not greater than or equal to the element immediately preceding it. If\n    no such element exists then return -1. The given array will not contain\n    duplicate values.\n\n    Examples:\n    can_arrange([1,2,4,3,5]) = 3\n    can_arrange([1,2,3]) = -1\n    \"\"\"\n\n\n    assert type(arr) == list, \"invalid inputs\" # $_CONTRACT_$\n    assert all(type(x) in [int, float] for x in arr), \"invalid inputs\" # $_CONTRACT_$\n    assert len(arr) == len(set(arr)), \"invalid inputs\" # $_CONTRACT_$\n\n\n    for i in range(len(arr) - 1, 0, -1):\n        if not (arr[i] >= arr[i - 1]):\n            return i\n    return -1\n\n\n\nContract List:\nassert_0: assert type(arr) == list, \"invalid inputs\nassert_1: assert all(type(x) in [int, float] for x in arr), \"invalid inputs\nassert_2: assert len(arr) == len(set(arr)), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec IsList ((v Value)) Bool\\n  (ite (is-Nil v)\\n       true\\n       (ite (is-Cons v)\\n            (IsList (tail v))\\n            false)))\\n\\n(define-fun-rec list_all_numeric ((v Value)) Bool\\n  (ite (is-Nil v)\\n       true\\n       (ite (is-Cons v)\\n            (and (or (is-IntVal (head v)) (is-FloatVal (head v)))\\n                 (list_all_numeric (tail v)))\\n            false)))\\n\\n(define-fun value_eq ((v1 Value) (v2 Value)) Bool\\n  (or (and (is-IntVal v1) (is-IntVal v2)\\n           (= (ival v1) (ival v2)))\\n      (and (is-FloatVal v1) (is-FloatVal v2)\\n           (= (fval v1) (fval v2)))\\n      (and (is-IntVal v1) (is-FloatVal v2)\\n           (= (to_real (ival v1)) (fval v2)))\\n      (and (is-FloatVal v1) (is-IntVal v2)\\n           (= (fval v1) (to_real (ival v2))))))\\n\\n(define-fun-rec list_contains ((e Value) (v Value)) Bool\\n  (ite (is-Nil v)\\n       false\\n       (ite (value_eq e (head v))\\n            true\\n            (list_contains e (tail v)))))\\n\\n(define-fun-rec list_unique ((v Value)) Bool\\n  (ite (is-Nil v)\\n       true\\n       (ite (is-Cons v)\\n            (and (not (list_contains (head v) (tail v)))\\n                 (list_unique (tail v)))\\n            false)))\",\n  \"inputs\": \"(declare-const arr Value)\",\n  \"basic_structure\": \"(assert (IsList arr))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (IsList arr))\\n(define-fun C1 () Bool (list_all_numeric arr))\\n(define-fun C2 () Bool (list_unique arr))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(arr) == list, \"invalid inputs", "assert_1": "assert all(type(x) in [int, float] for x in arr), \"invalid inputs", "assert_2": "assert len(arr) == len(set(arr)), \"invalid inputs"}]}], "reasoning": ["I translated each Python assertion into a precise SMT-LIB predicate (C0, C1, C2) and built recursive helper functions for list structure, numeric checks, and uniqueness. The basic structure enforces that `arr` is a proper list, and inputs declare `arr` as a `Value`.</think>"]}
{"name": "HumanEval/136", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: largest_smallest_integers\nProblem Description:\n\ndef largest_smallest_integers(lst):\n    '''\n    Create a function that returns a tuple (a, b), where 'a' is\n    the largest of negative integers, and 'b' is the smallest\n    of positive integers in a list.\n    If there is no negative or positive integers, return them as None.\n\n    Examples:\n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    '''\n\n\n    assert type(lst) == list, \"invalid inputs\" # $_CONTRACT_$\n    assert all(type(x) == int for x in lst), \"invalid inputs\" # $_CONTRACT_$\n\n    neg = list(filter(lambda x: x < 0, lst))\n    pos = list(filter(lambda x: x > 0, lst))\n    return None if neg == [] else max(neg), None if pos == [] else min(pos)\n\n\n\nContract List:\nassert_0: assert type(lst) == list, \"invalid inputs\nassert_1: assert all(type(x) == int for x in lst), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun is-list ((v Value)) Bool\\n  (or (is-Nil v)\\n      (is-Cons v)))\\n\\n(define-fun-rec list_all_int ((l Value)) Bool\\n  (ite (is-Nil l)\\n       true\\n       (ite (is-Cons l)\\n            (let ((h (head l))\\n                  (t (tail l)))\\n              (and (is-IntVal h)\\n                   (list_all_int t)))\\n            false)))\",\n  \"inputs\": \"(declare-const lst Value)\",\n  \"basic_structure\": \"(assert (is-list lst))\",\n  \"contract_defs\": \"(define-fun C0 () Bool\\n  (is-list lst))\\n(define-fun C1 () Bool\\n  (list_all_int lst))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(lst) == list, \"invalid inputs", "assert_1": "assert all(type(x) == int for x in lst), \"invalid inputs"}]}], "reasoning": ["I model the Python list and integer checks with a canonical SMT-LIB ADT and define recursive helpers for list structure and integer membership. Each Python assertion becomes a named predicate Ck, and I assert basic executability by requiring the input to be a well-formed list.</think>"]}
{"name": "HumanEval/137", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: compare_one\nProblem Description:\n\ndef compare_one(a, b):\n    \"\"\"\n    Create a function that takes integers, floats, or strings representing\n    real numbers, and returns the larger variable in its given variable type.\n    Return None if the values are equal.\n    Note: If a real number is represented as a string, the floating point might be . or ,\n\n    compare_one(1, 2.5) ➞ 2.5\n    compare_one(1, \"2,3\") ➞ \"2,3\"\n    compare_one(\"5,1\", \"6\") ➞ \"6\"\n    compare_one(\"1\", 1) ➞ None\n    \"\"\"\n\n\n    assert isinstance(a, (int, float, str)), \"invalid inputs\" # $_CONTRACT_$\n    assert isinstance(b, (int, float, str)), \"invalid inputs\" # $_CONTRACT_$\n    try: # $_CONTRACT_$\n        float(str(a).replace(\",\", \".\")) # $_CONTRACT_$\n        float(str(b).replace(\",\", \".\")) # $_CONTRACT_$\n    except ValueError: raise Exception(\"invalid inputs\") # $_CONTRACT_$\n\n\n    num_a = float(str(a).replace(\",\", \".\"))\n    num_b = float(str(b).replace(\",\", \".\"))\n    if num_a == num_b:\n        return None\n    return a if num_a > num_b else b\n\n\n\nContract List:\nassert_0: assert isinstance(a, (int, float, str)), \"invalid inputs\nassert_1: assert isinstance(b, (int, float, str)), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"\",\n  \"inputs\": \"(declare-const a Value)\\n(declare-const b Value)\",\n  \"basic_structure\": \"\",\n  \"contract_defs\": \"(define-fun C0 () Bool (or (is-IntVal a) (is-FloatVal a) (is-StrVal a)))\\n(define-fun C1 () Bool (or (is-IntVal b) (is-FloatVal b) (is-StrVal b)))\"\n}\n```\n", "constraints": [{"assert_0": "assert isinstance(a, (int, float, str)), \"invalid inputs", "assert_1": "assert isinstance(b, (int, float, str)), \"invalid inputs"}]}], "reasoning": ["I translate each Python type‐check assertion into an SMT predicate that uses the ADT’s built‐in testers, ensuring `a` and `b` are IntVal, FloatVal, or StrVal. I declare inputs, leave the base ADT as given, and define C0/C1 exactly matching the `isinstance` contracts.</think>"]}
{"name": "HumanEval/138", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: is_equal_to_sum_even\nProblem Description:\n\ndef is_equal_to_sum_even(n):\n    \"\"\"Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n    Example\n    is_equal_to_sum_even(4) == False\n    is_equal_to_sum_even(6) == False\n    is_equal_to_sum_even(8) == True\n    \"\"\"\n\n\n    assert type(n) == int, \"invalid inputs\" # $_CONTRACT_$\n\n    return n >= 8 and n % 2 == 0\n\n\n\nContract List:\nassert_0: assert type(n) == int, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun SafeIval ((v Value)) Int\\n  (ite (is-IntVal v) (ival v) 0))\",\n  \"inputs\": \"(declare-const n Value)\",\n  \"basic_structure\": \"(assert (is-IntVal n))\",\n  \"contract_defs\": \"(define-fun C0 () Bool\\n  (is-IntVal n))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(n) == int, \"invalid inputs"}]}], "reasoning": ["I will translate the single Python type‐check assertion into an SMT predicate while ensuring the input’s ADT shape supports numeric operations. I declare the Value ADT, an Int extractor helper for safety, assert the structural invariant, and define C0 to mirror `assert type(n) == int`.</think>"]}
{"name": "HumanEval/139", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: special_factorial\nProblem Description:\n\ndef special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n\n\n    assert type(n) == int, \"invalid inputs\" # $_CONTRACT_$\n    assert n > 0, \"invalid inputs\" # $_CONTRACT_$\n\n\n    fac, ans = 1, 1\n    for i in range(2, n + 1):\n        fac *= i\n        ans *= fac\n    return ans\n\n\n\nContract List:\nassert_0: assert type(n) == int, \"invalid inputs\nassert_1: assert n > 0, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"\",\n  \"inputs\": \"(declare-const n Value)\",\n  \"basic_structure\": \"(assert (is-IntVal n))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (is-IntVal n))\\n(define-fun C1 () Bool (ite (is-IntVal n) (> (ival n) 0) false))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(n) == int, \"invalid inputs", "assert_1": "assert n > 0, \"invalid inputs"}]}], "reasoning": ["I translate each Python assert into an SMT predicate wrapped with the correct ADT tester and guarded selector for safety, include a core structure assertion that ensures `n` is an integer, and keep helper functions empty since no additional ADTs or recursion are needed.</think>"]}
{"name": "HumanEval/140", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: fix_spaces\nProblem Description:\n\ndef fix_spaces(text):\n    \"\"\"\n    Given a string text, replace all spaces in it with underscores, \n    and if a string has more than 2 consecutive spaces, \n    then replace all consecutive spaces with - \n    \n    fix_spaces(\"Example\") == \"Example\"\n    fix_spaces(\"Example 1\") == \"Example_1\"\n    fix_spaces(\" Example 2\") == \"_Example_2\"\n    fix_spaces(\" Example   3\") == \"_Example-3\"\n    \"\"\"\n\n\n    assert isinstance(text, str), \"invalid inputs\" # $_CONTRACT_$\n\n    ans = text\n    for i in range(len(text), 2, -1):\n        ans = ans.replace(\" \" * i, \"-\")\n    return ans.replace(\" \", \"_\")\n\n\n\nContract List:\nassert_0: assert isinstance(text, str), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"\",\n  \"inputs\": \"(declare-const text Value)\",\n  \"basic_structure\": \"\",\n  \"contract_defs\": \"(define-fun C0 () Bool (is-StrVal text))\"\n}\n```\n", "constraints": [{"assert_0": "assert isinstance(text, str), \"invalid inputs"}]}], "reasoning": ["I translate the single Python type check into an SMT tester predicate, only adding necessary ADT constraints for the string parameter.</think>"]}
{"name": "HumanEval/141", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: file_name_check\nProblem Description:\n\ndef file_name_check(file_name):\n    \"\"\"Create a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\") # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n    \"\"\"\n\n\n    assert isinstance(file_name, str), \"invalid inputs\" # $_CONTRACT_$\n\n    if len(list(filter(lambda ch: ch.isdigit(), file_name))) > 3:\n        return \"No\"\n    f_list = file_name.split(\".\")\n    if len(f_list) != 2: return \"No\"\n    if len(f_list[0]) == 0: return \"No\"\n    if not f_list[0][0].isalpha(): return \"No\"\n    if f_list[1] not in [\"txt\", \"exe\", \"dll\"]: return \"No\"\n    return \"Yes\"\n\n\n\nContract List:\nassert_0: assert isinstance(file_name, str), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"\",\n  \"inputs\": \"(declare-const file_name Value)\",\n  \"basic_structure\": \"(assert (is-StrVal file_name))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (is-StrVal file_name))\"\n}\n```\n", "constraints": [{"assert_0": "assert isinstance(file_name, str), \"invalid inputs"}]}], "reasoning": ["I translate the single Python type-check assertion into an SMT predicate C0 over our ADT, declare the input, enforce the structural requirement for execution, and provide a reusable template for extensions.</think>"]}
{"name": "HumanEval/142", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: sum_squares\nProblem Description:\n\n\n\ndef sum_squares(lst):\n    \"\"\"\"\n    This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n    multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n    change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n    \n    Examples:\n    For lst = [1,2,3] the output should be 6\n    For lst = []  the output should be 0\n    For lst = [-1,-5,2,-1,-5]  the output should be -126\n    \"\"\"\n\n\n    assert type(lst) == list, \"invalid inputs\" # $_CONTRACT_$\n    assert all(type(x) == int for x in lst), \"invalid inputs\" # $_CONTRACT_$\n\n    ans = 0\n    for i, num in enumerate(lst):\n        if i % 3 == 0:\n            ans += num ** 2\n        elif i % 4 == 0:\n            ans += num ** 3\n        else:\n            ans += num\n    return ans\n\n\n\nContract List:\nassert_0: assert type(lst) == list, \"invalid inputs\nassert_1: assert all(type(x) == int for x in lst), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec IsList ((v Value)) Bool\\n  (ite (is-Nil v)\\n       true\\n       (ite (is-Cons v)\\n            (IsList (tail v))\\n            false)))\\n\\n(define-fun-rec list_all_int ((v Value)) Bool\\n  (ite (is-Nil v)\\n       true\\n       (ite (is-Cons v)\\n            (and (is-IntVal (head v))\\n                 (list_all_int (tail v)))\\n            false)))\",\n  \"inputs\": \"(declare-const lst Value)\",\n  \"basic_structure\": \"(assert (IsList lst))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (IsList lst))\\n(define-fun C1 () Bool (list_all_int lst))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(lst) == list, \"invalid inputs", "assert_1": "assert all(type(x) == int for x in lst), \"invalid inputs"}]}], "reasoning": ["I translated the Python list and type assertions into recursive SMT-LIB predicates over a canonical Value ADT, ensuring safe selectors and termination. I then declared the input, asserted basic list well‐formedness, and defined each contract as a standalone Bool function.</think>"]}
{"name": "HumanEval/143", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: words_in_sentence\nProblem Description:\n\ndef words_in_sentence(sentence):\n    \"\"\"\n    You are given a string representing a sentence,\n    the sentence contains some words separated by a space,\n    and you have to return a string that contains the words from the original sentence,\n    whose lengths are prime numbers,\n    the order of the words in the new string should be the same as the original one.\n\n    Example 1:\n        Input: sentence = \"This is a test\"\n        Output: \"is\"\n\n    Example 2:\n        Input: sentence = \"lets go for swimming\"\n        Output: \"go for\"\n\n    Constraints:\n        * 1 <= len(sentence) <= 100\n        * sentence contains only letters\n    \"\"\"\n\n\n    assert isinstance(sentence, str), \"invalid inputs\" # $_CONTRACT_$\n    assert 1 <= len(sentence) <= 100, \"invalid inputs\" # $_CONTRACT_$\n    assert \"  \" not in sentence, \"invalid inputs\" # $_CONTRACT_$\n    assert all(word.isalpha() for word in sentence.split(\" \")), \"invalid inputs\" # $_CONTRACT_$\n\n\n    def is_prime(a):\n        return not (a < 2 or any(a % x == 0 for x in range(2, int(a ** 0.5) + 1)))\n    return \" \".join(list(filter(lambda word: is_prime(len(word)), sentence.split(\" \"))))\n\n\n\nContract List:\nassert_0: assert isinstance(sentence, str), \"invalid inputs\nassert_1: assert 1 <= len(sentence) <= 100, \"invalid inputs\nassert_2: assert \"  \" not in sentence, \"invalid inputs\nassert_3: assert all(word.isalpha() for word in sentence.split(\" \")), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun SafeStrLen ((s Value)) Int\\n  (ite (is-StrVal s) (str.len (sval s)) 0))\\n\\n(define-fun-rec is_prime ((n Int)) Bool\\n  (and (>= n 2)\\n       (not (exists ((x Int))\\n               (and (>= x 2)\\n                    (<= (* x x) n)\\n                    (= (mod n x) 0))))))\\n\\n(define-fun-rec all_alpha_words ((s Value)) Bool\\n  (ite (not (is-StrVal s))\\n       false\\n       (let ((str (sval s)))\\n         (ite (str.contains str \\\" \\\")\\n              (let ((idx (str.indexof str \\\" \\\" 0)))\\n                (let ((headVal (StrVal (str.substr str 0 idx)))\\n                      (tailVal (StrVal (str.substr str (+ idx 1)\\n                                           (- (str.len str) (+ idx 1))))))\\n                  (and (all_alpha_words headVal)\\n                       (all_alpha_words tailVal))))\\n              (str.in.re str\\n                         (re.* (re.union\\n                                  (re.range \\\"A\\\" \\\"Z\\\")\\n                                  (re.range \\\"a\\\" \\\"z\\\"))))))))\",\n  \"inputs\": \"(declare-const sentence Value)\",\n  \"basic_structure\": \"(assert (is-StrVal sentence))\",\n  \"contract_defs\": \"(define-fun C0 () Bool\\n  (is-StrVal sentence))\\n(define-fun C1 () Bool\\n  (let ((len (ite (is-StrVal sentence)\\n                  (str.len (sval sentence))\\n                  0)))\\n    (and (<= 1 len)\\n         (<= len 100))))\\n(define-fun C2 () Bool\\n  (and (is-StrVal sentence)\\n       (not (str.contains (sval sentence) \\\"  \\\"))))\\n(define-fun C3 () Bool\\n  (all_alpha_words sentence))\"\n}\n```\n", "constraints": [{"assert_0": "assert isinstance(sentence, str), \"invalid inputs", "assert_1": "assert 1 <= len(sentence) <= 100, \"invalid inputs", "assert_2": "assert \"  \" not in sentence, \"invalid inputs", "assert_3": "assert all(word.isalpha() for word in sentence.split(\" \")), \"invalid inputs"}]}], "reasoning": ["I translate each Python assertion into an independent SMT Boolean, guard uses of sval/str.len with is-StrVal, define helpers for string length, prime check, and recursive word‐splitting for isalpha checks, and assert minimal ADT constraints to ensure executability.</think>"]}
{"name": "HumanEval/144", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: simplify\nProblem Description:\n\ndef simplify(x, n):\n    \"\"\"Your task is to implement a function that will simplify the expression\n    x * n. The function returns True if x * n evaluates to a whole number and False\n    otherwise. Both x and n, are string representation of a fraction, and have the following format,\n    <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n    You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n    simplify(\"1/5\", \"5/1\") = True\n    simplify(\"1/6\", \"2/1\") = False\n    simplify(\"7/10\", \"10/2\") = False\n    \"\"\"\n\n\n    def contract(x): # $_CONTRACT_$\n        assert isinstance(x, str), \"invalid inputs\" # $_CONTRACT_$\n        xs = x.split(\"/\") # $_CONTRACT_$\n        assert len(xs) == 2, \"invalid inputs\" # $_CONTRACT_$\n        assert xs[0].isdigit() and int(xs[0]) > 0, \"invalid inputs\" # $_CONTRACT_$\n        assert xs[1].isdigit() and int(xs[1]) > 0, \"invalid inputs\" # $_CONTRACT_$\n    contract(x) # $_CONTRACT_$\n    contract(n) # $_CONTRACT_$\n\n\n    x1, x2 = map(int, x.split(\"/\"))\n    n1, n2 = map(int, n.split(\"/\"))\n    return (x1 * n1) % (x2 * n2) == 0\n\n\n\nContract List:\nassert_0: assert isinstance(x, str), \"invalid inputs\nassert_1: assert len(xs) == 2, \"invalid inputs\nassert_2: assert xs[0].isdigit() and int(xs[0]) > 0, \"invalid inputs\nassert_3: assert xs[1].isdigit() and int(xs[1]) > 0, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun DIGIT () (RegEx String) (re.range \\\"0\\\" \\\"9\\\"))\\n(define-fun POSINT () (RegEx String) (re.++ (re.range \\\"1\\\" \\\"9\\\") (re.* DIGIT)))\",\n  \"inputs\": \"(declare-const x Value)\",\n  \"basic_structure\": \"(assert (is-StrVal x))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (is-StrVal x))\\n(define-fun C1 () Bool\\n  (let ((svx (sval x)) (idx (str.indexof (sval x) \\\"/\\\" 0)))\\n    (and (>= idx 0) (= (str.indexof svx \\\"/\\\" (+ idx 1)) -1))))\\n(define-fun C2 () Bool\\n  (let ((svx (sval x)) (idx (str.indexof (sval x) \\\"/\\\" 0)))\\n    (let ((num (str.substr svx 0 idx)))\\n      (and (not (= num \\\"\\\")) (str.in.re num POSINT)))))\\n(define-fun C3 () Bool\\n  (let ((svx (sval x)) (idx (str.indexof (sval x) \\\"/\\\" 0)))\\n    (let ((den (str.substr svx (+ idx 1) (- (str.len svx) (+ idx 1)))))\\n      (and (not (= den \\\"\\\")) (str.in.re den POSINT)))))\"\n}\n```\n", "constraints": [{"assert_0": "assert isinstance(x, str), \"invalid inputs", "assert_1": "assert len(xs) == 2, \"invalid inputs", "assert_2": "assert xs[0].isdigit() and int(xs[0]) > 0, \"invalid inputs", "assert_3": "assert xs[1].isdigit() and int(xs[1]) > 0, \"invalid inputs"}]}], "reasoning": ["I translate each Python assert into a precise SMT predicate, guarding string operations with `is-StrVal` and `ite` to ensure safe substrings, and declare minimal executability constraints.</think>"]}
{"name": "HumanEval/145", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: order_by_points\nProblem Description:\n\ndef order_by_points(nums):\n    \"\"\"\n    Write a function which sorts the given list of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original list.\n\n    For example:\n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"\n\n\n    assert all(type(x) == int for x in nums), \"invalid inputs\" # $_CONTRACT_$\n\n    def weight(x):\n        x_list = list(str(x))\n        if x_list[0] == \"-\":\n            x_list = x_list[1:]\n            x_list = list(map(int, x_list))\n            x_list[0] = -x_list[0]\n        else:\n            x_list = list(map(int, x_list))\n        return sum(x_list)\n    return sorted(nums, key=weight)\n\n\n\nContract List:\nassert_0: assert all(type(x) == int for x in nums), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec IsList ((v Value)) Bool\\n  (ite (is-Nil v)\\n       true\\n       (ite (is-Cons v)\\n            (IsList (tail v))\\n            false)))\\n(define-fun-rec list_all_int ((v Value)) Bool\\n  (ite (is-Nil v)\\n       true\\n       (ite (is-Cons v)\\n            (and (is-IntVal (head v))\\n                 (list_all_int (tail v)))\\n            false)))\",\n  \"inputs\": \"(declare-const nums Value)\",\n  \"basic_structure\": \"(assert (IsList nums))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (list_all_int nums))\"\n}\n```\n", "constraints": [{"assert_0": "assert all(type(x) == int for x in nums), \"invalid inputs"}]}], "reasoning": ["I model the Python list and integer types with an ADT and recursive predicates to ensure well-formed lists and integer-only elements. I then translate the `all(type(x)==int)` assertion into a Boolean predicate `C0` using these helpers and assert list structure for executability.</think>"]}
{"name": "HumanEval/146", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: specialFilter\nProblem Description:\n\ndef specialFilter(nums):\n    \"\"\"Write a function that takes an array of numbers as input and returns \n    the number of elements in the array that are greater than 10 and both \n    first and last digits of a number are odd (1, 3, 5, 7, 9).\n    For example:\n    specialFilter([15, -73, 14, -15]) => 1 \n    specialFilter([33, -2, -3, 45, 21, 109]) => 2\n    \"\"\"\n\n\n    assert type(nums) == list, \"invalid inputs\" # $_CONTRACT_$\n    assert all(type(x) == int for x in nums), \"invalid inputs\" # $_CONTRACT_$\n\n    ans, odd = 0, [\"1\", \"3\", \"5\", \"7\", \"9\"]\n    for num in nums:\n        if num > 10 and str(num)[0] in odd and str(num)[-1] in odd:\n            ans += 1\n    return ans\n\n\n\nContract List:\nassert_0: assert type(nums) == list, \"invalid inputs\nassert_1: assert all(type(x) == int for x in nums), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec IsList ((l Value)) Bool\\n  (ite (is-Nil l)\\n       true\\n       (ite (is-Cons l)\\n            (let ((tailVal (tail l)))\\n              (IsList tailVal))\\n            false)))\\n\\n(define-fun-rec list_all_int ((l Value)) Bool\\n  (ite (is-Nil l)\\n       true\\n       (ite (is-Cons l)\\n            (let ((headVal (head l))\\n                  (tailVal (tail l)))\\n              (and (is-IntVal headVal)\\n                   (list_all_int tailVal)))\\n            false)))\",\n  \"inputs\": \"(declare-const nums Value)\",\n  \"basic_structure\": \"(assert (IsList nums))\",\n  \"contract_defs\": \"(define-fun C0 () Bool\\n  (IsList nums))\\n(define-fun C1 () Bool\\n  (list_all_int nums))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(nums) == list, \"invalid inputs", "assert_1": "assert all(type(x) == int for x in nums), \"invalid inputs"}]}], "reasoning": ["I translate the Python `assert` checks for list shape and integer elements into precise SMT-LIB Boolean predicates, supplying recursive helpers to ensure well‐formed lists and all‐integer contents, while keeping only minimal base invariants for executability.</think>"]}
{"name": "HumanEval/147", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: get_max_triples\nProblem Description:\n\ndef get_max_triples(n):\n    \"\"\"\n    You are given a positive integer n. You have to create an integer array a of length n.\n        For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n        Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n    and a[i] + a[j] + a[k] is a multiple of 3.\n\n    Example :\n        Input: n = 5\n        Output: 1\n        Explanation: \n        a = [1, 3, 7, 13, 21]\n        The only valid triple is (1, 7, 13).\n    \"\"\"\n\n\n    assert type(n) == int, \"invalid inputs\" # $_CONTRACT_$\n    assert n > 0, \"invalid inputs\" # $_CONTRACT_$\n\n\n    if n <= 2: return False\n    one_cnt = 1 + (n - 2) // 3 * 2 + (n - 2) % 3\n    zero_cnt = n - one_cnt\n    return one_cnt * (one_cnt - 1) * (one_cnt - 2) // 6 + zero_cnt * (zero_cnt - 1) * (zero_cnt - 2) // 6\n\n\n\nContract List:\nassert_0: assert type(n) == int, \"invalid inputs\nassert_1: assert n > 0, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))\",\n  \"inputs\": \"(declare-const n Value)\",\n  \"basic_structure\": \"(assert (is-IntVal n))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (is-IntVal n))\\n(define-fun C1 () Bool (> (SafeI n) 0))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(n) == int, \"invalid inputs", "assert_1": "assert n > 0, \"invalid inputs"}]}], "reasoning": ["I translate the Python input checks into SMT Lib by modeling `n` as a generic `Value`, introducing a `SafeI` extractor to guard the integer selector, and defining each assertion as its own Boolean predicate while enforcing the basic executability requirement that `n` must be an `IntVal`.</think>"]}
{"name": "HumanEval/148", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: bf\nProblem Description:\n\ndef bf(planet1, planet2):\n    '''\n    There are eight planets in our solar system: the closerst to the Sun \n    is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n    Uranus, Neptune.\n    Write a function that takes two planet names as strings planet1 and planet2. \n    The function should return a tuple containing all planets whose orbits are \n    located between the orbit of planet1 and the orbit of planet2, sorted by \n    the proximity to the sun. \n    The function should return an empty tuple if planet1 or planet2\n    are not correct planet names. \n    Examples\n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    '''\n\n\n    assert isinstance(planet1, str) and isinstance(planet2, str), \"invalid inputs\" # $_CONTRACT_$\n\n    planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    if planet1 not in planets or planet2 not in planets: return tuple()\n    i1, i2 = planets.index(planet1), planets.index(planet2)\n    if i1 > i2: i1, i2 = i2, i1\n    return tuple(planets[i1 + 1 : i2])\n\n\n\nContract List:\nassert_0: assert isinstance(planet1, str) and isinstance(planet2, str), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun SafeStr ((v Value)) String (ite (is-StrVal v) (sval v) \\\"\\\"))\",\n  \"inputs\": \"(declare-const planet1 Value)\\n(declare-const planet2 Value)\",\n  \"basic_structure\": \"\",\n  \"contract_defs\": \"(define-fun C0 () Bool (and (is-StrVal planet1) (is-StrVal planet2)))\"\n}\n```\n", "constraints": [{"assert_0": "assert isinstance(planet1, str) and isinstance(planet2, str), \"invalid inputs"}]}], "reasoning": ["I will model the single Python type‐check assertion as an SMT predicate C0 requiring both inputs to be StrVal, include a SafeStr helper to extract strings, and declare the Value‐typed inputs for executability.</think>"]}
{"name": "HumanEval/149", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: sorted_list_sum\nProblem Description:\n\ndef sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n\n\n    assert type(lst) == list, \"invalid inputs\" # $_CONTRACT_$\n    assert all(type(x) == str for x in lst), \"invalid inputs\" # $_CONTRACT_$\n\n    from functools import cmp_to_key\n    def cmp(s: str, t: str):\n        if len(s) != len(t):\n            return len(s) - len(t)\n        return -1 if s < t else 1\n    return sorted(list(filter(lambda s: len(s) % 2 == 0, lst)), key=cmp_to_key(cmp))\n\n\n\nContract List:\nassert_0: assert type(lst) == list, \"invalid inputs\nassert_1: assert all(type(x) == str for x in lst), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec IsList ((l Value)) Bool\\n  (or\\n    (is-Nil l)\\n    (and (is-Cons l)\\n         (IsList (tail l)))))\\n\\n(define-fun-rec list_all_str ((l Value)) Bool\\n  (ite (is-Nil l)\\n       true\\n       (ite (is-Cons l)\\n            (let ((hd (head l))\\n                  (tl (tail l)))\\n              (and (is-StrVal hd)\\n                   (list_all_str tl)))\\n            false)))\",\n  \"inputs\": \"(declare-const lst Value)\",\n  \"basic_structure\": \"(assert (IsList lst))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (IsList lst))\\n(define-fun C1 () Bool (list_all_str lst))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(lst) == list, \"invalid inputs", "assert_1": "assert all(type(x) == str for x in lst), \"invalid inputs"}]}], "reasoning": ["I model the Python asserts as two SMT predicates ensuring the input is a list ADT and that all elements are string values. I provide recursive helpers for list shape and element-type checking, declare the input, assert basic executability invariants, and define named contract predicates C0 and C1.</think>"]}
{"name": "HumanEval/150", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: x_or_y\nProblem Description:\n\ndef x_or_y(n, x, y):\n    \"\"\"A simple program which should return the value of x if n is \n    a prime number and should return the value of y otherwise.\n\n    Examples:\n    for x_or_y(7, 34, 12) == 34\n    for x_or_y(15, 8, 5) == 5\n    \n    \"\"\"\n\n\n    assert type(n) == int, \"invalid inputs\" # $_CONTRACT_$\n\n    def is_prime(a):\n        return not (a < 2 or any(a % x == 0 for x in range(2, int(a ** 0.5) + 1)))\n    return x if is_prime(n) else y\n\n\n\nContract List:\nassert_0: assert type(n) == int, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"\",\n  \"inputs\": \"(declare-const n Value)\\n(declare-const x Value)\\n(declare-const y Value)\",\n  \"basic_structure\": \"\",\n  \"contract_defs\": \"(define-fun C0 () Bool (is-IntVal n))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(n) == int, \"invalid inputs"}]}], "reasoning": ["I map the single Python type check into an SMT predicate over the Value ADT, ensuring n is an IntVal. No recursive helpers are needed, and basic structure is empty since there are no universal invariants beyond the Value ADT declaration.</think>"]}
{"name": "HumanEval/151", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: double_the_difference\nProblem Description:\n\ndef double_the_difference(lst):\n    '''\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n    \n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n   \n    If the input list is empty, return 0.\n    '''\n\n\n    assert type(lst) == list, \"invalid inputs\" # $_CONTRACT_$\n\n    ans = 0\n    for num in lst:\n        if num % 2 == 1 and num > 0 and \".\" not in str(num):\n            ans += num ** 2\n    return ans\n\n\n\nContract List:\nassert_0: assert type(lst) == list, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec IsList ((v Value)) Bool\\n  (ite (is-Nil v) true\\n    (ite (is-Cons v)\\n      (IsList (tail v))\\n      false)))\",\n  \"inputs\": \"(declare-const lst Value)\",\n  \"basic_structure\": \"\",\n  \"contract_defs\": \"(define-fun C0 () Bool (IsList lst))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(lst) == list, \"invalid inputs"}]}], "reasoning": ["I map the Python list‐type check to an SMT recursive predicate IsList ensuring proper Nil/Cons structure, declare lst as a Value, and define C0 exactly as IsList(lst). No permanently enforced structural invariants are needed, so BASIC_STRUCTURE is empty.</think>"]}
{"name": "HumanEval/152", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: compare\nProblem Description:\n\ndef compare(game,guess):\n    \"\"\"I think we all remember that feeling when the result of some long-awaited\n    event is finally known. The feelings and thoughts you have at that moment are\n    definitely worth noting down and comparing.\n    Your task is to determine if a person correctly guessed the results of a number of matches.\n    You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    \n    \n    example:\n\n    compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n    compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n    \"\"\"\n\n\n    assert type(game) == list and type(guess) == list, \"invalid inputs\" # $_CONTRACT_$\n    assert all(type(x) == int for x in game), \"invalid inputs\" # $_CONTRACT_$\n    assert all(type(x) == int for x in guess), \"invalid inputs\" # $_CONTRACT_$\n    assert len(game) == len(guess), \"invalid inputs\" # $_CONTRACT_$\n\n\n    return [abs(game[i] - guess[i]) for i in range(len(game))]\n\n\n\nContract List:\nassert_0: assert type(game) == list and type(guess) == list, \"invalid inputs\nassert_1: assert all(type(x) == int for x in game), \"invalid inputs\nassert_2: assert all(type(x) == int for x in guess), \"invalid inputs\nassert_3: assert len(game) == len(guess), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec IsList ((v Value)) Bool (or (is-Nil v) (and (is-Cons v) (IsList (tail v)))))\\n(define-fun-rec ListAllInt ((v Value)) Bool (or (is-Nil v) (and (is-Cons v) (is-IntVal (head v)) (ListAllInt (tail v)))))\\n(define-fun-rec Length ((v Value)) Int (ite (is-Nil v) 0 (ite (is-Cons v) (+ 1 (Length (tail v))) 0)))\",\n  \"inputs\": \"(declare-const game Value)\\n(declare-const guess Value)\",\n  \"basic_structure\": \"(assert (and (IsList game) (IsList guess)))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (and (IsList game) (IsList guess)))\\n(define-fun C1 () Bool (ListAllInt game))\\n(define-fun C2 () Bool (ListAllInt guess))\\n(define-fun C3 () Bool (= (Length game) (Length guess)))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(game) == list and type(guess) == list, \"invalid inputs", "assert_1": "assert all(type(x) == int for x in game), \"invalid inputs", "assert_2": "assert all(type(x) == int for x in guess), \"invalid inputs", "assert_3": "assert len(game) == len(guess), \"invalid inputs"}]}], "reasoning": ["I capture the Python assertions by defining list‐shaping and integer‐element predicates (IsList, ListAllInt, Length) via define‐fun‐rec, then express each assert as Ck over these helpers while ensuring executability.</think>"]}
{"name": "HumanEval/153", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: Strongest_Extension\nProblem Description:\n\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"You will be given the name of a class (a string) and a list of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the list.\n    For example, if you are given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n    \"\"\"\n\n\n    assert isinstance(class_name, str), \"invalid inputs\" # $_CONTRACT_$\n    assert type(extensions) == list, \"invalid inputs\" # $_CONTRACT_$\n    assert all(isinstance(s, str) for s in extensions), \"invalid inputs\" # $_CONTRACT_$\n    assert len(extensions) > 0, \"invalid inputs\" # $_CONTRACT_$\n\n\n    def strength(s: str) -> int:\n        CAP, SM = 0, 0\n        for ch in s:\n            if ch.isupper(): CAP += 1\n            if ch.islower(): SM += 1\n        return CAP - SM\n    max_strength = max(map(strength, extensions))\n    for e in extensions:\n        if strength(e) == max_strength:\n            return class_name + \".\" + e\n\n\n\nContract List:\nassert_0: assert isinstance(class_name, str), \"invalid inputs\nassert_1: assert type(extensions) == list, \"invalid inputs\nassert_2: assert all(isinstance(s, str) for s in extensions), \"invalid inputs\nassert_3: assert len(extensions) > 0, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec IsList ((v Value)) Bool\\n  (ite (is-Nil v)\\n       true\\n       (ite (is-Cons v)\\n            (IsList (tail v))\\n            false)))\\n\\n(define-fun-rec list_all_str ((lst Value)) Bool\\n  (ite (is-Nil lst)\\n       true\\n       (ite (is-Cons lst)\\n            (and (is-StrVal (head lst))\\n                 (list_all_str (tail lst)))\\n            false)))\",\n  \"inputs\": \"(declare-const class_name Value)\\n(declare-const extensions Value)\",\n  \"basic_structure\": \"\",\n  \"contract_defs\": \"(define-fun C0 () Bool (is-StrVal class_name))\\n(define-fun C1 () Bool (IsList extensions))\\n(define-fun C2 () Bool (list_all_str extensions))\\n(define-fun C3 () Bool (is-Cons extensions))\"\n}\n```\n", "constraints": [{"assert_0": "assert isinstance(class_name, str), \"invalid inputs", "assert_1": "assert type(extensions) == list, \"invalid inputs", "assert_2": "assert all(isinstance(s, str) for s in extensions), \"invalid inputs", "assert_3": "assert len(extensions) > 0, \"invalid inputs"}]}], "reasoning": ["I translate each Python assertion into a precise SMT predicate (C0–C3), declare minimal ADT helpers for lists, and leave BASIC_STRUCTURE empty since all safety conditions are captured by the contract predicates.</think>"]}
{"name": "HumanEval/154", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: cycpattern_check\nProblem Description:\n\ndef cycpattern_check(a , b):\n    \"\"\"You are given 2 words. You need to return True if the second word or any of its rotations is a substring in the first word\n    cycpattern_check(\"abcd\",\"abd\") => False\n    cycpattern_check(\"hello\",\"ell\") => True\n    cycpattern_check(\"whassup\",\"psus\") => False\n    cycpattern_check(\"abab\",\"baa\") => True\n    cycpattern_check(\"efef\",\"eeff\") => False\n    cycpattern_check(\"himenss\",\"simen\") => True\n\n    \"\"\"\n\n\n    assert isinstance(a, str) and isinstance(b, str), \"invalid inputs\" # $_CONTRACT_$\n\n    if a == b:\n        return True\n    if b == \"\":\n        return True\n    for i in range(0, len(b)):\n        if b[i:] + b[:i] in a:\n            return True\n    return False\n\n\n\nContract List:\nassert_0: assert isinstance(a, str) and isinstance(b, str), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"\",\n  \"inputs\": \"(declare-const a Value)\\n(declare-const b Value)\",\n  \"basic_structure\": \"\",\n  \"contract_defs\": \"(define-fun C0 () Bool (and (is-StrVal a) (is-StrVal b)))\"\n}\n```\n", "constraints": [{"assert_0": "assert isinstance(a, str) and isinstance(b, str), \"invalid inputs"}]}], "reasoning": ["I capture the single `isinstance` check as a predicate C0 requiring both `a` and `b` be `StrVal`, with no extra structural invariants or helpers needed. Inputs are declared as generic `Value`s, and the combination block covers both the satisfied and violated scenarios via a simple disjunction.</think>"]}
{"name": "HumanEval/155", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: even_odd_count\nProblem Description:\n\ndef even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\"\n\n\n    assert type(num) == int, \"invalid inputs\" # $_CONTRACT_$\n\n    even, odd = 0, 0\n    for ch in str(num):\n        if ch in \"02468\": even += 1\n        if ch in \"13579\": odd += 1\n    return even, odd\n\n\n\nContract List:\nassert_0: assert type(num) == int, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"\",\n  \"inputs\": \"(declare-const num Value)\",\n  \"basic_structure\": \"\",\n  \"contract_defs\": \"(define-fun C0 () Bool (is-IntVal num))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(num) == int, \"invalid inputs"}]}], "reasoning": ["I translate the Python type-check into an SMT predicate ensuring the input is an IntVal, leave basic structure empty (no extra invariants needed), and declare the input as a Value.</think>"]}
{"name": "HumanEval/156", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: int_to_mini_roman\nProblem Description:\n\ndef int_to_mini_roman(number):\n    \"\"\"\n    Given a positive integer, obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19) == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n    \"\"\"\n\n\n    assert type(number) == int, \"invalid inputs\" # $_CONTRACT_$\n    assert 1 <= number <= 1000, \"invalid inputs\" # $_CONTRACT_$\n\n\n    m = [\"\", \"m\"]\n    c = [\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"]\n    x = [\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"]\n    i = [\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"]\n    thousands = m[number // 1000]\n    hundreds = c[(number % 1000) // 100]\n    tens = x[(number % 100) // 10]\n    ones = i[number % 10]\n    return thousands + hundreds + tens + ones\n\n\n\nContract List:\nassert_0: assert type(number) == int, \"invalid inputs\nassert_1: assert 1 <= number <= 1000, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun safe-ival ((v Value)) Int\\n  (ite (is-IntVal v) (ival v) 0))\",\n  \"inputs\": \"(declare-const number Value)\",\n  \"basic_structure\": \"\",\n  \"contract_defs\": \"(define-fun C0 () Bool\\n  (is-IntVal number))\\n(define-fun C1 () Bool\\n  (and (<= 1 (safe-ival number))\\n       (<= (safe-ival number) 1000)))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(number) == int, \"invalid inputs", "assert_1": "assert 1 <= number <= 1000, \"invalid inputs"}]}], "reasoning": ["I will model the integer‐to‐roman input checks as precise SMT predicates, define a safe integer extractor for ADT Values, and declare the necessary contract Booleans C0 and C1.</think>"]}
{"name": "HumanEval/157", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: right_angle_triangle\nProblem Description:\n\ndef right_angle_triangle(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return True if the three\n    sides form a right-angled triangle, False otherwise.\n    A right-angled triangle is a triangle in which one angle is right angle or \n    90 degree.\n    Example:\n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n\n\n    assert type(a) in [int, float] and type(b) in [int, float] and type(c) in [int, float], \"invalid inputs\" # $_CONTRACT_$\n    assert a > 0 and b > 0 and c > 0, \"invalid inputs\" # $_CONTRACT_$\n\n    \n    return a ** 2 + b ** 2 == c ** 2 or a ** 2 + c ** 2 == b ** 2 or b ** 2 + c ** 2 == a ** 2\n\n\n\nContract List:\nassert_0: assert type(a) in [int, float] and type(b) in [int, float] and type(c) in [int, float], \"invalid inputs\nassert_1: assert a > 0 and b > 0 and c > 0, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun getNum ((v Value)) Real (ite (is-IntVal v) (to_real (ival v)) (fval v)))\\n(define-fun square ((x Real)) Real (* x x))\",\n  \"inputs\": \"(declare-const a Value)\\n(declare-const b Value)\\n(declare-const c Value)\",\n  \"basic_structure\": \"\",\n  \"contract_defs\": \"(define-fun C0 () Bool (and (or (is-IntVal a) (is-FloatVal a)) (or (is-IntVal b) (is-FloatVal b)) (or (is-IntVal c) (is-FloatVal c))))\\n(define-fun C1 () Bool (let ((na (getNum a)) (nb (getNum b)) (nc (getNum c))) (and (> na 0.0) (> nb 0.0) (> nc 0.0))))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(a) in [int, float] and type(b) in [int, float] and type(c) in [int, float], \"invalid inputs", "assert_1": "assert a > 0 and b > 0 and c > 0, \"invalid inputs"}]}], "reasoning": ["I translate the Python type and positivity checks into precise SMT predicates, introducing a helper to safely extract numeric values and square them. C0 enforces each input is an IntVal or FloatVal, and C1 ensures all side lengths are strictly positive.</think>"]}
{"name": "HumanEval/158", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: find_max\nProblem Description:\n\ndef find_max(words):\n    \"\"\"Write a function that accepts a list of strings.\n    The list contains different words. Return the word with maximum number\n    of unique characters. If multiple strings have maximum number of unique\n    characters, return the one which comes first in lexicographical order.\n\n    find_max([\"name\", \"of\", \"string\"]) == \"string\"\n    find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n    find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n    \"\"\"\n\n\n    assert type(words) == list, \"invalid inputs\" # $_CONTRACT_$\n    assert all(isinstance(s, str) for s in words), \"invalid inputs\" # $_CONTRACT_$\n    assert len(words) > 0, \"invalid inputs\" # $_CONTRACT_$\n\n\n    mx_ch_cnt, ans = 0, \"\"\n    for word in words:\n        ch_cnt = len(set(word)) \n        if ch_cnt > mx_ch_cnt or (ch_cnt == mx_ch_cnt and word < ans):\n            mx_ch_cnt, ans = ch_cnt, word\n    return ans\n\n\n\nContract List:\nassert_0: assert type(words) == list, \"invalid inputs\nassert_1: assert all(isinstance(s, str) for s in words), \"invalid inputs\nassert_2: assert len(words) > 0, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec IsList ((l Value)) Bool\\n  (ite (is-Nil l)\\n       true\\n       (ite (is-Cons l)\\n            (IsList (tail l))\\n            false)))\\n\\n(define-fun-rec list_all_str ((l Value)) Bool\\n  (ite (is-Nil l)\\n       true\\n       (ite (is-Cons l)\\n            (and (is-StrVal (head l))\\n                 (list_all_str (tail l)))\\n            false)))\\n\\n(define-fun-rec list_length ((l Value)) Int\\n  (ite (is-Nil l)\\n       0\\n       (ite (is-Cons l)\\n            (+ 1 (list_length (tail l)))\\n            0)))\",\n  \"inputs\": \"(declare-const words Value)\",\n  \"basic_structure\": \"(assert (IsList words))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (IsList words))\\n(define-fun C1 () Bool (list_all_str words))\\n(define-fun C2 () Bool (> (list_length words) 0))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(words) == list, \"invalid inputs", "assert_1": "assert all(isinstance(s, str) for s in words), \"invalid inputs", "assert_2": "assert len(words) > 0, \"invalid inputs"}]}], "reasoning": ["I will introduce recursive helpers to recognize list structures, verify all elements are strings, and compute list length. Then I’ll declare the input, assert the basic executability invariant, and translate each Python assert into a corresponding SMT-LIB predicate C0, C1, and C2.</think>"]}
{"name": "HumanEval/159", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: eat\nProblem Description:\n\ndef eat(number, need, remaining):\n    \"\"\"\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10, 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\n\n\n    assert type(number) == int and type(need) == int and type(remaining) == int, \"invalid inputs\" # $_CONTRACT_$\n    assert 0 <= number <= 1000, \"invalid inputs\" # $_CONTRACT_$\n    assert 0 <= need <= 1000, \"invalid inputs\" # $_CONTRACT_$\n    assert 0 <= remaining <= 1000, \"invalid inputs\" # $_CONTRACT_$\n\n\n    if need <= remaining:\n        return [number + need, remaining - need]\n    else:\n        return [number + remaining, 0]\n\n\n\nContract List:\nassert_0: assert type(number) == int and type(need) == int and type(remaining) == int, \"invalid inputs\nassert_1: assert 0 <= number <= 1000, \"invalid inputs\nassert_2: assert 0 <= need <= 1000, \"invalid inputs\nassert_3: assert 0 <= remaining <= 1000, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))\",\n  \"inputs\": \"(declare-const number Value)\\n(declare-const need Value)\\n(declare-const remaining Value)\",\n  \"basic_structure\": \"(assert true)\",\n  \"contract_defs\": \"(define-fun C0 () Bool (and (is-IntVal number) (is-IntVal need) (is-IntVal remaining)))\\n(define-fun C1 () Bool (ite (is-IntVal number) (and (<= 0 (ival number)) (<= (ival number) 1000)) false))\\n(define-fun C2 () Bool (ite (is-IntVal need) (and (<= 0 (ival need)) (<= (ival need) 1000)) false))\\n(define-fun C3 () Bool (ite (is-IntVal remaining) (and (<= 0 (ival remaining)) (<= (ival remaining) 1000)) false))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(number) == int and type(need) == int and type(remaining) == int, \"invalid inputs", "assert_1": "assert 0 <= number <= 1000, \"invalid inputs", "assert_2": "assert 0 <= need <= 1000, \"invalid inputs", "assert_3": "assert 0 <= remaining <= 1000, \"invalid inputs"}]}], "reasoning": ["I will introduce a SafeI extractor for integer values to keep the core structure executable, then translate each Python assert into a separate SMT predicate (C0–C3), declare the three inputs as Value, and leave basic_structure minimal.</think>"]}
{"name": "HumanEval/160", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: do_algebra\nProblem Description:\n\ndef do_algebra(operator, operand):\n    \"\"\"\n    Given two lists operator, and operand. The first list has basic algebra operations, and \n    the second list is a list of integers. Use the two given lists to build the algebric \n    expression and return the evaluation of this expression.\n\n    The basic algebra operations:\n    Addition ( + ) \n    Subtraction ( - ) \n    Multiplication ( * ) \n    Floor division ( // ) \n    Exponentiation ( ** ) \n\n    Example:\n    operator['+', '*', '-']\n    array = [2, 3, 4, 5]\n    result = 2 + 3 * 4 - 5\n    => result = 9\n\n    Note:\n        The length of operator list is equal to the length of operand list minus one.\n        Operand is a list of of non-negative integers.\n        Operator list has at least one operator, and operand list has at least two operands.\n\n    \"\"\"\n\n\n    assert type(operator) == list and type(operand) == list, \"invalid inputs\" # $_CONTRACT_$\n    assert len(operator) >= 1, \"invalid inputs\" # $_CONTRACT_$\n    assert len(operand) == len(operator) + 1, \"invalid inputs\" # $_CONTRACT_$\n    assert all(type(x) == int and x >= 0 for x in operand), \"invalid inputs\" # $_CONTRACT_$\n    assert all(sgn in [\"+\", \"-\", \"*\", \"//\", \"**\"] for sgn in operator), \"invalid inputs\" # $_CONTRACT_$\n    assert not any([operand[i] == 0 and operator[i-1] == \"//\" for i in range(1, len(operand))]), \"invalid inputs\" # $_CONTRACT_$\n\n    exp = \"\"\n    for i in range(len(operator)):\n        exp += str(operand[i]) + operator[i]\n    exp += str(operand[-1])\n    return eval(exp)\n\n\n\nContract List:\nassert_0: assert type(operator) == list and type(operand) == list, \"invalid inputs\nassert_1: assert len(operator) >= 1, \"invalid inputs\nassert_2: assert len(operand) == len(operator) + 1, \"invalid inputs\nassert_3: assert all(type(x) == int and x >= 0 for x in operand), \"invalid inputs\nassert_4: assert all(sgn in [\"+\", \"-\", \"*\", \"//\", \"**\"] for sgn in operator), \"invalid inputs\nassert_5: assert not any([operand[i] == 0 and operator[i-1] == \"//\" for i in range(1, len(operand))]), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"(define-fun-rec IsList ((lst Value)) Bool\\n  (or (is-Nil lst)\\n      (and (is-Cons lst)\\n           (let ((tailVal (tail lst)))\\n             (IsList tailVal)))))\\n\\n(define-fun-rec ListLength ((lst Value)) Int\\n  (ite (is-Nil lst) 0\\n       (ite (is-Cons lst)\\n            (+ 1 (ListLength (tail lst)))\\n            0)))\\n\\n(define-fun-rec ListAllIntNonNeg ((lst Value)) Bool\\n  (ite (is-Nil lst) true\\n       (ite (and (is-Cons lst)\\n                 (let ((headVal (head lst)))\\n                   (and (is-IntVal headVal)\\n                        (>= (ival headVal) 0)))\\n                 (ListAllIntNonNeg (tail lst)))\\n            true\\n            false)))\\n\\n(define-fun-rec ListAllOp ((lst Value)) Bool\\n  (ite (is-Nil lst) true\\n       (ite (and (is-Cons lst)\\n                 (let ((headVal (head lst)))\\n                   (and (is-StrVal headVal)\\n                        (or (= (sval headVal) \\\"+\\\")\\n                            (= (sval headVal) \\\"-\\\")\\n                            (= (sval headVal) \\\"*\\\")\\n                            (= (sval headVal) \\\"//\\\")\\n                            (= (sval headVal) \\\"**\\\"))))\\n                 (ListAllOp (tail lst)))\\n            true\\n            false)))\\n\\n(define-fun-rec SafeDivs ((ops Value) (opnds Value)) Bool\\n  (ite (is-Cons ops)\\n       (let ((opHead (head ops))\\n             (opsTail (tail ops))\\n             (opndsTail (tail opnds)))\\n         (let ((nextOpnd (ite (is-Cons opndsTail)\\n                              (head opndsTail)\\n                              opndsTail)))\\n           (and (ite (is-StrVal opHead)\\n                     (ite (= (sval opHead) \\\"//\\\")\\n                          (not (and (is-IntVal nextOpnd)\\n                                    (= (ival nextOpnd) 0)))\\n                          true)\\n                     true)\\n                (SafeDivs opsTail opndsTail))))\\n       true))\",\n  \"inputs\": \"(declare-const operator Value)\\n(declare-const operand Value)\",\n  \"basic_structure\": \"(assert (IsList operator))\\n(assert (IsList operand))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (and (IsList operator) (IsList operand)))\\n(define-fun C1 () Bool (>= (ListLength operator) 1))\\n(define-fun C2 () Bool (= (ListLength operand) (+ (ListLength operator) 1)))\\n(define-fun C3 () Bool (ListAllIntNonNeg operand))\\n(define-fun C4 () Bool (ListAllOp operator))\\n(define-fun C5 () Bool (SafeDivs operator operand))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(operator) == list and type(operand) == list, \"invalid inputs", "assert_1": "assert len(operator) >= 1, \"invalid inputs", "assert_2": "assert len(operand) == len(operator) + 1, \"invalid inputs", "assert_3": "assert all(type(x) == int and x >= 0 for x in operand), \"invalid inputs", "assert_4": "assert all(sgn in [\"+\", \"-\", \"*\", \"//\", \"**\"] for sgn in operator), \"invalid inputs", "assert_5": "assert not any([operand[i] == 0 and operator[i-1] == \"//\" for i in range(1, len(operand))]), \"invalid inputs"}]}], "reasoning": ["I will model the Python list and value constraints using an ADT and recursive SMT functions, then translate each assertion into named predicates C0–C5 while ensuring basic executability invariants.</think>"]}
{"name": "HumanEval/161", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: solve\nProblem Description:\n\ndef solve(s):\n    \"\"\"You are given a string s.\n    if s[i] is a letter, reverse its case from lower to upper or vise versa, \n    otherwise keep it as it is.\n    If the string contains no letters, reverse the string.\n    The function should return the resulted string.\n    Examples\n    solve(\"1234\") = \"4321\"\n    solve(\"ab\") = \"AB\"\n    solve(\"#a@C\") = \"#A@c\"\n    \"\"\"\n\n\n    assert isinstance(s, str), \"invalid inputs\" # $_CONTRACT_$\n\n    ans, has_letter = \"\", False\n    for ch in s:\n        if ch.isalpha():\n            has_letter = True\n            ans += ch.swapcase()\n        else:\n            ans += ch\n    return ans if has_letter else s[::-1]\n\n\n\nContract List:\nassert_0: assert isinstance(s, str), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"\",\n  \"inputs\": \"(declare-const s Value)\",\n  \"basic_structure\": \"(assert (is-StrVal s))\",\n  \"contract_defs\": \"(define-fun C0 () Bool (is-StrVal s))\"\n}\n```\n", "constraints": [{"assert_0": "assert isinstance(s, str), \"invalid inputs"}]}], "reasoning": ["I’ve mapped the Python isinstance check to the SMT “is-StrVal” tester, declared `s` as a `Value`, enforced its string-ness in the basic structure, and defined C0 to capture the original assertion precisely.</think>"]}
{"name": "HumanEval/162", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: string_to_md5\nProblem Description:\n\ndef string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n\n\n    assert isinstance(text, str), \"invalid inputs\" # $_CONTRACT_$\n\n    if text == \"\": return None\n    import hashlib\n    m = hashlib.md5()\n    m.update(text.encode(\"utf-8\"))\n    return m.hexdigest()\n\n\n\nContract List:\nassert_0: assert isinstance(text, str), \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"\",\n  \"inputs\": \"(declare-const text Value)\",\n  \"basic_structure\": \"\",\n  \"contract_defs\": \"(define-fun C0 () Bool (is-StrVal text))\"\n}\n```\n", "constraints": [{"assert_0": "assert isinstance(text, str), \"invalid inputs"}]}], "reasoning": ["I model the Python assertion by declaring text as a Value and using the built-in StrVal tester for type checking. I define C0 to exactly capture `isinstance(text, str)` and keep the basic structure empty since no other invariants are needed for executability.</think>"]}
{"name": "HumanEval/163", "description": [{"role": "system", "content": "\nYou are an expert program analyst specializing in formal verification and SMT-LIB v2 specification.\n\nYour task is to analyze Python code with input-validation assertions (contracts) and generate a comprehensive SMT-LIB v2 specification that:\n1. Models each contract as a named Boolean predicate (C0, C1, C2, ...)\n2. Ensures program executability through proper ADT constraints\n3. Provides a reusable template for generating test scenarios\n4. Supports systematic contract violation testing\n\nFocus on creating precise, mathematically sound SMT specifications that accurately represent Python assertion semantics.\n\n\nSTRICT RULES (concise, extensible)\n- ADT: declare the Value ADT exactly once. It MAY include additional constructors if needed.\n- Inputs: default to (declare-const <param> Value); use primitive sorts only when truly necessary, consistently.\n- Testers: use only is-<Ctor> for any declared constructor (e.g., is-FloatVal v); never (is FloatVal v).\n- Selector safety: any use of ival/fval/sval/bval MUST be guarded by the matching tester or via Safe* helpers; if needed, wrap with ite.\n- Regex: use str.in.re with (str.to.re \"...\"); DO NOT use re.unit, re.full-match, or indexed forms like (_ str.to.re \"...\"); guard with is-StrVal or SafeS.\n- Let bindings: let-bindings are parallel; a binding MUST NOT reference another binding from the same let. Nest lets when dependencies are needed.\n- Naming: let-bound names MUST be descriptive and non-shadowing (e.g., char, restStr, newBal).\n- Executability vs contracts: BASIC_STRUCTURE SHALL contain only invariants required in all combinations; properties under test belong only in Ck.\n- Contracts & combination: each Ck is a standalone Bool, defined before use, parseable/satisfiable even when others are negated; COMBINATION may reference only Ck atoms (and/or their negations).\n- Recursive references: any function that calls itself (or is mutually recursive) MUST be defined with define-fun-rec; self-reference under define-fun is forbidden.\n- Recursion & folds: every define-fun-rec MUST have a base case and a strictly decreasing structural measure; predicates that call recursive/fold helpers MUST include a structural precondition and MUST short-circuit with ite so the helper term does NOT appear when the guard is false; prefer tail-recursive accumulator folds (e.g., SafeMax/SafeMin with Safe*).\n- Output hygiene: no comments; no undefined/unused symbols; definitions MUST precede first use.\n\n"}, {"role": "user", "content": "\nI will provide:\n- Method Name: the function name to analyze\n- Problem Description: natural language description of function behavior and constraints\n- Contract List: input validation assertions that enforce type, range, and structural constraints\n\nYour tasks:\n1) **CRITICAL**: Ensure ALL inputs satisfy basic structural requirements for program execution:\n   - Correct ADT shapes and types\n   - Valid list structures and nesting\n   - Appropriate numeric/string/boolean constraints\n   - **IMPORTANT**: Use `define-fun-rec` for recursive functions (list_all_numeric, length, etc.)\n2) **Generate ONE SMT-LIB v2 base template** containing:\n   - (a) Basic ADT structure (Value, IntVal, FloatVal, StrVal, BoolVal, Nil, Cons)\n   - (b) **Generate necessary helper functions** (IsList, list_all_numeric, etc.) based on the contracts\n   - (c) Input declarations: `(declare-const <param> Value)` for each parameter\n   - (d) Basic structure assertions for executability\n   - (e) Contract predicate definitions (C0, C1, C2, ...)\n3) **Define contract predicates**: For each Python assert, create a named Bool predicate Ck that exactly matches the assertion semantics\n4) **Ensure mathematical precision**: All SMT expressions must be syntactically correct and semantically equivalent to Python assertions\n5) Cover ALL combinations: singles, pairs, triples, … up to \"all violated\".\n6) **Output format**: Return a JSON object with the specified structure\n7) Output must contain NO comments: Do not generate any lines starting with ';' or ';;' inside helper_functions, basic_structure, inputs, or contract_defs.\nBase Template:\n\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n\n\nOutput Format:\n\n<think>\nBriefly explain your approach (2-3 sentences). Example: \"I will analyze the Python assertions and translate them into precise SMT-LIB predicates while maintaining program executability constraints.\"\n</think>\n```json\n{\n  \"helper_functions\": \"<<HELPER_FUNCTIONS>>\",\n  \"basic_structure\": \"<<BASIC_STRUCTURE>>\",\n  \"inputs\": \"(declare-const <param1> Value)\\n(declare-const <param2> Value)\\n...\",\n  \"contract_defs\": {\n    \"assert_0\": \"(define-fun C0 () Bool <...>)\",\n    \"assert_1\": \"(define-fun C1 () Bool <...>)\",\n    \"assert_2\": \"(define-fun C2 () Bool <...>)\",\n    ...\n  }\n}\n```\n----------------------------------------\n\n----------------------------------------\n\nMethod Name: generate_integers\nProblem Description:\n\ndef generate_integers(a, b):\n    \"\"\"\n    Given two positive integers a and b, return the even digits between a\n    and b, in ascending order.\n\n    For example:\n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n    \"\"\"\n\n\n    assert type(a) == int and type(b) == int, \"invalid inputs\" # $_CONTRACT_$\n    assert a > 0 and b > 0, \"invalid inputs\" # $_CONTRACT_$\n\n\n    if a > b: a, b = b, a\n    return [i for i in range(a, min(b + 1, 10)) if i % 2 == 0]\n\n\n\nContract List:\nassert_0: assert type(a) == int and type(b) == int, \"invalid inputs\nassert_1: assert a > 0 and b > 0, \"invalid inputs\n\n"}], "grammar": [{"production": "\n```json\n{\n  \"helper_functions\": \"\",\n  \"inputs\": \"(declare-const a Value)\\n(declare-const b Value)\",\n  \"basic_structure\": \"\",\n  \"contract_defs\": \"(define-fun C0 () Bool (and (is-IntVal a) (is-IntVal b)))\\n(define-fun C1 () Bool (and (is-IntVal a) (is-IntVal b) (> (ite (is-IntVal a) (ival a) 0) 0) (> (ite (is-IntVal b) (ival b) 0) 0)))\"\n}\n```\n", "constraints": [{"assert_0": "assert type(a) == int and type(b) == int, \"invalid inputs", "assert_1": "assert a > 0 and b > 0, \"invalid inputs"}]}], "reasoning": ["I map each Python assert to an SMT predicate C0 and C1 over the Value ADT, using type‐testers and guarded selectors to ensure exact semantics, and declare inputs with minimal basic structure for executability.</think>"]}
