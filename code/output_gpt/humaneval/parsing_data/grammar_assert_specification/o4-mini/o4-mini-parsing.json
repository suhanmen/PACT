{
  "gpt_model": {
    "HumanEval/0": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec list_all_numeric ((xs Value)) Bool\n  (ite (is-Nil xs) true\n       (ite (is-Cons xs)\n            (and (or (is-IntVal (head xs)) (is-FloatVal (head xs)))\n                 (list_all_numeric (tail xs)))\n            true\n       )\n  )\n)",
      "basic_structure": "",
      "inputs": "(declare-const threshold Value)\n(declare-const numbers Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (and (is-FloatVal threshold) (> (fval threshold) 0)))",
        "assert_1": "(define-fun C1 () Bool (or (is-Nil numbers) (is-Cons numbers)))",
        "assert_2": "(define-fun C2 () Bool (or (not (or (is-Nil numbers) (is-Cons numbers))) (list_all_numeric numbers)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(threshold, float) and threshold > 0, \"invalid inputs",
        "assert_1": "assert isinstance(numbers, list), \"invalid inputs",
        "assert_2": "assert all([isinstance(v, (int, float)) for v in numbers]), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/1": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun safe-sval ((v Value)) String\n  (ite (is-StrVal v) (sval v) \"\"))\n\n(define-fun-rec all_valid_chars ((v Value) (idx Int)) Bool\n  (ite (< idx (str.len (safe-sval v)))\n       (let ((ch (str.substr (safe-sval v) idx 1)))\n         (and (or (= ch \"(\") (= ch \")\") (= ch \" \"))\n              (all_valid_chars v (+ idx 1))))\n       true))\n\n(define-fun-rec prefix_balanced ((v Value) (idx Int) (cnt Int)) Bool\n  (ite (< idx (str.len (safe-sval v)))\n       (let ((ch (str.substr (safe-sval v) idx 1)))\n         (let ((new_cnt (ite (= ch \"(\") (+ cnt 1)\n                              (ite (= ch \")\") (- cnt 1) cnt))))\n           (and (>= new_cnt 0)\n                (prefix_balanced v (+ idx 1) new_cnt))))\n       true))\n\n(define-fun-rec final_count ((v Value) (idx Int) (cnt Int)) Int\n  (ite (< idx (str.len (safe-sval v)))\n       (let ((ch (str.substr (safe-sval v) idx 1)))\n         (final_count v (+ idx 1)\n                      (ite (= ch \"(\") (+ cnt 1)\n                           (ite (= ch \")\") (- cnt 1) cnt))))\n       cnt))",
      "basic_structure": "",
      "inputs": "(declare-const paren_string Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal paren_string))",
        "assert_1": "(define-fun C1 () Bool (all_valid_chars paren_string 0))",
        "assert_2": "(define-fun C2 () Bool (prefix_balanced paren_string 0 0))",
        "assert_3": "(define-fun C3 () Bool (= (final_count paren_string 0 0) 0))"
      },
      "constraints": {
        "assert_0": "assert type(paren_string) == str, \"invalid inputs",
        "assert_1": "assert ch in [\"(\", \")\", \" \"], \"invalid inputs",
        "assert_2": "assert cnt >= 0, \"invalid inputs",
        "assert_3": "assert cnt == 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/2": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun safe_fval ((v Value)) Real\n (ite (is-FloatVal v) (fval v) 0.0))\n(declare-const INF Real)",
      "basic_structure": "",
      "inputs": "(declare-const number Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (> (safe_fval number) 0.0))",
        "assert_1": "(define-fun C1 () Bool (is-FloatVal number))",
        "assert_2": "(define-fun C2 () Bool (and (is-FloatVal number) (not (= (fval number) INF))))"
      },
      "constraints": {
        "assert_0": "assert number > 0, \"invalid inputs",
        "assert_1": "assert isinstance(number, float), \"invalid inputs",
        "assert_2": "assert number != float(\"+inf\"), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/3": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec ListLen ((v Value)) Int\n  (ite (is-Nil v)\n       0\n       (ite (is-Cons v)\n            (+ 1 (ListLen (tail v)))\n            0)))\n\n(define-fun-rec list_all_int ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (is-IntVal (head v))\n                 (list_all_int (tail v)))\n            false)))",
      "basic_structure": "(assert (<= (ListLen operations) 32))",
      "inputs": "(declare-const operations Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (IsList operations))",
        "assert_1": "(define-fun C1 () Bool\n  (list_all_int operations))"
      },
      "constraints": {
        "assert_0": "assert type(operations) == list, \"invalid inputs",
        "assert_1": "assert all([isinstance(v, int) for v in operations]), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/4": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (or\n    (is-Nil v)\n    (and (is-Cons v) (IsList (tail v)))))\n\n(define-fun-rec ListLen ((v Value)) Int\n  (ite (is-Nil v)\n       0\n       (ite (is-Cons v)\n            (+ 1 (ListLen (tail v)))\n            0)))\n\n(define-fun-rec list_all_float ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (is-FloatVal (head v))\n                 (list_all_float (tail v)))\n            true)))",
      "basic_structure": "(assert (IsList numbers))\n(assert (<= (ListLen numbers) 32))",
      "inputs": "(declare-const numbers Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (list_all_float numbers))",
        "assert_1": "(define-fun C1 () Bool\n  (not (is-Nil numbers)))"
      },
      "constraints": {
        "assert_0": "assert all(isinstance(x, float) for x in numbers), \"invalid inputs",
        "assert_1": "assert numbers != [], \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/5": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (let ((h (head v))\n                  (t (tail v)))\n              (IsList t))\n            false)))\n\n(define-fun-rec list_all_ints ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (let ((h (head v))\n                  (t (tail v)))\n              (and (is-IntVal h)\n                   (list_all_ints t)))\n            false)))",
      "basic_structure": "(assert (IsList numbers))",
      "inputs": "(declare-const numbers Value)\n(declare-const delimeter Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (list_all_ints numbers))",
        "assert_1": "(define-fun C1 () Bool\n  (is-IntVal delimeter))"
      },
      "constraints": {
        "assert_0": "assert all([isinstance(v, int) for v in numbers]), \"invalid inputs",
        "assert_1": "assert isinstance(delimeter, int), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/6": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun ValidParenChars ((s String)) Bool\n  (str.in.re s (re.* (re.union (str.to.re \"(\") (re.union (str.to.re \")\") (str.to.re \" \"))))))\n\n(define-fun-rec prefix_ok ((s String) (i Int) (cnt Int)) Bool\n  (ite (>= i (str.len s))\n       true\n       (let ((ch (str.at s i)))\n         (let ((isL (str.in.re ch (str.to.re \"(\")))\n               (isR (str.in.re ch (str.to.re \")\"))))\n           (let ((newCnt (ite isL (+ cnt 1) (ite isR (- cnt 1) cnt))))\n             (and (>= newCnt 0)\n                  (prefix_ok s (+ i 1) newCnt)))))))\n\n(define-fun-rec sum_balance ((s String) (i Int)) Int\n  (ite (>= i (str.len s))\n       0\n       (let ((ch (str.at s i)))\n         (let ((isL (str.in.re ch (str.to.re \"(\")))\n               (isR (str.in.re ch (str.to.re \")\"))))\n           (let ((cur (ite isL 1 (ite isR (- 1) 0))))\n             (+ cur (sum_balance s (+ i 1))))))))",
      "basic_structure": "",
      "inputs": "(declare-const paren_string Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal paren_string))",
        "assert_1": "(define-fun C1 () Bool (and (is-StrVal paren_string) (ValidParenChars (sval paren_string))))",
        "assert_2": "(define-fun C2 () Bool (and (is-StrVal paren_string) (prefix_ok (sval paren_string) 0 0)))",
        "assert_3": "(define-fun C3 () Bool (and (is-StrVal paren_string) (= (sum_balance (sval paren_string) 0) 0)))"
      },
      "constraints": {
        "assert_0": "assert type(paren_string) == str, \"invalid inputs",
        "assert_1": "assert ch in [\"(\", \")\", \" \"], \"invalid inputs",
        "assert_2": "assert cnt >= 0, \"invalid inputs",
        "assert_3": "assert cnt == 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/7": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec ListLen ((v Value)) Int\n  (ite (is-Nil v) 0\n       (ite (is-Cons v)\n            (+ 1 (ListLen (tail v)))\n            0)))\n\n(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v) true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec list_all_str ((v Value)) Bool\n  (ite (is-Cons v)\n       (and (is-StrVal (head v))\n            (list_all_str (tail v)))\n       true))",
      "basic_structure": "(assert (<= (ListLen strings) 32))",
      "inputs": "(declare-const strings Value)\n(declare-const substring Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (IsList strings))",
        "assert_1": "(define-fun C1 () Bool\n  (list_all_str strings))",
        "assert_2": "(define-fun C2 () Bool\n  (is-StrVal substring))"
      },
      "constraints": {
        "assert_0": "assert type(strings) == list, \"invalid inputs",
        "assert_1": "assert all(type(x) == str for x in strings), \"invalid inputs",
        "assert_2": "assert isinstance(substring, str), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/8": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec ListLen ((l Value)) Int\n  (ite (is-Nil l)\n       0\n       (+ 1 (ListLen (tail l)))))\n\n(define-fun-rec IsList ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (and (is-Cons l)\n            (IsList (tail l)))))\n\n(define-fun-rec list_all_ints ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (and (is-Cons l)\n            (is-IntVal (head l))\n            (list_all_ints (tail l)))))",
      "basic_structure": "(assert (IsList numbers))\n(assert (<= (ListLen numbers) 32))",
      "inputs": "(declare-const numbers Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (list_all_ints numbers))"
      },
      "constraints": {
        "assert_0": "assert all([isinstance(v, int) for v in numbers]), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/9": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n(define-fun-rec ListLen ((v Value)) Int\n  (ite (is-Nil v)\n       0\n       (ite (is-Cons v)\n            (+ 1 (ListLen (tail v)))\n            0)))\n(define-fun-rec list_all_int ((v Value)) Bool\n  (ite (is-Cons v)\n       (and (is-IntVal (head v))\n            (list_all_int (tail v)))\n       true))",
      "basic_structure": "(assert (<= (ListLen numbers) 32))",
      "inputs": "(declare-const numbers Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (IsList numbers))",
        "assert_1": "(define-fun C1 () Bool\n  (list_all_int numbers))"
      },
      "constraints": {
        "assert_0": "assert isinstance(numbers, list), \"invalid inputs",
        "assert_1": "assert all([isinstance(v, int) for v in numbers]), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/10": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeS ((v Value)) Bool\n  (and (is-StrVal v)\n       (<= (str.len (sval v)) 32)))",
      "basic_structure": "(assert (SafeS string))",
      "inputs": "(declare-const string Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (is-StrVal string))"
      },
      "constraints": {
        "assert_0": "assert type(string) == str, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/11": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun Safe_Sval ((x Value)) String\n  (ite (is-StrVal x) (sval x) \"\"))\n(define-fun isBinaryString ((s Value)) Bool\n  (and (is-StrVal s)\n       (str.in.re (Safe_Sval s) (re.* (re.union (str.to.re \"0\") (str.to.re \"1\"))))))",
      "basic_structure": "",
      "inputs": "(declare-const a Value)\n(declare-const b Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (and (is-StrVal a) (is-StrVal b)))",
        "assert_1": "(define-fun C1 () Bool (= (str.len (Safe_Sval a)) (str.len (Safe_Sval b))))",
        "assert_2": "(define-fun C2 () Bool (and (isBinaryString a) (isBinaryString b)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(a, str) and isinstance(b, str), \"invalid inputs",
        "assert_1": "assert len(a) == len(b), \"invalid inputs",
        "assert_2": "assert set(a).issubset({\"0\", \"1\"}) and set(b).issubset({\"0\", \"1\"}), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/12": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec ListLen ((v Value)) Int\n  (ite (is-Cons v)\n       (+ 1 (ListLen (tail v)))\n       0))\n\n(define-fun-rec list_all_str ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (is-StrVal (head v))\n                 (list_all_str (tail v)))\n            false)))",
      "basic_structure": "(assert (<= (ListLen strings) 32))\n\n(assert (forall ((x Value))\n  (=> (is-StrVal x)\n      (<= (str.len (sval x)) 32))))",
      "inputs": "(declare-const strings Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (IsList strings))",
        "assert_1": "(define-fun C1 () Bool\n  (=> (IsList strings)\n      (list_all_str strings)))"
      },
      "constraints": {
        "assert_0": "assert type(strings) == list, \"invalid inputs",
        "assert_1": "assert all([isinstance(v, str) for v in strings]), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/13": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeI ((v Value)) Int\n  (ite (is-IntVal v) (ival v) 0))",
      "basic_structure": "",
      "inputs": "(declare-const a Value)\n(declare-const b Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (and (is-IntVal a) (is-IntVal b)))",
        "assert_1": "(define-fun C1 () Bool\n  (> (SafeI a) 0))",
        "assert_2": "(define-fun C2 () Bool\n  (> (SafeI b) 0))"
      },
      "constraints": {
        "assert_0": "assert type(a) == int and type(b) == int, \"invalid inputs",
        "assert_1": "assert a > 0 and b > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/14": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeStrLen ((v Value)) Int (ite (is-StrVal v) (str.len (sval v)) 0))",
      "basic_structure": "(<= (SafeStrLen string) 32)",
      "inputs": "(declare-const string Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal string))"
      },
      "constraints": {
        "assert_0": "assert isinstance(string, str), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/15": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
      "basic_structure": "(assert (<= (SafeI n) 32))",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
        "assert_1": "(define-fun C1 () Bool (and (is-IntVal n) (>= (SafeI n) 0)))"
      },
      "constraints": {
        "assert_0": "assert type(n) == int, \"invalid inputs",
        "assert_1": "assert n >= 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/16": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeS ((v Value)) String\n  (ite (is-StrVal v) (sval v) \"\"))",
      "basic_structure": "(assert (<= (str.len (SafeS string)) 32))",
      "inputs": "(declare-const string Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal string))"
      },
      "constraints": {
        "assert_0": "assert isinstance(string, str), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/17": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeS ((v Value)) String\n  (ite (is-StrVal v) (sval v) \"\"))",
      "basic_structure": "(assert (is-StrVal music_string))",
      "inputs": "(declare-const music_string Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal music_string))",
        "assert_1": "(define-fun C1 () Bool (or (= (SafeS music_string) \"\") (str.in.re (SafeS music_string) (re.union (str.to.re \"\") (re.++ (re.union (str.to.re \"o\") (str.to.re \"o|\") (str.to.re \".|\")) (re.* (re.++ (str.to.re \" \") (re.union (str.to.re \"o\") (str.to.re \"o|\") (str.to.re \".|\")))))))))"
      },
      "constraints": {
        "assert_0": "assert isinstance(music_string, str), \"invalid inputs",
        "assert_1": "assert music_string == \"\" or all(map(lambda x: x in [\"o\", \"o|\", \".|\"], music_string.split(\" \"))), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/18": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeS ((v Value)) String (ite (is-StrVal v) (sval v) \"\"))",
      "basic_structure": "(assert (<= (str.len (SafeS string)) 32))\n(assert (<= (str.len (SafeS substring)) 32))",
      "inputs": "(declare-const string Value)\n(declare-const substring Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (and (is-StrVal string) (is-StrVal substring)))",
        "assert_1": "(define-fun C1 () Bool (and (is-StrVal substring) (> (str.len (SafeS substring)) 0)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(string, str) and isinstance(substring, str), \"invalid inputs",
        "assert_1": "assert substring != \"\", \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/19": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec tokens_allowed ((s String)) Bool\n  (ite (= (str.len s) 0)\n       true\n       (let ((pos (str.indexof s \" \" 0)))\n         (let ((token (ite (= pos (- 1))\n                           s\n                           (str.substr s 0 pos))))\n           (let ((rest  (ite (= pos (- 1))\n                            \"\"\n                            (str.substr s\n                                        (+ pos 1)\n                                        (- (str.len s) (+ pos 1))))))\n             (and\n               (or (= token \"zero\")\n                   (= token \"one\")\n                   (= token \"two\")\n                   (= token \"three\")\n                   (= token \"four\")\n                   (= token \"five\")\n                   (= token \"six\")\n                   (= token \"seven\")\n                   (= token \"eight\")\n                   (= token \"nine\"))\n               (tokens_allowed rest)))))))",
      "basic_structure": "(assert (is-StrVal numbers))\n(assert (<= (str.len (sval numbers)) 64))",
      "inputs": "(declare-const numbers Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (is-StrVal numbers))",
        "assert_1": "(define-fun C1 () Bool\n  (and\n    (is-StrVal numbers)\n    (or\n      (= (sval numbers) \"\")\n      (tokens_allowed (sval numbers)))))"
      },
      "constraints": {
        "assert_0": "assert isinstance(numbers, str), \"invalid inputs",
        "assert_1": "assert numbers == \"\" or all(map(lambda x: x in [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"], numbers.split(\" \"))), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/20": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (or (is-Nil v)\n      (and (is-Cons v)\n           (let ((tailV (tail v)))\n             (IsList tailV)))))\n\n(define-fun-rec ListLen ((v Value)) Int\n  (ite (is-Nil v)\n       0\n       (ite (is-Cons v)\n            (let ((tailV (tail v)))\n              (+ 1 (ListLen tailV)))\n            0)))\n\n(define-fun-rec list_all_numeric ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (let ((hd (head v)) (tl (tail v)))\n              (and (or (is-IntVal hd) (is-FloatVal hd))\n                   (list_all_numeric tl)))\n            false)))",
      "basic_structure": "(assert (IsList numbers))\n(assert (<= (ListLen numbers) 32))",
      "inputs": "(declare-const numbers Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (list_all_numeric numbers))",
        "assert_1": "(define-fun C1 () Bool\n  (>= (ListLen numbers) 2))"
      },
      "constraints": {
        "assert_0": "assert all(type(x) in [int, float] for x in numbers), \"invalid inputs",
        "assert_1": "assert len(numbers) >= 2, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/21": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun ValueToReal ((v Value)) Real\n  (ite (is-IntVal v) (to_real (ival v)) (fval v)))\n\n(define-fun-rec IsList ((lst Value)) Bool\n  (ite (is-Nil lst) true\n       (ite (is-Cons lst) (IsList (tail lst)) false)))\n\n(define-fun-rec ListLen ((lst Value)) Int\n  (ite (is-Nil lst) 0\n       (ite (is-Cons lst) (+ 1 (ListLen (tail lst))) 0)))\n\n(define-fun-rec list_all_numeric ((lst Value)) Bool\n  (ite (is-Nil lst) true\n       (ite (is-Cons lst)\n            (and (or (is-IntVal (head lst)) (is-FloatVal (head lst)))\n                 (list_all_numeric (tail lst)))\n            false)))\n\n(define-fun-rec list_max ((lst Value)) Real\n  (ite (is-Cons lst)\n       (let ((hval (ValueToReal (head lst)))\n             (tmax (list_max (tail lst))))\n         (ite (is-Nil (tail lst))\n              hval\n              (ite (> hval tmax) hval tmax)))\n       0.0))\n\n(define-fun-rec list_min ((lst Value)) Real\n  (ite (is-Cons lst)\n       (let ((hval (ValueToReal (head lst)))\n             (tmin (list_min (tail lst))))\n         (ite (is-Nil (tail lst))\n              hval\n              (ite (< hval tmin) hval tmin)))\n       0.0))",
      "basic_structure": "(assert (IsList numbers))\n(assert (list_all_numeric numbers))\n(assert (<= (ListLen numbers) 32))",
      "inputs": "(declare-const numbers Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (list_all_numeric numbers))",
        "assert_1": "(define-fun C1 () Bool (>= (ListLen numbers) 2))",
        "assert_2": "(define-fun C2 () Bool (> (list_max numbers) (list_min numbers)))"
      },
      "constraints": {
        "assert_0": "assert all(type(x) in [int, float] for x in numbers), \"invalid inputs",
        "assert_1": "assert len(numbers) >= 2, \"invalid inputs",
        "assert_2": "assert max(numbers) > min(numbers), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/22": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec ListLen ((v Value)) Int\n  (ite (is-Nil v) 0\n    (ite (is-Cons v) (+ 1 (ListLen (tail v))) 0)))\n(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v) true\n    (ite (is-Cons v) (IsList (tail v)) false)))",
      "basic_structure": "(assert (<= (ListLen values) 32))",
      "inputs": "(declare-const values Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList values))"
      },
      "constraints": {
        "assert_0": "assert type(values) == list, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/23": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeStrLen ((v Value)) Int\n  (ite (is-StrVal v)\n       (str.len (sval v))\n       0))",
      "basic_structure": "(<= (SafeStrLen string) 32)",
      "inputs": "(declare-const string Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal string))"
      },
      "constraints": {
        "assert_0": "assert isinstance(string, str), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/24": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun getInt ((v Value)) Int (ite (is-IntVal v) (ival v) 0))\n(define-fun safeMod ((a Value) (b Value)) Int (ite (and (is-IntVal a) (is-IntVal b) (not (= (getInt b) 0))) (mod (getInt a) (getInt b)) 0))\n(define-fun safeDiv ((a Value) (b Value)) Int (ite (and (is-IntVal a) (is-IntVal b) (not (= (getInt b) 0))) (div (getInt a) (getInt b)) 0))",
      "basic_structure": "",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
        "assert_1": "(define-fun C1 () Bool (and (is-IntVal n) (> (getInt n) 1)))"
      },
      "constraints": {
        "assert_0": "assert type(n) == int, \"invalid inputs",
        "assert_1": "assert n > 1, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/25": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
        "assert_1": "(define-fun C1 () Bool (implies (is-IntVal n) (>= (ival n) 2)))"
      },
      "constraints": {
        "assert_0": "assert type(n) == int, \"invalid inputs",
        "assert_1": "assert n >= 2, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/26": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec ListLen ((v Value)) Int\n  (ite (is-Nil v)\n       0\n       (ite (is-Cons v)\n            (let ((tailv (tail v)))\n              (+ 1 (ListLen tailv)))\n            0)))\n\n(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (let ((tailv (tail v)))\n              (IsList tailv))\n            false)))\n\n(define-fun-rec list_all_int ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (let ((headv (head v)) (tailv (tail v)))\n              (and (is-IntVal headv) (list_all_int tailv)))\n            false)))",
      "basic_structure": "(assert (IsList numbers))\n(assert (<= (ListLen numbers) 32))",
      "inputs": "(declare-const numbers Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList numbers))",
        "assert_1": "(define-fun C1 () Bool (list_all_int numbers))"
      },
      "constraints": {
        "assert_0": "assert type(numbers) == list, \"invalid inputs",
        "assert_1": "assert all(type(x) == int for x in numbers), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/27": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeStr ((v Value)) String (ite (is-StrVal v) (sval v) \"\"))",
      "basic_structure": "(assert (is-StrVal string))\n(assert (<= (str.len (sval string)) 32))",
      "inputs": "(declare-const string Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal string))"
      },
      "constraints": {
        "assert_0": "assert type(string) == str, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/28": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun isList ((v Value)) Bool\n  (or (is-Nil v) (is-Cons v)))\n\n(define-fun-rec list_all_str ((lst Value)) Bool\n  (ite (is-Nil lst)\n       true\n       (ite (is-Cons lst)\n            (and (is-StrVal (head lst))\n                 (list_all_str (tail lst)))\n            false)))",
      "basic_structure": "",
      "inputs": "(declare-const strings Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (list_all_str strings))",
        "assert_1": "(define-fun C1 () Bool\n  (isList strings))"
      },
      "constraints": {
        "assert_0": "assert all(isinstance(s, str) for s in strings), \"invalid inputs",
        "assert_1": "assert isinstance(strings, list), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/29": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun is-List ((v Value)) Bool (or (is-Nil v) (is-Cons v)))\n(define-fun-rec list_length ((l Value)) Int\n  (ite (is-Nil l)\n       0\n       (ite (is-Cons l)\n            (+ 1 (list_length (tail l)))\n            0)))\n(define-fun-rec list_all_str ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (and (is-StrVal (head l)) (list_all_str (tail l)))\n            false)))",
      "basic_structure": "(define-fun BASIC_STRUCTURE () Bool\n  (and\n    (is-List strings)\n    (<= (list_length strings) 32)))",
      "inputs": "(declare-const strings Value)\n(declare-const prefix Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (list_all_str strings))",
        "assert_1": "(define-fun C1 () Bool (is-StrVal prefix))"
      },
      "constraints": {
        "assert_0": "assert all(isinstance(s, str) for s in strings), \"invalid inputs",
        "assert_1": "assert isinstance(prefix, str), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/30": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (or (is-Nil v)\n      (and (is-Cons v)\n           (let ((head_ (head v)) (tail_ (tail v)))\n             (IsList tail_)))))\n\n(define-fun-rec list_len ((v Value)) Int\n  (ite (is-Nil v)\n       0\n       (ite (is-Cons v)\n            (+ 1 (list_len (tail v)))\n            0)))\n\n(define-fun-rec list_all_numeric ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (and (is-Cons v)\n            (let ((head_ (head v)) (tail_ (tail v)))\n              (and (or (is-IntVal head_) (is-FloatVal head_))\n                   (list_all_numeric tail_))))))",
      "basic_structure": "(assert (IsList l))\n(assert (list_all_numeric l))\n(assert (<= (list_len l) 32))",
      "inputs": "(declare-const l Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (or (is-Nil l) (is-Cons l)))"
      },
      "constraints": {
        "assert_0": "assert type(l) == list, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/31": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))"
      },
      "constraints": {
        "assert_0": "assert type(n) == int, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/32": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec isList ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (isList (tail l))\n            false)))\n(define-fun-rec length ((l Value)) Int\n  (ite (is-Nil l)\n       0\n       (ite (is-Cons l)\n            (+ 1 (length (tail l)))\n            0)))\n(define-fun-rec lastElem ((l Value)) Value\n  (ite (and (is-Cons l) (is-Nil (tail l)))\n       (head l)\n       (ite (is-Cons l)\n            (lastElem (tail l))\n            l)))\n(define-fun-rec list_all_int ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (and (is-Cons l) (is-IntVal (head l)) (list_all_int (tail l)))\n            true\n            false)))\n(define-fun-rec pow ((x Real) (n Int)) Real\n  (ite (= n 0)\n       1\n       (* x (pow x (- n 1)))))\n(define-fun-rec poly_help ((l Value) (idx Int) (x Real)) Real\n  (ite (is-Nil l)\n       0\n       (let ((h (head l)) (t (tail l)))\n         (ite (is-IntVal h)\n              (+ (* (to_real (ival h)) (pow x idx))\n                 (poly_help t (+ idx 1) x))\n              (poly_help t (+ idx 1) x)))))\n(define-fun poly ((l Value) (x Real)) Real\n  (poly_help l 0 x))\n(define-fun abs ((r Real)) Real\n  (ite (< r 0) (- r) r))\n(declare-fun find_zero ((Value)) Real)",
      "basic_structure": "(assert (isList xs))\n(assert (> (length xs) 0))",
      "inputs": "(declare-const xs Value)\n",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (and (isList xs)\n       (> (length xs) 0)\n       (= (mod (length xs) 2) 0)))",
        "assert_1": "(define-fun C1 () Bool\n  (not (= (lastElem xs) (IntVal 0))))",
        "assert_2": "(define-fun C2 () Bool\n  (list_all_int xs))",
        "assert_3": "(define-fun C3 () Bool\n  (< (abs (poly xs (find_zero xs))) 1e-5))"
      },
      "constraints": {
        "assert_0": "assert isinstance(xs, list) and len(xs) > 0 and len(xs) % 2 == 0, \"invalid inputs",
        "assert_1": "assert xs[-1] != 0, \"invalid inputs",
        "assert_2": "assert all(type(x) == int for x in xs), \"invalid inputs",
        "assert_3": "assert abs(poly(xs, x)) < tol, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/33": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec ListLen ((v Value)) Int\n  (ite (is-Nil v) 0\n    (ite (is-Cons v) (+ 1 (ListLen (tail v))) 0)\n  )\n)\n(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v) true\n    (ite (is-Cons v) (IsList (tail v)) false)\n  )\n)",
      "basic_structure": "(assert (<= (ListLen l) 32))",
      "inputs": "(declare-const l Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList l))"
      },
      "constraints": {
        "assert_0": "assert type(l) == list, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/34": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v) true\n    (ite (is-Cons v)\n      (IsList (tail v))\n      false)))\n\n(define-fun-rec ListLen ((v Value)) Int\n  (ite (is-Nil v) 0\n    (ite (is-Cons v)\n      (+ 1 (ListLen (tail v)))\n      0)))",
      "basic_structure": "(assert (IsList l))\n(assert (<= (ListLen l) 32))",
      "inputs": "(declare-const l Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList l))"
      },
      "constraints": {
        "assert_0": "assert type(l) == list, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/35": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (or (is-Nil l)\n      (and (is-Cons l)\n           (IsList (tail l)))))\n\n(define-fun-rec list_len ((l Value)) Int\n  (ite (is-Nil l) 0\n       (ite (is-Cons l)\n            (+ 1 (list_len (tail l)))\n            0)))\n\n(define-fun-rec list_all_numeric ((l Value)) Bool\n  (ite (is-Nil l) true\n       (ite (is-Cons l)\n            (and (or (is-IntVal (head l)) (is-FloatVal (head l)))\n                 (list_all_numeric (tail l)))\n            false)))",
      "basic_structure": "(assert (IsList l))\n(assert (<= (list_len l) 32))",
      "inputs": "(declare-const l Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (IsList l))",
        "assert_1": "(define-fun C1 () Bool\n  (and (IsList l)\n       (not (= (list_len l) 0))))",
        "assert_2": "(define-fun C2 () Bool\n  (and (IsList l)\n       (list_all_numeric l)))"
      },
      "constraints": {
        "assert_0": "assert type(l) == list, \"invalid inputs",
        "assert_1": "assert len(l) != 0, \"invalid inputs",
        "assert_2": "assert all(type(x) in [int, float] for x in l), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/36": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "(assert (is-IntVal n))",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (> (ival n) 0))"
      },
      "constraints": {
        "assert_0": "assert type(n) == int and n > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/37": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (IsList (tail l))\n            false)))\n\n(define-fun-rec list_len ((l Value)) Int\n  (ite (is-Nil l)\n       0\n       (ite (is-Cons l)\n            (+ 1 (list_len (tail l)))\n            0)))\n\n(define-fun-rec list_all_numeric ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (and (or (is-IntVal (head l)) (is-FloatVal (head l)))\n                 (list_all_numeric (tail l)))\n            false)))",
      "basic_structure": "(assert (IsList l))\n(assert (<= (list_len l) 32))",
      "inputs": "(declare-const l Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList l))",
        "assert_1": "(define-fun C1 () Bool (and (IsList l) (list_all_numeric l)))"
      },
      "constraints": {
        "assert_0": "assert type(l) == list, \"invalid inputs",
        "assert_1": "assert all(type(x) in [int, float] for x in l), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/38": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeS ((v Value)) String (ite (is-StrVal v) (sval v) \"\"))",
      "basic_structure": "(<= (str.len (SafeS s)) 32)",
      "inputs": "(declare-const s Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal s))"
      },
      "constraints": {
        "assert_0": "assert isinstance(s, str), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/39": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
      "basic_structure": "(assert (<= (SafeI n) 2147483647))\n(assert (>= (SafeI n) -2147483648))",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
        "assert_1": "(define-fun C1 () Bool (or (not (is-IntVal n)) (<= 1 (SafeI n))))",
        "assert_2": "(define-fun C2 () Bool (or (not (is-IntVal n)) (<= (SafeI n) 12)))"
      },
      "constraints": {
        "assert_0": "assert type(n) == int, \"invalid inputs",
        "assert_1": "assert 1 <= n <= 12, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/40": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec list_all_int ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (is-IntVal (head v))\n                 (list_all_int (tail v)))\n            false)))",
      "basic_structure": "(and (IsList l) (list_all_int l))",
      "inputs": "(declare-const l Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList l))"
      },
      "constraints": {
        "assert_0": "assert type(l) == list, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/41": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun absI ((i Int)) Int (ite (>= i 0) i (- i)))",
      "basic_structure": "(assert (is-IntVal n))\n(assert (<= (absI (ival n)) 100))",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
        "assert_1": "(define-fun C1 () Bool (and (is-IntVal n) (>= (ival n) 1)))"
      },
      "constraints": {
        "assert_0": "assert type(n) == int, \"invalid inputs",
        "assert_1": "assert n >= 1, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/42": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec ListLen ((l Value)) Int\n  (ite (is-Cons l)\n       (+ 1 (ListLen (tail l)))\n       0))\n\n(define-fun-rec IsList ((l Value)) Bool\n  (or (is-Nil l)\n      (and (is-Cons l)\n           (IsList (tail l)))))",
      "basic_structure": "(assert (<= (ListLen l) 32))",
      "inputs": "(declare-const l Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (IsList l))"
      },
      "constraints": {
        "assert_0": "assert type(l) == list, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/43": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((xs Value)) Bool\n  (ite (is-Nil xs)\n       true\n       (ite (is-Cons xs)\n            (let ((tl (tail xs)))\n              (IsList tl))\n            false)))\n\n(define-fun-rec ListLen ((xs Value)) Int\n  (ite (is-Nil xs)\n       0\n       (ite (is-Cons xs)\n            (let ((tl (tail xs)))\n              (+ 1 (ListLen tl)))\n            0)))\n\n(define-fun-rec list_all_numeric ((xs Value)) Bool\n  (ite (is-Nil xs)\n       true\n       (ite (is-Cons xs)\n            (let ((hd (head xs)) (tl (tail xs)))\n              (and (or (is-IntVal hd) (is-FloatVal hd))\n                   (list_all_numeric tl)))\n            false)))\n\n(define-fun-rec list_all_int ((xs Value)) Bool\n  (ite (is-Nil xs)\n       true\n       (ite (is-Cons xs)\n            (let ((hd (head xs)) (tl (tail xs)))\n              (and (is-IntVal hd)\n                   (list_all_int tl)))\n            false)))",
      "basic_structure": "(assert (IsList l))\n(assert (<= (ListLen l) 32))\n(assert (list_all_numeric l))",
      "inputs": "(declare-const l Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (list_all_int l))"
      },
      "constraints": {
        "assert_0": "assert all([isinstance(v, int) for v in l]), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/44": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const x Value)\n(declare-const base Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal x))",
        "assert_1": "(define-fun C1 () Bool (is-IntVal base))",
        "assert_2": "(define-fun C2 () Bool (or (not (is-IntVal x)) (>= (ival x) 0)))",
        "assert_3": "(define-fun C3 () Bool (or (not (is-IntVal base)) (>= (ival base) 2)))",
        "assert_4": "(define-fun C4 () Bool (or (not (is-IntVal base)) (<= (ival base) 9)))"
      },
      "constraints": {
        "assert_0": "assert type(x) == int and type(base) == int, \"invalid inputs",
        "assert_1": "assert x >= 0, \"invalid inputs",
        "assert_2": "assert 2 <= base <= 9, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/45": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun is_numeric ((v Value)) Bool\n  (or (is-IntVal v) (is-FloatVal v)))\n\n(define-fun safe-to-real ((v Value)) Real\n  (ite (is-IntVal v)\n       (to_real (ival v))\n       (ite (is-FloatVal v)\n            (fval v)\n            0)))",
      "basic_structure": "",
      "inputs": "(declare-const a Value)\n(declare-const h Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (and (is_numeric a)\n       (is_numeric h)))",
        "assert_1": "(define-fun C1 () Bool\n  (and (is_numeric a)\n       (is_numeric h)\n       (> (safe-to-real a) 0)\n       (> (safe-to-real h) 0)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(a, (int, float)) and isinstance(h, (int, float)), \"invalid inputs",
        "assert_1": "assert a > 0 and h > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/46": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
        "assert_1": "(define-fun C1 () Bool (and (is-IntVal n) (>= (ival n) 0)))"
      },
      "constraints": {
        "assert_0": "assert type(n) == int, \"invalid inputs",
        "assert_1": "assert n >= 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/47": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (IsList (tail l))\n            false)))\n\n(define-fun-rec list_len ((l Value)) Int\n  (ite (is-Cons l)\n       (+ 1 (list_len (tail l)))\n       0))\n\n(define-fun-rec list_all_numeric ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (and (or (is-IntVal (head l)) (is-FloatVal (head l)))\n                 (list_all_numeric (tail l)))\n            false)))",
      "basic_structure": "(assert (IsList l))\n(assert (<= (list_len l) 32))",
      "inputs": "(declare-const l Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (> (list_len l) 0))",
        "assert_1": "(define-fun C1 () Bool (list_all_numeric l))"
      },
      "constraints": {
        "assert_0": "assert len(l) > 0, \"invalid inputs",
        "assert_1": "assert all([isinstance(v, (int, float)) for v in l]), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/48": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeS ((v Value)) String (ite (is-StrVal v) (sval v) \"\"))",
      "basic_structure": "",
      "inputs": "(declare-const text Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal text))"
      },
      "constraints": {
        "assert_0": "assert isinstance(text, str), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/49": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const n Value)\n(declare-const p Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
        "assert_1": "(define-fun C1 () Bool (is-IntVal p))",
        "assert_2": "(define-fun C2 () Bool (and (is-IntVal n) (>= (ival n) 0)))",
        "assert_3": "(define-fun C3 () Bool (and (is-IntVal p) (>= (ival p) 1)))"
      },
      "constraints": {
        "assert_0": "assert type(n) == int and type(p) == int, \"invalid inputs",
        "assert_1": "assert n >= 0 and p >= 1, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/50": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeS ((v Value)) String\n  (ite (is-StrVal v) (sval v) \"\"))\n\n(define-fun-rec has_cased ((st String)) Bool\n  (ite (= (str.len st) 0)\n       false\n       (let ((ch (str.substr st 0 1))\n             (rest (str.substr st 1 (- (str.len st) 1))))\n         (or (str.in.re ch (re.union (re.range \"A\" \"Z\") (re.range \"a\" \"z\")))\n             (has_cased rest)))))\n\n(define-fun-rec is_lower_all_cased ((st String)) Bool\n  (ite (= (str.len st) 0)\n       true\n       (let ((ch (str.substr st 0 1))\n             (rest (str.substr st 1 (- (str.len st) 1))))\n         (and (or (not (str.in.re ch (re.union (re.range \"A\" \"Z\") (re.range \"a\" \"z\"))))\n                  (str.in.re ch (re.range \"a\" \"z\")))\n              (is_lower_all_cased rest)))))",
      "basic_structure": "(assert (is-StrVal s))\n(assert (<= (str.len (SafeS s)) 32))",
      "inputs": "(declare-const s Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (let ((s_str (SafeS s)))\n    (or (= (str.len s_str) 0)\n        (and (has_cased s_str)\n             (is_lower_all_cased s_str)))))"
      },
      "constraints": {
        "assert_0": "assert s == \"\" or s.islower(), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/51": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeS ((v Value)) String (ite (is-StrVal v) (sval v) \"\"))",
      "basic_structure": "(assert (<= (str.len (SafeS text)) 32))",
      "inputs": "(declare-const text Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal text))"
      },
      "constraints": {
        "assert_0": "assert type(text) == str, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/52": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec is_list ((v Value)) Bool (or (is-Cons v) (is-Nil v)))\n(define-fun-rec list_len ((v Value)) Int (ite (is-Cons v) (+ 1 (list_len (tail v))) 0))\n(define-fun-rec list_all_numeric ((v Value)) Bool\n  (ite (is-Cons v)\n       (and (or (is-IntVal (head v))\n                (is-FloatVal (head v))\n                (is-BoolVal (head v)))\n            (list_all_numeric (tail v)))\n       (is-Nil v)))\n(define-fun value_to_real ((v Value)) Real\n  (ite (is-IntVal v)\n       (to_real (ival v))\n       (ite (is-FloatVal v)\n            (fval v)\n            (ite (is-BoolVal v)\n                 (ite (bval v) 1.0 0.0)\n                 0.0))))\n(define-fun-rec list_all_lt ((v Value) (t Value)) Bool\n  (ite (is-Cons v)\n       (and (< (value_to_real (head v)) (value_to_real t))\n            (list_all_lt (tail v) t))\n       true))",
      "basic_structure": "(assert (<= (list_len l) 32))",
      "inputs": "(declare-const l Value)\n(declare-const t Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is_list l))",
        "assert_1": "(define-fun C1 () Bool (is-IntVal t))",
        "assert_2": "(define-fun C2 () Bool (list_all_numeric l))"
      },
      "constraints": {
        "assert_0": "assert type(l) == list, \"invalid inputs",
        "assert_1": "assert type(t) == int, \"invalid inputs",
        "assert_2": "assert all(isinstance(x, (int, float, bool)) for x in l), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/53": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const x Value)\n(declare-const y Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal x))",
        "assert_1": "(define-fun C1 () Bool (is-IntVal y))"
      },
      "constraints": {
        "assert_0": "assert isinstance(x, int), \"invalid inputs",
        "assert_1": "assert isinstance(y, int), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/54": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec str_contains ((haystack String) (ch String)) Bool\n  (ite (= (str.len haystack) 0)\n       false\n       (let ((first (str.substr haystack 0 1)))\n         (or (= first ch)\n             (str_contains (str.substr haystack 1 (- (str.len haystack) 1)) ch)))))\n\n(define-fun-rec all_chars_in ((v1 String) (v2 String)) Bool\n  (ite (= (str.len v1) 0)\n       true\n       (let ((ch (str.substr v1 0 1))\n             (rest (str.substr v1 1 (- (str.len v1) 1))))\n         (and (str_contains v2 ch)\n              (all_chars_in rest v2)))))",
      "basic_structure": "(assert (is-StrVal s0))\n(assert (is-StrVal s1))\n(assert (<= (str.len (sval s0)) 32))\n(assert (<= (str.len (sval s1)) 32))",
      "inputs": "(declare-const s0 Value)\n(declare-const s1 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (and (is-StrVal s0)\n       (is-StrVal s1)))"
      },
      "constraints": {
        "assert_0": "assert type(s0) == type(s1) == str, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/55": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeInt ((v Value)) Int\n  (ite (is-IntVal v) (ival v) 0))",
      "basic_structure": "",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (and (is-IntVal n) (>= (ival n) 0)))",
        "assert_1": "(define-fun C1 () Bool\n  (is-IntVal n))"
      },
      "constraints": {
        "assert_0": "assert n >= 0, \"invalid inputs",
        "assert_1": "assert isinstance(n, int), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/56": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeS ((v Value)) String\n  (ite (is-StrVal v) (sval v) \"\"))\n\n(define-fun-rec allAngleChars ((s String)) Bool\n  (ite (= (str.len s) 0)\n       true\n       (let ((c (str.substr s 0 1))\n             (rest (str.substr s 1 (- (str.len s) 1))))\n         (and (or (= c \"<\") (= c \">\"))\n              (allAngleChars rest)))))",
      "basic_structure": "(assert (is-StrVal brackets))",
      "inputs": "(declare-const brackets Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal brackets))",
        "assert_1": "(define-fun C1 () Bool (allAngleChars (SafeS brackets)))"
      },
      "constraints": {
        "assert_0": "assert type(brackets) == str, \"invalid inputs",
        "assert_1": "assert all(x in \"<>\" for x in brackets)"
      },
      "single_toggles": null
    },
    "HumanEval/57": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun isList ((v Value)) Bool\n  (or (is-Nil v) (is-Cons v)))\n\n(define-fun-rec lengthList ((v Value)) Int\n  (ite (is-Cons v)\n       (+ 1 (lengthList (tail v)))\n       (ite (is-Nil v)\n            0\n            0)))\n\n(define-fun-rec list_all_numeric ((v Value)) Bool\n  (ite (is-Cons v)\n       (let ((h (head v)) (t (tail v)))\n         (and\n           (or (is-IntVal h) (is-FloatVal h) (is-BoolVal h))\n           (list_all_numeric t)))\n       (ite (is-Nil v)\n            true\n            true)))",
      "basic_structure": "(assert (isList l))\n(assert (<= (lengthList l) 32))",
      "inputs": "(declare-const l Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (isList l))",
        "assert_1": "(define-fun C1 () Bool\n  (list_all_numeric l))"
      },
      "constraints": {
        "assert_0": "assert type(l) == list, \"invalid inputs",
        "assert_1": "assert all(type(x) in (int, float, bool) for x in l), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/58": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (IsList (tail l))\n            false)))\n\n(define-fun-rec ListLen ((l Value)) Int\n  (ite (is-Nil l)\n       0\n       (ite (is-Cons l)\n            (+ 1 (ListLen (tail l)))\n            0)))",
      "basic_structure": "(assert (IsList l1))\n(assert (IsList l2))\n(assert (<= (ListLen l1) 32))\n(assert (<= (ListLen l2) 32))",
      "inputs": "(declare-const l1 Value)\n(declare-const l2 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (and (IsList l1) (IsList l2)))"
      },
      "constraints": {
        "assert_0": "assert type(l1) == type(l2) == list, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/59": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))\n(define-fun-rec has_divisor ((n Int) (x Int)) Bool\n  (ite (> (* x x) n)\n       false\n       (ite (= (mod n x) 0)\n            true\n            (has_divisor n (+ x 1)))))\n(define-fun is_prime ((v Value)) Bool\n  (let ((n (SafeI v)))\n    (and (>= n 2)\n         (not (has_divisor n 2)))))",
      "basic_structure": "(assert (is-IntVal n))",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
        "assert_1": "(define-fun C1 () Bool (and (> (SafeI n) 1) (not (is_prime n))))"
      },
      "constraints": {
        "assert_0": "assert isinstance(n, int), \"invalid inputs",
        "assert_1": "assert n > 1 and not is_prime(n), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/60": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
      "basic_structure": "",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
        "assert_1": "(define-fun C1 () Bool (=> (is-IntVal n) (>= (ival n) 1)))"
      },
      "constraints": {
        "assert_0": "assert type(n) == int, \"invalid inputs",
        "assert_1": "assert n >= 1, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/61": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun MaxStrLen () Int 32)\n(define-fun SafeStrLen ((v Value)) Int\n  (ite (is-StrVal v) (str.len (sval v)) 0))",
      "basic_structure": "(define-fun AllowedParensRe () (RegEx String)\n  (re.* (re.union (str.to.re \"(\") (str.to.re \")\"))))\n(assert (<= (SafeStrLen brackets) MaxStrLen))",
      "inputs": "(declare-const brackets Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (is-StrVal brackets))",
        "assert_1": "(define-fun C1 () Bool\n  (or (not (is-StrVal brackets))\n      (str.in.re (sval brackets) AllowedParensRe)))"
      },
      "constraints": {
        "assert_0": "assert type(brackets) == str, \"invalid inputs",
        "assert_1": "assert all(x in \"()\" for x in brackets)"
      },
      "single_toggles": null
    },
    "HumanEval/62": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec ListLen ((lst Value)) Int\n  (ite (is-Cons lst)\n       (+ 1 (ListLen (tail lst)))\n       0))\n(define-fun-rec IsList ((lst Value)) Bool\n  (ite (is-Nil lst)\n       true\n       (ite (is-Cons lst)\n            (IsList (tail lst))\n            false)))\n(define-fun-rec list_all_numeric ((lst Value)) Bool\n  (ite (is-Nil lst)\n       true\n       (ite (and (is-Cons lst)\n                 (or (is-IntVal (head lst))\n                     (is-FloatVal (head lst))))\n            (list_all_numeric (tail lst))\n            false)))",
      "basic_structure": "(assert (IsList xs))\n(assert (<= (ListLen xs) 32))",
      "inputs": "(declare-const xs Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (and (IsList xs)\n       (> (ListLen xs) 0)))",
        "assert_1": "(define-fun C1 () Bool\n  (and (IsList xs)\n       (list_all_numeric xs)))"
      },
      "constraints": {
        "assert_0": "assert len(xs) > 0, \"invalid inputs",
        "assert_1": "assert all(type(x) in (int, float) for x in xs), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/63": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeIval ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
      "basic_structure": "",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
        "assert_1": "(define-fun C1 () Bool (and (is-IntVal n) (>= (ival n) 0)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(n, int), \"invalid inputs",
        "assert_1": "assert n >= 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/64": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "(assert (is-StrVal s))",
      "inputs": "(declare-const s Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal s))"
      },
      "constraints": {
        "assert_0": "assert type(s) == str, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/65": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const x Value)\n(declare-const shift Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (and (is-IntVal x) (is-IntVal shift)))",
        "assert_1": "(define-fun C1 () Bool (and (is-IntVal x) (is-IntVal shift) (>= (ival x) 0) (>= (ival shift) 0)))"
      },
      "constraints": {
        "assert_0": "assert type(x) == type(shift) == int, \"invalid inputs",
        "assert_1": "assert x >= 0 and shift >= 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/66": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeS ((v Value)) String (ite (is-StrVal v) (sval v) \"\"))",
      "basic_structure": "(assert (<= (str.len (SafeS s)) 32))",
      "inputs": "(declare-const s Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal s))"
      },
      "constraints": {
        "assert_0": "assert type(s) == str, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/67": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun DIGIT () (RegEx String) (re.range \"0\" \"9\"))\n(define-fun LETTER () (RegEx String) (re.union (re.range \"A\" \"Z\") (re.range \"a\" \"z\")))\n(define-fun ALNUM () (RegEx String) (re.union LETTER DIGIT))\n(define-fun WORD () (RegEx String) (re.++ LETTER (re.* ALNUM)))\n(define-fun NUM () (RegEx String) (re.++ DIGIT (re.* DIGIT)))\n(define-fun TOKEN () (RegEx String) (re.union WORD NUM))\n(define-fun SP () (RegEx String) (str.to.re \" \"))\n(define-const R5 (RegEx String) (re.++ TOKEN SP TOKEN SP TOKEN SP TOKEN SP TOKEN))\n(define-const RW (RegEx String) (re.++ TOKEN (str.to.re \" apples and \") TOKEN (str.to.re \" oranges\")))\n(define-const RN (RegEx String) (re.++ NUM (str.to.re \" apples and \") NUM (str.to.re \" oranges\")))",
      "basic_structure": "",
      "inputs": "(declare-const s Value)\n(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (and (is-StrVal s) (is-IntVal n)))",
        "assert_1": "(define-fun C1 () Bool (and (is-StrVal s) (str.in.re (sval s) R5)))",
        "assert_2": "(define-fun C2 () Bool (and (is-StrVal s) (str.in.re (sval s) RW)))",
        "assert_3": "(define-fun C3 () Bool (and (is-StrVal s) (str.in.re (sval s) RN)))",
        "assert_4": "(define-fun C4 () Bool (and (is-StrVal s) (is-IntVal n) (let ((sep1 \" apples and \") (sep2 \" oranges\") (S (sval s))) (let ((i1 (str.indexof S sep1 0))) (and (>= i1 0) (let ((x (str.substr S 0 i1)) (start2 (+ i1 (str.len sep1)))) (let ((i2 (str.indexof S sep2 start2))) (and (>= i2 0) (let ((y (str.substr S start2 (- i2 start2)))) (and (str.in.re x NUM) (str.in.re y NUM) (>= (ival n) (+ (str.to.int x) (str.to.int y)))))))))))))"
      },
      "constraints": {
        "assert_0": "assert type(s) == str and type(n) == int, \"invalid inputs",
        "assert_1": "assert len(words) == 5, \"invalid inputs",
        "assert_2": "assert words[1] == \"apples\" and words[2] == \"and\" and words[4] == \"oranges\", \"invalid inputs",
        "assert_3": "assert words[0].isdigit() and words[3].isdigit(), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/68": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec list_len ((v Value)) Int\n  (ite (is-Cons v)\n       (+ 1 (list_len (tail v)))\n       0))\n\n(define-fun-rec list_all_int_nonneg ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (is-IntVal (head v))\n                 (>= (ival (head v)) 0)\n                 (list_all_int_nonneg (tail v)))\n            false)))",
      "basic_structure": "(assert (IsList arr))",
      "inputs": "(declare-const arr Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (<= (list_len arr) 10000))",
        "assert_1": "(define-fun C1 () Bool (list_all_int_nonneg arr))"
      },
      "constraints": {
        "assert_0": "assert len(arr) <= 10000, \"invalid inputs",
        "assert_1": "assert all(type(val) == int and val >= 0 for val in arr), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/69": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((lst Value)) Bool\n  (or (is-Nil lst)\n      (and (is-Cons lst)\n           (IsList (tail lst)))))\n\n(define-fun-rec All_Ints ((lst Value)) Bool\n  (ite (is-Nil lst)\n       true\n       (and (is-Cons lst)\n            (let ((h (head lst))\n                  (t (tail lst)))\n              (and (is-IntVal h)\n                   (All_Ints t))))))\n\n(define-fun-rec ListLen ((lst Value)) Int\n  (ite (is-Nil lst)\n       0\n       (ite (is-Cons lst)\n            (+ 1 (ListLen (tail lst)))\n            0)))\n\n(define-fun-rec All_Pos ((lst Value)) Bool\n  (ite (is-Nil lst)\n       true\n       (and (is-Cons lst)\n            (let ((h (head lst))\n                  (t (tail lst)))\n              (and (> (ival h) 0)\n                   (All_Pos t))))))",
      "basic_structure": "(assert (IsList lst))\n(assert (All_Ints lst))\n(assert (<= (ListLen lst) 32))",
      "inputs": "(declare-const lst Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (All_Pos lst))"
      },
      "constraints": {
        "assert_0": "assert all(type(val) == int and val > 0 for val in lst), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/70": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec ListLen ((v Value)) Int\n  (ite (is-Nil v)\n       0\n       (ite (is-Cons v)\n            (+ 1 (ListLen (tail v)))\n            0)))\n(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n(define-fun-rec AllInt ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (is-IntVal (head v))\n                 (AllInt (tail v)))\n            false)))",
      "basic_structure": "(<= (ListLen lst) 32)",
      "inputs": "(declare-const lst Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList lst))",
        "assert_1": "(define-fun C1 () Bool (AllInt lst))"
      },
      "constraints": {
        "assert_0": "assert type(lst) == list, \"invalid inputs",
        "assert_1": "assert all(type(x) == int for x in lst), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/71": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun is-numeric ((v Value)) Bool (or (is-IntVal v) (is-FloatVal v)))\n(define-fun safe-to-real ((v Value)) Real\n  (ite (is-IntVal v) (to_real (ival v))\n    (ite (is-FloatVal v) (fval v) 0)))",
      "basic_structure": "(assert (is-numeric a))\n(assert (is-numeric b))\n(assert (is-numeric c))\n(let ((ra (safe-to-real a)) (rb (safe-to-real b)) (rc (safe-to-real c)))\n  (assert (and (<= (- 1000) ra) (<= ra 1000)\n               (<= (- 1000) rb) (<= rb 1000)\n               (<= (- 1000) rc) (<= rc 1000))))",
      "inputs": "(declare-const a Value)\n(declare-const b Value)\n(declare-const c Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (> (safe-to-real a) 0))",
        "assert_1": "(define-fun C1 () Bool (> (safe-to-real b) 0))",
        "assert_2": "(define-fun C2 () Bool (> (safe-to-real c) 0))"
      },
      "constraints": {
        "assert_0": "assert a > 0 and b > 0 and c > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/72": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun is_ListVal ((v Value)) Bool (or (is-Nil v) (is-Cons v)))\n(define-fun-rec list_length ((v Value)) Int\n  (ite (is-Nil v)\n       0\n       (ite (is-Cons v)\n            (+ 1 (list_length (tail v)))\n            0)))\n(define-fun-rec list_all_numeric ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (or (is-IntVal (head v)) (is-FloatVal (head v)))\n                 (list_all_numeric (tail v)))\n            false)))\n(define-fun safe_to_real ((v Value)) Real\n  (ite (is-IntVal v)\n       (to_real (ival v))\n       (ite (is-FloatVal v)\n            (fval v)\n            0.0)))\n(define-fun-rec sum_list ((v Value)) Real\n  (ite (is-Nil v)\n       0.0\n       (ite (is-Cons v)\n            (+ (safe_to_real (head v)) (sum_list (tail v)))\n            0.0)))",
      "basic_structure": "(<= (list_length q) 32)",
      "inputs": "(declare-const q Value)\n(declare-const w Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (and (is_ListVal q) (list_all_numeric q)))",
        "assert_1": "(define-fun C1 () Bool (or (is-IntVal w) (is-FloatVal w)))"
      },
      "constraints": {
        "assert_0": "assert type(q) == list and all(type(x) in [int, float] for x in q), \"invalid inputs",
        "assert_1": "assert type(w) in [int, float], \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/73": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec ListLen ((v Value)) Int\n  (ite (is-Cons v)\n       (+ 1 (ListLen (tail v)))\n       0))\n(define-fun-rec IsList ((v Value)) Bool\n  (or (is-Nil v)\n      (and (is-Cons v)\n           (IsList (tail v)))))\n(define-fun-rec list_all_int ((v Value)) Bool\n  (ite (is-Cons v)\n       (and (is-IntVal (head v))\n            (list_all_int (tail v)))\n       (is-Nil v)))",
      "basic_structure": "(assert (IsList arr))\n(assert (<= (ListLen arr) 32))",
      "inputs": "(declare-const arr Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList arr))",
        "assert_1": "(define-fun C1 () Bool (list_all_int arr))"
      },
      "constraints": {
        "assert_0": "assert type(arr) == list, \"invalid inputs",
        "assert_1": "assert all(type(x) == int for x in arr), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/74": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec list_all_str ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (is-StrVal (head v))\n                 (list_all_str (tail v)))\n            false)))",
      "basic_structure": "",
      "inputs": "(declare-const lst1 Value)\n(declare-const lst2 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (and (IsList lst1)\n       (IsList lst2)))",
        "assert_1": "(define-fun C1 () Bool\n  (=> (IsList lst1)\n      (list_all_str lst1)))",
        "assert_2": "(define-fun C2 () Bool\n  (=> (IsList lst2)\n      (list_all_str lst2)))"
      },
      "constraints": {
        "assert_0": "assert type(lst1) == type(lst2) == list, \"invalid inputs",
        "assert_1": "assert all(type(x) == str for x in lst1), \"invalid inputs",
        "assert_2": "assert all(type(x) == str for x in lst2), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/75": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
      "basic_structure": "",
      "inputs": "(declare-const a Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal a))",
        "assert_1": "(define-fun C1 () Bool (or (not (is-IntVal a)) (< (SafeI a) 100)))"
      },
      "constraints": {
        "assert_0": "assert type(a) == int, \"invalid inputs",
        "assert_1": "assert a < 100, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/76": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))\n(define-fun abs_int ((i Int)) Int (ite (< i 0) (- i) i))",
      "basic_structure": "",
      "inputs": "(declare-const x Value)\n(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (and (is-IntVal x) (is-IntVal n)))"
      },
      "constraints": {
        "assert_0": "assert type(x) == int and type(n) == int, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/77": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "(assert (is-IntVal a))",
      "inputs": "(declare-const a Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool true)"
      },
      "constraints": {
        "assert_0": "assert type(a) == int, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/78": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec str_all_hex ((s String) (i Int)) Bool\n  (ite (< i 0)\n       true\n       (let ((ch (str.at s i)))\n         (and (str.in.re ch (str.to.re \"0123456789ABCDEF\"))\n              (str_all_hex s (- i 1))))))",
      "basic_structure": "(assert (is-StrVal num))\n(assert (<= (str.len (sval num)) 32))",
      "inputs": "(declare-const num Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (str_all_hex (sval num) (- (str.len (sval num)) 1)))"
      },
      "constraints": {
        "assert_0": "assert all(x in \"0123456789ABCDEF\" for x in num), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/79": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeI ((v Value)) Int\n  (ite (is-IntVal v) (ival v) 0))",
      "basic_structure": "",
      "inputs": "(declare-const decimal Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (is-IntVal decimal))",
        "assert_1": "(define-fun C1 () Bool\n  (and (is-IntVal decimal)\n       (>= (SafeI decimal) 0)))"
      },
      "constraints": {
        "assert_0": "assert type(decimal) == int, \"invalid inputs",
        "assert_1": "assert decimal >= 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/80": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeStrLen ((v Value)) Int\n  (ite (is-StrVal v) (str.len (sval v)) 0))\n(define-fun SafeCharAt ((v Value) (i Int)) String\n  (ite (is-StrVal v) (str.at (sval v) i) \"\"))",
      "basic_structure": "",
      "inputs": "(declare-const s Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (is-StrVal s))"
      },
      "constraints": {
        "assert_0": "assert type(s) == str, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/81": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun ValueToReal ((v Value)) Real\n  (ite (is-IntVal v)\n       (to_real (ival v))\n       (ite (is-FloatVal v)\n            (fval v)\n            0.0)))\n\n(define-fun IsList ((v Value)) Bool\n  (or (is-Nil v)\n      (is-Cons v)))\n\n(define-fun-rec ListLen ((v Value)) Int\n  (ite (is-Nil v)\n       0\n       (ite (is-Cons v)\n            (+ 1 (ListLen (tail v)))\n            0)))\n\n(define-fun-rec list_all_numeric ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (or (is-IntVal (head v)) (is-FloatVal (head v)))\n                 (list_all_numeric (tail v)))\n            false)))\n\n(define-fun-rec list_all_in_range ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (<= 0.0 (ValueToReal (head v)))\n                 (<= (ValueToReal (head v)) 4.0)\n                 (list_all_in_range (tail v)))\n            false)))",
      "basic_structure": "(assert (IsList grades))\n(assert (<= (ListLen grades) 32))\n(assert (list_all_numeric grades))",
      "inputs": "(declare-const grades Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (list_all_in_range grades))"
      },
      "constraints": {
        "assert_0": "assert all(0.0 <= x <= 4.0 for x in grades), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/82": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeS ((v Value)) String (ite (is-StrVal v) (sval v) \"\"))\n(define-fun-rec exists_divisor ((a Int) (x Int)) Bool\n  (ite (> (* x x) a)\n       false\n       (ite (= (mod a x) 0)\n            true\n            (exists_divisor a (+ x 1)))))\n(define-fun is_prime ((a Int)) Bool\n  (and (>= a 2) (not (exists_divisor a 2))))",
      "basic_structure": "(<= (str.len (SafeS string)) 32)",
      "inputs": "(declare-const string Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal string))"
      },
      "constraints": {
        "assert_0": "assert type(string) == str, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/83": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
        "assert_1": "(define-fun C1 () Bool (and (is-IntVal n) (> (ival n) 0)))"
      },
      "constraints": {
        "assert_0": "assert type(n) == int and n > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/84": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
      "basic_structure": "",
      "inputs": "(declare-const N Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal N))",
        "assert_1": "(define-fun C1 () Bool (and (is-IntVal N) (> (ival N) 0) (<= (ival N) 10000)))"
      },
      "constraints": {
        "assert_0": "assert type(N) == int, \"invalid inputs",
        "assert_1": "assert 0 < N <= 10000, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/85": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec list_len ((xs Value)) Int\n  (ite (is-Nil xs) 0\n       (+ 1 (list_len (tail xs)))))\n\n(define-fun-rec IsList ((xs Value)) Bool\n  (ite (is-Nil xs) true\n       (ite (is-Cons xs)\n            (IsList (tail xs))\n            false)))\n\n(define-fun-rec list_all_int ((xs Value)) Bool\n  (ite (is-Nil xs) true\n       (ite (is-Cons xs)\n            (and (is-IntVal (head xs))\n                 (list_all_int (tail xs)))\n            true)))",
      "basic_structure": "(assert (IsList lst))\n(assert (<= (list_len lst) 32))",
      "inputs": "(declare-const lst Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (> (list_len lst) 0))",
        "assert_1": "(define-fun C1 () Bool (list_all_int lst))"
      },
      "constraints": {
        "assert_0": "assert len(lst) > 0, \"invalid inputs",
        "assert_1": "assert all(type(x) == int for x in lst), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/86": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const s Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal s))"
      },
      "constraints": {
        "assert_0": "assert type(s) == str, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/87": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec ListLen ((l Value)) Int\n  (ite (is-Nil l) 0\n    (ite (is-Cons l)\n      (+ 1 (ListLen (tail l)))\n      0)))\n(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v) true\n    (ite (is-Cons v)\n      (IsList (tail v))\n      false)))\n(define-fun-rec ListElemsAreList ((v Value)) Bool\n  (ite (is-Nil v) true\n    (ite (is-Cons v)\n      (and (IsList (head v)) (ListElemsAreList (tail v)))\n      false)))",
      "basic_structure": "(assert (<= (ListLen lst) 32))",
      "inputs": "(declare-const lst Value)\n(declare-const x Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (is-IntVal x))",
        "assert_1": "(define-fun C1 () Bool\n  (IsList lst))",
        "assert_2": "(define-fun C2 () Bool\n  (ListElemsAreList lst))"
      },
      "constraints": {
        "assert_0": "assert type(x) == int, \"invalid inputs",
        "assert_1": "assert type(lst) == list, \"invalid inputs",
        "assert_2": "assert all(type(y) == list for y in lst), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/88": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec list_all_non_negative ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (let ((h (head v)) (t (tail v)))\n              (and (is-IntVal h)\n                   (>= (ival h) 0)\n                   (list_all_non_negative t)))\n            false)))",
      "basic_structure": "(assert (IsList array))",
      "inputs": "(declare-const array Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (list_all_non_negative array))"
      },
      "constraints": {
        "assert_0": "assert all(x >= 0 for x in array), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/89": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "(assert (is-StrVal s))",
      "inputs": "(declare-const s Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (or (= (sval s) \"\")\n      (str.in.re (sval s) (str.to.re \"[a-z]*\"))))"
      },
      "constraints": {
        "assert_0": "assert s == \"\" or s.islower(), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/90": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun IsList ((v Value)) Bool (or (is-Nil v) (is-Cons v)))\n\n(define-fun-rec ListLen ((lst Value)) Int\n  (ite (is-Cons lst)\n       (+ 1 (ListLen (tail lst)))\n       0))\n\n(define-fun-rec list_all_int ((lst Value)) Bool\n  (ite (is-Cons lst)\n       (and (is-IntVal (head lst)) (list_all_int (tail lst)))\n       true))",
      "basic_structure": "(assert (IsList lst))\n(assert (<= (ListLen lst) 32))",
      "inputs": "(declare-const lst Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (list_all_int lst))"
      },
      "constraints": {
        "assert_0": "assert all(type(x) == int for x in lst), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/91": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const S Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal S))"
      },
      "constraints": {
        "assert_0": "assert type(S) == str, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/92": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun is-numeric-or-bool ((v Value)) Bool (or (is-IntVal v) (is-FloatVal v) (is-BoolVal v)))",
      "basic_structure": "",
      "inputs": "(declare-const x Value)\n(declare-const y Value)\n(declare-const z Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (and (is-numeric-or-bool x) (is-numeric-or-bool y) (is-numeric-or-bool z)))"
      },
      "constraints": {
        "assert_0": "assert all(isinstance(v, (int, float, bool)) for v in [x, y, z]), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/93": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeS ((v Value)) String\n  (ite (is-StrVal v) (sval v) \"\"))\n\n(define-fun LetterRe () (RegEx String)\n  (re.union (re.range \"A\" \"Z\") (re.range \"a\" \"z\")))",
      "basic_structure": "(define-fun msgStr () String (SafeS message))\n(assert (<= (str.len msgStr) 32))",
      "inputs": "(declare-const message Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (is-StrVal message))",
        "assert_1": "(define-fun C1 () Bool\n  (forall ((i Int))\n    (=> (and (>= i 0) (< i (str.len msgStr)))\n        (or (= (str.at msgStr i) \" \")\n            (str.in.re (str.at msgStr i) LetterRe)))))"
      },
      "constraints": {
        "assert_0": "assert type(message) == str, \"invalid inputs",
        "assert_1": "assert all(ch == \" \" or ch.isalpha() for ch in message), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/94": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec ListLen ((lst Value)) Int\n  (ite (is-Nil lst) 0\n    (ite (is-Cons lst) (+ 1 (ListLen (tail lst))) 0)))\n\n(define-fun-rec list_all_int ((lst Value)) Bool\n  (ite (is-Nil lst) true\n    (ite (is-Cons lst)\n      (and (is-IntVal (head lst)) (list_all_int (tail lst)))\n      false)))\n\n(define-fun-rec is_prime_aux ((a Int) (x Int)) Bool\n  (ite (> (* x x) a) true\n    (ite (= (mod a x) 0) false\n      (is_prime_aux a (+ x 1)))))\n\n(define-fun is_prime ((a Value)) Bool\n  (ite (is-IntVal a)\n    (let ((ai (ival a))) (and (>= ai 2) (is_prime_aux ai 2)))\n    false))\n\n(define-fun-rec list_any_prime ((lst Value)) Bool\n  (ite (is-Nil lst) false\n    (ite (is-Cons lst)\n      (or (is_prime (head lst)) (list_any_prime (tail lst)))\n      false)))",
      "basic_structure": "(assert (list_all_int lst))\n(assert (<= (ListLen lst) 32))",
      "inputs": "(declare-const lst Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (list_any_prime lst))"
      },
      "constraints": {
        "assert_0": "assert any(is_prime(x) for x in lst), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/95": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun IsKV2 ((p Value)) Bool\n  (and (is-Cons p)\n       (is-Cons (tail p))\n       (is-Nil (tail (tail p)))\n       (is-StrVal (head p))))\n\n(define-fun-rec IsDictLike ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (IsKV2 (head v)) (IsDictLike (tail v)))\n            false)))\n\n(define-fun-rec KeysV ((v Value)) Value\n  (ite (is-Nil v)\n       Nil\n       (Cons (head (head v)) (KeysV (tail v)))))",
      "basic_structure": "(assert (=> (IsDictLike dict)\n                 (IsList (KeysV dict))))",
      "inputs": "(declare-const dict Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (IsDictLike dict))"
      },
      "constraints": {
        "assert_0": "assert type(dict).__name__ == \"dict\", \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/96": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))\n(define-fun MAX_N () Int 32)",
      "basic_structure": "(assert (<= (SafeI n) MAX_N))",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
        "assert_1": "(define-fun C1 () Bool (and (is-IntVal n) (>= (SafeI n) 0)))"
      },
      "constraints": {
        "assert_0": "assert type(n) == int and n >= 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/97": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const a Value)\n(declare-const b Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (and (is-IntVal a) (is-IntVal b)))"
      },
      "constraints": {
        "assert_0": "assert type(a) == type(b) == int, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/98": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const s Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal s))"
      },
      "constraints": {
        "assert_0": "assert type(s) == str, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/99": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(declare-fun str_to_real (String) Real)\n(declare-fun is_inf (Real) Bool)\n(declare-fun is_nan (Real) Bool)\n(define-fun ValToReal ((v Value)) Real\n  (ite (is-StrVal v)\n       (str_to_real (sval v))\n       0))",
      "basic_structure": "",
      "inputs": "(declare-const value Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (is-StrVal value))",
        "assert_1": "(define-fun C1 () Bool\n  (not (or (is_inf (ValToReal value))\n           (is_nan (ValToReal value)))))"
      },
      "constraints": {
        "assert_0": "assert isinstance(value, str)",
        "assert_1": "assert not (math.isinf(value) or math.isnan(value)), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/100": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
      "basic_structure": "(assert (is-IntVal n))\n(assert (<= (SafeI n) 32))",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (>= (SafeI n) 1))"
      },
      "constraints": {
        "assert_0": "assert type(n) == int and n >= 1, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/101": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "(assert (is-StrVal s))",
      "inputs": "(declare-const s Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal s))"
      },
      "constraints": {
        "assert_0": "assert isinstance(s, str), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/102": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
      "basic_structure": "",
      "inputs": "(declare-const x Value)\n(declare-const y Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (and (is-IntVal x) (is-IntVal y)))",
        "assert_1": "(define-fun C1 () Bool (and (is-IntVal x) (> (ival x) 0) (is-IntVal y) (> (ival y) 0)))"
      },
      "constraints": {
        "assert_0": "assert type(x) == int and type(y) == int, \"invalid inputs",
        "assert_1": "assert x > 0 and y > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/103": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeIval ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
      "basic_structure": "(assert (<= (SafeIval n) 1000))\n(assert (>= (SafeIval n) -1000))\n(assert (<= (SafeIval m) 1000))\n(assert (>= (SafeIval m) -1000))",
      "inputs": "(declare-const n Value)\n(declare-const m Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
        "assert_1": "(define-fun C1 () Bool (is-IntVal m))",
        "assert_2": "(define-fun C2 () Bool (and (is-IntVal n) (> (SafeIval n) 0)))",
        "assert_3": "(define-fun C3 () Bool (and (is-IntVal m) (> (SafeIval m) 0)))"
      },
      "constraints": {
        "assert_0": "assert type(n) == int and type(m) == int, \"invalid inputs",
        "assert_1": "assert n > 0 and m > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/104": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec ListLen ((v Value)) Int\n  (ite (is-Nil v)\n       0\n       (ite (is-Cons v)\n            (+ 1 (ListLen (tail v)))\n            0)))\n\n(define-fun-rec all_pos_int ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (let ((h (head v)) (t (tail v)))\n              (and (is-IntVal h)\n                   (> (ival h) 0)\n                   (all_pos_int t)))\n            false)))",
      "basic_structure": "(assert (<= (ListLen x) 32))",
      "inputs": "(declare-const x Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (IsList x))",
        "assert_1": "(define-fun C1 () Bool\n  (all_pos_int x))"
      },
      "constraints": {
        "assert_0": "assert type(x) == list, \"invalid inputs",
        "assert_1": "assert all(type(num) == int and num > 0 for num in x), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/105": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec list_len ((v Value)) Int\n  (ite (is-Nil v)\n       0\n       (ite (is-Cons v)\n            (+ 1 (list_len (tail v)))\n            0)))\n\n(define-fun-rec list_all_int ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (ite (is-IntVal (head v))\n                 (list_all_int (tail v))\n                 false)\n            true)))",
      "basic_structure": "(assert (<= (list_len arr) 32))",
      "inputs": "(declare-const arr Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (IsList arr))",
        "assert_1": "(define-fun C1 () Bool\n  (ite (IsList arr)\n       (list_all_int arr)\n       true))"
      },
      "constraints": {
        "assert_0": "assert type(arr) == list, \"invalid inputs",
        "assert_1": "assert all(type(x) == int for x in arr), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/106": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
      "basic_structure": "(assert (<= (SafeI n) 32))\n(assert (>= (SafeI n) -32))",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
        "assert_1": "(define-fun C1 () Bool (=> (is-IntVal n) (>= (SafeI n) 0)))"
      },
      "constraints": {
        "assert_0": "assert type(n) == int, \"invalid inputs",
        "assert_1": "assert n >= 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/107": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
      "basic_structure": "(assert true)",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
        "assert_1": "(define-fun C1 () Bool (and (<= 1 (SafeI n)) (<= (SafeI n) 1000)))"
      },
      "constraints": {
        "assert_0": "assert type(n) == int, \"invalid inputs",
        "assert_1": "assert 1 <= n <= 1000, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/108": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec ListLen ((v Value)) Int\n  (ite (is-Nil v)\n       0\n       (ite (is-Cons v)\n            (+ 1 (ListLen (tail v)))\n            0)))\n(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n(define-fun-rec list_all_int ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (is-IntVal (head v))\n                 (list_all_int (tail v)))\n            false)))",
      "basic_structure": "(assert (IsList arr))\n(assert (<= (ListLen arr) 32))",
      "inputs": "(declare-const arr Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList arr))",
        "assert_1": "(define-fun C1 () Bool (or (not (IsList arr)) (list_all_int arr)))"
      },
      "constraints": {
        "assert_0": "assert type(arr) == list, \"invalid inputs",
        "assert_1": "assert all(type(x) == int for x in arr), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/109": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeI ((v Value)) Int\n  (ite (is-IntVal v) (ival v) 0))\n\n(define-fun-rec IsList ((l Value)) Bool\n  (or (is-Nil l)\n      (and (is-Cons l)\n           (IsList (tail l)))))\n\n(define-fun-rec ListLen ((l Value)) Int\n  (ite (is-Nil l)\n       0\n       (+ 1 (ListLen (tail l)))))\n\n(define-fun-rec list_all_int ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (and (is-Cons l)\n            (is-IntVal (head l))\n            (list_all_int (tail l)))))\n\n(define-fun-rec list_elem ((l Value) (x Int)) Bool\n  (ite (is-Nil l)\n       false\n       (let ((h (head l)) (t (tail l)))\n         (let ((hVal (SafeI h)))\n           (ite (= hVal x)\n                true\n                (list_elem t x))))))\n\n(define-fun-rec list_all_unique ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (let ((h (head l)) (t (tail l)))\n         (let ((hVal (SafeI h)))\n           (and (not (list_elem t hVal))\n                (list_all_unique t))))))",
      "basic_structure": "(assert (IsList arr))\n(assert (<= (ListLen arr) 32))",
      "inputs": "(declare-const arr Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList arr))",
        "assert_1": "(define-fun C1 () Bool (list_all_int arr))",
        "assert_2": "(define-fun C2 () Bool (list_all_unique arr))",
        "assert_3": "(define-fun C3 () Bool (list_all_int arr))"
      },
      "constraints": {
        "assert_0": "assert type(arr) == list, \"invalid inputs",
        "assert_1": "assert all(type(x) == int for x in arr), \"invalid inputs",
        "assert_2": "assert len(set(arr)) == len(arr), \"invalid inputs",
        "assert_3": "assert all(type(x) == int for x in arr), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/110": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec ListLen ((lst Value)) Int\n  (ite (is-Nil lst)\n       0\n       (ite (is-Cons lst)\n            (+ 1 (ListLen (tail lst)))\n            0)))\n\n(define-fun-rec list_all_int ((lst Value)) Bool\n  (ite (is-Nil lst)\n       true\n       (ite (is-Cons lst)\n            (and (is-IntVal (head lst))\n                 (list_all_int (tail lst)))\n            false)))",
      "basic_structure": "(assert (IsList lst1))\n(assert (IsList lst2))\n(assert (<= (ListLen lst1) 32))\n(assert (<= (ListLen lst2) 32))",
      "inputs": "(declare-const lst1 Value)\n(declare-const lst2 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool true)",
        "assert_1": "(define-fun C1 () Bool (list_all_int lst1))",
        "assert_2": "(define-fun C2 () Bool (list_all_int lst2))",
        "assert_3": "(define-fun C3 () Bool (and (> (ListLen lst1) 0)\n                              (> (ListLen lst2) 0)))"
      },
      "constraints": {
        "assert_0": "assert type(lst1) == list and type(lst2) == list, \"invalid inputs",
        "assert_1": "assert all(type(x) == int for x in lst1), \"invalid inputs",
        "assert_2": "assert all(type(x) == int for x in lst2), \"invalid inputs",
        "assert_3": "assert len(lst1) > 0 and len(lst2) > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/111": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeS ((v Value)) String (ite (is-StrVal v) (sval v) \"\"))",
      "basic_structure": "(assert (is-StrVal test))",
      "inputs": "(declare-const test Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal test))",
        "assert_1": "(define-fun C1 () Bool (let ((s (SafeS test))) (str.in.re s (str.to.re \"^(|[a-z]( [a-z])*)$\"))))"
      },
      "constraints": {
        "assert_0": "assert isinstance(test, str), \"invalid inputs",
        "assert_1": "assert len(word) == 1 and word.islower(), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/112": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "(assert (<= (ite (is-StrVal s) (str.len (sval s)) 0) 32))\n(assert (<= (ite (is-StrVal c) (str.len (sval c)) 0) 32))",
      "inputs": "(declare-const s Value)\n(declare-const c Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (and (is-StrVal s) (is-StrVal c)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(s, str) and isinstance(c, str), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/113": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (or\n    (is-Nil v)\n    (and (is-Cons v)\n         (IsList (tail v))\n    )\n  )\n)\n\n(define-fun-rec list_all_str ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (is-StrVal (head v))\n                 (list_all_str (tail v)))\n            false\n       )\n  )\n)\n\n(define-fun str_all_digits ((s Value)) Bool\n  (and\n    (is-StrVal s)\n    (str.in.re (sval s) (str.to.re \"[0-9]+\"))\n  )\n)\n\n(define-fun-rec list_all_digit_strings ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (str_all_digits (head v))\n                 (list_all_digit_strings (tail v)))\n            false\n       )\n  )\n)",
      "basic_structure": "",
      "inputs": "(declare-const lst Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList lst))",
        "assert_1": "(define-fun C1 () Bool (list_all_str lst))",
        "assert_2": "(define-fun C2 () Bool (list_all_digit_strings lst))"
      },
      "constraints": {
        "assert_0": "assert type(lst) == list, \"invalid inputs",
        "assert_1": "assert all(isinstance(s, str) for s in lst), \"invalid inputs",
        "assert_2": "assert all(s.isdigit() for s in lst), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/114": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (or (is-Nil v)\n      (and (is-Cons v)\n           (IsList (tail v)))))\n\n(define-fun-rec list_all_int ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (and (is-Cons v)\n            (is-IntVal (head v))\n            (list_all_int (tail v)))))\n\n(define-fun-rec length ((v Value)) Int\n  (ite (is-Nil v)\n       0\n       (ite (is-Cons v)\n            (+ 1 (length (tail v)))\n            0)))",
      "basic_structure": "(assert (=> (IsList nums) (list_all_int nums)))",
      "inputs": "(declare-const nums Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (IsList nums))",
        "assert_1": "(define-fun C1 () Bool\n  (> (length nums) 0))"
      },
      "constraints": {
        "assert_0": "assert type(nums) == list, \"invalid inputs",
        "assert_1": "assert len(nums) > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/115": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool (or (is-Nil v) (is-Cons v)))\n(define-fun-rec ListLen ((v Value)) Int\n  (ite (is-Nil v) 0\n    (ite (is-Cons v)\n      (let ((t (ListLen (tail v)))) (+ 1 t))\n      0)))\n(define-fun-rec list_all_numeric ((v Value)) Bool\n  (ite (is-Nil v) true\n    (ite (is-Cons v)\n      (let ((h (head v)))\n        (and (or (is-IntVal h) (is-FloatVal h)) (list_all_numeric (tail v))))\n      false)))\n(define-fun-rec grid_rows_valid ((g Value)) Bool\n  (ite (is-Nil g) true\n    (ite (is-Cons g)\n      (let ((row (head g)))\n        (and (IsList row) (list_all_numeric row) (grid_rows_valid (tail g))))\n      false)))\n(define-fun-rec grid_max_row_len ((g Value)) Int\n  (ite (is-Nil g) 0\n    (ite (is-Cons g)\n      (let ((lenh (ListLen (head g))) (rm (grid_max_row_len (tail g))))\n        (ite (> lenh rm) lenh rm))\n      0)))\n(define-fun-rec grid_min_row_len ((g Value)) Int\n  (ite (is-Cons g)\n    (let ((lenh (ListLen (head g))) (t (tail g)))\n      (ite (is-Nil t)\n        lenh\n        (let ((rm (grid_min_row_len t))) (ite (< lenh rm) lenh rm))))\n    0))\n(define-fun-rec list_all_binary ((v Value)) Bool\n  (ite (is-Nil v) true\n    (ite (is-Cons v)\n      (let ((h (head v)))\n        (and (is-IntVal h)\n             (let ((i (ival h))) (or (= i 0) (= i 1)))\n             (list_all_binary (tail v))))\n      false)))\n(define-fun-rec grid_all_binary ((g Value)) Bool\n  (ite (is-Nil g) true\n    (ite (is-Cons g)\n      (and (list_all_binary (head g)) (grid_all_binary (tail g)))\n      false)))",
      "basic_structure": "(assert (IsList grid))\n(assert (grid_rows_valid grid))\n(assert (is-IntVal capacity))",
      "inputs": "(declare-const grid Value)\n(declare-const capacity Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (let ((l (ListLen grid))) (and (>= l 1) (<= l 100))))",
        "assert_1": "(define-fun C1 () Bool (let ((maxl (grid_max_row_len grid)) (minl (grid_min_row_len grid))) (and (= maxl minl) (>= maxl 1) (<= maxl 100))))",
        "assert_2": "(define-fun C2 () Bool (grid_all_binary grid))",
        "assert_3": "(define-fun C3 () Bool (let ((cap (ival capacity))) (and (>= cap 1) (<= cap 10))))"
      },
      "constraints": {
        "assert_0": "assert 1 <= len(grid) <= 100, \"invalid inputs",
        "assert_1": "assert max(lens) == min(lens) and 1 <= max(lens) <= 100, \"invalid inputs",
        "assert_2": "assert x == 0 or x == 1, \"invalid inputs",
        "assert_3": "assert 1 <= capacity <= 10, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/116": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec ListLen ((v Value)) Int\n  (ite (is-Nil v)\n       0\n       (ite (is-Cons v)\n            (+ 1 (ListLen (tail v)))\n            0)))\n\n(define-fun-rec list_all_int ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (is-IntVal (head v))\n                 (list_all_int (tail v)))\n            false)))\n\n(define-fun-rec list_all_nonneg ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (is-IntVal (head v))\n                 (let ((x (ival (head v))))\n                   (and (>= x 0)\n                        (list_all_nonneg (tail v)))))\n            false)))",
      "basic_structure": "(assert (IsList arr))\n(assert (<= (ListLen arr) 32))",
      "inputs": "(declare-const arr Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (list_all_int arr))",
        "assert_1": "(define-fun C1 () Bool (list_all_nonneg arr))"
      },
      "constraints": {
        "assert_0": "assert isinstance(arr, list), \"invalid inputs",
        "assert_1": "assert all(isinstance(x, int) and x >= 0 for x in arr), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/117": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "(define-fun AllowedRe () (RegEx String)\n  (re.union (re.range \"a\" \"z\") (re.range \"A\" \"Z\") (str.to.re \" \")))",
      "inputs": "(declare-const s Value)\n(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (is-StrVal s))",
        "assert_1": "(define-fun C1 () Bool\n  (and (is-StrVal s)\n       (str.in.re (sval s) AllowedRe)))",
        "assert_2": "(define-fun C2 () Bool\n  (is-IntVal n))",
        "assert_3": "(define-fun C3 () Bool\n  (and (is-IntVal n)\n       (>= (ival n) 0)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(s, str), \"invalid inputs",
        "assert_1": "assert all(ch == \" \" or ch.isalpha() for ch in s), \"invalid inputs",
        "assert_2": "assert type(n) == int, \"invalid inputs",
        "assert_3": "assert n >= 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/118": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec all_alpha ((s String)) Bool\n  (ite (= (str.len s) 0)\n       true\n       (let ((ch (str.at s 0))\n             (rest (str.substr s 1 (- (str.len s) 1))))\n         (and (str.in.re ch (str.to.re \"[A-Za-z]\"))\n              (all_alpha rest)))))",
      "basic_structure": "(assert (is-StrVal word))\n(assert (<= (str.len (sval word)) 32))",
      "inputs": "(declare-const word Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal word))",
        "assert_1": "(define-fun C1 () Bool (or (= (sval word) \"\") (all_alpha (sval word))))"
      },
      "constraints": {
        "assert_0": "assert isinstance(word, str), \"invalid inputs",
        "assert_1": "assert word == \"\" or word.isalpha(), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/119": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun isList ((v Value)) Bool\n  (or (is-Nil v) (is-Cons v)))\n\n(define-fun-rec ListLen ((v Value)) Int\n  (ite (is-Cons v)\n       (+ 1 (ListLen (tail v)))\n       0))\n\n(define-fun-rec list_all_str ((v Value)) Bool\n  (ite (is-Cons v)\n       (and (is-StrVal (head v))\n            (list_all_str (tail v)))\n       true))\n\n(define-fun safe_head ((v Value)) Value\n  (ite (is-Cons v) (head v) Nil))\n\n(define-fun safe_tail ((v Value)) Value\n  (ite (is-Cons v) (tail v) Nil))\n\n(define-fun AllowedParensRe () (RegEx String)\n  (re.* (re.union (str.to.re \"(\") (str.to.re \")\"))))",
      "basic_structure": "(assert (isList lst))\n(assert (<= (ListLen lst) 32))\n(assert (<= (str.len (sval (safe_head lst))) 32))\n(assert (<= (str.len (sval (safe_head (safe_tail lst)))) 32))",
      "inputs": "(declare-const lst Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (isList lst))",
        "assert_1": "(define-fun C1 () Bool\n  (list_all_str lst))",
        "assert_2": "(define-fun C2 () Bool\n  (= (ListLen lst) 2))",
        "assert_3": "(define-fun C3 () Bool\n  (let ((v0 (safe_head lst)))\n    (and (is-StrVal v0)\n         (str.in.re (sval v0) AllowedParensRe))))",
        "assert_4": "(define-fun C4 () Bool\n  (let ((v1 (safe_head (safe_tail lst))))\n    (and (is-StrVal v1)\n         (str.in.re (sval v1) AllowedParensRe))))"
      },
      "constraints": {
        "assert_0": "assert type(lst) == list, \"invalid inputs",
        "assert_1": "assert all(isinstance(s, str) for s in lst), \"invalid inputs",
        "assert_2": "assert len(lst) == 2, \"invalid inputs",
        "assert_3": "assert all(ch == \"(\" or ch == \")\" for ch in lst[0]), \"invalid inputs",
        "assert_4": "assert all(ch == \"(\" or ch == \")\" for ch in lst[1]), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/120": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v) true\n    (ite (is-Cons v) (IsList (tail v)) false)))\n\n(define-fun-rec ListLen ((v Value)) Int\n  (ite (is-Nil v) 0\n    (ite (is-Cons v) (+ 1 (ListLen (tail v))) 0)))\n\n(define-fun-rec list_all_ge_min ((v Value)) Bool\n  (ite (is-Nil v) true\n    (ite (is-Cons v)\n      (let ((h (head v)) (t (tail v)))\n        (and (is-IntVal h)\n             (>= (ival h) -1000)\n             (list_all_ge_min t)))\n      false)))\n\n(define-fun-rec list_all_le_max ((v Value)) Bool\n  (ite (is-Nil v) true\n    (ite (is-Cons v)\n      (let ((h (head v)) (t (tail v)))\n        (and (is-IntVal h)\n             (<= (ival h) 1000)\n             (list_all_le_max t)))\n      false)))",
      "basic_structure": "(assert (<= (ListLen arr) 1000))",
      "inputs": "(declare-const arr Value)\n(declare-const k Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList arr))",
        "assert_1": "(define-fun C1 () Bool (>= (ListLen arr) 1))",
        "assert_2": "(define-fun C2 () Bool (list_all_ge_min arr))",
        "assert_3": "(define-fun C3 () Bool (list_all_le_max arr))",
        "assert_4": "(define-fun C4 () Bool (is-IntVal k))",
        "assert_5": "(define-fun C5 () Bool (>= (ival k) 0))",
        "assert_6": "(define-fun C6 () Bool (<= (ival k) (ListLen arr)))"
      },
      "constraints": {
        "assert_0": "assert type(arr) == list, \"invalid inputs",
        "assert_1": "assert 1 <= len(arr) <= 1000, \"invalid inputs",
        "assert_2": "assert all(-1000 <= x <= 1000 for x in arr), \"invalid inputs",
        "assert_3": "assert type(k) == int, \"invalid inputs",
        "assert_4": "assert 0 <= k <= len(arr), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/121": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec list_all_int ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (is-IntVal (head v))\n                 (list_all_int (tail v)))\n            false)))\n\n(define-fun-rec length ((v Value)) Int\n  (ite (is-Nil v)\n       0\n       (ite (is-Cons v)\n            (+ 1 (length (tail v)))\n            0)))",
      "basic_structure": "(assert (IsList lst))",
      "inputs": "(declare-const lst Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList lst))",
        "assert_1": "(define-fun C1 () Bool (list_all_int lst))",
        "assert_2": "(define-fun C2 () Bool (> (length lst) 0))"
      },
      "constraints": {
        "assert_0": "assert type(lst) == list, \"invalid inputs",
        "assert_1": "assert all(type(x) == int for x in lst), \"invalid inputs",
        "assert_2": "assert len(lst) > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/122": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeI ((v Value)) Int\n  (ite (is-IntVal v) (ival v) 0))\n\n(define-fun-rec Length ((l Value)) Int\n  (ite (is-Cons l)\n       (+ 1 (Length (tail l)))\n       (ite (is-Nil l)\n            0\n            0)))\n\n(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Cons v)\n       (IsList (tail v))\n       (ite (is-Nil v)\n            true\n            false)))\n\n(define-fun-rec list_all_int ((l Value)) Bool\n  (ite (is-Cons l)\n       (and (is-IntVal (head l))\n            (list_all_int (tail l)))\n       true))",
      "basic_structure": "(<= (Length arr) 100)",
      "inputs": "(declare-const arr Value)\n(declare-const k Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList arr))",
        "assert_1": "(define-fun C1 () Bool (list_all_int arr))",
        "assert_2": "(define-fun C2 () Bool (>= (Length arr) 1))",
        "assert_3": "(define-fun C3 () Bool (is-IntVal k))",
        "assert_4": "(define-fun C4 () Bool (>= (SafeI k) 1))",
        "assert_5": "(define-fun C5 () Bool (or (< (Length arr) 1) (<= (SafeI k) (Length arr))))"
      },
      "constraints": {
        "assert_0": "assert type(arr) == list, \"invalid inputs",
        "assert_1": "assert all(type(x) == int for x in arr), \"invalid inputs",
        "assert_2": "assert 1 <= len(arr) <= 100, \"invalid inputs",
        "assert_3": "assert type(k) == int, \"invalid inputs",
        "assert_4": "assert 1 <= k <= len(arr), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/123": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
        "assert_1": "(define-fun C1 () Bool (and (is-IntVal n) (> (ival n) 0)))"
      },
      "constraints": {
        "assert_0": "assert type(n) == int, \"invalid inputs",
        "assert_1": "assert n > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/124": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeS ((v Value)) String\n  (ite (is-StrVal v) (sval v) \"\"))\n\n(define-fun s_len ((v Value)) Int\n  (str.len (SafeS v)))\n\n(define-fun s_char ((v Value) (i Int)) String\n  (str.substr (SafeS v) i 1))\n\n(define-fun str_to_int2 ((v Value)) Int\n  (let ((s (SafeS v))\n        (c0 (str.substr (SafeS v) 0 1))\n        (c1 (str.substr (SafeS v) 1 1)))\n    (+ (* (- (str.to_code c0) 48) 10)\n       (- (str.to_code c1) 48))))",
      "basic_structure": "",
      "inputs": "(declare-const date Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal date))"
      },
      "constraints": {
        "assert_0": "assert isinstance(date, str), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/125": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "(assert (is-StrVal txt))",
      "inputs": "(declare-const txt Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal txt))",
        "assert_1": "(define-fun C1 () Bool (and (is-StrVal txt) (not (str.prefixof \" \" (sval txt))) (not (str.prefixof \",\" (sval txt))) (not (str.suffixof \" \" (sval txt))) (not (str.suffixof \",\" (sval txt)))))"
      },
      "constraints": {
        "assert_0": "assert type(txt) == str, \"invalid inputs",
        "assert_1": "assert not txt.startswith(\" \") and not txt.startswith(\",\") and not txt.endswith(\" \") and not txt.endswith(\",\"), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/126": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (IsList (tail l))\n            false)))\n\n(define-fun-rec all_nonneg_int ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (let ((elem (head l)))\n              (let ((i (ival elem))\n                    (rest (tail l)))\n                (and (is-IntVal elem) (>= i 0) (all_nonneg_int rest))))\n            false)))",
      "basic_structure": "(assert (IsList lst))",
      "inputs": "(declare-const lst Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList lst))",
        "assert_1": "(define-fun C1 () Bool (all_nonneg_int lst))"
      },
      "constraints": {
        "assert_0": "assert type(lst) == list, \"invalid inputs",
        "assert_1": "assert all(type(x) == int and x >= 0 for x in lst), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/127": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec ListLen ((v Value)) Int\n  (ite (is-Nil v)\n       0\n       (ite (is-Cons v)\n            (+ 1 (ListLen (tail v)))\n            0)))\n\n(define-fun-rec list_all_int ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (is-IntVal (head v))\n                 (list_all_int (tail v)))\n            false)))",
      "basic_structure": "(assert (or (is-Nil interval1) (is-Cons interval1)))\n(assert (<= (ListLen interval1) 32))\n(assert (or (is-Nil interval2) (is-Cons interval2)))\n(assert (<= (ListLen interval2) 32))",
      "inputs": "(declare-const interval1 Value)\n(declare-const interval2 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (and\n    (= (ListLen interval1) 2)\n    (<=\n      (ite (and (is-Cons interval1)\n                (is-IntVal (head interval1)))\n           (ival (head interval1))\n           0)\n      (ite (and (is-Cons interval1)\n                (is-Cons (tail interval1))\n                (is-IntVal (head (tail interval1))))\n           (ival (head (tail interval1)))\n           0))))",
        "assert_1": "(define-fun C1 () Bool\n  (list_all_int interval1))",
        "assert_2": "(define-fun C2 () Bool\n  (and\n    (= (ListLen interval2) 2)\n    (<=\n      (ite (and (is-Cons interval2)\n                (is-IntVal (head interval2)))\n           (ival (head interval2))\n           0)\n      (ite (and (is-Cons interval2)\n                (is-Cons (tail interval2))\n                (is-IntVal (head (tail interval2))))\n           (ival (head (tail interval2)))\n           0))))",
        "assert_3": "(define-fun C3 () Bool\n  (list_all_int interval2))"
      },
      "constraints": {
        "assert_0": "assert len(interval1) == 2 and interval1[0] <= interval1[1], \"invalid inputs",
        "assert_1": "assert all(type(x) == int for x in interval1), \"invalid inputs",
        "assert_2": "assert len(interval2) == 2 and interval2[0] <= interval2[1], \"invalid inputs",
        "assert_3": "assert all(type(x) == int for x in interval2), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/128": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v) true\n    (ite (is-Cons v) (IsList (tail v)) false)))\n\n(define-fun-rec list_len ((v Value)) Int\n  (ite (is-Nil v) 0\n    (ite (is-Cons v) (+ 1 (list_len (tail v))) 0)))\n\n(define-fun-rec list_all_ints ((v Value)) Bool\n  (ite (is-Nil v) true\n    (ite (is-Cons v)\n         (and (is-IntVal (head v)) (list_all_ints (tail v)))\n         false)))",
      "basic_structure": "(assert (<= (list_len arr) 32))",
      "inputs": "(declare-const arr Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList arr))",
        "assert_1": "(define-fun C1 () Bool (or (not (IsList arr)) (list_all_ints arr)))"
      },
      "constraints": {
        "assert_0": "assert type(arr) == list, \"invalid inputs",
        "assert_1": "assert all(type(x) == int for x in arr), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/129": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec ListLen ((l Value)) Int\n  (ite (is-Nil l)\n       0\n       (let ((tl (tail l)))\n         (+ 1 (ListLen tl)))))\n\n(define-fun-rec list_append ((l1 Value) (l2 Value)) Value\n  (ite (is-Nil l1)\n       l2\n       (let ((hd (head l1)) (tl (tail l1)))\n         (Cons hd (list_append tl l2)))))\n\n(define-fun-rec list_flatten ((ll Value)) Value\n  (ite (is-Nil ll)\n       Nil\n       (let ((hd (head ll)) (tl (tail ll)))\n         (list_append hd (list_flatten tl)))))\n\n(define-fun-rec list_all_lists ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (let ((hd (head l)) (tl (tail l)))\n         (and (or (is-Nil hd) (is-Cons hd))\n              (list_all_lists tl)))))\n\n(define-fun-rec list_all_ints ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (let ((hd (head l)) (tl (tail l)))\n         (and (is-IntVal hd)\n              (list_all_ints tl)))))\n\n(define-fun-rec list_contains ((l Value) (v Value)) Bool\n  (ite (is-Nil l)\n       false\n       (let ((hd (head l)) (tl (tail l)))\n         (ite (and (is-IntVal hd)\n                   (is-IntVal v)\n                   (= (ival hd) (ival v)))\n              true\n              (list_contains tl v)))))\n\n(define-fun-rec list_no_dup ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (let ((hd (head l)) (tl (tail l)))\n         (and (list_no_dup tl)\n              (not (list_contains tl hd))))))\n\n(define-fun-rec list_all_in_range ((l Value) (low Int) (high Int)) Bool\n  (ite (is-Nil l)\n       true\n       (let ((hd (head l)) (tl (tail l)))\n         (and (is-IntVal hd)\n              (<= low (ival hd))\n              (<= (ival hd) high)\n              (list_all_in_range tl low high)))))\n\n(define-fun-rec all_inner_len_equal ((ll Value) (n Int)) Bool\n  (ite (is-Nil ll)\n       true\n       (let ((hd (head ll)) (tl (tail ll)))\n         (and (= (ListLen hd) n)\n              (all_inner_len_equal tl n)))))",
      "basic_structure": "(assert (is-IntVal k))\n(assert (list_all_lists grid))\n(assert (list_all_ints (list_flatten grid)))",
      "inputs": "(declare-const grid Value)\n(declare-const k Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (is-IntVal k))",
        "assert_1": "(define-fun C1 () Bool\n  (> (ival k) 0))",
        "assert_2": "(define-fun C2 () Bool\n  (>= (ListLen grid) 2))",
        "assert_3": "(define-fun C3 () Bool\n  (all_inner_len_equal grid (ListLen grid)))",
        "assert_4": "(define-fun C4 () Bool\n  (let ((n (ListLen grid))\n        (flat (list_flatten grid)))\n    (and (= (ListLen flat) (* n n))\n         (list_all_in_range flat 1 (* n n))\n         (list_no_dup flat))))"
      },
      "constraints": {
        "assert_0": "assert type(k) == int, \"invalid inputs",
        "assert_1": "assert k > 0, \"invalid inputs",
        "assert_2": "assert len(grid) >= 2, \"invalid inputs",
        "assert_3": "assert all(len(l) == len(grid) for l in grid), \"invalid inputs",
        "assert_4": "assert {x for l in grid for x in l} == set(range(1, len(grid) ** 2 + 1)), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/130": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "(define-fun MAX_N () Int 32)\n(assert (or (not (is-IntVal n))\n            (and (>= (ival n) (- MAX_N))\n                 (<= (ival n) MAX_N))))",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (is-IntVal n))",
        "assert_1": "(define-fun C1 () Bool\n  (and (is-IntVal n)\n       (>= (ival n) 0)))"
      },
      "constraints": {
        "assert_0": "assert type(n) == int, \"invalid inputs",
        "assert_1": "assert n >= 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/131": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeI ((v Value) (default Int)) Int (ite (is-IntVal v) (ival v) default))",
      "basic_structure": "(is-IntVal n)",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
        "assert_1": "(define-fun C1 () Bool (and (is-IntVal n) (> (SafeI n 0) 0)))"
      },
      "constraints": {
        "assert_0": "assert type(n) == int, \"invalid inputs",
        "assert_1": "assert n > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/132": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec all_brackets ((sVal Value) (pos Int)) Bool\n  (ite (not (is-StrVal sVal))\n       false\n       (let ((str (sval sVal))\n             (len (str.len (sval sVal))))\n         (ite (>= pos len)\n              true\n              (let ((ch (str.substr str pos 1)))\n                (ite (or (= ch \"[\") (= ch \"]\"))\n                     (all_brackets sVal (+ pos 1))\n                     false))))))",
      "basic_structure": "",
      "inputs": "(declare-const string Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal string))",
        "assert_1": "(define-fun C1 () Bool (all_brackets string 0))"
      },
      "constraints": {
        "assert_0": "assert isinstance(string, str), \"invalid inputs",
        "assert_1": "assert all(ch == \"[\" or ch == \"]\" for ch in string), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/133": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec ListLen ((v Value)) Int\n  (ite (is-Nil v)\n    0\n    (ite (is-Cons v)\n      (+ 1 (ListLen (tail v)))\n      0)))\n\n(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n    true\n    (ite (is-Cons v)\n      (IsList (tail v))\n      false)))\n\n(define-fun-rec list_all_numeric ((v Value)) Bool\n  (ite (is-Nil v)\n    true\n    (ite (is-Cons v)\n      (and (or (is-IntVal (head v)) (is-FloatVal (head v)))\n           (list_all_numeric (tail v)))\n      false)))",
      "basic_structure": "(assert (IsList lst))\n(assert (<= (ListLen lst) 32))",
      "inputs": "(declare-const lst Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList lst))",
        "assert_1": "(define-fun C1 () Bool (list_all_numeric lst))"
      },
      "constraints": {
        "assert_0": "assert type(lst) == list, \"invalid inputs",
        "assert_1": "assert all(type(x) in [int, float] for x in lst), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/134": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "(assert (is-StrVal txt))\n(assert (<= (str.len (sval txt)) 32))",
      "inputs": "(declare-const txt Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal txt))"
      },
      "constraints": {
        "assert_0": "assert type(txt) == str, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/135": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((x Value)) Bool (ite (is-Nil x) true (ite (is-Cons x) (IsList (tail x)) false)))\n(define-fun-rec ListLen ((x Value)) Int (ite (is-Nil x) 0 (ite (is-Cons x) (+ 1 (ListLen (tail x))) 0)))\n(define-fun SafeRealVal ((v Value)) Real (ite (is-IntVal v) (to_real (ival v)) (ite (is-FloatVal v) (fval v) 0)))\n(define-fun-rec ListAllNumeric ((x Value)) Bool (ite (is-Nil x) true (ite (is-Cons x) (and (or (is-IntVal (head x)) (is-FloatVal (head x))) (ListAllNumeric (tail x))) false)))\n(define-fun-rec ListContains ((v Value) (lst Value)) Bool (ite (is-Nil lst) false (ite (is-Cons lst) (or (= (SafeRealVal v) (SafeRealVal (head lst))) (ListContains v (tail lst))) false)))\n(define-fun-rec ListNoDup ((x Value)) Bool (ite (is-Nil x) true (ite (is-Cons x) (and (not (ListContains (head x) (tail x))) (ListNoDup (tail x))) false)))",
      "basic_structure": "(assert (<= (ListLen arr) 32))",
      "inputs": "(declare-const arr Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList arr))",
        "assert_1": "(define-fun C1 () Bool (ListAllNumeric arr))",
        "assert_2": "(define-fun C2 () Bool (ListNoDup arr))"
      },
      "constraints": {
        "assert_0": "assert type(arr) == list, \"invalid inputs",
        "assert_1": "assert all(type(x) in [int, float] for x in arr), \"invalid inputs",
        "assert_2": "assert len(arr) == len(set(arr)), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/136": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec is_list ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (is_list (tail v))\n            false)))\n\n(define-fun-rec list_len ((v Value)) Int\n  (ite (is-Nil v)\n       0\n       (ite (is-Cons v)\n            (+ 1 (list_len (tail v)))\n            0)))\n\n(define-fun-rec list_all_ints ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (is-IntVal (head v))\n                 (list_all_ints (tail v)))\n            false)))",
      "basic_structure": "(assert (<= (list_len lst) 32))",
      "inputs": "(declare-const lst Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is_list lst))",
        "assert_1": "(define-fun C1 () Bool (or (not (is_list lst)) (list_all_ints lst)))"
      },
      "constraints": {
        "assert_0": "assert type(lst) == list, \"invalid inputs",
        "assert_1": "assert all(type(x) == int for x in lst), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/137": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const a Value)\n(declare-const b Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (or (is-IntVal a) (is-FloatVal a) (is-StrVal a)))",
        "assert_1": "(define-fun C1 () Bool (or (is-IntVal b) (is-FloatVal b) (is-StrVal b)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(a, (int, float, str)), \"invalid inputs",
        "assert_1": "assert isinstance(b, (int, float, str)), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/138": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
      "basic_structure": "",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))"
      },
      "constraints": {
        "assert_0": "assert type(n) == int, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/139": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
      "basic_structure": "",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
        "assert_1": "(define-fun C1 () Bool (and (is-IntVal n) (> (SafeI n) 0)))"
      },
      "constraints": {
        "assert_0": "assert type(n) == int, \"invalid inputs",
        "assert_1": "assert n > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/140": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "(assert (is-StrVal text))",
      "inputs": "(declare-const text Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal text))"
      },
      "constraints": {
        "assert_0": "assert isinstance(text, str), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/141": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeStrLen ((v Value)) Int\n  (ite (is-StrVal v) (str.len (sval v)) 0))",
      "basic_structure": "(assert (<= (SafeStrLen file_name) 32))",
      "inputs": "(declare-const file_name Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal file_name))"
      },
      "constraints": {
        "assert_0": "assert isinstance(file_name, str), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/142": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((x Value)) Bool\n  (ite (is-Nil x)\n    true\n    (ite (is-Cons x)\n      (IsList (tail x))\n      false)))\n\n(define-fun-rec ListAllInt ((x Value)) Bool\n  (ite (is-Nil x)\n    true\n    (ite (is-Cons x)\n      (and (is-IntVal (head x)) (ListAllInt (tail x)))\n      false)))",
      "basic_structure": "",
      "inputs": "(declare-const lst Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (or (is-Nil lst) (is-Cons lst)))",
        "assert_1": "(define-fun C1 () Bool\n  (ite (or (is-Nil lst) (is-Cons lst))\n    (ListAllInt lst)\n    true))"
      },
      "constraints": {
        "assert_0": "assert type(lst) == list, \"invalid inputs",
        "assert_1": "assert all(type(x) == int for x in lst), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/143": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeStrLen ((s Value)) Int\n  (ite (is-StrVal s) (str.len (sval s)) 0))\n\n(define-fun-rec is_prime ((n Int)) Bool\n  (and (>= n 2)\n       (not (exists ((x Int))\n               (and (>= x 2)\n                    (<= (* x x) n)\n                    (= (mod n x) 0))))))\n\n(define-fun-rec all_alpha_words ((s Value)) Bool\n  (ite (not (is-StrVal s))\n       false\n       (let ((str (sval s)))\n         (ite (str.contains str \" \")\n              (let ((idx (str.indexof str \" \" 0)))\n                (let ((headVal (StrVal (str.substr str 0 idx)))\n                      (tailVal (StrVal (str.substr str (+ idx 1)\n                                           (- (str.len str) (+ idx 1))))))\n                  (and (all_alpha_words headVal)\n                       (all_alpha_words tailVal))))\n              (str.in.re str\n                         (re.* (re.union\n                                  (re.range \"A\" \"Z\")\n                                  (re.range \"a\" \"z\"))))))))",
      "basic_structure": "(assert (is-StrVal sentence))",
      "inputs": "(declare-const sentence Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (is-StrVal sentence))",
        "assert_1": "(define-fun C1 () Bool\n  (let ((len (ite (is-StrVal sentence)\n                  (str.len (sval sentence))\n                  0)))\n    (and (<= 1 len)\n         (<= len 100))))",
        "assert_2": "(define-fun C2 () Bool\n  (and (is-StrVal sentence)\n       (not (str.contains (sval sentence) \"  \"))))",
        "assert_3": "(define-fun C3 () Bool\n  (all_alpha_words sentence))"
      },
      "constraints": {
        "assert_0": "assert isinstance(sentence, str), \"invalid inputs",
        "assert_1": "assert 1 <= len(sentence) <= 100, \"invalid inputs",
        "assert_2": "assert \"  \" not in sentence, \"invalid inputs",
        "assert_3": "assert all(word.isalpha() for word in sentence.split(\" \")), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/144": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun DIGIT () (RegEx String) (re.range \"0\" \"9\"))\n(define-fun POSINT () (RegEx String) (re.++ (re.range \"1\" \"9\") (re.* DIGIT)))",
      "basic_structure": "(assert (is-StrVal x))",
      "inputs": "(declare-const x Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal x))",
        "assert_1": "(define-fun C1 () Bool\n  (let ((svx (sval x)) (idx (str.indexof (sval x) \"/\" 0)))\n    (and (>= idx 0) (= (str.indexof svx \"/\" (+ idx 1)) -1))))",
        "assert_2": "(define-fun C2 () Bool\n  (let ((svx (sval x)) (idx (str.indexof (sval x) \"/\" 0)))\n    (let ((num (str.substr svx 0 idx)))\n      (and (not (= num \"\")) (str.in.re num POSINT)))))",
        "assert_3": "(define-fun C3 () Bool\n  (let ((svx (sval x)) (idx (str.indexof (sval x) \"/\" 0)))\n    (let ((den (str.substr svx (+ idx 1) (- (str.len svx) (+ idx 1)))))\n      (and (not (= den \"\")) (str.in.re den POSINT)))))"
      },
      "constraints": {
        "assert_0": "assert isinstance(x, str), \"invalid inputs",
        "assert_1": "assert len(xs) == 2, \"invalid inputs",
        "assert_2": "assert xs[0].isdigit() and int(xs[0]) > 0, \"invalid inputs",
        "assert_3": "assert xs[1].isdigit() and int(xs[1]) > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/145": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec ListLen ((v Value)) Int\n  (ite (is-Nil v)\n       0\n       (ite (is-Cons v)\n            (+ 1 (ListLen (tail v)))\n            0)))\n\n(define-fun-rec list_all_int ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (is-IntVal (head v))\n                 (list_all_int (tail v)))\n            false)))",
      "basic_structure": "(assert (IsList nums))\n(assert (<= (ListLen nums) 32))",
      "inputs": "(declare-const nums Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (list_all_int nums))"
      },
      "constraints": {
        "assert_0": "assert all(type(x) == int for x in nums), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/146": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((lst Value)) Bool\n  (ite (is-Nil lst)\n       true\n       (ite (is-Cons lst)\n            (IsList (tail lst))\n            false)))\n\n(define-fun-rec ListLen ((lst Value)) Int\n  (ite (is-Nil lst)\n       0\n       (ite (is-Cons lst)\n            (+ 1 (ListLen (tail lst)))\n            0)))\n\n(define-fun-rec ListAllInt ((lst Value)) Bool\n  (ite (is-Nil lst)\n       true\n       (ite (is-Cons lst)\n            (and (is-IntVal (head lst))\n                 (ListAllInt (tail lst)))\n            false)))",
      "basic_structure": "(assert (IsList nums))\n(assert (<= (ListLen nums) 32))",
      "inputs": "(declare-const nums Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (IsList nums))",
        "assert_1": "(define-fun C1 () Bool\n  (ListAllInt nums))"
      },
      "constraints": {
        "assert_0": "assert type(nums) == list, \"invalid inputs",
        "assert_1": "assert all(type(x) == int for x in nums), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/147": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const n Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))",
        "assert_1": "(define-fun C1 () Bool (and (is-IntVal n) (> (ival n) 0)))"
      },
      "constraints": {
        "assert_0": "assert type(n) == int, \"invalid inputs",
        "assert_1": "assert n > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/148": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeString ((v Value)) Bool (or (not (is-StrVal v)) (<= (str.len (sval v)) 32)))",
      "basic_structure": "(assert (SafeString planet1))\n(assert (SafeString planet2))",
      "inputs": "(declare-const planet1 Value)\n(declare-const planet2 Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (and (is-StrVal planet1) (is-StrVal planet2)))"
      },
      "constraints": {
        "assert_0": "assert isinstance(planet1, str) and isinstance(planet2, str), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/149": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (or\n    (is-Nil l)\n    (and (is-Cons l)\n         (IsList (tail l)))))\n\n(define-fun-rec list_all_str ((l Value)) Bool\n  (ite (is-Nil l)\n       true\n       (ite (is-Cons l)\n            (let ((hd (head l))\n                  (tl (tail l)))\n              (and (is-StrVal hd)\n                   (list_all_str tl)))\n            false)))",
      "basic_structure": "(assert (IsList lst))",
      "inputs": "(declare-const lst Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList lst))",
        "assert_1": "(define-fun C1 () Bool (list_all_str lst))"
      },
      "constraints": {
        "assert_0": "assert type(lst) == list, \"invalid inputs",
        "assert_1": "assert all(type(x) == str for x in lst), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/150": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
      "basic_structure": "",
      "inputs": "(declare-const n Value)\n(declare-const x Value)\n(declare-const y Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal n))"
      },
      "constraints": {
        "assert_0": "assert type(n) == int, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/151": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n\n(define-fun-rec ListLen ((v Value)) Int\n  (ite (is-Nil v)\n       0\n       (ite (is-Cons v)\n            (+ 1 (ListLen (tail v)))\n            0)))",
      "basic_structure": "(assert (IsList lst))\n(assert (<= (ListLen lst) 32))",
      "inputs": "(declare-const lst Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList lst))"
      },
      "constraints": {
        "assert_0": "assert type(lst) == list, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/152": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun is-List ((v Value)) Bool (or (is-Nil v) (is-Cons v)))\n(define-fun-rec ListLen ((v Value)) Int\n  (ite (is-Nil v) 0\n    (ite (is-Cons v)\n         (+ 1 (ListLen (tail v)))\n         0)))\n(define-fun-rec list_all_int ((v Value)) Bool\n  (ite (is-Nil v) true\n    (ite (is-Cons v)\n         (and (is-IntVal (head v)) (list_all_int (tail v)))\n         false)))",
      "basic_structure": "(assert (is-List game))\n(assert (is-List guess))\n(assert (<= (ListLen game) 32))\n(assert (<= (ListLen guess) 32))",
      "inputs": "(declare-const game Value)\n(declare-const guess Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (and (is-List game) (is-List guess)))",
        "assert_1": "(define-fun C1 () Bool (list_all_int game))",
        "assert_2": "(define-fun C2 () Bool (list_all_int guess))",
        "assert_3": "(define-fun C3 () Bool (= (ListLen game) (ListLen guess)))"
      },
      "constraints": {
        "assert_0": "assert type(game) == list and type(guess) == list, \"invalid inputs",
        "assert_1": "assert all(type(x) == int for x in game), \"invalid inputs",
        "assert_2": "assert all(type(x) == int for x in guess), \"invalid inputs",
        "assert_3": "assert len(game) == len(guess), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/153": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeS ((v Value)) String\n  (ite (is-StrVal v) (sval v) \"\"))\n(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n(define-fun-rec ListLen ((v Value)) Int\n  (ite (is-Nil v)\n       0\n       (ite (is-Cons v)\n            (+ 1 (ListLen (tail v)))\n            0)))\n(define-fun-rec ListAllStr ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (and (is-StrVal (head v)) (ListAllStr (tail v)))\n            false)))",
      "basic_structure": "(assert (<= (ListLen extensions) 32))\n(assert (<= (str.len (SafeS class_name)) 32))",
      "inputs": "(declare-const class_name Value)\n(declare-const extensions Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal class_name))",
        "assert_1": "(define-fun C1 () Bool (IsList extensions))",
        "assert_2": "(define-fun C2 () Bool (ListAllStr extensions))",
        "assert_3": "(define-fun C3 () Bool (> (ListLen extensions) 0))"
      },
      "constraints": {
        "assert_0": "assert isinstance(class_name, str), \"invalid inputs",
        "assert_1": "assert type(extensions) == list, \"invalid inputs",
        "assert_2": "assert all(isinstance(s, str) for s in extensions), \"invalid inputs",
        "assert_3": "assert len(extensions) > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/154": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeS ((v Value)) String (ite (is-StrVal v) (sval v) \"\"))",
      "basic_structure": "(assert (<= (str.len (SafeS a)) 32))\n(assert (<= (str.len (SafeS b)) 32))",
      "inputs": "(declare-const a Value)\n(declare-const b Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal a))",
        "assert_1": "(define-fun C1 () Bool (is-StrVal b))"
      },
      "constraints": {
        "assert_0": "assert isinstance(a, str) and isinstance(b, str), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/155": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const num Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal num))"
      },
      "constraints": {
        "assert_0": "assert type(num) == int, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/156": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
      "basic_structure": "",
      "inputs": "(declare-const number Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-IntVal number))",
        "assert_1": "(define-fun C1 () Bool (and (<= 1 (SafeI number)) (<= (SafeI number) 1000)))"
      },
      "constraints": {
        "assert_0": "assert type(number) == int, \"invalid inputs",
        "assert_1": "assert 1 <= number <= 1000, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/157": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeNum ((v Value)) Real\n  (ite (is-IntVal v)\n       (to_real (ival v))\n       (ite (is-FloatVal v)\n            (fval v)\n            0)))",
      "basic_structure": "",
      "inputs": "(declare-const a Value)\n(declare-const b Value)\n(declare-const c Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool\n  (and (or (is-IntVal a) (is-FloatVal a))\n       (or (is-IntVal b) (is-FloatVal b))\n       (or (is-IntVal c) (is-FloatVal c))))",
        "assert_1": "(define-fun C1 () Bool\n  (and (> (SafeNum a) 0)\n       (> (SafeNum b) 0)\n       (> (SafeNum c) 0)))"
      },
      "constraints": {
        "assert_0": "assert type(a) in [int, float] and type(b) in [int, float] and type(c) in [int, float], \"invalid inputs",
        "assert_1": "assert a > 0 and b > 0 and c > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/158": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((v Value)) Bool\n  (ite (is-Nil v)\n       true\n       (ite (is-Cons v)\n            (IsList (tail v))\n            false)))\n(define-fun-rec ListLen ((v Value)) Int\n  (ite (is-Nil v)\n       0\n       (ite (is-Cons v)\n            (+ 1 (ListLen (tail v)))\n            0)))\n(define-fun-rec list_all_str ((v Value)) Bool\n  (ite (is-Cons v)\n       (and (is-StrVal (head v))\n            (list_all_str (tail v)))\n       true))",
      "basic_structure": "(assert (IsList words))\n(assert (<= (ListLen words) 32))",
      "inputs": "(declare-const words Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList words))",
        "assert_1": "(define-fun C1 () Bool (list_all_str words))",
        "assert_2": "(define-fun C2 () Bool (and (IsList words) (> (ListLen words) 0)))"
      },
      "constraints": {
        "assert_0": "assert type(words) == list, \"invalid inputs",
        "assert_1": "assert all(isinstance(s, str) for s in words), \"invalid inputs",
        "assert_2": "assert len(words) > 0, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/159": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeI ((v Value)) Int (ite (is-IntVal v) (ival v) 0))",
      "basic_structure": "",
      "inputs": "(declare-const number Value)\n(declare-const need Value)\n(declare-const remaining Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (and (is-IntVal number) (is-IntVal need) (is-IntVal remaining)))",
        "assert_1": "(define-fun C1 () Bool (<= 0 (SafeI number)))",
        "assert_2": "(define-fun C2 () Bool (<= (SafeI number) 1000))",
        "assert_3": "(define-fun C3 () Bool (<= 0 (SafeI need)))",
        "assert_4": "(define-fun C4 () Bool (<= (SafeI need) 1000))",
        "assert_5": "(define-fun C5 () Bool (<= 0 (SafeI remaining)))",
        "assert_6": "(define-fun C6 () Bool (<= (SafeI remaining) 1000))"
      },
      "constraints": {
        "assert_0": "assert type(number) == int and type(need) == int and type(remaining) == int, \"invalid inputs",
        "assert_1": "assert 0 <= number <= 1000, \"invalid inputs",
        "assert_2": "assert 0 <= need <= 1000, \"invalid inputs",
        "assert_3": "assert 0 <= remaining <= 1000, \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/160": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun-rec IsList ((l Value)) Bool\n  (or (is-Nil l)\n      (and (is-Cons l)\n           (IsList (tail l)))))\n\n(define-fun-rec ListLen ((l Value)) Int\n  (ite (is-Nil l) 0\n       (ite (is-Cons l) (+ 1 (ListLen (tail l))) 0)))\n\n(define-fun-rec list_all_int ((l Value)) Bool\n  (ite (is-Nil l) true\n       (ite (is-Cons l)\n            (and (is-IntVal (head l))\n                 (list_all_int (tail l)))\n            false)))\n\n(define-fun-rec list_all_nonneg ((l Value)) Bool\n  (ite (is-Nil l) true\n       (ite (is-Cons l)\n            (and (is-IntVal (head l))\n                 (>= (ival (head l)) 0)\n                 (list_all_nonneg (tail l)))\n            false)))\n\n(define-fun-rec list_all_valid_op ((l Value)) Bool\n  (ite (is-Nil l) true\n       (ite (is-Cons l)\n            (let ((sv (head l)))\n              (and (is-StrVal sv)\n                   (or (= (sval sv) \"+\")\n                       (= (sval sv) \"-\")\n                       (= (sval sv) \"*\")\n                       (= (sval sv) \"//\")\n                       (= (sval sv) \"**\"))\n                   (list_all_valid_op (tail l))))\n            false)))\n\n(define-fun-rec no_zero_div ((ops Value) (operands Value)) Bool\n  (ite (is-Cons ops)\n       (let ((curOp (head ops))\n             (restOps (tail ops)))\n         (and (is-Cons operands)\n              (let ((restOperands (tail operands)))\n                (ite (and (is-Cons restOperands)\n                          (is-StrVal curOp)\n                          (= (sval curOp) \"//\")\n                          (let ((nextOpnd (head restOperands)))\n                            (and (is-IntVal nextOpnd)\n                                 (= (ival nextOpnd) 0))))\n                     false\n                     (no_zero_div restOps restOperands)))))\n       true))",
      "basic_structure": "(assert (IsList operator))\n(assert (IsList operand))\n(assert (<= (ListLen operator) 32))\n(assert (<= (ListLen operand) 32))",
      "inputs": "(declare-const operator Value)\n(declare-const operand Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (IsList operator))",
        "assert_1": "(define-fun C1 () Bool (IsList operand))",
        "assert_2": "(define-fun C2 () Bool (>= (ListLen operator) 1))",
        "assert_3": "(define-fun C3 () Bool (= (ListLen operand) (+ (ListLen operator) 1)))",
        "assert_4": "(define-fun C4 () Bool (list_all_int operand))",
        "assert_5": "(define-fun C5 () Bool (list_all_nonneg operand))",
        "assert_6": "(define-fun C6 () Bool (list_all_valid_op operator))",
        "assert_7": "(define-fun C7 () Bool (no_zero_div operator operand))"
      },
      "constraints": {
        "assert_0": "assert type(operator) == list and type(operand) == list, \"invalid inputs",
        "assert_1": "assert len(operator) >= 1, \"invalid inputs",
        "assert_2": "assert len(operand) == len(operator) + 1, \"invalid inputs",
        "assert_3": "assert all(type(x) == int and x >= 0 for x in operand), \"invalid inputs",
        "assert_4": "assert all(sgn in [\"+\", \"-\", \"*\", \"//\", \"**\"] for sgn in operator), \"invalid inputs",
        "assert_5": "assert not any([operand[i] == 0 and operator[i-1] == \"//\" for i in range(1, len(operand))]), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/161": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeS ((v Value)) String (ite (is-StrVal v) (sval v) \"\"))",
      "basic_structure": "(assert (<= (str.len (SafeS s)) 32))",
      "inputs": "(declare-const s Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal s))"
      },
      "constraints": {
        "assert_0": "assert isinstance(s, str), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/162": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "(define-fun SafeS ((v Value)) String (ite (is-StrVal v) (sval v) \"\"))",
      "basic_structure": "(<= (str.len (SafeS text)) 32)",
      "inputs": "(declare-const text Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (is-StrVal text))"
      },
      "constraints": {
        "assert_0": "assert isinstance(text, str), \"invalid inputs"
      },
      "single_toggles": null
    },
    "HumanEval/163": {
      "template": "\n(set-logic ALL)\n\n; ==== CANONICAL PYTHON-LIKE ADT (DO NOT MODIFY) ====\n(declare-datatypes ((Value 0)) (\n  ((IntVal (ival Int))\n   (FloatVal (fval Real))\n   (StrVal (sval String))\n   (BoolVal (bval Bool))\n   (Nil)\n   (Cons (head Value) (tail Value)))\n))\n\n; === ADD HELPER FUNCTIONS HERE ===\n<<HELPER_FUNCTIONS>>\n\n; === Inputs ===\n<<INPUT>>\n\n; === BASIC STRUCTURE ===\n<<BASIC_STRUCTURE>>\n\n; === Contract predicates ===\n<<CONTRACT_DEFS>>\n\n; === COMBINATION ===\n<<COMBINATION>>\n\n(check-sat)\n(get-model)\n",
      "helper_functions": "",
      "basic_structure": "",
      "inputs": "(declare-const a Value)\n(declare-const b Value)",
      "contract_defs": {
        "assert_0": "(define-fun C0 () Bool (and (is-IntVal a) (is-IntVal b)))",
        "assert_1": "(define-fun C1 () Bool (and (is-IntVal a) (is-IntVal b) (> (ite (is-IntVal a) (ival a) 0) 0) (> (ite (is-IntVal b) (ival b) 0) 0)))"
      },
      "constraints": {
        "assert_0": "assert type(a) == int and type(b) == int, \"invalid inputs",
        "assert_1": "assert a > 0 and b > 0, \"invalid inputs"
      },
      "single_toggles": null
    }
  }
}